###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Aug/2017  13:59:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\Flash.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\Flash.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\Flash.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\Flash.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\Flash.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : Flash.c
      4            * Description        : This file provides code for the control, reading and 
      5            *                      writing of the Flash Memory on the Design.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2017 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "Flash.h"
     37          #include <math.h>
     38          #include "stdbool.h"
     39          
     40          // Frame Structure Define
     41          //FrameStructure Frame_Save  @ 0x08070000;
     42          
     43          /* Private define ------------------------------------------------------------*/
     44          
     45          /* Private typedef -----------------------------------------------------------*/
     46          typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
     47          
     48          /* Uncomment this line to Enable Write Protection */
     49          //#define WRITE_PROTECTION_ENABLE
     50          
     51          /* Uncomment this line to Disable Write Protection */
     52          #define WRITE_PROTECTION_DISABLE
     53          
     54          /* Check the status of the switches */
     55          /* Enable by default the disable protection */
     56          #if !defined(WRITE_PROTECTION_ENABLE)&&!defined(WRITE_PROTECTION_DISABLE)
     57          #define WRITE_PROTECTION_DISABLE
     58          #endif /* !WRITE_PROTECTION_ENABLE && !WRITE_PROTECTION_DISABLE */
     59          
     60          /* Both switches cannot be enabled in the same time */
     61          #if defined(WRITE_PROTECTION_ENABLE)&&defined(WRITE_PROTECTION_DISABLE)
     62          #error "Switches WRITE_PROTECTION_ENABLE & WRITE_PROTECTION_DISABLE cannot be enabled in the time!"
     63          #endif /* WRITE_PROTECTION_ENABLE && WRITE_PROTECTION_DISABLE */
     64          
     65          /* Private macro -------------------------------------------------------------*/
     66          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     67          uint32_t Address = 0;
   \                     Address:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     68          uint32_t PageError = 0;
   \                     PageError:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     69          uint32_t ProtectedPAGE = 0x0;
   \                     ProtectedPAGE:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
     70          __IO TestStatus MemoryProgramStatus = PASSED;
   \                     MemoryProgramStatus:
   \   00000000   0x01               DC8 1
     71          /*Variable used for Erase procedure*/
     72          //static FLASH_EraseInitTypeDef EraseInitStruct;
     73          /*Variable used to handle the Options Bytes*/
     74          //static FLASH_OBProgramInitTypeDef OptionsBytesStruct;
     75          
     76          //  uint32_t NbPages;     /*!< NbPages: Number of pages to be erased.
     77          //                             This parameter must be a value between 1 and (max number of pages - value of Initial page)*/
     78          
     79          
     80            /**
     81            * @brief  This function Initializes Option Bytes and writes the specified data to Target Flash memory.
     82            * @param  uint32_t  FlashProtect: Specifies the sector(s) which are write protected between Sector 0 to 31.
     83            *                                 This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection1
     84            *                                   @defgroup FLASHEx_Option_Bytes_Write_Protection1 FLASHEx Option Bytes Write Protection1
     85            *                                   Module stm32l1xx_hal_flash_ex.h
     86            * @retval HAL_StatusTypeDef:     HAL_OK:       Flash Operation success.
     87            *                                HAL_ERROR:    Error found in Tasking or data passed.
     88            *                                HAL_BUSY:     Flash is busy.
     89            *                                HAL_TIMEOUT:  Flash timed out.
     90            */

   \                                 In section .text, align 2, keep-with-next
     91          HAL_StatusTypeDef RoadBrd_FlashInitOption( uint32_t  FlashProtect)
     92          {
   \                     RoadBrd_FlashInitOption: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     93            HAL_StatusTypeDef Status;
     94            /*Variable used to handle the Options Bytes*/
     95            static FLASH_OBProgramInitTypeDef OptionsBytesStruct;
     96          
     97            Status = HAL_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
     98          
     99            //*
    100            //*
    101            //* INITITIALIZE KEY STRUCTURES BEFORE STARTING OPERATION.
    102            //*
    103            //*
    104            Status = HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0005             MOVS     R5,R0
    105            /* Unlock the Flash to enable the flash control register access *************/ 
    106            HAL_FLASH_Unlock();
   \   0000000C   0x.... 0x....      BL       HAL_FLASH_Unlock
    107          
    108            /* Unlock the Options Bytes *************************************************/
    109            HAL_FLASH_OB_Unlock();
   \   00000010   0x.... 0x....      BL       HAL_FLASH_OB_Unlock
    110          
    111            /* Get pages write protection status ****************************************/
    112            HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x.... 0x....      BL       HAL_FLASHEx_OBGetConfig
    113          
    114          #ifdef WRITE_PROTECTION_DISABLE
    115            /* Check if desired pages are already write protected ***********************/
    116            if((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == FlashProtect)
   \   0000001A   0x....             LDR.N    R0,??DataTable2
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x4020             ANDS     R0,R4,R0
   \   00000020   0x42A0             CMP      R0,R4
   \   00000022   0xD113             BNE.N    ??RoadBrd_FlashInitOption_0
    117            {
    118              /* Restore write protected pages */
    119              OptionsBytesStruct.OptionType   = OPTIONBYTE_WRP;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable2
   \   00000028   0x6008             STR      R0,[R1, #+0]
    120              OptionsBytesStruct.WRPState     = OB_WRPSTATE_DISABLE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable2
   \   0000002E   0x6048             STR      R0,[R1, #+4]
    121              OptionsBytesStruct.WRPSector0To31 = FlashProtect;
   \   00000030   0x....             LDR.N    R0,??DataTable2
   \   00000032   0x6084             STR      R4,[R0, #+8]
    122              Status = HAL_FLASHEx_OBProgram(&OptionsBytesStruct);
   \   00000034   0x....             LDR.N    R0,??DataTable2
   \   00000036   0x.... 0x....      BL       HAL_FLASHEx_OBProgram
   \   0000003A   0x0005             MOVS     R5,R0
    123              if(Status != HAL_OK)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD002             BEQ.N    ??RoadBrd_FlashInitOption_1
    124                return Status;
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE007             B.N      ??RoadBrd_FlashInitOption_2
    125          
    126              /* Generate System Reset to load the new option byte values ***************/
    127              HAL_FLASH_OB_Launch();
   \                     ??RoadBrd_FlashInitOption_1: (+1)
   \   00000048   0x.... 0x....      BL       HAL_FLASH_OB_Launch
    128            }
    129          #elif defined WRITE_PROTECTION_ENABLE
    130            /* Get current write protected pages and the new pages to be protected ******/
    131            ProtectedPAGE =  OptionsBytesStruct.WRPSector0To31 | FlashProtect; 
    132          
    133            /* Check if desired pages are not yet write protected ***********************/
    134            if((OptionsBytesStruct.WRPSector0To31 & FlashProtect )!= FlashProtect)
    135            {
    136              /* Enable the pages write protection **************************************/
    137              OptionsBytesStruct.OptionType = OPTIONBYTE_WRP;
    138              OptionsBytesStruct.WRPState   = OB_WRPSTATE_ENABLE;
    139              OptionsBytesStruct.WRPSector0To31    = FlashProtect;
    140              Status = HAL_FLASHEx_OBProgram(&OptionsBytesStruct);
    141              if(Status != HAL_OK)
    142                return Status;
    143          
    144              /* Generate System Reset to load the new option byte values ***************/
    145              HAL_FLASH_OB_Launch();
    146            }
    147          #endif /* WRITE_PROTECTION_DISABLE */
    148            /* Lock the Options Bytes *************************************************/
    149            HAL_FLASH_OB_Lock();
   \                     ??RoadBrd_FlashInitOption_0: (+1)
   \   0000004C   0x.... 0x....      BL       HAL_FLASH_OB_Lock
    150          
    151            /* Lock the Flash to disable the flash control register access (recommended
    152               to protect the FLASH memory against possible unwanted operation) *********/
    153            HAL_FLASH_Lock();
   \   00000050   0x.... 0x....      BL       HAL_FLASH_Lock
    154            return Status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_FlashInitOption_2: (+1)
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    155          }

   \                                 In section .bss, align 4
   \                     `RoadBrd_FlashInitOption::OptionsBytesStruct`:
   \   00000000                      DS8 28
    156          
    157          /**
    158            * @brief  This function Initializes Option Bytes and writes the specified data to Target Flash memory.
    159            * @param  uint32_t  FlashProtect: Specifies the sector(s) which are write protected between Sector 0 to 31.
    160            *                                 This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection1
    161            *                                   @defgroup FLASHEx_Option_Bytes_Write_Protection1 FLASHEx Option Bytes Write Protection1
    162            *                                   Module stm32l1xx_hal_flash_ex.h
    163            * @param  uint32_t TypeErase:     Page Erase only.
    164            *                                 This parameter can be a value of @ref FLASHEx_Type_Erase
    165            *                                   @defgroup FLASHEx_Option_Type FLASHEx Option Type
    166            *                                   Module stm32l1xx_hal_flash_ex.h
    167            * @param  uint32_t FlashAddress:  Initial FLASH address to be erased and written.
    168            *                                 This parameter must be a value belonging to FLASH Programm address (depending on the devices)
    169            * @param  uint32_t *ReadAddress:  Address of data to be written to flash.
    170            * @param  uint32_t Size:          Number of bytes/pages to be erased and written. Note that the Pages are an increment of 256 Bytes rounded up.
    171            * @retval HAL_StatusTypeDef:     HAL_OK:       Flash Operation success.
    172            *                                HAL_ERROR:    Error found in Tasking or data passed.
    173            *                                HAL_BUSY:     Flash is busy.
    174            *                                HAL_TIMEOUT:  Flash timed out.
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          HAL_StatusTypeDef RoadBrd_FlashInitWrite( uint32_t  FlashProtect,
    177                                                uint32_t TypeErase,
    178                                                uint32_t FlashAddress,
    179                                                uint32_t *ReadAddress,
    180                                                uint32_t Size)
    181          {
   \                     RoadBrd_FlashInitWrite: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x468B             MOV      R11,R1
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0x469A             MOV      R10,R3
   \   0000000E   0xF8DD 0x9030      LDR      R9,[SP, #+48]
    182            HAL_StatusTypeDef Status;
    183            float num_pages;
    184            uint32_t Address;
    185            uint32_t EndAddress;
    186            uint32_t *DataPtr;
    187            /*Variable used for Erase procedure*/
    188            static FLASH_EraseInitTypeDef EraseInitStruct;
    189            /*Variable used to handle the Options Bytes*/
    190            static FLASH_OBProgramInitTypeDef OptionsBytesStruct;
    191          
    192            Status = HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0005             MOVS     R5,R0
    193          
    194            //*
    195            //*
    196            //* INITITIALIZE KEY STRUCTURES BEFORE STARTING OPERATION.
    197            //*
    198            //*
    199            Status = HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
    200            /* Unlock the Flash to enable the flash control register access *************/ 
    201            HAL_FLASH_Unlock();
   \   0000001A   0x.... 0x....      BL       HAL_FLASH_Unlock
    202          
    203            /* Unlock the Options Bytes *************************************************/
    204            HAL_FLASH_OB_Unlock();
   \   0000001E   0x.... 0x....      BL       HAL_FLASH_OB_Unlock
    205          
    206            /* Get pages write protection status ****************************************/
    207            HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
   \   00000022   0x....             LDR.N    R0,??DataTable2_1
   \   00000024   0x.... 0x....      BL       HAL_FLASHEx_OBGetConfig
    208          
    209          #ifdef WRITE_PROTECTION_DISABLE
    210            /* Check if desired pages are already write protected ***********************/
    211            if((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == FlashProtect)
   \   00000028   0x....             LDR.N    R0,??DataTable2_1
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0xEA18 0x0000      ANDS     R0,R8,R0
   \   00000030   0x4540             CMP      R0,R8
   \   00000032   0xD114             BNE.N    ??RoadBrd_FlashInitWrite_0
    212            {
    213              /* Restore write protected pages */
    214              OptionsBytesStruct.OptionType   = OPTIONBYTE_WRP;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable2_1
   \   00000038   0x6008             STR      R0,[R1, #+0]
    215              OptionsBytesStruct.WRPState     = OB_WRPSTATE_DISABLE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable2_1
   \   0000003E   0x6048             STR      R0,[R1, #+4]
    216              OptionsBytesStruct.WRPSector0To31 = FlashProtect;
   \   00000040   0x....             LDR.N    R0,??DataTable2_1
   \   00000042   0xF8C0 0x8008      STR      R8,[R0, #+8]
    217              Status = HAL_FLASHEx_OBProgram(&OptionsBytesStruct);
   \   00000046   0x....             LDR.N    R0,??DataTable2_1
   \   00000048   0x.... 0x....      BL       HAL_FLASHEx_OBProgram
   \   0000004C   0x0005             MOVS     R5,R0
    218              if(Status != HAL_OK)
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD002             BEQ.N    ??RoadBrd_FlashInitWrite_1
    219                return Status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xE076             B.N      ??RoadBrd_FlashInitWrite_2
    220          
    221              /* Generate System Reset to load the new option byte values ***************/
    222              HAL_FLASH_OB_Launch();
   \                     ??RoadBrd_FlashInitWrite_1: (+1)
   \   0000005A   0x.... 0x....      BL       HAL_FLASH_OB_Launch
    223            }
    224          #elif defined WRITE_PROTECTION_ENABLE
    225            /* Get current write protected pages and the new pages to be protected ******/
    226            ProtectedPAGE =  OptionsBytesStruct.WRPSector0To31 | FlashProtect; 
    227          
    228            /* Check if desired pages are not yet write protected ***********************/
    229            if((OptionsBytesStruct.WRPSector0To31 & FlashProtect )!= FlashProtect)
    230            {
    231              /* Enable the pages write protection **************************************/
    232              OptionsBytesStruct.OptionType = OPTIONBYTE_WRP;
    233              OptionsBytesStruct.WRPState   = OB_WRPSTATE_ENABLE;
    234              OptionsBytesStruct.WRPSector0To31    = FlashProtect;
    235              Status = HAL_FLASHEx_OBProgram(&OptionsBytesStruct);
    236              if(Status != HAL_OK)
    237                return Status;
    238          
    239              /* Generate System Reset to load the new option byte values ***************/
    240              HAL_FLASH_OB_Launch();
    241            }
    242          #endif /* WRITE_PROTECTION_DISABLE */
    243            /* Lock the Options Bytes *************************************************/
    244            HAL_FLASH_OB_Lock();
   \                     ??RoadBrd_FlashInitWrite_0: (+1)
   \   0000005E   0x.... 0x....      BL       HAL_FLASH_OB_Lock
    245          
    246            //*
    247            //*
    248            //* ERASE TARGET FLASH MEMORY.
    249            //*
    250            //*
    251            /* The selected pages are not write protected *******************************/
    252            if ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
   \   00000062   0x....             LDR.N    R0,??DataTable2_1
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0xEA10 0x0F08      TST      R0,R8
   \   0000006A   0xD150             BNE.N    ??RoadBrd_FlashInitWrite_3
    253            {
    254              /* Fill EraseInit structure************************************************/
    255              EraseInitStruct.TypeErase   = TypeErase;
   \   0000006C   0x....             LDR.N    R0,??DataTable2_2
   \   0000006E   0xF8C0 0xB000      STR      R11,[R0, #+0]
    256              EraseInitStruct.PageAddress = FlashAddress;
   \   00000072   0x....             LDR.N    R0,??DataTable2_2
   \   00000074   0x6044             STR      R4,[R0, #+4]
    257              num_pages = Size/FLASH_PAGE_SIZE;
   \   00000076   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   0000007A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000007E   0x9001             STR      R0,[SP, #+4]
    258              EraseInitStruct.NbPages     = (uint32_t)ceil(num_pages);
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0x.... 0x....      BL       ceil
   \   0000008A   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000008E   0x....             LDR.N    R1,??DataTable2_2
   \   00000090   0x6088             STR      R0,[R1, #+8]
    259          
    260              Status = HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);
   \   00000092   0x....             LDR.N    R1,??DataTable2_3
   \   00000094   0x....             LDR.N    R0,??DataTable2_2
   \   00000096   0x.... 0x....      BL       HAL_FLASHEx_Erase
   \   0000009A   0x0005             MOVS     R5,R0
    261              if(Status != HAL_OK)
   \   0000009C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009E   0x2D00             CMP      R5,#+0
   \   000000A0   0xD004             BEQ.N    ??RoadBrd_FlashInitWrite_4
    262              {
    263                /* Lock the Flash to disable the flash control register access (recommended
    264                  to protect the FLASH memory against possible unwanted operation) *********/
    265                HAL_FLASH_Lock();
   \   000000A2   0x.... 0x....      BL       HAL_FLASH_Lock
    266                return Status;
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0xE04D             B.N      ??RoadBrd_FlashInitWrite_2
    267              }
    268          
    269              //*
    270              //*
    271              //* WRITE TO TARGET FLASH MEMORY.
    272              //*
    273              //*
    274              Address = FlashAddress;
   \                     ??RoadBrd_FlashInitWrite_4: (+1)
   \   000000AC   0x0026             MOVS     R6,R4
    275              EndAddress = FlashAddress + Size;
   \   000000AE   0xEB19 0x0004      ADDS     R0,R9,R4
   \   000000B2   0x9000             STR      R0,[SP, #+0]
    276              DataPtr = ReadAddress;
   \   000000B4   0x4657             MOV      R7,R10
    277              while (Address < EndAddress)
   \                     ??RoadBrd_FlashInitWrite_5: (+1)
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0x4286             CMP      R6,R0
   \   000000BA   0xD211             BCS.N    ??RoadBrd_FlashInitWrite_6
    278              {
    279                Status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, *DataPtr++);
   \   000000BC   0x683A             LDR      R2,[R7, #+0]
   \   000000BE   0x2300             MOVS     R3,#+0
   \   000000C0   0x0031             MOVS     R1,R6
   \   000000C2   0x2002             MOVS     R0,#+2
   \   000000C4   0x.... 0x....      BL       HAL_FLASH_Program
   \   000000C8   0x0005             MOVS     R5,R0
   \   000000CA   0x1D3F             ADDS     R7,R7,#+4
    280                if(Status == HAL_OK)
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0x2D00             CMP      R5,#+0
   \   000000D0   0xD101             BNE.N    ??RoadBrd_FlashInitWrite_7
    281                {
    282                  Address = Address + 4;
   \   000000D2   0x1D36             ADDS     R6,R6,#+4
   \   000000D4   0xE7EF             B.N      ??RoadBrd_FlashInitWrite_5
    283                }
    284                else
    285                {
    286                  /* Lock the Flash to disable the flash control register access (recommended
    287                    to protect the FLASH memory against possible unwanted operation) *********/
    288                  HAL_FLASH_Lock();
   \                     ??RoadBrd_FlashInitWrite_7: (+1)
   \   000000D6   0x.... 0x....      BL       HAL_FLASH_Lock
    289                 /* Error occurred while writing data in Flash memory. */
    290                  return Status;
   \   000000DA   0x0028             MOVS     R0,R5
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xE033             B.N      ??RoadBrd_FlashInitWrite_2
    291                }
    292              }
    293          
    294              //*
    295              //*
    296              //* VERIFY WRITE TO TARGET FLASH MEMORY.
    297              //*
    298              //*
    299              /* Check the correctness of written data */
    300              Address = FlashAddress;
   \                     ??RoadBrd_FlashInitWrite_6: (+1)
   \   000000E0   0x0026             MOVS     R6,R4
    301              EndAddress = FlashAddress + Size;
   \   000000E2   0xEB19 0x0004      ADDS     R0,R9,R4
   \   000000E6   0x9000             STR      R0,[SP, #+0]
    302              DataPtr = ReadAddress;
   \   000000E8   0x4657             MOV      R7,R10
    303          
    304              while (Address < EndAddress)
   \                     ??RoadBrd_FlashInitWrite_8: (+1)
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0x4286             CMP      R6,R0
   \   000000EE   0xD227             BCS.N    ??RoadBrd_FlashInitWrite_9
    305              {
    306                if((*(__IO uint32_t*) Address) != *DataPtr++)
   \   000000F0   0x6830             LDR      R0,[R6, #+0]
   \   000000F2   0x0039             MOVS     R1,R7
   \   000000F4   0x1D0F             ADDS     R7,R1,#+4
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xD006             BEQ.N    ??RoadBrd_FlashInitWrite_10
    307                {
    308                  Status = HAL_ERROR;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x0005             MOVS     R5,R0
    309                  /* Lock the Flash to disable the flash control register access (recommended
    310                    to protect the FLASH memory against possible unwanted operation) *********/
    311                  HAL_FLASH_Lock();
   \   00000100   0x.... 0x....      BL       HAL_FLASH_Lock
    312                  return Status;
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0xE01E             B.N      ??RoadBrd_FlashInitWrite_2
    313                }
    314                Address += 4;
   \                     ??RoadBrd_FlashInitWrite_10: (+1)
   \   0000010A   0x1D36             ADDS     R6,R6,#+4
   \   0000010C   0xE7ED             B.N      ??RoadBrd_FlashInitWrite_8
    315              }
    316            } //EndIf ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
    317            else
    318            { 
    319              /* The desired pages are write protected */ 
    320              /* Check that it is not allowed to write in this page */
    321              Address = FlashAddress;
   \                     ??RoadBrd_FlashInitWrite_3: (+1)
   \   0000010E   0x0026             MOVS     R6,R4
    322              DataPtr = ReadAddress;
   \   00000110   0x4657             MOV      R7,R10
    323              Status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, *DataPtr++);
   \   00000112   0x683A             LDR      R2,[R7, #+0]
   \   00000114   0x2300             MOVS     R3,#+0
   \   00000116   0x0031             MOVS     R1,R6
   \   00000118   0x2002             MOVS     R0,#+2
   \   0000011A   0x.... 0x....      BL       HAL_FLASH_Program
   \   0000011E   0x0005             MOVS     R5,R0
   \   00000120   0x1D3F             ADDS     R7,R7,#+4
    324              if (Status != HAL_OK)
   \   00000122   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000124   0x2D00             CMP      R5,#+0
   \   00000126   0xD009             BEQ.N    ??RoadBrd_FlashInitWrite_11
    325              {
    326                /* Error returned during programmation. */
    327                /* Check that WRPERR flag is well set */
    328                if (HAL_FLASH_GetError() == HAL_FLASH_ERROR_WRP) 
   \   00000128   0x.... 0x....      BL       HAL_FLASH_GetError
   \   0000012C   0x2802             CMP      R0,#+2
   \   0000012E   0xD102             BNE.N    ??RoadBrd_FlashInitWrite_12
    329                {
    330                  Status = HAL_ERROR;
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0x0005             MOVS     R5,R0
   \   00000134   0xE004             B.N      ??RoadBrd_FlashInitWrite_9
    331                }
    332                else
    333                {
    334                  /* Another error occurred.
    335                     User can add here some code to deal with this error */
    336                  Status = HAL_ERROR;
   \                     ??RoadBrd_FlashInitWrite_12: (+1)
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x0005             MOVS     R5,R0
   \   0000013A   0xE001             B.N      ??RoadBrd_FlashInitWrite_9
    337                }
    338              }
    339              else
    340              {
    341                /* Write operation is successful. Should not occur
    342                   User can add here some code to deal with this error */
    343                Status = HAL_ERROR;
   \                     ??RoadBrd_FlashInitWrite_11: (+1)
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0x0005             MOVS     R5,R0
    344              }
    345            } //EndElse ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
    346          
    347            /* Lock the Flash to disable the flash control register access (recommended
    348               to protect the FLASH memory against possible unwanted operation) *********/
    349            HAL_FLASH_Lock();
   \                     ??RoadBrd_FlashInitWrite_9: (+1)
   \   00000140   0x.... 0x....      BL       HAL_FLASH_Lock
    350            return Status;
   \   00000144   0x0028             MOVS     R0,R5
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_FlashInitWrite_2: (+1)
   \   00000148   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    351          }

   \                                 In section .bss, align 4
   \                     `RoadBrd_FlashInitWrite::EraseInitStruct`:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     `RoadBrd_FlashInitWrite::OptionsBytesStruct`:
   \   00000000                      DS8 28
    352          
    353          /**
    354            * @brief  This function writes the specified data to Target Flash memory.
    355            * @param  uint32_t  FlashProtect: Specifies the sector(s) which are write protected between Sector 0 to 31.
    356            *                                 This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection1
    357            *                                   @defgroup FLASHEx_Option_Bytes_Write_Protection1 FLASHEx Option Bytes Write Protection1
    358            *                                   Module stm32l1xx_hal_flash_ex.h
    359            * @param  uint32_t TypeErase:     Page Erase only.
    360            *                                 This parameter can be a value of @ref FLASHEx_Type_Erase
    361            *                                   @defgroup FLASHEx_Option_Type FLASHEx Option Type
    362            *                                   Module stm32l1xx_hal_flash_ex.h
    363            * @param  uint32_t FlashAddress:  Initial FLASH address to be erased and written.
    364            *                                 This parameter must be a value belonging to FLASH Programm address (depending on the devices)
    365            * @param  uint32_t *ReadAddress:  Address of data to be written to flash.
    366            * @param  uint32_t Size:          Number of bytes/pages to be erased and written. Note that the Pages are an increment of 256 Bytes rounded up.
    367            * @retval HAL_StatusTypeDef:     HAL_OK:       Flash Operation success.
    368            *                                HAL_ERROR:    Error found in Tasking or data passed.
    369            *                                HAL_BUSY:     Flash is busy.
    370            *                                HAL_TIMEOUT:  Flash timed out.
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          HAL_StatusTypeDef RoadBrd_FlashWrite( uint32_t  FlashProtect,
    373                                                uint32_t TypeErase,
    374                                                uint32_t FlashAddress,
    375                                                uint32_t *ReadAddress,
    376                                                uint32_t Size)
    377          {
   \                     RoadBrd_FlashWrite: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4683             MOV      R11,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    378            HAL_StatusTypeDef Status;
    379            float num_pages;
    380            uint32_t Address;
    381            uint32_t EndAddress;
    382            uint32_t *DataPtr;
    383            /*Variable used for Erase procedure*/
    384            static FLASH_EraseInitTypeDef EraseInitStruct;
    385            /*Variable used to handle the Options Bytes*/
    386            static FLASH_OBProgramInitTypeDef OptionsBytesStruct;
    387          
    388            Status = HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0005             MOVS     R5,R0
    389          
    390            /* Unlock the Flash to enable the flash control register access *************/ 
    391            Status = HAL_FLASH_Unlock();
   \   00000016   0x.... 0x....      BL       HAL_FLASH_Unlock
   \   0000001A   0x0005             MOVS     R5,R0
    392            if(Status != HAL_OK)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD002             BEQ.N    ??RoadBrd_FlashWrite_0
    393            {
    394              return Status;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xE07B             B.N      ??RoadBrd_FlashWrite_1
    395            }
    396          
    397            // Clear any outstanding Flash States before starting...
    398            SET_BIT(FLASH->SR, FLASH_SR_WRPERR);
   \                     ??RoadBrd_FlashWrite_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023c18
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000030   0x....             LDR.N    R1,??DataTable2_4  ;; 0x40023c18
   \   00000032   0x6008             STR      R0,[R1, #+0]
    399            //*
    400            //*
    401            //* ERASE TARGET FLASH MEMORY.
    402            //*
    403            //*
    404            /* The selected pages are not write protected *******************************/
    405            if ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
   \   00000034   0x....             LDR.N    R0,??DataTable2_5
   \   00000036   0x6880             LDR      R0,[R0, #+8]
   \   00000038   0xEA10 0x0F0B      TST      R0,R11
   \   0000003C   0xD153             BNE.N    ??RoadBrd_FlashWrite_2
    406            {
    407              /* Fill EraseInit structure************************************************/
    408              EraseInitStruct.TypeErase   = TypeErase;
   \   0000003E   0x....             LDR.N    R0,??DataTable2_6
   \   00000040   0xF8C0 0xA000      STR      R10,[R0, #+0]
    409              EraseInitStruct.PageAddress = FlashAddress;
   \   00000044   0x....             LDR.N    R0,??DataTable2_6
   \   00000046   0x6044             STR      R4,[R0, #+4]
    410              num_pages = (float)Size/FLASH_PAGE_SIZE;
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000004E   0xF05F 0x4187      MOVS     R1,#+1132462080
   \   00000052   0x.... 0x....      BL       __aeabi_fdiv
   \   00000056   0x9001             STR      R0,[SP, #+4]
    411              EraseInitStruct.NbPages     = (uint32_t)ceil(num_pages);
   \   00000058   0x9801             LDR      R0,[SP, #+4]
   \   0000005A   0x.... 0x....      BL       __aeabi_f2d
   \   0000005E   0x.... 0x....      BL       ceil
   \   00000062   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000066   0x....             LDR.N    R1,??DataTable2_6
   \   00000068   0x6088             STR      R0,[R1, #+8]
    412          
    413              Status = HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);
   \   0000006A   0x....             LDR.N    R1,??DataTable2_3
   \   0000006C   0x....             LDR.N    R0,??DataTable2_6
   \   0000006E   0x.... 0x....      BL       HAL_FLASHEx_Erase
   \   00000072   0x0005             MOVS     R5,R0
    414              if(Status != HAL_OK)
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD004             BEQ.N    ??RoadBrd_FlashWrite_3
    415              {
    416                /* Lock the Flash to disable the flash control register access (recommended
    417                  to protect the FLASH memory against possible unwanted operation) *********/
    418                HAL_FLASH_Lock();
   \   0000007A   0x.... 0x....      BL       HAL_FLASH_Lock
    419                return Status;
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE04D             B.N      ??RoadBrd_FlashWrite_1
    420              }
    421          
    422              //*
    423              //*
    424              //* WRITE TO TARGET FLASH MEMORY.
    425              //*
    426              //*
    427              Address = FlashAddress;
   \                     ??RoadBrd_FlashWrite_3: (+1)
   \   00000084   0x0026             MOVS     R6,R4
    428              EndAddress = FlashAddress + Size;
   \   00000086   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000008A   0x9000             STR      R0,[SP, #+0]
    429              DataPtr = ReadAddress;
   \   0000008C   0x464F             MOV      R7,R9
    430              while (Address < EndAddress)
   \                     ??RoadBrd_FlashWrite_4: (+1)
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x4286             CMP      R6,R0
   \   00000092   0xD211             BCS.N    ??RoadBrd_FlashWrite_5
    431              {
    432                Status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, *DataPtr++);
   \   00000094   0x683A             LDR      R2,[R7, #+0]
   \   00000096   0x2300             MOVS     R3,#+0
   \   00000098   0x0031             MOVS     R1,R6
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0x.... 0x....      BL       HAL_FLASH_Program
   \   000000A0   0x0005             MOVS     R5,R0
   \   000000A2   0x1D3F             ADDS     R7,R7,#+4
    433                if(Status == HAL_OK)
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD101             BNE.N    ??RoadBrd_FlashWrite_6
    434                {
    435                  Address = Address + 4;
   \   000000AA   0x1D36             ADDS     R6,R6,#+4
   \   000000AC   0xE7EF             B.N      ??RoadBrd_FlashWrite_4
    436                }
    437                else
    438                {
    439                  /* Lock the Flash to disable the flash control register access (recommended
    440                    to protect the FLASH memory against possible unwanted operation) *********/
    441                  HAL_FLASH_Lock();
   \                     ??RoadBrd_FlashWrite_6: (+1)
   \   000000AE   0x.... 0x....      BL       HAL_FLASH_Lock
    442                 /* Error occurred while writing data in Flash memory. */
    443                  return Status;
   \   000000B2   0x0028             MOVS     R0,R5
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xE033             B.N      ??RoadBrd_FlashWrite_1
    444                }
    445              }
    446          
    447              //*
    448              //*
    449              //* VERIFY WRITE TO TARGET FLASH MEMORY.
    450              //*
    451              //*
    452              /* Check the correctness of written data */
    453              Address = FlashAddress;
   \                     ??RoadBrd_FlashWrite_5: (+1)
   \   000000B8   0x0026             MOVS     R6,R4
    454              EndAddress = FlashAddress + Size;
   \   000000BA   0xEB18 0x0004      ADDS     R0,R8,R4
   \   000000BE   0x9000             STR      R0,[SP, #+0]
    455              DataPtr = ReadAddress;
   \   000000C0   0x464F             MOV      R7,R9
    456          
    457              while (Address < EndAddress)
   \                     ??RoadBrd_FlashWrite_7: (+1)
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0x4286             CMP      R6,R0
   \   000000C6   0xD227             BCS.N    ??RoadBrd_FlashWrite_8
    458              {
    459                if((*(__IO uint32_t*) Address) != *DataPtr++)
   \   000000C8   0x6830             LDR      R0,[R6, #+0]
   \   000000CA   0x0039             MOVS     R1,R7
   \   000000CC   0x1D0F             ADDS     R7,R1,#+4
   \   000000CE   0x6809             LDR      R1,[R1, #+0]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD006             BEQ.N    ??RoadBrd_FlashWrite_9
    460                {
    461                  Status = HAL_ERROR;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x0005             MOVS     R5,R0
    462                  /* Lock the Flash to disable the flash control register access (recommended
    463                    to protect the FLASH memory against possible unwanted operation) *********/
    464                  HAL_FLASH_Lock();
   \   000000D8   0x.... 0x....      BL       HAL_FLASH_Lock
    465                  return Status;
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xE01E             B.N      ??RoadBrd_FlashWrite_1
    466                }
    467                Address += 4;
   \                     ??RoadBrd_FlashWrite_9: (+1)
   \   000000E2   0x1D36             ADDS     R6,R6,#+4
   \   000000E4   0xE7ED             B.N      ??RoadBrd_FlashWrite_7
    468              }
    469            } //EndIf ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
    470            else
    471            { 
    472              /* The desired pages are write protected */ 
    473              /* Check that it is not allowed to write in this page */
    474              Address = FlashAddress;
   \                     ??RoadBrd_FlashWrite_2: (+1)
   \   000000E6   0x0026             MOVS     R6,R4
    475              DataPtr = ReadAddress;
   \   000000E8   0x464F             MOV      R7,R9
    476              Status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, *DataPtr++);
   \   000000EA   0x683A             LDR      R2,[R7, #+0]
   \   000000EC   0x2300             MOVS     R3,#+0
   \   000000EE   0x0031             MOVS     R1,R6
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0x.... 0x....      BL       HAL_FLASH_Program
   \   000000F6   0x0005             MOVS     R5,R0
   \   000000F8   0x1D3F             ADDS     R7,R7,#+4
    477              if (Status != HAL_OK)
   \   000000FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FC   0x2D00             CMP      R5,#+0
   \   000000FE   0xD009             BEQ.N    ??RoadBrd_FlashWrite_10
    478              {
    479                /* Error returned during programmation. */
    480                /* Check that WRPERR flag is well set */
    481                if (HAL_FLASH_GetError() == HAL_FLASH_ERROR_WRP) 
   \   00000100   0x.... 0x....      BL       HAL_FLASH_GetError
   \   00000104   0x2802             CMP      R0,#+2
   \   00000106   0xD102             BNE.N    ??RoadBrd_FlashWrite_11
    482                {
    483                  Status = HAL_ERROR;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0x0005             MOVS     R5,R0
   \   0000010C   0xE004             B.N      ??RoadBrd_FlashWrite_8
    484                }
    485                else
    486                {
    487                  /* Another error occurred.
    488                     User can add here some code to deal with this error */
    489                  Status = HAL_ERROR;
   \                     ??RoadBrd_FlashWrite_11: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x0005             MOVS     R5,R0
   \   00000112   0xE001             B.N      ??RoadBrd_FlashWrite_8
    490                }
    491              }
    492              else
    493              {
    494                /* Write operation is successful. Should not occur
    495                   User can add here some code to deal with this error */
    496                Status = HAL_ERROR;
   \                     ??RoadBrd_FlashWrite_10: (+1)
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0x0005             MOVS     R5,R0
    497              }
    498            } //EndElse ((OptionsBytesStruct.WRPSector0To31 & FlashProtect) == 0x00)
    499          
    500            /* Lock the Flash to disable the flash control register access (recommended
    501               to protect the FLASH memory against possible unwanted operation) *********/
    502            HAL_FLASH_Lock();
   \                     ??RoadBrd_FlashWrite_8: (+1)
   \   00000118   0x.... 0x....      BL       HAL_FLASH_Lock
    503            return Status;
   \   0000011C   0x0028             MOVS     R0,R5
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_FlashWrite_1: (+1)
   \   00000120   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    504          }

   \                                 In section .bss, align 4
   \                     `RoadBrd_FlashWrite::EraseInitStruct`:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     `RoadBrd_FlashWrite::OptionsBytesStruct`:
   \   00000000                      DS8 28
    505          
    506          /**
    507            * @brief  This function reads the specified data from Target Flash memory.
    508            * @param  uint32_t FlashAddress:  Initial FLASH address to be read.
    509            * @param  uint32_t *ReadAddress:  Address of data to be read from flash.
    510            * @param  uint32_t Size:          Number of bytes to read.
    511            * @retval HAL_StatusTypeDef:     HAL_OK:       Flash Operation success.
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          HAL_StatusTypeDef RoadBrd_FlashRead(  uint32_t FlashAddress,
    514                                                uint32_t *ReadAddress,
    515                                                uint32_t Size)
    516          {
   \                     RoadBrd_FlashRead: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    517            uint32_t Address;
    518            uint32_t EndAddress;
    519            uint32_t *DataPtr;
    520          
    521            //* Read Data to Target Locations.
    522            Address = FlashAddress;
   \   00000004   0x001C             MOVS     R4,R3
    523            EndAddress = FlashAddress + Size;
   \   00000006   0x18D0             ADDS     R0,R2,R3
   \   00000008   0x0005             MOVS     R5,R0
    524            DataPtr = ReadAddress;
   \   0000000A   0x000E             MOVS     R6,R1
    525          
    526            while (Address < EndAddress)
   \                     ??RoadBrd_FlashRead_0: (+1)
   \   0000000C   0x42AC             CMP      R4,R5
   \   0000000E   0xD204             BCS.N    ??RoadBrd_FlashRead_1
    527            {
    528              *DataPtr++ = (*(__IO uint32_t*) Address);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6030             STR      R0,[R6, #+0]
   \   00000014   0x1D36             ADDS     R6,R6,#+4
    529              Address += 4;
   \   00000016   0x1D24             ADDS     R4,R4,#+4
   \   00000018   0xE7F8             B.N      ??RoadBrd_FlashRead_0
    530            }
    531          
    532            return HAL_OK;
   \                     ??RoadBrd_FlashRead_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBC70             POP      {R4-R6}
   \   0000001E   0x4770             BX       LR               ;; return
    533          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     `RoadBrd_FlashInitOption::OptionsBytesStruct`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     `RoadBrd_FlashInitWrite::OptionsBytesStruct`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     `RoadBrd_FlashInitWrite::EraseInitStruct`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     PageError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40023C18         DC32     0x40023c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     `RoadBrd_FlashWrite::OptionsBytesStruct`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     `RoadBrd_FlashWrite::EraseInitStruct`
    534          
    535          
    536          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   RoadBrd_FlashInitOption
        16   -> HAL_FLASHEx_OBGetConfig
        16   -> HAL_FLASHEx_OBProgram
        16   -> HAL_FLASH_Lock
        16   -> HAL_FLASH_OB_Launch
        16   -> HAL_FLASH_OB_Lock
        16   -> HAL_FLASH_OB_Unlock
        16   -> HAL_FLASH_Unlock
      48   RoadBrd_FlashInitWrite
        48   -> HAL_FLASHEx_Erase
        48   -> HAL_FLASHEx_OBGetConfig
        48   -> HAL_FLASHEx_OBProgram
        48   -> HAL_FLASH_GetError
        48   -> HAL_FLASH_Lock
        48   -> HAL_FLASH_OB_Launch
        48   -> HAL_FLASH_OB_Lock
        48   -> HAL_FLASH_OB_Unlock
        48   -> HAL_FLASH_Program
        48   -> HAL_FLASH_Unlock
        48   -> __aeabi_d2uiz
        48   -> __aeabi_f2d
        48   -> __aeabi_ui2f
        48   -> ceil
      12   RoadBrd_FlashRead
      48   RoadBrd_FlashWrite
        48   -> HAL_FLASHEx_Erase
        48   -> HAL_FLASH_GetError
        48   -> HAL_FLASH_Lock
        48   -> HAL_FLASH_Program
        48   -> HAL_FLASH_Unlock
        48   -> __aeabi_d2uiz
        48   -> __aeabi_f2d
        48   -> __aeabi_fdiv
        48   -> __aeabi_ui2f
        48   -> ceil


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  Address
      12  EraseInitStruct
      12  EraseInitStruct
       1  MemoryProgramStatus
      28  OptionsBytesStruct
      28  OptionsBytesStruct
      28  OptionsBytesStruct
       4  PageError
       4  ProtectedPAGE
      90  RoadBrd_FlashInitOption
     332  RoadBrd_FlashInitWrite
      32  RoadBrd_FlashRead
     292  RoadBrd_FlashWrite

 
 120 bytes in section .bss
   1 byte  in section .data
 774 bytes in section .text
 
 774 bytes of CODE memory
 121 bytes of DATA memory

Errors: none
Warnings: none
