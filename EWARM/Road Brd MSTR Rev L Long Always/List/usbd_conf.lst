###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Sep/2017  09:08:05
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usbd_conf.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usbd_conf.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\usbd_conf.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\usbd_conf.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usbd_conf.c
      1          /**
      2            ******************************************************************************
      3            * @file           : usbd_conf.c 
      4            * @version        : v1.0_Cube
      5            * @brief          : This file implements the board support package for the USB device library
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            * 1. Redistributions of source code must retain the above copyright notice,
     13            * this list of conditions and the following disclaimer.
     14            * 2. Redistributions in binary form must reproduce the above copyright notice,
     15            * this list of conditions and the following disclaimer in the documentation
     16            * and/or other materials provided with the distribution.
     17            * 3. Neither the name of STMicroelectronics nor the names of its contributors
     18            * may be used to endorse or promote products derived from this software
     19            * without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33          */
     34          /* Includes ------------------------------------------------------------------*/
     35          #include "stm32l1xx.h"
     36          #include "stm32l1xx_hal.h"
     37          #include "usbd_def.h"
     38          #include "usbd_core.h"
     39          #include "usbd_cdc.h"
     40          /* Private typedef -----------------------------------------------------------*/
     41          /* Private define ------------------------------------------------------------*/
     42          /* Private macro -------------------------------------------------------------*/
     43          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     44          PCD_HandleTypeDef hpcd_USB_FS;
   \                     hpcd_USB_FS:
   \   00000000                      DS8 544
     45          void Error_Handler(void);
     46          
     47          /* USER CODE BEGIN 0 */
     48          
     49          /* USER CODE END 0 */
     50          
     51          /* Private function prototypes -----------------------------------------------*/
     52          /* Private functions ---------------------------------------------------------*/
     53          /* USER CODE BEGIN 1 */
     54          
     55          /* USER CODE END 1 */
     56          void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state);
     57          
     58          /*******************************************************************************
     59                                 LL Driver Callbacks (PCD -> USB Device Library)
     60          *******************************************************************************/
     61          /* MSP Init */
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
     64          {
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     65            if(pcdHandle->Instance==USB)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable5  ;; 0x40005c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD113             BNE.N    ??HAL_PCD_MspInit_0
     66            {
     67            /* USER CODE BEGIN USB_MspInit 0 */
     68          
     69            /* USER CODE END USB_MspInit 0 */
     70              /* Peripheral clock enable */
     71              __HAL_RCC_USB_CLK_ENABLE();
   \   0000000E   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023824
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000016   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40023824
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023824
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF410 0x0000      ANDS     R0,R0,#0x800000
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
     72          
     73              /* Peripheral interrupt init */
     74              HAL_NVIC_SetPriority(USB_LP_IRQn, 5, 0);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x2014             MOVS     R0,#+20
   \   0000002C   0x.... 0x....      BL       HAL_NVIC_SetPriority
     75              HAL_NVIC_EnableIRQ(USB_LP_IRQn);
   \   00000030   0x2014             MOVS     R0,#+20
   \   00000032   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
     76            /* USER CODE BEGIN USB_MspInit 1 */
     77          
     78            /* USER CODE END USB_MspInit 1 */
     79            }
     80          }
   \                     ??HAL_PCD_MspInit_0: (+1)
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     81          

   \                                 In section .text, align 2, keep-with-next
     82          void HAL_PCD_MspDeInit(PCD_HandleTypeDef* pcdHandle)
     83          {
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     84            if(pcdHandle->Instance==USB)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable5  ;; 0x40005c00
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD108             BNE.N    ??HAL_PCD_MspDeInit_0
     85            {
     86            /* USER CODE BEGIN USB_MspDeInit 0 */
     87          
     88            /* USER CODE END USB_MspDeInit 0 */
     89              /* Peripheral clock disable */
     90              __HAL_RCC_USB_CLK_DISABLE();
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023824
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000014   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40023824
   \   00000016   0x6008             STR      R0,[R1, #+0]
     91          
     92              /* Peripheral interrupt Deinit*/
     93              HAL_NVIC_DisableIRQ(USB_LP_IRQn);
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
     94          
     95            /* USER CODE BEGIN USB_MspDeInit 1 */
     96          
     97            /* USER CODE END USB_MspDeInit 1 */
     98            }
     99          }
   \                     ??HAL_PCD_MspDeInit_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    100          
    101          /**
    102            * @brief  Setup stage callback
    103            * @param  hpcd: PCD handle
    104            * @retval None
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    107          {
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    108            USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
   \   00000004   0xF44F 0x70F6      MOV      R0,#+492
   \   00000008   0xEB04 0x0100      ADD      R1,R4,R0
   \   0000000C   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000010   0x.... 0x....      BL       USBD_LL_SetupStage
    109          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    110          
    111          /**
    112            * @brief  Data Out stage callback.
    113            * @param  hpcd: PCD handle
    114            * @param  epnum: Endpoint Number
    115            * @retval None
    116            */

   \                                 In section .text, align 2, keep-with-next
    117          void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    118          {
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    119            USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000000E   0x4420             ADD      R0,R4,R0
   \   00000010   0xF8D0 0x2118      LDR      R2,[R0, #+280]
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   0000001C   0x.... 0x....      BL       USBD_LL_DataOutStage
    120          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    121          
    122          /**
    123            * @brief  Data In stage callback..
    124            * @param  hpcd: PCD handle
    125            * @param  epnum: Endpoint Number
    126            * @retval None
    127            */

   \                                 In section .text, align 2, keep-with-next
    128          void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    129          {
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    130            USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000000E   0x4420             ADD      R0,R4,R0
   \   00000010   0x6B82             LDR      R2,[R0, #+56]
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   0000001A   0x.... 0x....      BL       USBD_LL_DataInStage
    131          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    132          
    133          /**
    134            * @brief  SOF callback.
    135            * @param  hpcd: PCD handle
    136            * @retval None
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    139          {
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    140            USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
   \   00000004   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000008   0x.... 0x....      BL       USBD_LL_SOF
    141          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    142          
    143          /**
    144            * @brief  Reset callback.
    145            * @param  hpcd: PCD handle
    146            * @retval None
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    149          { 
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    150            USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
   \   00000004   0x2501             MOVS     R5,#+1
    151          
    152            /*Set USB Current Speed*/
    153            switch (hpcd->Init.speed)
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD102             BNE.N    ??HAL_PCD_ResetCallback_0
    154            {
    155            case PCD_SPEED_FULL:
    156              speed = USBD_SPEED_FULL;    
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x0005             MOVS     R5,R0
    157              break;
   \   00000010   0xE001             B.N      ??HAL_PCD_ResetCallback_1
    158          	
    159            default:
    160              speed = USBD_SPEED_FULL;    
   \                     ??HAL_PCD_ResetCallback_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x0005             MOVS     R5,R0
    161              break;    
    162            }
    163            USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);  
   \                     ??HAL_PCD_ResetCallback_1: (+1)
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   0000001E   0x.... 0x....      BL       USBD_LL_SetSpeed
    164            
    165            /*Reset Device*/
    166            USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
   \   00000022   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000026   0x.... 0x....      BL       USBD_LL_Reset
    167          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    168          
    169          /**
    170            * @brief  Suspend callback.
    171            * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
    172            * @param  hpcd: PCD handle
    173            * @retval None
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    176          {
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    177            /* Inform USB library that core enters in suspend Mode */
    178            USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
   \   00000004   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000008   0x.... 0x....      BL       USBD_LL_Suspend
    179            /*Enter in STOP mode */
    180            /* USER CODE BEGIN 2 */
    181            if (hpcd->Init.low_power_enable)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??HAL_PCD_SuspendCallback_0
    182            {
    183              /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    184              SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
   \   00000012   0x....             LDR.N    R0,??DataTable5_2  ;; 0xe000ed10
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   0000001A   0x....             LDR.N    R1,??DataTable5_2  ;; 0xe000ed10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    185            }
    186            /* USER CODE END 2 */
    187          }
   \                     ??HAL_PCD_SuspendCallback_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    188          
    189          /**
    190            * @brief  Resume callback.
    191            * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
    192            * @param  hpcd: PCD handle
    193            * @retval None
    194            */

   \                                 In section .text, align 2, keep-with-next
    195          void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    196          {
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    197            /* USER CODE BEGIN 3 */
    198          
    199            /* USER CODE END 3 */
    200            USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
   \   00000004   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000008   0x.... 0x....      BL       USBD_LL_Resume
    201            
    202          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    203          
    204          /**
    205            * @brief  ISOOUTIncomplete callback.
    206            * @param  hpcd: PCD handle
    207            * @param  epnum: Endpoint Number
    208            * @retval None
    209            */

   \                                 In section .text, align 2, keep-with-next
    210          void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    211          {
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212            USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   0000000E   0x.... 0x....      BL       USBD_LL_IsoOUTIncomplete
    213          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    214          
    215          /**
    216            * @brief  ISOINIncomplete callback.
    217            * @param  hpcd: PCD handle
    218            * @param  epnum: Endpoint Number
    219            * @retval None
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    222          {
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    223            USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   0000000E   0x.... 0x....      BL       USBD_LL_IsoINIncomplete
    224          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    225          
    226          /**
    227            * @brief  ConnectCallback callback.
    228            * @param  hpcd: PCD handle
    229            * @retval None
    230            */

   \                                 In section .text, align 2, keep-with-next
    231          void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    232          {
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    233            USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
   \   00000004   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000008   0x.... 0x....      BL       USBD_LL_DevConnected
    234          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    235          
    236          /**
    237            * @brief  Disconnect callback.
    238            * @param  hpcd: PCD handle
    239            * @retval None
    240            */

   \                                 In section .text, align 2, keep-with-next
    241          void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    242          {
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    243            USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
   \   00000004   0xF8D4 0x021C      LDR      R0,[R4, #+540]
   \   00000008   0x.... 0x....      BL       USBD_LL_DevDisconnected
    244          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    245          
    246          /*******************************************************************************
    247                                 LL Driver Interface (USB Device Library --> PCD)
    248          *******************************************************************************/
    249          /**
    250            * @brief  Initializes the Low Level portion of the Device driver.
    251            * @param  pdev: Device handle
    252            * @retval USBD Status
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
    255          { 
   \                     USBD_LL_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    256            /* Init USB_IP */
    257            /* Link The driver to the stack */
    258            hpcd_USB_FS.pData = pdev;
   \   00000004   0x....             LDR.N    R0,??DataTable5_3
   \   00000006   0xF8C0 0x421C      STR      R4,[R0, #+540]
    259            pdev->pData = &hpcd_USB_FS;
   \   0000000A   0x....             LDR.N    R0,??DataTable5_3
   \   0000000C   0xF8C4 0x0220      STR      R0,[R4, #+544]
    260          
    261            hpcd_USB_FS.Instance = USB;
   \   00000010   0x....             LDR.N    R0,??DataTable5  ;; 0x40005c00
   \   00000012   0x....             LDR.N    R1,??DataTable5_3
   \   00000014   0x6008             STR      R0,[R1, #+0]
    262            hpcd_USB_FS.Init.dev_endpoints = 8;
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x....             LDR.N    R1,??DataTable5_3
   \   0000001A   0x6048             STR      R0,[R1, #+4]
    263            hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x....             LDR.N    R1,??DataTable5_3
   \   00000020   0x6088             STR      R0,[R1, #+8]
    264            hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_8;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x....             LDR.N    R1,??DataTable5_3
   \   00000026   0x60C8             STR      R0,[R1, #+12]
    265            hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x....             LDR.N    R1,??DataTable5_3
   \   0000002C   0x6108             STR      R0,[R1, #+16]
    266            hpcd_USB_FS.Init.low_power_enable = DISABLE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable5_3
   \   00000032   0x6188             STR      R0,[R1, #+24]
    267            hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable5_3
   \   00000038   0x6208             STR      R0,[R1, #+32]
    268            if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
   \   0000003A   0x....             LDR.N    R0,??DataTable5_3
   \   0000003C   0x.... 0x....      BL       HAL_PCD_Init
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD001             BEQ.N    ??USBD_LL_Init_0
    269            {
    270              Error_Handler();
   \   00000044   0x.... 0x....      BL       Error_Handler
    271            }
    272          
    273            HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
   \                     ??USBD_LL_Init_0: (+1)
   \   00000048   0x2318             MOVS     R3,#+24
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000052   0x.... 0x....      BL       HAL_PCDEx_PMAConfig
    274            HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
   \   00000056   0x2358             MOVS     R3,#+88
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x2180             MOVS     R1,#+128
   \   0000005C   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000060   0x.... 0x....      BL       HAL_PCDEx_PMAConfig
    275            HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);  
   \   00000064   0x23C0             MOVS     R3,#+192
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2181             MOVS     R1,#+129
   \   0000006A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000006E   0x.... 0x....      BL       HAL_PCDEx_PMAConfig
    276            HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
   \   00000072   0xF44F 0x7388      MOV      R3,#+272
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000007E   0x.... 0x....      BL       HAL_PCDEx_PMAConfig
    277            HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);  
   \   00000082   0xF44F 0x7380      MOV      R3,#+256
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x2182             MOVS     R1,#+130
   \   0000008A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000008E   0x.... 0x....      BL       HAL_PCDEx_PMAConfig
    278            return USBD_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD10             POP      {R4,PC}          ;; return
    279          }
    280          
    281          /**
    282            * @brief  De-Initializes the Low Level portion of the Device driver.
    283            * @param  pdev: Device handle
    284            * @retval USBD Status
    285            */

   \                                 In section .text, align 2, keep-with-next
    286          USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
    287          {
   \                     USBD_LL_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288            HAL_PCD_DeInit((PCD_HandleTypeDef*)pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_DeInit
    289            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    290          }
    291          
    292          /**
    293            * @brief  Starts the Low Level portion of the Device driver. 
    294            * @param  pdev: Device handle
    295            * @retval USBD Status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
    298          {
   \                     USBD_LL_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    299            HAL_PCD_Start((PCD_HandleTypeDef*)pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_Start
    300            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    301          }
    302          
    303          /**
    304            * @brief  Stops the Low Level portion of the Device driver.
    305            * @param  pdev: Device handle
    306            * @retval USBD Status
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
    309          {
   \                     USBD_LL_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    310            HAL_PCD_Stop((PCD_HandleTypeDef*) pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_Stop
    311            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    312          }
    313          
    314          /**
    315            * @brief  Opens an endpoint of the Low Level Driver.
    316            * @param  pdev: Device handle
    317            * @param  ep_addr: Endpoint Number
    318            * @param  ep_type: Endpoint Type
    319            * @param  ep_mps: Endpoint Max Packet Size
    320            * @retval USBD Status
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
    323                                                uint8_t  ep_addr,                                      
    324                                                uint8_t  ep_type,
    325                                                uint16_t ep_mps)
    326          {
   \                     USBD_LL_OpenEP: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    327            HAL_PCD_EP_Open((PCD_HandleTypeDef*) pdev->pData,
    328                            ep_addr,
    329                            ep_mps,
    330                            ep_type);
   \   0000000A   0x0033             MOVS     R3,R6
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x003A             MOVS     R2,R7
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000001A   0x.... 0x....      BL       HAL_PCD_EP_Open
    331            
    332            return USBD_OK; 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    333          }
    334          
    335          /**
    336            * @brief  Closes an endpoint of the Low Level Driver.
    337            * @param  pdev: Device handle
    338            * @param  ep_addr: Endpoint Number
    339            * @retval USBD Status
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
    342          {
   \                     USBD_LL_CloseEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    343            HAL_PCD_EP_Close((PCD_HandleTypeDef*) pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_Close
    344            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    345          }
    346          
    347          /**
    348            * @brief  Flushes an endpoint of the Low Level Driver.
    349            * @param  pdev: Device handle
    350            * @param  ep_addr: Endpoint Number
    351            * @retval USBD Status
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
    354          {
   \                     USBD_LL_FlushEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    355            HAL_PCD_EP_Flush((PCD_HandleTypeDef*) pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_Flush
    356            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    357          }
    358          
    359          /**
    360            * @brief  Sets a Stall condition on an endpoint of the Low Level Driver.
    361            * @param  pdev: Device handle
    362            * @param  ep_addr: Endpoint Number
    363            * @retval USBD Status
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
    366          {
   \                     USBD_LL_StallEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    367            HAL_PCD_EP_SetStall((PCD_HandleTypeDef*) pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_SetStall
    368            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    369          }
    370          
    371          /**
    372            * @brief  Clears a Stall condition on an endpoint of the Low Level Driver.
    373            * @param  pdev: Device handle
    374            * @param  ep_addr: Endpoint Number
    375            * @retval USBD Status
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
    378          {
   \                     USBD_LL_ClearStallEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    379            HAL_PCD_EP_ClrStall((PCD_HandleTypeDef*) pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_ClrStall
    380            return USBD_OK; 
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    381          }
    382          
    383          /**
    384            * @brief  Returns Stall condition.
    385            * @param  pdev: Device handle
    386            * @param  ep_addr: Endpoint Number
    387            * @retval Stall (1: Yes, 0: No)
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
    390          {
   \                     USBD_LL_IsStallEP: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    391            PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
   \   00000002   0xF8D2 0x0220      LDR      R0,[R2, #+544]
    392            
    393            if((ep_addr & 0x80) == 0x80)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x060B             LSLS     R3,R1,#+24
   \   0000000A   0xD508             BPL.N    ??USBD_LL_IsStallEP_0
    394            {
    395              return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000012   0x231C             MOVS     R3,#+28
   \   00000014   0x4359             MULS     R1,R3,R1
   \   00000016   0x4408             ADD      R0,R0,R1
   \   00000018   0xF890 0x002A      LDRB     R0,[R0, #+42]
   \   0000001C   0xE007             B.N      ??USBD_LL_IsStallEP_1
    396            }
    397            else
    398            {
    399              return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
   \                     ??USBD_LL_IsStallEP_0: (+1)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000024   0x231C             MOVS     R3,#+28
   \   00000026   0x4359             MULS     R1,R3,R1
   \   00000028   0x4408             ADD      R0,R0,R1
   \   0000002A   0xF890 0x010A      LDRB     R0,[R0, #+266]
   \                     ??USBD_LL_IsStallEP_1: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    400            }
    401          }
    402          /**
    403            * @brief  Assigns a USB address to the device.
    404            * @param  pdev: Device handle
    405            * @param  ep_addr: Endpoint Number
    406            * @retval USBD Status
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
    409          {
   \                     USBD_LL_SetUSBAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    410            HAL_PCD_SetAddress((PCD_HandleTypeDef*) pdev->pData, dev_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_SetAddress
    411            return USBD_OK; 
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    412          }
    413          
    414          /**
    415            * @brief  Transmits data over an endpoint.
    416            * @param  pdev: Device handle
    417            * @param  ep_addr: Endpoint Number
    418            * @param  pbuf: Pointer to data to be sent
    419            * @param  size: Data size    
    420            * @retval USBD Status
    421            */

   \                                 In section .text, align 2, keep-with-next
    422          USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
    423                                                uint8_t  ep_addr,                                      
    424                                                uint8_t  *pbuf,
    425                                                uint16_t  size)
    426          {
   \                     USBD_LL_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    427            HAL_PCD_EP_Transmit((PCD_HandleTypeDef*) pdev->pData, ep_addr, pbuf, size);
   \   0000000A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000018   0x.... 0x....      BL       HAL_PCD_EP_Transmit
    428            return USBD_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    429          }
    430          
    431          /**
    432            * @brief  Prepares an endpoint for reception.
    433            * @param  pdev: Device handle
    434            * @param  ep_addr: Endpoint Number
    435            * @param  pbuf: Pointer to data to be received
    436            * @param  size: Data size
    437            * @retval USBD Status
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
    440                                                     uint8_t  ep_addr,                                      
    441                                                     uint8_t  *pbuf,
    442                                                     uint16_t  size)
    443          {
   \                     USBD_LL_PrepareReceive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    444            HAL_PCD_EP_Receive((PCD_HandleTypeDef*) pdev->pData, ep_addr, pbuf, size);
   \   0000000A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000018   0x.... 0x....      BL       HAL_PCD_EP_Receive
    445            return USBD_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    446          }
    447          
    448          /**
    449            * @brief  Returns the last transfered packet size.
    450            * @param  pdev: Device handle
    451            * @param  ep_addr: Endpoint Number
    452            * @retval Recived Data Size
    453            */

   \                                 In section .text, align 2, keep-with-next
    454          uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
    455          {
   \                     USBD_LL_GetRxDataSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    456            return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_GetRxCount
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    457          }
    458          
    459          /**
    460            * @brief  Delays routine for the USB Device Library.
    461            * @param  Delay: Delay in ms
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void  USBD_LL_Delay (uint32_t Delay)
    465          {
   \                     USBD_LL_Delay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    466            HAL_Delay(Delay);  
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_Delay
    467          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    468          
    469          /**
    470            * @brief  static single allocation.
    471            * @param  size: size of allocated memory
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          void *USBD_static_malloc(uint32_t size)
    475          {
   \                     USBD_static_malloc: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    476            static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];//On 32-bit boundary
    477            return mem;
   \   00000002   0x....             LDR.N    R0,??DataTable5_4
   \   00000004   0x4770             BX       LR               ;; return
    478          }

   \                                 In section .bss, align 4
   \                     `USBD_static_malloc::mem`:
   \   00000000                      DS8 544
    479          
    480          /**
    481            * @brief  Dummy memory free
    482            * @param  *p pointer to allocated  memory address
    483            * @retval None
    484            */

   \                                 In section .text, align 2, keep-with-next
    485          void USBD_static_free(void *p)
    486          {
    487          
    488          }
   \                     USBD_static_free: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    489          
    490          /**
    491          * @brief Software Device Connection
    492          * @param hpcd: PCD handle
    493          * @param state: connection state (0 : disconnected / 1: connected) 
    494          * @retval None
    495          */

   \                                 In section .text, align 2, keep-with-next
    496          void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
    497          {
    498          /* USER CODE BEGIN 5 */
    499            if (state == 1)
   \                     HAL_PCDEx_SetConnectionState: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??HAL_PCDEx_SetConnectionState_0
    500            {
    501              /* Configure Low Connection State */
    502          	__HAL_SYSCFG_USBPULLUP_ENABLE();
   \   00000006   0x....             LDR.N    R2,??DataTable5_5  ;; 0x40010004
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000E   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40010004
   \   00000010   0x601A             STR      R2,[R3, #+0]
   \   00000012   0xE005             B.N      ??HAL_PCDEx_SetConnectionState_1
    503            }
    504            else
    505            {
    506              /* Configure High Connection State */
    507              __HAL_SYSCFG_USBPULLUP_DISABLE();
   \                     ??HAL_PCDEx_SetConnectionState_0: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable5_5  ;; 0x40010004
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x0852             LSRS     R2,R2,#+1
   \   0000001A   0x0052             LSLS     R2,R2,#+1
   \   0000001C   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40010004
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    508            } 
    509          /* USER CODE END 5 */
    510          }
   \                     ??HAL_PCDEx_SetConnectionState_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     hpcd_USB_FS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     `USBD_static_malloc::mem`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40010004         DC32     0x40010004
    511          
    512          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PCDEx_SetConnectionState
       8   HAL_PCD_ConnectCallback
         8   -> USBD_LL_DevConnected
      16   HAL_PCD_DataInStageCallback
        16   -> USBD_LL_DataInStage
      16   HAL_PCD_DataOutStageCallback
        16   -> USBD_LL_DataOutStage
       8   HAL_PCD_DisconnectCallback
         8   -> USBD_LL_DevDisconnected
      16   HAL_PCD_ISOINIncompleteCallback
        16   -> USBD_LL_IsoINIncomplete
      16   HAL_PCD_ISOOUTIncompleteCallback
        16   -> USBD_LL_IsoOUTIncomplete
       8   HAL_PCD_MspDeInit
         8   -> HAL_NVIC_DisableIRQ
      16   HAL_PCD_MspInit
        16   -> HAL_NVIC_EnableIRQ
        16   -> HAL_NVIC_SetPriority
      16   HAL_PCD_ResetCallback
        16   -> USBD_LL_Reset
        16   -> USBD_LL_SetSpeed
       8   HAL_PCD_ResumeCallback
         8   -> USBD_LL_Resume
       8   HAL_PCD_SOFCallback
         8   -> USBD_LL_SOF
       8   HAL_PCD_SetupStageCallback
         8   -> USBD_LL_SetupStage
       8   HAL_PCD_SuspendCallback
         8   -> USBD_LL_Suspend
      16   USBD_LL_ClearStallEP
        16   -> HAL_PCD_EP_ClrStall
      16   USBD_LL_CloseEP
        16   -> HAL_PCD_EP_Close
       8   USBD_LL_DeInit
         8   -> HAL_PCD_DeInit
       8   USBD_LL_Delay
         8   -> HAL_Delay
      16   USBD_LL_FlushEP
        16   -> HAL_PCD_EP_Flush
      16   USBD_LL_GetRxDataSize
        16   -> HAL_PCD_EP_GetRxCount
       8   USBD_LL_Init
         8   -> Error_Handler
         8   -> HAL_PCDEx_PMAConfig
         8   -> HAL_PCD_Init
       0   USBD_LL_IsStallEP
      24   USBD_LL_OpenEP
        24   -> HAL_PCD_EP_Open
      24   USBD_LL_PrepareReceive
        24   -> HAL_PCD_EP_Receive
      16   USBD_LL_SetUSBAddress
        16   -> HAL_PCD_SetAddress
      16   USBD_LL_StallEP
        16   -> HAL_PCD_EP_SetStall
       8   USBD_LL_Start
         8   -> HAL_PCD_Start
       8   USBD_LL_Stop
         8   -> HAL_PCD_Stop
      24   USBD_LL_Transmit
        24   -> HAL_PCD_EP_Transmit
       0   USBD_static_free
       0   USBD_static_malloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
      34  HAL_PCDEx_SetConnectionState
      14  HAL_PCD_ConnectCallback
      32  HAL_PCD_DataInStageCallback
      34  HAL_PCD_DataOutStageCallback
      14  HAL_PCD_DisconnectCallback
      20  HAL_PCD_ISOINIncompleteCallback
      20  HAL_PCD_ISOOUTIncompleteCallback
      32  HAL_PCD_MspDeInit
      56  HAL_PCD_MspInit
      44  HAL_PCD_ResetCallback
      14  HAL_PCD_ResumeCallback
      14  HAL_PCD_SOFCallback
      22  HAL_PCD_SetupStageCallback
      32  HAL_PCD_SuspendCallback
      22  USBD_LL_ClearStallEP
      22  USBD_LL_CloseEP
      16  USBD_LL_DeInit
      12  USBD_LL_Delay
      22  USBD_LL_FlushEP
      20  USBD_LL_GetRxDataSize
     150  USBD_LL_Init
      48  USBD_LL_IsStallEP
      34  USBD_LL_OpenEP
      32  USBD_LL_PrepareReceive
      22  USBD_LL_SetUSBAddress
      22  USBD_LL_StallEP
      16  USBD_LL_Start
      16  USBD_LL_Stop
      32  USBD_LL_Transmit
       2  USBD_static_free
       6  USBD_static_malloc
     544  hpcd_USB_FS
     544  mem

 
 1 088 bytes in section .bss
   900 bytes in section .text
 
   900 bytes of CODE memory
 1 088 bytes of DATA memory

Errors: none
Warnings: none
