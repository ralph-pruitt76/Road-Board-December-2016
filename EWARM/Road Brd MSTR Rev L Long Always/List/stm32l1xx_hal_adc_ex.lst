###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Sep/2017  09:07:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc_ex.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc_ex.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\stm32l1xx_hal_adc_ex.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\stm32l1xx_hal_adc_ex.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_adc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC)
      9            *          peripheral:
     10            *           + Operation functions
     11            *             ++ Start, stop, get result of conversions of injected
     12            *                group, using 2 possible modes: polling, interruption.
     13            *             ++ Calibration (ADC automatic self-calibration)
     14            *           + Control functions
     15            *             ++ Channels configuration on injected group
     16            *          Other functions (generic functions) are available in file 
     17            *          "stm32l1xx_hal_adc.c".
     18            *
     19            @verbatim
     20            [..] 
     21            (@) Sections "ADC peripheral features" and "How to use this driver" are
     22                available in file of generic functions "stm32l1xx_hal_adc.c".
     23            [..]
     24            @endverbatim
     25            ******************************************************************************
     26            * @attention
     27            *
     28            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     29            *
     30            * Redistribution and use in source and binary forms, with or without modification,
     31            * are permitted provided that the following conditions are met:
     32            *   1. Redistributions of source code must retain the above copyright notice,
     33            *      this list of conditions and the following disclaimer.
     34            *   2. Redistributions in binary form must reproduce the above copyright notice,
     35            *      this list of conditions and the following disclaimer in the documentation
     36            *      and/or other materials provided with the distribution.
     37            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     38            *      may be used to endorse or promote products derived from this software
     39            *      without specific prior written permission.
     40            *
     41            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     42            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     43            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     44            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     45            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     46            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     47            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     48            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     49            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     50            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     51            *
     52            ******************************************************************************
     53            */
     54          
     55          /* Includes ------------------------------------------------------------------*/
     56          #include "stm32l1xx_hal.h"
     57          
     58          /** @addtogroup STM32L1xx_HAL_Driver
     59            * @{
     60            */
     61          
     62          /** @defgroup ADCEx ADCEx
     63            * @brief ADC Extension HAL module driver
     64            * @{
     65            */
     66          
     67          #ifdef HAL_ADC_MODULE_ENABLED
     68          
     69          /* Private typedef -----------------------------------------------------------*/
     70          /* Private define ------------------------------------------------------------*/
     71          /** @defgroup ADCEx_Private_Constants ADCEx Private Constants
     72            * @{
     73            */
     74          
     75            /* ADC conversion cycles (unit: ADC clock cycles)                           */
     76            /* (selected sampling time + conversion time of 12 ADC clock cycles, with   */
     77            /* resolution 12 bits)                                                      */
     78            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_4CYCLE5   ((uint32_t) 16)
     79            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_9CYCLES   ((uint32_t) 21)
     80            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_16CYCLES  ((uint32_t) 28)
     81            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_24CYCLES  ((uint32_t) 36)
     82            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_48CYCLES  ((uint32_t) 60)
     83            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_96CYCLES  ((uint32_t)108)
     84            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_192CYCLES ((uint32_t)204)
     85            #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_384CYCLES ((uint32_t)396)
     86          
     87            /* Delay for temperature sensor stabilization time.                         */
     88            /* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
     89            /* Unit: us                                                                 */
     90            #define ADC_TEMPSENSOR_DELAY_US         ((uint32_t) 10)
     91          
     92          /**
     93            * @}
     94            */
     95          
     96          /* Private macro -------------------------------------------------------------*/
     97          /* Private variables ---------------------------------------------------------*/
     98          /* Private function prototypes -----------------------------------------------*/
     99          /* Private functions ---------------------------------------------------------*/
    100          
    101          /** @defgroup ADCEx_Exported_Functions ADCEx Exported Functions
    102            * @{
    103            */
    104          
    105          /** @defgroup ADCEx_Exported_Functions_Group1 ADC Extended IO operation functions
    106           *  @brief    ADC Extended Input and Output operation functions
    107           *
    108          @verbatim
    109           ===============================================================================
    110                                ##### IO operation functions #####
    111           ===============================================================================
    112              [..]  This section provides functions allowing to:
    113                (+) Start conversion of injected group.
    114                (+) Stop conversion of injected group.
    115                (+) Poll for conversion complete on injected group.
    116                (+) Get result of injected channel conversion.
    117                (+) Start conversion of injected group and enable interruptions.
    118                (+) Stop conversion of injected group and disable interruptions.
    119                
    120          @endverbatim
    121            * @{
    122            */
    123          
    124          /**
    125            * @brief  Enables ADC, starts conversion of injected group.
    126            *         Interruptions enabled in this function: None.
    127            * @param  hadc: ADC handle
    128            * @retval HAL status
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
    131          {
   \                     HAL_ADCEx_InjectedStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    132            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    133            
    134            /* Check the parameters */
    135            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    136            
    137            /* Process locked */
    138            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE02D             B.N      ??HAL_ADCEx_InjectedStart_1
   \                     ??HAL_ADCEx_InjectedStart_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    139              
    140            /* Enable the ADC peripheral */
    141            tmp_hal_status = ADC_Enable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_Enable
   \   0000001E   0x0005             MOVS     R5,R0
    142            
    143            /* Start conversion if ADC is effectively enabled */
    144            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD121             BNE.N    ??HAL_ADCEx_InjectedStart_2
    145            {
    146              /* Set ADC state                                                          */
    147              /* - Clear state bitfield related to injected group conversion results    */
    148              /* - Set state bitfield related to injected operation                     */
    149              ADC_STATE_CLR_SET(hadc->State,
    150                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    151                                HAL_ADC_STATE_INJ_BUSY);
   \   00000026   0x6CE0             LDR      R0,[R4, #+76]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0xffffdffe
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000032   0x64E0             STR      R0,[R4, #+76]
    152              
    153              /* Check if a regular conversion is ongoing */
    154              /* Note: On this device, there is no ADC error code fields related to     */
    155              /*       conversions on group injected only. In case of conversion on     */
    156              /*       going on group regular, no error code is reset.                  */
    157              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   00000034   0x6CE0             LDR      R0,[R4, #+76]
   \   00000036   0x05C0             LSLS     R0,R0,#+23
   \   00000038   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_3
    158              {
    159                /* Reset ADC all error code fields */
    160                ADC_CLEAR_ERRORCODE(hadc);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6520             STR      R0,[R4, #+80]
    161              }
    162              
    163              /* Process unlocked */
    164              /* Unlock before starting ADC conversions: in case of potential           */
    165              /* interruption, to let the process to ADC IRQ Handler.                   */
    166              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_3: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x0048      STRB     R0,[R4, #+72]
    167              
    168              /* Clear injected group conversion flag */
    169              /* (To ensure of no unknown state from potential previous ADC operations) */
    170              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \   00000044   0xF07F 0x0004      MVNS     R0,#+4
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    171              
    172              /* Enable conversion of injected group.                                   */
    173              /* If software start has been selected, conversion starts immediately.    */
    174              /* If external trigger has been selected, conversion will start at next   */
    175              /* trigger event.                                                         */
    176              /* If automatic injected conversion is enabled, conversion will start     */
    177              /* after next regular group conversion.                                   */
    178              if (ADC_IS_SOFTWARE_START_INJECTED(hadc)              && 
    179                  HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6880             LDR      R0,[R0, #+8]
   \   00000050   0xF410 0x1F40      TST      R0,#0x300000
   \   00000054   0xD109             BNE.N    ??HAL_ADCEx_InjectedStart_2
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0x0540             LSLS     R0,R0,#+21
   \   0000005C   0xD405             BMI.N    ??HAL_ADCEx_InjectedStart_2
    180              {
    181                /* Enable ADC software conversion for injected channels */
    182                SET_BIT(hadc->Instance->CR2, ADC_CR2_JSWSTART);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6088             STR      R0,[R1, #+8]
    183              }
    184            }
    185            
    186            /* Return function status */
    187            return tmp_hal_status;
   \                     ??HAL_ADCEx_InjectedStart_2: (+1)
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADCEx_InjectedStart_1: (+1)
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    188          }
    189          
    190          /**
    191            * @brief  Stop conversion of injected channels. Disable ADC peripheral if
    192            *         no regular conversion is on going.
    193            * @note   If ADC must be disabled and if conversion is on going on 
    194            *         regular group, function HAL_ADC_Stop must be used to stop both
    195            *         injected and regular groups, and disable the ADC.
    196            * @note   If injected group mode auto-injection is enabled,
    197            *         function HAL_ADC_Stop must be used.
    198            * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
    199            * @param  hadc: ADC handle
    200            * @retval None
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
    203          {
   \                     HAL_ADCEx_InjectedStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    204            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    205            
    206            /* Check the parameters */
    207            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    208          
    209            /* Process locked */
    210            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE022             B.N      ??HAL_ADCEx_InjectedStop_1
   \                     ??HAL_ADCEx_InjectedStop_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    211              
    212            /* Stop potential conversion and disable ADC peripheral                     */
    213            /* Conditioned to:                                                          */
    214            /* - No conversion on the other group (regular group) is intended to        */
    215            /*   continue (injected and regular groups stop conversion and ADC disable  */
    216            /*   are common)                                                            */
    217            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
    218            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    219               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \   00000018   0x6CE0             LDR      R0,[R4, #+76]
   \   0000001A   0x05C0             LSLS     R0,R0,#+23
   \   0000001C   0xD411             BMI.N    ??HAL_ADCEx_InjectedStop_2
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0x0540             LSLS     R0,R0,#+21
   \   00000024   0xD40D             BMI.N    ??HAL_ADCEx_InjectedStop_2
    220            {
    221              /* Stop potential conversion on going, on regular and injected groups */
    222              /* Disable ADC peripheral */
    223              tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000002C   0x0005             MOVS     R5,R0
    224              
    225              /* Check if ADC is effectively disabled */
    226              if (tmp_hal_status == HAL_OK)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD10C             BNE.N    ??HAL_ADCEx_InjectedStop_3
    227              {
    228                /* Set ADC state */
    229                ADC_STATE_CLR_SET(hadc->State,
    230                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    231                                  HAL_ADC_STATE_READY);
   \   00000034   0x6CE0             LDR      R0,[R4, #+76]
   \   00000036   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x64E0             STR      R0,[R4, #+76]
   \   00000040   0xE005             B.N      ??HAL_ADCEx_InjectedStop_3
    232              }
    233            }
    234            else
    235            {
    236              /* Update ADC state machine to error */
    237              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_2: (+1)
   \   00000042   0x6CE0             LDR      R0,[R4, #+76]
   \   00000044   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000048   0x64E0             STR      R0,[R4, #+76]
    238                
    239              tmp_hal_status = HAL_ERROR;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0005             MOVS     R5,R0
    240            }
    241            
    242            /* Process unlocked */
    243            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_3: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF884 0x0048      STRB     R0,[R4, #+72]
    244            
    245            /* Return function status */
    246            return tmp_hal_status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADCEx_InjectedStop_1: (+1)
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    247          }
    248          
    249          /**
    250            * @brief  Wait for injected group conversion to be completed.
    251            * @param  hadc: ADC handle
    252            * @param  Timeout: Timeout value in millisecond.
    253            * @retval HAL status
    254            */

   \                                 In section .text, align 2, keep-with-next
    255          HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    256          {
   \                     HAL_ADCEx_InjectedPollForConversion: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    257            uint32_t tickstart;
    258          
    259            /* Variables for polling in case of scan mode enabled and polling for each  */
    260            /* conversion.                                                              */
    261            /* Note: Variable "conversion_timeout_cpu_cycles" set to offset 28 CPU      */
    262            /* cycles to compensate number of CPU cycles for processing of variable     */
    263            /* "conversion_timeout_cpu_cycles_max"                                      */
    264            uint32_t conversion_timeout_cpu_cycles = 28;
   \   00000008   0x271C             MOVS     R7,#+28
    265            uint32_t conversion_timeout_cpu_cycles_max = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    266            
    267            /* Check the parameters */
    268            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    269            
    270            /* Get timeout */
    271            tickstart = HAL_GetTick();  
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x0006             MOVS     R6,R0
    272               
    273            /* Polling for end of conversion: differentiation if single/sequence        */
    274            /* conversion.                                                              */
    275            /* For injected group, flag JEOC is set only at the end of the sequence,    */
    276            /* not for each conversion within the sequence.                             */
    277            /* If setting "EOCSelection" is set to poll for each single conversion,     */
    278            /* management of polling depends on setting of injected group sequencer:    */ 
    279            /*  - If single conversion for injected group (scan mode disabled or        */
    280            /*    InjectedNbrOfConversion ==1), flag JEOC is used to determine the      */
    281            /*    conversion completion.                                                */
    282            /*  - If sequence conversion for injected group (scan mode enabled and      */
    283            /*    InjectedNbrOfConversion >=2), flag JEOC is set only at the end of the */
    284            /*    sequence.                                                             */
    285            /*    To poll for each conversion, the maximum conversion time is computed  */
    286            /*    from ADC conversion time (selected sampling time + conversion time of */
    287            /*    12 ADC clock cycles) and APB2/ADC clock prescalers (depending on      */
    288            /*    settings, conversion time range can vary from 8 to several thousands  */
    289            /*    of CPU cycles).                                                       */
    290          
    291            /* Note: On STM32L1, setting "EOCSelection" is related to regular group     */
    292            /*       only, by hardware. For compatibility with other STM32 devices,     */
    293            /*       this setting is related also to injected group by software.        */
    294            if (((hadc->Instance->JSQR & ADC_JSQR_JL) == RESET)  ||
    295                (hadc->Init.EOCSelection != ADC_EOC_SINGLE_CONV)   )
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6C40             LDR      R0,[R0, #+68]
   \   00000018   0xF410 0x1F40      TST      R0,#0x300000
   \   0000001C   0xD003             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_0
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000024   0xD016             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_1
    296            {
    297              /* Wait until End of Conversion flag is raised */
    298              while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
   \                     ??HAL_ADCEx_InjectedPollForConversion_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0740             LSLS     R0,R0,#+29
   \   0000002C   0xD454             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_2
    299              {
    300                /* Check if timeout is disabled (set to infinite wait) */
    301                if(Timeout != HAL_MAX_DELAY)
   \   0000002E   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000032   0xD0F8             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_0
    302                {
    303                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_3
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B80             SUBS     R0,R0,R6
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD2F1             BCS.N    ??HAL_ADCEx_InjectedPollForConversion_0
    304                  {
    305                    /* Update ADC state machine to timeout */
    306                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADCEx_InjectedPollForConversion_3: (+1)
   \   00000042   0x6CE0             LDR      R0,[R4, #+76]
   \   00000044   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000048   0x64E0             STR      R0,[R4, #+76]
    307                    
    308                    /* Process unlocked */
    309                    __HAL_UNLOCK(hadc);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF884 0x0048      STRB     R0,[R4, #+72]
    310                    
    311                    return HAL_TIMEOUT;
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0xE072             B.N      ??HAL_ADCEx_InjectedPollForConversion_4
    312                  }
    313                }
    314              }
    315            }
    316            else
    317            {
    318              /* Computation of CPU cycles corresponding to ADC conversion cycles.      */
    319              /* Retrieve ADC clock prescaler and ADC maximum conversion cycles on all  */
    320              /* channels.                                                              */
    321              conversion_timeout_cpu_cycles_max = ADC_GET_CLOCK_PRESCALER_DECIMAL(hadc);
   \                     ??HAL_ADCEx_InjectedPollForConversion_1: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable3_1  ;; 0x40012704
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   00000060   0xF44F 0x4240      MOV      R2,#+49152
   \   00000064   0xFAB2 0xF282      CLZ      R2,R2
   \   00000068   0x40D0             LSRS     R0,R0,R2
   \   0000006A   0xFA11 0xF000      LSLS     R0,R1,R0
   \   0000006E   0x4680             MOV      R8,R0
    322              conversion_timeout_cpu_cycles_max *= ADC_CONVCYCLES_MAX_RANGE(hadc);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6940             LDR      R0,[R0, #+20]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable3_2  ;; 0x24924924
   \   00000078   0x4208             TST      R0,R1
   \   0000007A   0xD112             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_5
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6900             LDR      R0,[R0, #+16]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable3_2  ;; 0x24924924
   \   00000084   0x4208             TST      R0,R1
   \   00000086   0xD10C             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_5
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable3_2  ;; 0x24924924
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD106             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_5
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6DC0             LDR      R0,[R0, #+92]
   \   00000098   0xF010 0x0F24      TST      R0,#0x24
   \   0000009C   0xD101             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_5
   \   0000009E   0x2024             MOVS     R0,#+36
   \   000000A0   0xE001             B.N      ??HAL_ADCEx_InjectedPollForConversion_6
   \                     ??HAL_ADCEx_InjectedPollForConversion_5: (+1)
   \   000000A2   0xF44F 0x70C6      MOV      R0,#+396
   \                     ??HAL_ADCEx_InjectedPollForConversion_6: (+1)
   \   000000A6   0xFB00 0xF808      MUL      R8,R0,R8
    323          
    324              /* Poll with maximum conversion time */
    325              while(conversion_timeout_cpu_cycles < conversion_timeout_cpu_cycles_max)
   \                     ??HAL_ADCEx_InjectedPollForConversion_7: (+1)
   \   000000AA   0x4547             CMP      R7,R8
   \   000000AC   0xD214             BCS.N    ??HAL_ADCEx_InjectedPollForConversion_2
    326              {
    327                /* Check if timeout is disabled (set to infinite wait) */
    328                if(Timeout != HAL_MAX_DELAY)
   \   000000AE   0xF5B5 0x4F00      CMP      R5,#+32768
   \   000000B2   0xD00F             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_8
    329                {
    330                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   000000B4   0x2D00             CMP      R5,#+0
   \   000000B6   0xD004             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_9
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0x1B80             SUBS     R0,R0,R6
   \   000000BE   0x4285             CMP      R5,R0
   \   000000C0   0xD208             BCS.N    ??HAL_ADCEx_InjectedPollForConversion_8
    331                  {
    332                    /* Update ADC state machine to timeout */
    333                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADCEx_InjectedPollForConversion_9: (+1)
   \   000000C2   0x6CE0             LDR      R0,[R4, #+76]
   \   000000C4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000C8   0x64E0             STR      R0,[R4, #+76]
    334          
    335                    /* Process unlocked */
    336                    __HAL_UNLOCK(hadc);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0048      STRB     R0,[R4, #+72]
    337                    
    338                    return HAL_TIMEOUT;
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0xE032             B.N      ??HAL_ADCEx_InjectedPollForConversion_4
    339                  }
    340                }
    341                conversion_timeout_cpu_cycles ++;
   \                     ??HAL_ADCEx_InjectedPollForConversion_8: (+1)
   \   000000D4   0x1C7F             ADDS     R7,R7,#+1
   \   000000D6   0xE7E8             B.N      ??HAL_ADCEx_InjectedPollForConversion_7
    342              }
    343            }
    344            
    345            /* Clear end of conversion flag of injected group if low power feature      */
    346            /* "Auto Wait" is disabled, to not interfere with this feature until data   */
    347            /* register is read using function HAL_ADCEx_InjectedGetValue().            */
    348            if (hadc->Init.LowPowerAutoWait == DISABLE)
   \                     ??HAL_ADCEx_InjectedPollForConversion_2: (+1)
   \   000000D8   0x69A0             LDR      R0,[R4, #+24]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD103             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_10
    349            {
    350              /* Clear injected group conversion flag */
    351              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC);
   \   000000DE   0xF07F 0x000C      MVNS     R0,#+12
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x6008             STR      R0,[R1, #+0]
    352            }
    353            
    354            /* Update ADC state machine */
    355            SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \                     ??HAL_ADCEx_InjectedPollForConversion_10: (+1)
   \   000000E6   0x6CE0             LDR      R0,[R4, #+76]
   \   000000E8   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000EC   0x64E0             STR      R0,[R4, #+76]
    356            
    357            /* Determine whether any further conversion upcoming on group injected      */
    358            /* by external trigger, continuous mode or scan sequence on going.          */
    359            /* Note: On STM32L1, there is no independent flag of end of sequence.       */
    360            /*       The test of scan sequence on going is done either with scan        */
    361            /*       sequence disabled or with end of conversion flag set to            */
    362            /*       of end of sequence.                                                */
    363            if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
    364               (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
    365                HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
    366               (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
    367                (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
    368                (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6880             LDR      R0,[R0, #+8]
   \   000000F2   0xF410 0x1F40      TST      R0,#0x300000
   \   000000F6   0xD11F             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_11
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6C40             LDR      R0,[R0, #+68]
   \   000000FC   0xF410 0x1F40      TST      R0,#0x300000
   \   00000100   0xD003             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_12
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6880             LDR      R0,[R0, #+8]
   \   00000106   0x0540             LSLS     R0,R0,#+21
   \   00000108   0xD416             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_11
   \                     ??HAL_ADCEx_InjectedPollForConversion_12: (+1)
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6840             LDR      R0,[R0, #+4]
   \   0000010E   0x0540             LSLS     R0,R0,#+21
   \   00000110   0xD412             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_11
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6880             LDR      R0,[R0, #+8]
   \   00000116   0xF010 0x5F40      TST      R0,#0x30000000
   \   0000011A   0xD10D             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_11
   \   0000011C   0x6A60             LDR      R0,[R4, #+36]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD10A             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_11
    369            {
    370              /* Set ADC state */
    371              CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
   \   00000122   0x6CE0             LDR      R0,[R4, #+76]
   \   00000124   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000128   0x64E0             STR      R0,[R4, #+76]
    372              
    373              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   0000012A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000012C   0x05C0             LSLS     R0,R0,#+23
   \   0000012E   0xD403             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_11
    374              { 
    375                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   00000130   0x6CE0             LDR      R0,[R4, #+76]
   \   00000132   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000136   0x64E0             STR      R0,[R4, #+76]
    376              }
    377            }
    378            
    379            /* Return ADC state */
    380            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedPollForConversion_11: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedPollForConversion_4: (+1)
   \   0000013A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    381          }
    382          
    383          /**
    384            * @brief  Enables ADC, starts conversion of injected group with interruption.
    385            *          - JEOC (end of conversion of injected group)
    386            *         Each of these interruptions has its dedicated callback function.
    387            * @param  hadc: ADC handle
    388            * @retval HAL status.
    389            */

   \                                 In section .text, align 2, keep-with-next
    390          HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
    391          {
   \                     HAL_ADCEx_InjectedStart_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    392            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    393            
    394            /* Check the parameters */
    395            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    396            
    397            /* Process locked */
    398            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE032             B.N      ??HAL_ADCEx_InjectedStart_IT_1
   \                     ??HAL_ADCEx_InjectedStart_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    399              
    400            /* Enable the ADC peripheral */
    401            tmp_hal_status = ADC_Enable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_Enable
   \   0000001E   0x0005             MOVS     R5,R0
    402            
    403            /* Start conversion if ADC is effectively enabled */
    404            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD126             BNE.N    ??HAL_ADCEx_InjectedStart_IT_2
    405            {
    406              /* Set ADC state                                                          */
    407              /* - Clear state bitfield related to injected group conversion results    */
    408              /* - Set state bitfield related to injected operation                     */
    409              ADC_STATE_CLR_SET(hadc->State,
    410                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    411                                HAL_ADC_STATE_INJ_BUSY);
   \   00000026   0x6CE0             LDR      R0,[R4, #+76]
   \   00000028   0x....             LDR.N    R1,??DataTable3  ;; 0xffffdffe
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000030   0x64E0             STR      R0,[R4, #+76]
    412              
    413              /* Check if a regular conversion is ongoing */
    414              /* Note: On this device, there is no ADC error code fields related to     */
    415              /*       conversions on group injected only. In case of conversion on     */
    416              /*       going on group regular, no error code is reset.                  */
    417              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   00000032   0x6CE0             LDR      R0,[R4, #+76]
   \   00000034   0x05C0             LSLS     R0,R0,#+23
   \   00000036   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_IT_3
    418              {
    419                /* Reset ADC all error code fields */
    420                ADC_CLEAR_ERRORCODE(hadc);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6520             STR      R0,[R4, #+80]
    421              }
    422              
    423              /* Process unlocked */
    424              /* Unlock before starting ADC conversions: in case of potential           */
    425              /* interruption, to let the process to ADC IRQ Handler.                   */
    426              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_IT_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x0048      STRB     R0,[R4, #+72]
    427              
    428              /* Clear injected group conversion flag */
    429              /* (To ensure of no unknown state from potential previous ADC operations) */
    430              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \   00000042   0xF07F 0x0004      MVNS     R0,#+4
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
    431              
    432              /* Enable end of conversion interrupt for injected channels */
    433              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
    434              
    435              /* Enable conversion of injected group.                                   */
    436              /* If software start has been selected, conversion starts immediately.    */
    437              /* If external trigger has been selected, conversion will start at next   */
    438              /* trigger event.                                                         */
    439              /* If automatic injected conversion is enabled, conversion will start     */
    440              /* after next regular group conversion.                                   */
    441              if (ADC_IS_SOFTWARE_START_INJECTED(hadc)              && 
    442                  HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6880             LDR      R0,[R0, #+8]
   \   0000005A   0xF410 0x1F40      TST      R0,#0x300000
   \   0000005E   0xD109             BNE.N    ??HAL_ADCEx_InjectedStart_IT_2
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x0540             LSLS     R0,R0,#+21
   \   00000066   0xD405             BMI.N    ??HAL_ADCEx_InjectedStart_IT_2
    443              {
    444                /* Enable ADC software conversion for injected channels */
    445                SET_BIT(hadc->Instance->CR2, ADC_CR2_JSWSTART);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6880             LDR      R0,[R0, #+8]
   \   0000006C   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6088             STR      R0,[R1, #+8]
    446              }
    447            }
    448            
    449            /* Return function status */
    450            return tmp_hal_status;
   \                     ??HAL_ADCEx_InjectedStart_IT_2: (+1)
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADCEx_InjectedStart_IT_1: (+1)
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    451          }
    452          
    453          /**
    454            * @brief  Stop conversion of injected channels, disable interruption of 
    455            *         end-of-conversion. Disable ADC peripheral if no regular conversion
    456            *         is on going.
    457            * @note   If ADC must be disabled and if conversion is on going on 
    458            *         regular group, function HAL_ADC_Stop must be used to stop both
    459            *         injected and regular groups, and disable the ADC.
    460            * @note   If injected group mode auto-injection is enabled,
    461            *         function HAL_ADC_Stop must be used.
    462            * @param  hadc: ADC handle
    463            * @retval None
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
    466          {
   \                     HAL_ADCEx_InjectedStop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    467            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    468            
    469            /* Check the parameters */
    470            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    471          
    472            /* Process locked */
    473            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE029             B.N      ??HAL_ADCEx_InjectedStop_IT_1
   \                     ??HAL_ADCEx_InjectedStop_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    474              
    475            /* Stop potential conversion and disable ADC peripheral                     */
    476            /* Conditioned to:                                                          */
    477            /* - No conversion on the other group (regular group) is intended to        */
    478            /*   continue (injected and regular groups stop conversion and ADC disable  */
    479            /*   are common)                                                            */
    480            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
    481            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    482               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \   00000018   0x6CE0             LDR      R0,[R4, #+76]
   \   0000001A   0x05C0             LSLS     R0,R0,#+23
   \   0000001C   0xD418             BMI.N    ??HAL_ADCEx_InjectedStop_IT_2
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0x0540             LSLS     R0,R0,#+21
   \   00000024   0xD414             BMI.N    ??HAL_ADCEx_InjectedStop_IT_2
    483            {
    484              /* Stop potential conversion on going, on regular and injected groups */
    485              /* Disable ADC peripheral */
    486              tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000002C   0x0005             MOVS     R5,R0
    487              
    488              /* Check if ADC is effectively disabled */
    489              if (tmp_hal_status == HAL_OK)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD113             BNE.N    ??HAL_ADCEx_InjectedStop_IT_3
    490              {
    491                /* Disable ADC end of conversion interrupt for injected channels */
    492                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0xF07F 0x0180      MVNS     R1,#+128
   \   0000003C   0x4008             ANDS     R0,R1,R0
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x6048             STR      R0,[R1, #+4]
    493                
    494                /* Set ADC state */
    495                ADC_STATE_CLR_SET(hadc->State,
    496                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    497                                  HAL_ADC_STATE_READY);
   \   00000042   0x6CE0             LDR      R0,[R4, #+76]
   \   00000044   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   00000048   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004C   0x64E0             STR      R0,[R4, #+76]
   \   0000004E   0xE005             B.N      ??HAL_ADCEx_InjectedStop_IT_3
    498              }
    499            }
    500            else
    501            {
    502              /* Update ADC state machine to error */
    503              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_IT_2: (+1)
   \   00000050   0x6CE0             LDR      R0,[R4, #+76]
   \   00000052   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000056   0x64E0             STR      R0,[R4, #+76]
    504                
    505              tmp_hal_status = HAL_ERROR;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x0005             MOVS     R5,R0
    506            }
    507            
    508            /* Process unlocked */
    509            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_IT_3: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF884 0x0048      STRB     R0,[R4, #+72]
    510            
    511            /* Return function status */
    512            return tmp_hal_status;
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADCEx_InjectedStop_IT_1: (+1)
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    513          }
    514          
    515          /**
    516            * @brief  Get ADC injected group conversion result.
    517            * @note   Reading register JDRx automatically clears ADC flag JEOC
    518            *         (ADC group injected end of unitary conversion).
    519            * @note   This function does not clear ADC flag JEOS 
    520            *         (ADC group injected end of sequence conversion)
    521            *         Occurrence of flag JEOS rising:
    522            *          - If sequencer is composed of 1 rank, flag JEOS is equivalent
    523            *            to flag JEOC.
    524            *          - If sequencer is composed of several ranks, during the scan
    525            *            sequence flag JEOC only is raised, at the end of the scan sequence
    526            *            both flags JEOC and EOS are raised.
    527            *         Flag JEOS must not be cleared by this function because
    528            *         it would not be compliant with low power features
    529            *         (feature low power auto-wait, not available on all STM32 families).
    530            *         To clear this flag, either use function: 
    531            *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
    532            *         model polling: @ref HAL_ADCEx_InjectedPollForConversion() 
    533            *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_JEOS).
    534            * @param  hadc: ADC handle
    535            * @param  InjectedRank: the converted ADC injected rank.
    536            *          This parameter can be one of the following values:
    537            *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
    538            *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
    539            *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
    540            *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
    541            * @retval ADC group injected conversion data
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
    544          {
   \                     HAL_ADCEx_InjectedGetValue: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    545            uint32_t tmp_jdr = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    546            
    547            /* Check the parameters */
    548            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    549            assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
    550            
    551            /* Get ADC converted value */
    552            switch(InjectedRank)
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD00C             BEQ.N    ??HAL_ADCEx_InjectedGetValue_0
   \   00000008   0xD30F             BCC.N    ??HAL_ADCEx_InjectedGetValue_1
   \   0000000A   0x2904             CMP      R1,#+4
   \   0000000C   0xD001             BEQ.N    ??HAL_ADCEx_InjectedGetValue_2
   \   0000000E   0xD304             BCC.N    ??HAL_ADCEx_InjectedGetValue_3
   \   00000010   0xE00B             B.N      ??HAL_ADCEx_InjectedGetValue_1
    553            {  
    554              case ADC_INJECTED_RANK_4:
    555                tmp_jdr = hadc->Instance->JDR4;
   \                     ??HAL_ADCEx_InjectedGetValue_2: (+1)
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0x6D5B             LDR      R3,[R3, #+84]
   \   00000016   0x0018             MOVS     R0,R3
    556                break;
   \   00000018   0xE00A             B.N      ??HAL_ADCEx_InjectedGetValue_4
    557              case ADC_INJECTED_RANK_3: 
    558                tmp_jdr = hadc->Instance->JDR3;
   \                     ??HAL_ADCEx_InjectedGetValue_3: (+1)
   \   0000001A   0x6813             LDR      R3,[R2, #+0]
   \   0000001C   0x6D1B             LDR      R3,[R3, #+80]
   \   0000001E   0x0018             MOVS     R0,R3
    559                break;
   \   00000020   0xE006             B.N      ??HAL_ADCEx_InjectedGetValue_4
    560              case ADC_INJECTED_RANK_2: 
    561                tmp_jdr = hadc->Instance->JDR2;
   \                     ??HAL_ADCEx_InjectedGetValue_0: (+1)
   \   00000022   0x6813             LDR      R3,[R2, #+0]
   \   00000024   0x6CDB             LDR      R3,[R3, #+76]
   \   00000026   0x0018             MOVS     R0,R3
    562                break;
   \   00000028   0xE002             B.N      ??HAL_ADCEx_InjectedGetValue_4
    563              case ADC_INJECTED_RANK_1:
    564              default:
    565                tmp_jdr = hadc->Instance->JDR1;
   \                     ??HAL_ADCEx_InjectedGetValue_1: (+1)
   \   0000002A   0x6813             LDR      R3,[R2, #+0]
   \   0000002C   0x6C9B             LDR      R3,[R3, #+72]
   \   0000002E   0x0018             MOVS     R0,R3
    566                break;
    567            }
    568            
    569            /* Return ADC converted value */ 
    570            return tmp_jdr;
   \                     ??HAL_ADCEx_InjectedGetValue_4: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    571          }
    572          
    573          /**
    574            * @brief  Injected conversion complete callback in non blocking mode 
    575            * @param  hadc: ADC handle
    576            * @retval None
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
    579          {
    580            /* Prevent unused argument(s) compilation warning */
    581            UNUSED(hadc);
    582          
    583            /* NOTE : This function Should not be modified, when the callback is needed,
    584                      the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
    585            */
    586          }
   \                     HAL_ADCEx_InjectedConvCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    587          
    588          /**
    589            * @}
    590            */
    591          
    592          /** @defgroup ADCEx_Exported_Functions_Group2 ADC Extended Peripheral Control functions
    593            * @brief    ADC Extended Peripheral Control functions
    594            *
    595          @verbatim   
    596           ===============================================================================
    597                       ##### Peripheral Control functions #####
    598           ===============================================================================  
    599              [..]  This section provides functions allowing to:
    600                (+) Configure channels on injected group
    601                
    602          @endverbatim
    603            * @{
    604            */
    605          
    606          /**
    607            * @brief  Configures the ADC injected group and the selected channel to be
    608            *         linked to the injected group.
    609            * @note   Possibility to update parameters on the fly:
    610            *         This function initializes injected group, following calls to this 
    611            *         function can be used to reconfigure some parameters of structure
    612            *         "ADC_InjectionConfTypeDef" on the fly, without reseting the ADC.
    613            *         The setting of these parameters is conditioned to ADC state: 
    614            *         this function must be called when ADC is not under conversion.
    615            * @param  hadc: ADC handle
    616            * @param  sConfigInjected: Structure of ADC injected group and ADC channel for
    617            *         injected group.
    618            * @retval None
    619            */

   \                                 In section .text, align 2, keep-with-next
    620          HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
    621          {   
   \                     HAL_ADCEx_InjectedConfigChannel: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   \   00000002   0x0002             MOVS     R2,R0
    622            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2300             MOVS     R3,#+0
    623            __IO uint32_t wait_loop_index = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    624            
    625            /* Check the parameters */
    626            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    627            assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
    628            assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
    629            assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
    630            assert_param(IS_ADC_EXTTRIGINJEC(sConfigInjected->ExternalTrigInjecConv));
    631            assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, sConfigInjected->InjectedOffset));
    632            
    633            if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
   \   0000000A   0x6910             LDR      R0,[R2, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
    634            {
    635              assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
    636              assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
    637              assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
    638            }
    639            
    640            if(sConfigInjected->ExternalTrigInjecConvEdge != ADC_INJECTED_SOFTWARE_START)
   \                     ??HAL_ADCEx_InjectedConfigChannel_0: (+1)
   \   0000000E   0x6A08             LDR      R0,[R1, #+32]
   \   00000010   0x2810             CMP      R0,#+16
    641            {
    642              assert_param(IS_ADC_EXTTRIGINJEC_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
    643            }
    644            
    645            /* Process locked */
    646            __HAL_LOCK(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_1: (+1)
   \   00000012   0xF892 0x0048      LDRB     R0,[R2, #+72]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_2
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE12D             B.N      ??HAL_ADCEx_InjectedConfigChannel_3
   \                     ??HAL_ADCEx_InjectedConfigChannel_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF882 0x0048      STRB     R0,[R2, #+72]
    647            
    648            /* Configuration of injected group sequencer:                               */
    649            /* - if scan mode is disabled, injected channels sequence length is set to  */
    650            /*   0x00: 1 channel converted (channel on regular rank 1)                  */
    651            /*   Parameter "InjectedNbrOfConversion" is discarded.                      */
    652            /*   Note: Scan mode is present by hardware on this device and, if          */
    653            /*   disabled, discards automatically nb of conversions. Anyway, nb of      */
    654            /*   conversions is forced to 0x00 for alignment over all STM32 devices.    */
    655            /* - if scan mode is enabled, injected channels sequence length is set to   */
    656            /*   parameter ""InjectedNbrOfConversion".                                  */
    657            if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
   \   00000024   0x6910             LDR      R0,[R2, #+16]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD113             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_4
    658            {
    659              if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
   \   0000002A   0x6848             LDR      R0,[R1, #+4]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD109             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_5
    660              {
    661                /* Clear the old SQx bits for all injected ranks */
    662                  MODIFY_REG(hadc->Instance->JSQR                              ,
    663                             ADC_JSQR_JL   |
    664                             ADC_JSQR_JSQ4 |
    665                             ADC_JSQR_JSQ3 |
    666                             ADC_JSQR_JSQ2 |
    667                             ADC_JSQR_JSQ1                                     ,
    668                             ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,
    669                                              ADC_INJECTED_RANK_1,
    670                                              0x01)                             );
   \   00000030   0x6810             LDR      R0,[R2, #+0]
   \   00000032   0x6C40             LDR      R0,[R0, #+68]
   \   00000034   0x0D80             LSRS     R0,R0,#+22
   \   00000036   0x0580             LSLS     R0,R0,#+22
   \   00000038   0x680C             LDR      R4,[R1, #+0]
   \   0000003A   0xEA50 0x30C4      ORRS     R0,R0,R4, LSL #+15
   \   0000003E   0x6814             LDR      R4,[R2, #+0]
   \   00000040   0x6460             STR      R0,[R4, #+68]
   \   00000042   0xE036             B.N      ??HAL_ADCEx_InjectedConfigChannel_6
    671              }
    672              /* If another injected rank than rank1 was intended to be set, and could  */
    673              /* not due to ScanConvMode disabled, error is reported.                   */
    674              else
    675              {
    676                /* Update ADC state machine to error */
    677                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedConfigChannel_5: (+1)
   \   00000044   0x6CD0             LDR      R0,[R2, #+76]
   \   00000046   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004A   0x64D0             STR      R0,[R2, #+76]
    678                  
    679                tmp_hal_status = HAL_ERROR;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0003             MOVS     R3,R0
   \   00000050   0xE02F             B.N      ??HAL_ADCEx_InjectedConfigChannel_6
    680              }
    681            }
    682            else
    683            {   
    684              /* Since injected channels rank conv. order depends on total number of   */
    685              /* injected conversions, selected rank must be below or equal to total   */
    686              /* number of injected conversions to be updated.                         */
    687              if (sConfigInjected->InjectedRank <= sConfigInjected->InjectedNbrOfConversion)
   \                     ??HAL_ADCEx_InjectedConfigChannel_4: (+1)
   \   00000052   0x6908             LDR      R0,[R1, #+16]
   \   00000054   0x684C             LDR      R4,[R1, #+4]
   \   00000056   0x42A0             CMP      R0,R4
   \   00000058   0xD31C             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_7
    688              {
    689                /* Clear the old SQx bits for the selected rank */
    690                /* Set the SQx bits for the selected rank */
    691                MODIFY_REG(hadc->Instance->JSQR                                                     ,
    692                           
    693                           ADC_JSQR_JL                                               |
    694                           ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
    695                                            sConfigInjected->InjectedRank,         
    696                                            sConfigInjected->InjectedNbrOfConversion)               ,
    697                           
    698                           ADC_JSQR_JL_SHIFT(sConfigInjected->InjectedNbrOfConversion)             |
    699                           ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,      
    700                                                          sConfigInjected->InjectedRank,         
    701                                                          sConfigInjected->InjectedNbrOfConversion)  );
   \   0000005A   0x6810             LDR      R0,[R2, #+0]
   \   0000005C   0x6C40             LDR      R0,[R0, #+68]
   \   0000005E   0x241F             MOVS     R4,#+31
   \   00000060   0x690D             LDR      R5,[R1, #+16]
   \   00000062   0x684E             LDR      R6,[R1, #+4]
   \   00000064   0x1B75             SUBS     R5,R6,R5
   \   00000066   0x1CED             ADDS     R5,R5,#+3
   \   00000068   0x2605             MOVS     R6,#+5
   \   0000006A   0x4375             MULS     R5,R6,R5
   \   0000006C   0x40AC             LSLS     R4,R4,R5
   \   0000006E   0xF454 0x1440      ORRS     R4,R4,#0x300000
   \   00000072   0x43A0             BICS     R0,R0,R4
   \   00000074   0x690C             LDR      R4,[R1, #+16]
   \   00000076   0x1E64             SUBS     R4,R4,#+1
   \   00000078   0xEA50 0x5004      ORRS     R0,R0,R4, LSL #+20
   \   0000007C   0x680C             LDR      R4,[R1, #+0]
   \   0000007E   0x690D             LDR      R5,[R1, #+16]
   \   00000080   0x684E             LDR      R6,[R1, #+4]
   \   00000082   0x1B75             SUBS     R5,R6,R5
   \   00000084   0x1CED             ADDS     R5,R5,#+3
   \   00000086   0x2605             MOVS     R6,#+5
   \   00000088   0x4375             MULS     R5,R6,R5
   \   0000008A   0x40AC             LSLS     R4,R4,R5
   \   0000008C   0x4320             ORRS     R0,R4,R0
   \   0000008E   0x6814             LDR      R4,[R2, #+0]
   \   00000090   0x6460             STR      R0,[R4, #+68]
   \   00000092   0xE00E             B.N      ??HAL_ADCEx_InjectedConfigChannel_6
    702              }
    703              else
    704              {
    705                /* Clear the old SQx bits for the selected rank */
    706                MODIFY_REG(hadc->Instance->JSQR                                       ,
    707                           
    708                           ADC_JSQR_JL                                               |
    709                           ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
    710                                            sConfigInjected->InjectedRank,         
    711                                            sConfigInjected->InjectedNbrOfConversion) ,
    712                           
    713                           0x00000000                                                  );
   \                     ??HAL_ADCEx_InjectedConfigChannel_7: (+1)
   \   00000094   0x6810             LDR      R0,[R2, #+0]
   \   00000096   0x6C40             LDR      R0,[R0, #+68]
   \   00000098   0x241F             MOVS     R4,#+31
   \   0000009A   0x690D             LDR      R5,[R1, #+16]
   \   0000009C   0x684E             LDR      R6,[R1, #+4]
   \   0000009E   0x1B75             SUBS     R5,R6,R5
   \   000000A0   0x1CED             ADDS     R5,R5,#+3
   \   000000A2   0x2605             MOVS     R6,#+5
   \   000000A4   0x4375             MULS     R5,R6,R5
   \   000000A6   0x40AC             LSLS     R4,R4,R5
   \   000000A8   0xF454 0x1440      ORRS     R4,R4,#0x300000
   \   000000AC   0x43A0             BICS     R0,R0,R4
   \   000000AE   0x6814             LDR      R4,[R2, #+0]
   \   000000B0   0x6460             STR      R0,[R4, #+68]
    714              }
    715            } 
    716              
    717            /* Enable external trigger if trigger selection is different of software    */
    718            /* start.                                                                   */
    719            /* Note: This configuration keeps the hardware feature of parameter         */
    720            /*       ExternalTrigConvEdge "trigger edge none" equivalent to             */
    721            /*       software start.                                                    */
    722            
    723            if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
   \                     ??HAL_ADCEx_InjectedConfigChannel_6: (+1)
   \   000000B2   0x69C8             LDR      R0,[R1, #+28]
   \   000000B4   0x2810             CMP      R0,#+16
   \   000000B6   0xD00A             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_8
    724            {    
    725              MODIFY_REG(hadc->Instance->CR2                        ,
    726                         ADC_CR2_JEXTEN  |
    727                         ADC_CR2_JEXTSEL                            ,
    728                         sConfigInjected->ExternalTrigInjecConv    |
    729                         sConfigInjected->ExternalTrigInjecConvEdge  );
   \   000000B8   0x6810             LDR      R0,[R2, #+0]
   \   000000BA   0x6880             LDR      R0,[R0, #+8]
   \   000000BC   0xF430 0x107C      BICS     R0,R0,#0x3F0000
   \   000000C0   0x69CC             LDR      R4,[R1, #+28]
   \   000000C2   0x4320             ORRS     R0,R4,R0
   \   000000C4   0x6A0C             LDR      R4,[R1, #+32]
   \   000000C6   0x4320             ORRS     R0,R4,R0
   \   000000C8   0x6814             LDR      R4,[R2, #+0]
   \   000000CA   0x60A0             STR      R0,[R4, #+8]
   \   000000CC   0xE005             B.N      ??HAL_ADCEx_InjectedConfigChannel_9
    730            }
    731            else
    732            {
    733              MODIFY_REG(hadc->Instance->CR2,
    734                         ADC_CR2_JEXTEN  |
    735                         ADC_CR2_JEXTSEL    ,
    736                         0x00000000          );
   \                     ??HAL_ADCEx_InjectedConfigChannel_8: (+1)
   \   000000CE   0x6810             LDR      R0,[R2, #+0]
   \   000000D0   0x6880             LDR      R0,[R0, #+8]
   \   000000D2   0xF430 0x107C      BICS     R0,R0,#0x3F0000
   \   000000D6   0x6814             LDR      R4,[R2, #+0]
   \   000000D8   0x60A0             STR      R0,[R4, #+8]
    737            }
    738          
    739            /* Configuration of injected group                                          */
    740            /* Parameters update conditioned to ADC state:                              */
    741            /* Parameters that can be updated only when ADC is disabled:                */
    742            /*  - Automatic injected conversion                                         */
    743            /*  - Injected discontinuous mode                                           */
    744            if ((ADC_IS_ENABLE(hadc) == RESET))
   \                     ??HAL_ADCEx_InjectedConfigChannel_9: (+1)
   \   000000DA   0x6810             LDR      R0,[R2, #+0]
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x0640             LSLS     R0,R0,#+25
   \   000000E0   0xD42B             BMI.N    ??HAL_ADCEx_InjectedConfigChannel_10
    745            {
    746              hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO   |
    747                                       ADC_CR1_JDISCEN  );
   \   000000E2   0x6810             LDR      R0,[R2, #+0]
   \   000000E4   0x6840             LDR      R0,[R0, #+4]
   \   000000E6   0xF430 0x50A0      BICS     R0,R0,#0x1400
   \   000000EA   0x6814             LDR      R4,[R2, #+0]
   \   000000EC   0x6060             STR      R0,[R4, #+4]
    748              
    749              /* Automatic injected conversion can be enabled if injected group         */
    750              /* external triggers are disabled.                                        */
    751              if (sConfigInjected->AutoInjectedConv == ENABLE)
   \   000000EE   0x6988             LDR      R0,[R1, #+24]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD10F             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_11
    752              {
    753                if (sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
   \   000000F4   0x69C8             LDR      R0,[R1, #+28]
   \   000000F6   0x2810             CMP      R0,#+16
   \   000000F8   0xD106             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_12
    754                {
    755                  SET_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \   000000FA   0x6810             LDR      R0,[R2, #+0]
   \   000000FC   0x6840             LDR      R0,[R0, #+4]
   \   000000FE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000102   0x6814             LDR      R4,[R2, #+0]
   \   00000104   0x6060             STR      R0,[R4, #+4]
   \   00000106   0xE005             B.N      ??HAL_ADCEx_InjectedConfigChannel_11
    756                }
    757                else
    758                {
    759                  /* Update ADC state machine to error */
    760                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedConfigChannel_12: (+1)
   \   00000108   0x6CD0             LDR      R0,[R2, #+76]
   \   0000010A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000010E   0x64D0             STR      R0,[R2, #+76]
    761                  
    762                  tmp_hal_status = HAL_ERROR;
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0x0003             MOVS     R3,R0
    763                }
    764              }
    765              
    766              /* Injected discontinuous can be enabled only if auto-injected mode is    */
    767              /* disabled.                                                              */  
    768              if (sConfigInjected->InjectedDiscontinuousConvMode == ENABLE)
   \                     ??HAL_ADCEx_InjectedConfigChannel_11: (+1)
   \   00000114   0x6948             LDR      R0,[R1, #+20]
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xD10F             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_10
    769              {
    770                if (sConfigInjected->AutoInjectedConv == DISABLE)
   \   0000011A   0x6988             LDR      R0,[R1, #+24]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD106             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_13
    771                {
    772                  SET_BIT(hadc->Instance->CR1, ADC_CR1_JDISCEN);
   \   00000120   0x6810             LDR      R0,[R2, #+0]
   \   00000122   0x6840             LDR      R0,[R0, #+4]
   \   00000124   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000128   0x6814             LDR      R4,[R2, #+0]
   \   0000012A   0x6060             STR      R0,[R4, #+4]
   \   0000012C   0xE005             B.N      ??HAL_ADCEx_InjectedConfigChannel_10
    773                } 
    774                else
    775                {
    776                  /* Update ADC state machine to error */
    777                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedConfigChannel_13: (+1)
   \   0000012E   0x6CD0             LDR      R0,[R2, #+76]
   \   00000130   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000134   0x64D0             STR      R0,[R2, #+76]
    778                  
    779                  tmp_hal_status = HAL_ERROR;
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x0003             MOVS     R3,R0
    780                }
    781              }
    782            }
    783          
    784            /* Channel sampling time configuration */
    785            /* For InjectedChannels 0 to 9 */
    786            if (sConfigInjected->InjectedChannel < ADC_CHANNEL_10)
   \                     ??HAL_ADCEx_InjectedConfigChannel_10: (+1)
   \   0000013A   0x6808             LDR      R0,[R1, #+0]
   \   0000013C   0x280A             CMP      R0,#+10
   \   0000013E   0xD210             BCS.N    ??HAL_ADCEx_InjectedConfigChannel_14
    787            {
    788              MODIFY_REG(hadc->Instance->SMPR3,
    789                         ADC_SMPR3(ADC_SMPR3_SMP0, sConfigInjected->InjectedChannel),
    790                         ADC_SMPR3(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
   \   00000140   0x6810             LDR      R0,[R2, #+0]
   \   00000142   0x6940             LDR      R0,[R0, #+20]
   \   00000144   0x2407             MOVS     R4,#+7
   \   00000146   0x680D             LDR      R5,[R1, #+0]
   \   00000148   0x2603             MOVS     R6,#+3
   \   0000014A   0x4375             MULS     R5,R6,R5
   \   0000014C   0x40AC             LSLS     R4,R4,R5
   \   0000014E   0x43A0             BICS     R0,R0,R4
   \   00000150   0x688C             LDR      R4,[R1, #+8]
   \   00000152   0x680D             LDR      R5,[R1, #+0]
   \   00000154   0x2603             MOVS     R6,#+3
   \   00000156   0x4375             MULS     R5,R6,R5
   \   00000158   0x40AC             LSLS     R4,R4,R5
   \   0000015A   0x4320             ORRS     R0,R4,R0
   \   0000015C   0x6814             LDR      R4,[R2, #+0]
   \   0000015E   0x6160             STR      R0,[R4, #+20]
   \   00000160   0xE03D             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    791            }
    792            /* For InjectedChannels 10 to 19 */
    793            else if (sConfigInjected->InjectedChannel < ADC_CHANNEL_20)
   \                     ??HAL_ADCEx_InjectedConfigChannel_14: (+1)
   \   00000162   0x6808             LDR      R0,[R1, #+0]
   \   00000164   0x2814             CMP      R0,#+20
   \   00000166   0xD212             BCS.N    ??HAL_ADCEx_InjectedConfigChannel_16
    794            {
    795              MODIFY_REG(hadc->Instance->SMPR2,
    796                         ADC_SMPR2(ADC_SMPR2_SMP10, sConfigInjected->InjectedChannel),
    797                         ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
   \   00000168   0x6810             LDR      R0,[R2, #+0]
   \   0000016A   0x6900             LDR      R0,[R0, #+16]
   \   0000016C   0x2407             MOVS     R4,#+7
   \   0000016E   0x680D             LDR      R5,[R1, #+0]
   \   00000170   0x3D0A             SUBS     R5,R5,#+10
   \   00000172   0x2603             MOVS     R6,#+3
   \   00000174   0x4375             MULS     R5,R6,R5
   \   00000176   0x40AC             LSLS     R4,R4,R5
   \   00000178   0x43A0             BICS     R0,R0,R4
   \   0000017A   0x688C             LDR      R4,[R1, #+8]
   \   0000017C   0x680D             LDR      R5,[R1, #+0]
   \   0000017E   0x3D0A             SUBS     R5,R5,#+10
   \   00000180   0x2603             MOVS     R6,#+3
   \   00000182   0x4375             MULS     R5,R6,R5
   \   00000184   0x40AC             LSLS     R4,R4,R5
   \   00000186   0x4320             ORRS     R0,R4,R0
   \   00000188   0x6814             LDR      R4,[R2, #+0]
   \   0000018A   0x6120             STR      R0,[R4, #+16]
   \   0000018C   0xE027             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    798            }
    799            /* For InjectedChannels 20 to 26 for devices Cat.1, Cat.2, Cat.3 */
    800            /* For InjectedChannels 20 to 29 for devices Cat4, Cat.5 */
    801            else if (sConfigInjected->InjectedChannel <= ADC_SMPR1_CHANNEL_MAX)
   \                     ??HAL_ADCEx_InjectedConfigChannel_16: (+1)
   \   0000018E   0x6808             LDR      R0,[R1, #+0]
   \   00000190   0x281E             CMP      R0,#+30
   \   00000192   0xD212             BCS.N    ??HAL_ADCEx_InjectedConfigChannel_17
    802            {   
    803              MODIFY_REG(hadc->Instance->SMPR1,
    804                         ADC_SMPR1(ADC_SMPR1_SMP20, sConfigInjected->InjectedChannel),
    805                         ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
   \   00000194   0x6810             LDR      R0,[R2, #+0]
   \   00000196   0x68C0             LDR      R0,[R0, #+12]
   \   00000198   0x2407             MOVS     R4,#+7
   \   0000019A   0x680D             LDR      R5,[R1, #+0]
   \   0000019C   0x3D14             SUBS     R5,R5,#+20
   \   0000019E   0x2603             MOVS     R6,#+3
   \   000001A0   0x4375             MULS     R5,R6,R5
   \   000001A2   0x40AC             LSLS     R4,R4,R5
   \   000001A4   0x43A0             BICS     R0,R0,R4
   \   000001A6   0x688C             LDR      R4,[R1, #+8]
   \   000001A8   0x680D             LDR      R5,[R1, #+0]
   \   000001AA   0x3D14             SUBS     R5,R5,#+20
   \   000001AC   0x2603             MOVS     R6,#+3
   \   000001AE   0x4375             MULS     R5,R6,R5
   \   000001B0   0x40AC             LSLS     R4,R4,R5
   \   000001B2   0x4320             ORRS     R0,R4,R0
   \   000001B4   0x6814             LDR      R4,[R2, #+0]
   \   000001B6   0x60E0             STR      R0,[R4, #+12]
   \   000001B8   0xE011             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    806            }
    807            /* For InjectedChannels 30 to 31 for devices Cat4, Cat.5 */
    808            else
    809            {
    810              ADC_SMPR0_CHANNEL_SET(hadc, sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
   \                     ??HAL_ADCEx_InjectedConfigChannel_17: (+1)
   \   000001BA   0x6810             LDR      R0,[R2, #+0]
   \   000001BC   0x6DC0             LDR      R0,[R0, #+92]
   \   000001BE   0x2407             MOVS     R4,#+7
   \   000001C0   0x680D             LDR      R5,[R1, #+0]
   \   000001C2   0x3D1E             SUBS     R5,R5,#+30
   \   000001C4   0x2603             MOVS     R6,#+3
   \   000001C6   0x4375             MULS     R5,R6,R5
   \   000001C8   0x40AC             LSLS     R4,R4,R5
   \   000001CA   0x43A0             BICS     R0,R0,R4
   \   000001CC   0x688C             LDR      R4,[R1, #+8]
   \   000001CE   0x680D             LDR      R5,[R1, #+0]
   \   000001D0   0x3D1E             SUBS     R5,R5,#+30
   \   000001D2   0x2603             MOVS     R6,#+3
   \   000001D4   0x4375             MULS     R5,R6,R5
   \   000001D6   0x40AC             LSLS     R4,R4,R5
   \   000001D8   0x4320             ORRS     R0,R4,R0
   \   000001DA   0x6814             LDR      R4,[R2, #+0]
   \   000001DC   0x65E0             STR      R0,[R4, #+92]
    811            }
    812            
    813            
    814            /* Configure the offset: offset enable/disable, InjectedChannel, offset value */
    815            switch(sConfigInjected->InjectedRank)
   \                     ??HAL_ADCEx_InjectedConfigChannel_15: (+1)
   \   000001DE   0x6848             LDR      R0,[R1, #+4]
   \   000001E0   0x2801             CMP      R0,#+1
   \   000001E2   0xD004             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_18
   \   000001E4   0xD31E             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_19
   \   000001E6   0x2803             CMP      R0,#+3
   \   000001E8   0xD013             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_20
   \   000001EA   0xD309             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_21
   \   000001EC   0xE01A             B.N      ??HAL_ADCEx_InjectedConfigChannel_19
    816            {
    817              case 1:
    818                /* Set injected channel 1 offset */
    819                MODIFY_REG(hadc->Instance->JOFR1,
    820                           ADC_JOFR1_JOFFSET1,
    821                           sConfigInjected->InjectedOffset);
   \                     ??HAL_ADCEx_InjectedConfigChannel_18: (+1)
   \   000001EE   0x6810             LDR      R0,[R2, #+0]
   \   000001F0   0x6980             LDR      R0,[R0, #+24]
   \   000001F2   0x0B00             LSRS     R0,R0,#+12
   \   000001F4   0x0300             LSLS     R0,R0,#+12
   \   000001F6   0x68CC             LDR      R4,[R1, #+12]
   \   000001F8   0x4320             ORRS     R0,R4,R0
   \   000001FA   0x6814             LDR      R4,[R2, #+0]
   \   000001FC   0x61A0             STR      R0,[R4, #+24]
    822                break;
   \   000001FE   0xE019             B.N      ??HAL_ADCEx_InjectedConfigChannel_22
    823              case 2:
    824                /* Set injected channel 2 offset */
    825                MODIFY_REG(hadc->Instance->JOFR2,
    826                           ADC_JOFR2_JOFFSET2,
    827                           sConfigInjected->InjectedOffset);
   \                     ??HAL_ADCEx_InjectedConfigChannel_21: (+1)
   \   00000200   0x6810             LDR      R0,[R2, #+0]
   \   00000202   0x69C0             LDR      R0,[R0, #+28]
   \   00000204   0x0B00             LSRS     R0,R0,#+12
   \   00000206   0x0300             LSLS     R0,R0,#+12
   \   00000208   0x68CC             LDR      R4,[R1, #+12]
   \   0000020A   0x4320             ORRS     R0,R4,R0
   \   0000020C   0x6814             LDR      R4,[R2, #+0]
   \   0000020E   0x61E0             STR      R0,[R4, #+28]
    828                break;
   \   00000210   0xE010             B.N      ??HAL_ADCEx_InjectedConfigChannel_22
    829              case 3:
    830                /* Set injected channel 3 offset */
    831                MODIFY_REG(hadc->Instance->JOFR3,
    832                           ADC_JOFR3_JOFFSET3,
    833                           sConfigInjected->InjectedOffset);
   \                     ??HAL_ADCEx_InjectedConfigChannel_20: (+1)
   \   00000212   0x6810             LDR      R0,[R2, #+0]
   \   00000214   0x6A00             LDR      R0,[R0, #+32]
   \   00000216   0x0B00             LSRS     R0,R0,#+12
   \   00000218   0x0300             LSLS     R0,R0,#+12
   \   0000021A   0x68CC             LDR      R4,[R1, #+12]
   \   0000021C   0x4320             ORRS     R0,R4,R0
   \   0000021E   0x6814             LDR      R4,[R2, #+0]
   \   00000220   0x6220             STR      R0,[R4, #+32]
    834                break;
   \   00000222   0xE007             B.N      ??HAL_ADCEx_InjectedConfigChannel_22
    835              case 4:
    836              default:
    837                MODIFY_REG(hadc->Instance->JOFR4,
    838                           ADC_JOFR4_JOFFSET4,
    839                           sConfigInjected->InjectedOffset);
   \                     ??HAL_ADCEx_InjectedConfigChannel_19: (+1)
   \   00000224   0x6810             LDR      R0,[R2, #+0]
   \   00000226   0x6A40             LDR      R0,[R0, #+36]
   \   00000228   0x0B00             LSRS     R0,R0,#+12
   \   0000022A   0x0300             LSLS     R0,R0,#+12
   \   0000022C   0x68CC             LDR      R4,[R1, #+12]
   \   0000022E   0x4320             ORRS     R0,R4,R0
   \   00000230   0x6814             LDR      R4,[R2, #+0]
   \   00000232   0x6260             STR      R0,[R4, #+36]
    840                break;
    841            }
    842            
    843            /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
    844            /* and VREFINT measurement path.                                            */
    845            if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
    846                (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
   \                     ??HAL_ADCEx_InjectedConfigChannel_22: (+1)
   \   00000234   0x6808             LDR      R0,[R1, #+0]
   \   00000236   0x2810             CMP      R0,#+16
   \   00000238   0xD002             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_23
   \   0000023A   0x6808             LDR      R0,[R1, #+0]
   \   0000023C   0x2811             CMP      R0,#+17
   \   0000023E   0xD117             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_24
    847            {
    848              SET_BIT(ADC->CCR, ADC_CCR_TSVREFE);
   \                     ??HAL_ADCEx_InjectedConfigChannel_23: (+1)
   \   00000240   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40012704
   \   00000242   0x6800             LDR      R0,[R0, #+0]
   \   00000244   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000248   0x....             LDR.N    R4,??DataTable3_1  ;; 0x40012704
   \   0000024A   0x6020             STR      R0,[R4, #+0]
    849              
    850              if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR))
   \   0000024C   0x6808             LDR      R0,[R1, #+0]
   \   0000024E   0x2810             CMP      R0,#+16
   \   00000250   0xD10E             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_24
    851              {
    852                /* Delay for temperature sensor stabilization time */
    853                /* Compute number of CPU cycles to wait for */
    854                wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
   \   00000252   0x....             LDR.N    R0,??DataTable3_3
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0x....             LDR.N    R4,??DataTable3_4  ;; 0xf4240
   \   00000258   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   0000025C   0x240A             MOVS     R4,#+10
   \   0000025E   0x4360             MULS     R0,R4,R0
   \   00000260   0x9000             STR      R0,[SP, #+0]
    855                while(wait_loop_index != 0)
   \                     ??HAL_ADCEx_InjectedConfigChannel_25: (+1)
   \   00000262   0x9800             LDR      R0,[SP, #+0]
   \   00000264   0x2800             CMP      R0,#+0
   \   00000266   0xD003             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_24
    856                {
    857                  wait_loop_index--;
   \   00000268   0x9800             LDR      R0,[SP, #+0]
   \   0000026A   0x1E40             SUBS     R0,R0,#+1
   \   0000026C   0x9000             STR      R0,[SP, #+0]
   \   0000026E   0xE7F8             B.N      ??HAL_ADCEx_InjectedConfigChannel_25
    858                }
    859              }
    860            }
    861            
    862            /* Process unlocked */
    863            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_24: (+1)
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0xF882 0x0048      STRB     R0,[R2, #+72]
    864            
    865            /* Return function status */
    866            return tmp_hal_status;
   \   00000276   0x0018             MOVS     R0,R3
   \   00000278   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADCEx_InjectedConfigChannel_3: (+1)
   \   0000027A   0xBC72             POP      {R1,R4-R6}
   \   0000027C   0x4770             BX       LR               ;; return
    867          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xFFFFDFFE         DC32     0xffffdffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40012704         DC32     0x40012704

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x24924924         DC32     0x24924924

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x000F4240         DC32     0xf4240
    868          
    869          /**
    870            * @}
    871            */  
    872          
    873          /**
    874            * @}
    875            */
    876          
    877          #endif /* HAL_ADC_MODULE_ENABLED */
    878          /**
    879            * @}
    880            */
    881          
    882          /**
    883            * @}
    884            */
    885          
    886          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_ADCEx_InjectedConfigChannel
       0   HAL_ADCEx_InjectedConvCpltCallback
       0   HAL_ADCEx_InjectedGetValue
      24   HAL_ADCEx_InjectedPollForConversion
        24   -> HAL_GetTick
      16   HAL_ADCEx_InjectedStart
        16   -> ADC_Enable
      16   HAL_ADCEx_InjectedStart_IT
        16   -> ADC_Enable
      16   HAL_ADCEx_InjectedStop
        16   -> ADC_ConversionStop_Disable
      16   HAL_ADCEx_InjectedStop_IT
        16   -> ADC_ConversionStop_Disable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
     638  HAL_ADCEx_InjectedConfigChannel
       2  HAL_ADCEx_InjectedConvCpltCallback
      50  HAL_ADCEx_InjectedGetValue
     318  HAL_ADCEx_InjectedPollForConversion
     112  HAL_ADCEx_InjectedStart
     122  HAL_ADCEx_InjectedStart_IT
      90  HAL_ADCEx_InjectedStop
     104  HAL_ADCEx_InjectedStop_IT

 
 1 456 bytes in section .text
 
 1 456 bytes of CODE memory

Errors: none
Warnings: none
