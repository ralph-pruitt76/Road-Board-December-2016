###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       09/Sep/2017  15:28:10
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\VMonitor.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\VMonitor.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\VMonitor.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\VMonitor.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\VMonitor.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : VMonitor.c
      4            * Description        : This file provides code for the control of the Power
      5            *                      monitor hardware based on the ISL28022 chip.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "VMonitor.h"
     37          #include "Calibration.h"
     38          
     39          
     40          /* barometer init function */
     41          /**
     42            * @brief  This function initiaizes the Baromoeter Sensor
     43            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
     44            *                                HAL_ERROR:    Error found in Tasking or data passed.
     45            *                                HAL_BUSY:     UART is busy.
     46            *                                HAL_TIMEOUT:  UART timed out.
     47            */

   \                                 In section .text, align 2, keep-with-next
     48          HAL_StatusTypeDef RoadBrd_Init_VMonitor( void )
     49          {
   \                     RoadBrd_Init_VMonitor: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
     50            HAL_StatusTypeDef Status;
     51            int Loop_cnt;
     52            int num_bytes;
     53            uint8_t i2cData[4];  
     54            Loop_cnt = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0005             MOVS     R5,R0
     55          
     56            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_Init_VMonitor_0: (+1)
   \   00000006   0x2D01             CMP      R5,#+1
   \   00000008   0xDA2C             BGE.N    ??RoadBrd_Init_VMonitor_1
     57            {
     58              num_bytes = 0;    // No Data to Pass.
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
     59          #ifdef REV_L
     60              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CALIB, i2cData, (uint16_t)num_bytes);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x0003             MOVS     R3,R0
   \   00000012   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   0xAA01             ADD      R2,SP,#+4
   \   00000016   0x2105             MOVS     R1,#+5
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001E   0x0006             MOVS     R6,R0
     61              RoadBrd_Delay( 50 );
   \   00000020   0x2032             MOVS     R0,#+50
   \   00000022   0x.... 0x....      BL       RoadBrd_Delay
     62              // 2. If Status was good, Time to get response.
     63              if (Status == HAL_OK)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD119             BNE.N    ??RoadBrd_Init_VMonitor_2
     64              {
     65                // Now wait for completion of XMIT.
     66                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   0000002C   0x2064             MOVS     R0,#+100
   \   0000002E   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000032   0x0006             MOVS     R6,R0
     67                if (Status == HAL_OK)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD112             BNE.N    ??RoadBrd_Init_VMonitor_2
     68                {
     69                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x2082             MOVS     R0,#+130
   \   00000040   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000044   0x0006             MOVS     R6,R0
     70                  RoadBrd_Delay( 50 );
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0x.... 0x....      BL       RoadBrd_Delay
     71                  if (Status == HAL_OK)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD106             BNE.N    ??RoadBrd_Init_VMonitor_2
     72                  {
     73                    // Now wait for completion of Receive.
     74                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000052   0x2064             MOVS     R0,#+100
   \   00000054   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000058   0x0006             MOVS     R6,R0
     75                    if (Status == HAL_OK)
   \   0000005A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD001             BEQ.N    ??RoadBrd_Init_VMonitor_1
     76                      break;
     77                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
     78                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
     79              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
     80          #else
     81              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CALIB, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
     82              // Wait 100msec.
     83              RoadBrd_Delay( 50 );
     84            
     85              // 2. If Status was good, Time to get response.
     86              if (Status == HAL_OK)
     87              {
     88                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
     89              }
     90              if (Status == HAL_OK)
     91                break;
     92              // Wait 100msec.
     93              RoadBrd_Delay( 50 );
     94          #endif
     95              Loop_cnt++;
   \                     ??RoadBrd_Init_VMonitor_2: (+1)
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   \   00000062   0xE7D0             B.N      ??RoadBrd_Init_VMonitor_0
     96            }
     97            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
     98            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_Init_VMonitor_1: (+1)
   \   00000064   0x2D01             CMP      R5,#+1
   \   00000066   0xDB02             BLT.N    ??RoadBrd_Init_VMonitor_3
     99              return Status;
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xE022             B.N      ??RoadBrd_Init_VMonitor_4
    100                              
    101            // Now Test Results from read..
    102            if((i2cData[0]==((uint8_t)(CALIBRATION_VALUE/256))) && 
    103               (i2cData[1]==((uint8_t)CALIBRATION_VALUE & 0xff)))
   \                     ??RoadBrd_Init_VMonitor_3: (+1)
   \   0000006E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000072   0x2810             CMP      R0,#+16
   \   00000074   0xD105             BNE.N    ??RoadBrd_Init_VMonitor_5
   \   00000076   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000007A   0x2862             CMP      R0,#+98
   \   0000007C   0xD101             BNE.N    ??RoadBrd_Init_VMonitor_5
    104            {
    105              // No Need to write New Value. It is good.)
    106              return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE018             B.N      ??RoadBrd_Init_VMonitor_4
    107            }
    108            else
    109            {
    110              // Wait 50msec.
    111              RoadBrd_Delay( 50 );
   \                     ??RoadBrd_Init_VMonitor_5: (+1)
   \   00000082   0x2032             MOVS     R0,#+50
   \   00000084   0x.... 0x....      BL       RoadBrd_Delay
    112              // Load Config Register with Config Settings
    113              num_bytes = 2;    // No Data to Pass.
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x0004             MOVS     R4,R0
    114              i2cData[0] = (uint8_t)(CALIBRATION_VALUE/256);
   \   0000008C   0x2010             MOVS     R0,#+16
   \   0000008E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    115              i2cData[1] = (uint8_t)CALIBRATION_VALUE & 0xff;
   \   00000092   0x2062             MOVS     R0,#+98
   \   00000094   0xF88D 0x0005      STRB     R0,[SP, #+5]
    116              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CALIB, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
   \   00000098   0xF44F 0x70FA      MOV      R0,#+500
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x0003             MOVS     R3,R0
   \   000000A2   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A4   0xAA01             ADD      R2,SP,#+4
   \   000000A6   0x2105             MOVS     R1,#+5
   \   000000A8   0x2082             MOVS     R0,#+130
   \   000000AA   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   000000AE   0x0006             MOVS     R6,R0
    117            }
    118            return Status;
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_Init_VMonitor_4: (+1)
   \   000000B4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    119          }
    120          
    121            /**
    122            * @brief  This function reads the Scaled Shunt Voltage to the passed Voltage Structure.
    123            * @param  VoltagePtr VPtr: Ptr to structure to receive the final values of the SHunt Voltage.
    124            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    125            *                                HAL_ERROR:    Error found in Tasking or data passed.
    126            *                                HAL_BUSY:     UART is busy.
    127            *                                HAL_TIMEOUT:  UART timed out.
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          HAL_StatusTypeDef RoadBrd_VMonitor_RdShntVltg_Scaled( VoltagePtr VPtr )
    130          {
   \                     RoadBrd_VMonitor_RdShntVltg_Scaled: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    131            HAL_StatusTypeDef Status;
    132            int Loop_cnt;
    133            int num_bytes;
    134            uint8_t i2cData[4];  
    135            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    136            char tempBffr2[5];
    137            float Shunt_V;
    138          
    139            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    140            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_1
    141            {
    142              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4680             MOV      R8,R0
    143          #ifdef REV_L
    144              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_SHNTV, i2cData, (uint16_t)num_bytes);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    145              // 2. If Status was good, Time to get response.
    146              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_2
    147              {
    148                // Now wait for completion of XMIT.
    149                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    150                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_2
    151                {
    152                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    153                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_2
    154                  {
    155                  // Now wait for completion of Receive.
    156                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    157                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_1
    158                      break;
    159                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    160                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    161              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    162          #else
    163              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_SHNTV, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    164              // 2. If Status was good, Time to get response.
    165              if (Status == HAL_OK)
    166              {
    167                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    168              }
    169              if (Status == HAL_OK)
    170                break;
    171          #endif
    172              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdShntVltg_Scaled_0
    173            }
    174            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    175            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_3
    176              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE042             B.N      ??RoadBrd_VMonitor_RdShntVltg_Scaled_4
    177                                
    178            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD13D             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_Scaled_5
    179            {
    180              // NOW, Build Data String..
    181              sprintf( (char *)VPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000007A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000007E   0x.... 0x....      BL       sprintf
    182              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000082   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000008A   0xA801             ADD      R0,SP,#+4
   \   0000008C   0x.... 0x....      BL       sprintf
    183              strcat( (char *)VPtr->Raw, (char *)tempBffr2 );
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000096   0x.... 0x....      BL       strcat
    184              //strcat( (char *)VPtr->Raw, "Rw" );
    185            }
    186            else
    187              return Status;
    188            // Now calculate Shunt Voltage.
    189            Shunt_V = (i2cData[0]*256 + i2cData[1]) * SHNT_VLTG_TICK * MV_SCALE_ADJUST;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xF44F 0x7180      MOV      R1,#+256
   \   000000A2   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x.... 0x....      LDR.W    R2,??DataTable7_2  ;; 0x88e368f1
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable7_3  ;; 0x3ee4f8b5
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x408f4000
   \   000000C0   0x.... 0x....      BL       __aeabi_dmul
   \   000000C4   0x.... 0x....      BL       __aeabi_d2f
   \   000000C8   0x0005             MOVS     R5,R0
    190            Shunt_V = RoadBrd_CAL_ScaleValue( CAL_SHNT_VLTG, Shunt_V);
   \   000000CA   0x0029             MOVS     R1,R5
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       RoadBrd_CAL_ScaleValue
   \   000000D2   0x0005             MOVS     R5,R0
    191            sprintf( (char *)VPtr->Voltage, "%2.3f", Shunt_V );
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       __aeabi_f2d
   \   000000DA   0x0002             MOVS     R2,R0
   \   000000DC   0x000B             MOVS     R3,R1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       sprintf
    192            return Status;
   \   000000E8   0x0038             MOVS     R0,R7
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0xE001             B.N      ??RoadBrd_VMonitor_RdShntVltg_Scaled_4
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_5: (+1)
   \   000000EE   0x0038             MOVS     R0,R7
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdShntVltg_Scaled_4: (+1)
   \   000000F2   0xB004             ADD      SP,SP,#+16
   \   000000F4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    193          }
    194          
    195            /**
    196            * @brief  This function reads the Shunt Voltage to the passed Voltage Structure.
    197            * @param  VoltagePtr VPtr: Ptr to structure to receive the final values of the SHunt Voltage.
    198            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    199            *                                HAL_ERROR:    Error found in Tasking or data passed.
    200            *                                HAL_BUSY:     UART is busy.
    201            *                                HAL_TIMEOUT:  UART timed out.
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          HAL_StatusTypeDef RoadBrd_VMonitor_RdShntVltg( VoltagePtr VPtr )
    204          {
   \                     RoadBrd_VMonitor_RdShntVltg: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    205            HAL_StatusTypeDef Status;
    206            int Loop_cnt;
    207            int num_bytes;
    208            uint8_t i2cData[4];  
    209            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    210            char tempBffr2[5];
    211            float Shunt_V;
    212          
    213            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    214            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdShntVltg_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdShntVltg_1
    215            {
    216              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    217          #ifdef REV_L
    218              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_SHNTV, i2cData, (uint16_t)num_bytes);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    219              // 2. If Status was good, Time to get response.
    220              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_2
    221              {
    222                // Now wait for completion of XMIT.
    223                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    224                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_2
    225                {
    226                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    227                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_2
    228                  {
    229                  // Now wait for completion of Receive.
    230                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    231                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdShntVltg_1
    232                      break;
    233                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    234                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    235              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    236          #else
    237              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_SHNTV, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    238              // 2. If Status was good, Time to get response.
    239              if (Status == HAL_OK)
    240              {
    241                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    242              }
    243              if (Status == HAL_OK)
    244                break;
    245          #endif
    246              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdShntVltg_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdShntVltg_0
    247            }
    248            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    249            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdShntVltg_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdShntVltg_3
    250              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE03D             B.N      ??RoadBrd_VMonitor_RdShntVltg_4
    251                                
    252            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdShntVltg_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD138             BNE.N    ??RoadBrd_VMonitor_RdShntVltg_5
    253            {
    254              // NOW, Build Data String..
    255              sprintf( (char *)VPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000007A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000007E   0x.... 0x....      BL       sprintf
    256              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000082   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000008A   0xA801             ADD      R0,SP,#+4
   \   0000008C   0x.... 0x....      BL       sprintf
    257              strcat( (char *)VPtr->Raw, (char *)tempBffr2 );
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000096   0x.... 0x....      BL       strcat
    258              //strcat( (char *)VPtr->Raw, "Rw" );
    259            }
    260            else
    261              return Status;
    262            // Now calculate Shunt Voltage.
    263            Shunt_V = (i2cData[0]*256 + i2cData[1]) * SHNT_VLTG_TICK * MV_SCALE_ADJUST;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xF44F 0x7180      MOV      R1,#+256
   \   000000A2   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x.... 0x....      LDR.W    R2,??DataTable7_2  ;; 0x88e368f1
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable7_3  ;; 0x3ee4f8b5
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x408f4000
   \   000000C0   0x.... 0x....      BL       __aeabi_dmul
   \   000000C4   0x.... 0x....      BL       __aeabi_d2f
   \   000000C8   0x4680             MOV      R8,R0
    264            sprintf( (char *)VPtr->Voltage, "%2.3f", Shunt_V );
   \   000000CA   0x4640             MOV      R0,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_f2d
   \   000000D0   0x0002             MOVS     R2,R0
   \   000000D2   0x000B             MOVS     R3,R1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       sprintf
    265            return Status;
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xE001             B.N      ??RoadBrd_VMonitor_RdShntVltg_4
   \                     ??RoadBrd_VMonitor_RdShntVltg_5: (+1)
   \   000000E4   0x0038             MOVS     R0,R7
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdShntVltg_4: (+1)
   \   000000E8   0xB004             ADD      SP,SP,#+16
   \   000000EA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    266          }
    267          
    268            /**
    269            * @brief  This function reads the operagtional current to the passed Current Structure.
    270            * @param  CurrentPtr CPtr: Ptr to structure to receive the final values of the Operational Current.
    271            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    272            *                                HAL_ERROR:    Error found in Tasking or data passed.
    273            *                                HAL_BUSY:     UART is busy.
    274            *                                HAL_TIMEOUT:  UART timed out.
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          HAL_StatusTypeDef RoadBrd_VMonitor_RdCurrent_Scaled( CurrentPtr CPtr )
    277          {
   \                     RoadBrd_VMonitor_RdCurrent_Scaled: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    278            HAL_StatusTypeDef Status;
    279            int Loop_cnt;
    280            int num_bytes;
    281            uint8_t i2cData[4];  
    282            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    283            char tempBffr2[5];
    284            float Crrnt;
    285          
    286            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    287            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_1
    288            {
    289              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4680             MOV      R8,R0
    290          #ifdef REV_L
    291              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CRRNT, i2cData, (uint16_t)num_bytes);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    292              // 2. If Status was good, Time to get response.
    293              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_2
    294              {
    295                // Now wait for completion of XMIT.
    296                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    297                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_2
    298                {
    299                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    300                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_2
    301                  {
    302                    // Now wait for completion of Receive.
    303                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    304                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_1
    305                      break;
    306                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    307                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    308              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    309          #else
    310              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CRRNT, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    311              // 2. If Status was good, Time to get response.
    312              if (Status == HAL_OK)
    313              {
    314                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    315              }
    316              if (Status == HAL_OK)
    317                break;
    318          #endif
    319              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdCurrent_Scaled_0
    320            }
    321            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    322            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_3
    323              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE042             B.N      ??RoadBrd_VMonitor_RdCurrent_Scaled_4
    324                                
    325            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD13D             BNE.N    ??RoadBrd_VMonitor_RdCurrent_Scaled_5
    326            {
    327              // NOW, Build Data String..
    328              sprintf( (char *)CPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000007A   0xF114 0x0009      ADDS     R0,R4,#+9
   \   0000007E   0x.... 0x....      BL       sprintf
    329              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000082   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000008A   0xA801             ADD      R0,SP,#+4
   \   0000008C   0x.... 0x....      BL       sprintf
    330              strcat( (char *)CPtr->Raw, (char *)tempBffr2 );
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0xF114 0x0009      ADDS     R0,R4,#+9
   \   00000096   0x.... 0x....      BL       strcat
    331              //strcat( (char *)CPtr->Raw, "Rw" );
    332            }
    333            else
    334              return Status;
    335            // Now calculate Current.
    336            Crrnt = (i2cData[0]*256 + i2cData[1]) * CURRENT_TICK * MA_SCALE_ADJUST;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xF44F 0x7180      MOV      R1,#+256
   \   000000A2   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x.... 0x....      LDR.W    R2,??DataTable7_6  ;; 0x9c511dc4
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable7_7  ;; 0x3f300001
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x408f4000
   \   000000C0   0x.... 0x....      BL       __aeabi_dmul
   \   000000C4   0x.... 0x....      BL       __aeabi_d2f
   \   000000C8   0x0005             MOVS     R5,R0
    337            Crrnt = RoadBrd_CAL_ScaleValue( CAL_CURRENT, Crrnt);
   \   000000CA   0x0029             MOVS     R1,R5
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x.... 0x....      BL       RoadBrd_CAL_ScaleValue
   \   000000D2   0x0005             MOVS     R5,R0
    338            sprintf( (char *)CPtr->Current, "%4.1f", Crrnt );
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       __aeabi_f2d
   \   000000DA   0x0002             MOVS     R2,R0
   \   000000DC   0x000B             MOVS     R3,R1
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable7_8
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       sprintf
    339            return Status;
   \   000000E8   0x0038             MOVS     R0,R7
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0xE001             B.N      ??RoadBrd_VMonitor_RdCurrent_Scaled_4
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_5: (+1)
   \   000000EE   0x0038             MOVS     R0,R7
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdCurrent_Scaled_4: (+1)
   \   000000F2   0xB004             ADD      SP,SP,#+16
   \   000000F4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    340          }
    341          
    342            /**
    343            * @brief  This function reads the operagtional current to the passed Current Structure.
    344            * @param  CurrentPtr CPtr: Ptr to structure to receive the final values of the Operational Current.
    345            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    346            *                                HAL_ERROR:    Error found in Tasking or data passed.
    347            *                                HAL_BUSY:     UART is busy.
    348            *                                HAL_TIMEOUT:  UART timed out.
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          HAL_StatusTypeDef RoadBrd_VMonitor_RdCurrent( CurrentPtr CPtr )
    351          {
   \                     RoadBrd_VMonitor_RdCurrent: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    352            HAL_StatusTypeDef Status;
    353            int Loop_cnt;
    354            int num_bytes;
    355            uint8_t i2cData[4];  
    356            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    357            char tempBffr2[5];
    358            float Crrnt;
    359          
    360            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    361            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdCurrent_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdCurrent_1
    362            {
    363              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    364          #ifdef REV_L
    365              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CRRNT, i2cData, (uint16_t)num_bytes);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    366              // 2. If Status was good, Time to get response.
    367              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdCurrent_2
    368              {
    369                // Now wait for completion of XMIT.
    370                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    371                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdCurrent_2
    372                {
    373                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    374                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdCurrent_2
    375                  {
    376                    // Now wait for completion of Receive.
    377                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    378                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdCurrent_1
    379                      break;
    380                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    381                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    382              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    383          #else
    384              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_CRRNT, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    385              // 2. If Status was good, Time to get response.
    386              if (Status == HAL_OK)
    387              {
    388                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    389              }
    390              if (Status == HAL_OK)
    391                break;
    392          #endif
    393              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdCurrent_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdCurrent_0
    394            }
    395            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    396            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdCurrent_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdCurrent_3
    397              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE03D             B.N      ??RoadBrd_VMonitor_RdCurrent_4
    398                                
    399            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdCurrent_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD138             BNE.N    ??RoadBrd_VMonitor_RdCurrent_5
    400            {
    401              // NOW, Build Data String..
    402              sprintf( (char *)CPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000007A   0xF114 0x0009      ADDS     R0,R4,#+9
   \   0000007E   0x.... 0x....      BL       sprintf
    403              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000082   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000008A   0xA801             ADD      R0,SP,#+4
   \   0000008C   0x.... 0x....      BL       sprintf
    404              strcat( (char *)CPtr->Raw, (char *)tempBffr2 );
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0xF114 0x0009      ADDS     R0,R4,#+9
   \   00000096   0x.... 0x....      BL       strcat
    405              //strcat( (char *)CPtr->Raw, "Rw" );
    406            }
    407            else
    408              return Status;
    409            // Now calculate Current.
    410            Crrnt = (i2cData[0]*256 + i2cData[1]) * CURRENT_TICK * MA_SCALE_ADJUST;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xF44F 0x7180      MOV      R1,#+256
   \   000000A2   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x.... 0x....      LDR.W    R2,??DataTable7_6  ;; 0x9c511dc4
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable7_7  ;; 0x3f300001
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x408f4000
   \   000000C0   0x.... 0x....      BL       __aeabi_dmul
   \   000000C4   0x.... 0x....      BL       __aeabi_d2f
   \   000000C8   0x4680             MOV      R8,R0
    411            sprintf( (char *)CPtr->Current, "%4.1f", Crrnt );
   \   000000CA   0x4640             MOV      R0,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_f2d
   \   000000D0   0x0002             MOVS     R2,R0
   \   000000D2   0x000B             MOVS     R3,R1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable7_8
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       sprintf
    412            return Status;
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xE001             B.N      ??RoadBrd_VMonitor_RdCurrent_4
   \                     ??RoadBrd_VMonitor_RdCurrent_5: (+1)
   \   000000E4   0x0038             MOVS     R0,R7
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdCurrent_4: (+1)
   \   000000E8   0xB004             ADD      SP,SP,#+16
   \   000000EA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    413          }
    414          
    415            /**
    416            * @brief  This function reads the operagtional Power to the passed Power Structure.
    417            * @param  PowerPtr PPtr: Ptr to structure to receive the final values of the Operational Power.
    418            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    419            *                                HAL_ERROR:    Error found in Tasking or data passed.
    420            *                                HAL_BUSY:     UART is busy.
    421            *                                HAL_TIMEOUT:  UART timed out.
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          HAL_StatusTypeDef RoadBrd_VMonitor_RdPower_Scaled( PowerPtr PPtr )
    424          {
   \                     RoadBrd_VMonitor_RdPower_Scaled: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    425            HAL_StatusTypeDef Status;
    426            int Loop_cnt;
    427            int num_bytes;
    428            uint8_t i2cData[4];  
    429            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    430            char tempBffr2[5];
    431            float Power;
    432          
    433            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    434            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdPower_Scaled_1
    435            {
    436              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4680             MOV      R8,R0
    437          #ifdef REV_L
    438              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_POWER, i2cData, (uint16_t)num_bytes);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    439              // 2. If Status was good, Time to get response.
    440              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdPower_Scaled_2
    441              {
    442                // Now wait for completion of XMIT.
    443                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    444                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdPower_Scaled_2
    445                {
    446                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    447                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdPower_Scaled_2
    448                  {
    449                    // Now wait for completion of Receive.
    450                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    451                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdPower_Scaled_1
    452                      break;
    453                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    454                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    455              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    456          #else
    457              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_POWER, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    458              // 2. If Status was good, Time to get response.
    459              if (Status == HAL_OK)
    460              {
    461                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    462              }
    463              if (Status == HAL_OK)
    464                break;
    465          #endif
    466              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdPower_Scaled_0
    467            } // EndWhile
    468            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    469            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdPower_Scaled_3
    470              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE040             B.N      ??RoadBrd_VMonitor_RdPower_Scaled_4
    471                                
    472            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD13B             BNE.N    ??RoadBrd_VMonitor_RdPower_Scaled_5
    473            {
    474              // NOW, Build Data String..
    475              sprintf( (char *)PPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable7_1
   \   00000078   0xF114 0x0009      ADDS     R0,R4,#+9
   \   0000007C   0x.... 0x....      BL       sprintf
    476              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000080   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000084   0x....             LDR.N    R1,??DataTable7_1
   \   00000086   0xA801             ADD      R0,SP,#+4
   \   00000088   0x.... 0x....      BL       sprintf
    477              strcat( (char *)PPtr->Raw, (char *)tempBffr2 );
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xF114 0x0009      ADDS     R0,R4,#+9
   \   00000092   0x.... 0x....      BL       strcat
    478              //strcat( (char *)PPtr->Raw, "Rw" );
    479            }
    480            else
    481              return Status;
    482            // Now calculate Power.
    483            Power = (i2cData[0]*256 + i2cData[1]) * POWER_TICK * POWER_ADJUST * MW_SCALE_ADJUST;
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0xF44F 0x7180      MOV      R1,#+256
   \   0000009E   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A2   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000A6   0x.... 0x....      BL       __aeabi_i2d
   \   000000AA   0x....             LDR.N    R2,??DataTable7_9  ;; 0x1341adcd
   \   000000AC   0x....             LDR.N    R3,??DataTable7_10  ;; 0x3eb0624b
   \   000000AE   0x.... 0x....      BL       __aeabi_dmul
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x....             LDR.N    R3,??DataTable7_11  ;; 0x40c38800
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x....             LDR.N    R3,??DataTable7_4  ;; 0x408f4000
   \   000000BE   0x.... 0x....      BL       __aeabi_dmul
   \   000000C2   0x.... 0x....      BL       __aeabi_d2f
   \   000000C6   0x0005             MOVS     R5,R0
    484            Power = RoadBrd_CAL_ScaleValue( CAL_POWER, Power);
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0x.... 0x....      BL       RoadBrd_CAL_ScaleValue
   \   000000D0   0x0005             MOVS     R5,R0
    485            sprintf( (char *)PPtr->Power, "%4.1f", Power );
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x.... 0x....      BL       __aeabi_f2d
   \   000000D8   0x0002             MOVS     R2,R0
   \   000000DA   0x000B             MOVS     R3,R1
   \   000000DC   0x....             LDR.N    R1,??DataTable7_8
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       sprintf
    486            return Status;
   \   000000E4   0x0038             MOVS     R0,R7
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0xE001             B.N      ??RoadBrd_VMonitor_RdPower_Scaled_4
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_5: (+1)
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdPower_Scaled_4: (+1)
   \   000000EE   0xB004             ADD      SP,SP,#+16
   \   000000F0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    487          }
    488          
    489            /**
    490            * @brief  This function reads the operagtional Power to the passed Power Structure.
    491            * @param  PowerPtr PPtr: Ptr to structure to receive the final values of the Operational Power.
    492            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    493            *                                HAL_ERROR:    Error found in Tasking or data passed.
    494            *                                HAL_BUSY:     UART is busy.
    495            *                                HAL_TIMEOUT:  UART timed out.
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          HAL_StatusTypeDef RoadBrd_VMonitor_RdPower( PowerPtr PPtr )
    498          {
   \                     RoadBrd_VMonitor_RdPower: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    499            HAL_StatusTypeDef Status;
    500            int Loop_cnt;
    501            int num_bytes;
    502            uint8_t i2cData[4];  
    503            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    504            char tempBffr2[5];
    505            float Power;
    506          
    507            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    508            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdPower_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdPower_1
    509            {
    510              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    511          #ifdef REV_L
    512              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_POWER, i2cData, (uint16_t)num_bytes);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    513              // 2. If Status was good, Time to get response.
    514              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdPower_2
    515              {
    516                // Now wait for completion of XMIT.
    517                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    518                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdPower_2
    519                {
    520                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    521                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdPower_2
    522                  {
    523                    // Now wait for completion of Receive.
    524                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    525                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdPower_1
    526                      break;
    527                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    528                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    529              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    530          #else
    531              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_POWER, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    532              // 2. If Status was good, Time to get response.
    533              if (Status == HAL_OK)
    534              {
    535                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    536              }
    537              if (Status == HAL_OK)
    538                break;
    539          #endif
    540              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdPower_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdPower_0
    541            } // EndWhile
    542            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    543            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdPower_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdPower_3
    544              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE03B             B.N      ??RoadBrd_VMonitor_RdPower_4
    545                                
    546            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdPower_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD136             BNE.N    ??RoadBrd_VMonitor_RdPower_5
    547            {
    548              // NOW, Build Data String..
    549              sprintf( (char *)PPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable7_1
   \   00000078   0xF114 0x0009      ADDS     R0,R4,#+9
   \   0000007C   0x.... 0x....      BL       sprintf
    550              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000080   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000084   0x....             LDR.N    R1,??DataTable7_1
   \   00000086   0xA801             ADD      R0,SP,#+4
   \   00000088   0x.... 0x....      BL       sprintf
    551              strcat( (char *)PPtr->Raw, (char *)tempBffr2 );
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xF114 0x0009      ADDS     R0,R4,#+9
   \   00000092   0x.... 0x....      BL       strcat
    552              //strcat( (char *)PPtr->Raw, "Rw" );
    553            }
    554            else
    555              return Status;
    556            // Now calculate Power.
    557            Power = (i2cData[0]*256 + i2cData[1]) * POWER_TICK * POWER_ADJUST * MW_SCALE_ADJUST;
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0xF44F 0x7180      MOV      R1,#+256
   \   0000009E   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A2   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000A6   0x.... 0x....      BL       __aeabi_i2d
   \   000000AA   0x....             LDR.N    R2,??DataTable7_9  ;; 0x1341adcd
   \   000000AC   0x....             LDR.N    R3,??DataTable7_10  ;; 0x3eb0624b
   \   000000AE   0x.... 0x....      BL       __aeabi_dmul
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x....             LDR.N    R3,??DataTable7_11  ;; 0x40c38800
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x....             LDR.N    R3,??DataTable7_4  ;; 0x408f4000
   \   000000BE   0x.... 0x....      BL       __aeabi_dmul
   \   000000C2   0x.... 0x....      BL       __aeabi_d2f
   \   000000C6   0x4680             MOV      R8,R0
    558            sprintf( (char *)PPtr->Power, "%4.1f", Power );
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0x.... 0x....      BL       __aeabi_f2d
   \   000000CE   0x0002             MOVS     R2,R0
   \   000000D0   0x000B             MOVS     R3,R1
   \   000000D2   0x....             LDR.N    R1,??DataTable7_8
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       sprintf
    559            return Status;
   \   000000DA   0x0038             MOVS     R0,R7
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xE001             B.N      ??RoadBrd_VMonitor_RdPower_4
   \                     ??RoadBrd_VMonitor_RdPower_5: (+1)
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdPower_4: (+1)
   \   000000E4   0xB004             ADD      SP,SP,#+16
   \   000000E6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    560          }
    561          
    562            /**
    563            * @brief  This function reads the operagtional Bus Voltage to the passed Voltage Structure.
    564            * @param  VoltagePtr VPtr: Ptr to structure to receive the final values of the Bus Voltage.
    565            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    566            *                                HAL_ERROR:    Error found in Tasking or data passed.
    567            *                                HAL_BUSY:     UART is busy.
    568            *                                HAL_TIMEOUT:  UART timed out.
    569            */

   \                                 In section .text, align 2, keep-with-next
    570          HAL_StatusTypeDef RoadBrd_VMonitor_RdVoltage_Scaled( VoltagePtr VPtr )
    571          {
   \                     RoadBrd_VMonitor_RdVoltage_Scaled: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    572            HAL_StatusTypeDef Status;
    573            int Loop_cnt;
    574            int num_bytes;
    575            uint8_t i2cData[4];  
    576            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    577            char tempBffr2[5];
    578            float Bus_V;
    579            
    580            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    581            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_1
    582            {
    583              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4680             MOV      R8,R0
    584          #ifdef REV_L
    585              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_BUSV, i2cData, (uint16_t)num_bytes);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    586              // 2. If Status was good, Time to get response.
    587              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_2
    588              {
    589                // Now wait for completion of XMIT.
    590                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    591                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_2
    592                {
    593                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    594                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_2
    595                  {
    596                    // Now wait for completion of Receive.
    597                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    598                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_1
    599                      break;
    600                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    601                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    602              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    603          #else
    604              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_BUSV, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    605              // 2. If Status was good, Time to get response.
    606              if (Status == HAL_OK)
    607              {
    608                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    609              }
    610              if (Status == HAL_OK)
    611                break;
    612          #endif
    613              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdVoltage_Scaled_0
    614            }
    615            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    616            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_3
    617              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE03F             B.N      ??RoadBrd_VMonitor_RdVoltage_Scaled_4
    618                                
    619            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD13A             BNE.N    ??RoadBrd_VMonitor_RdVoltage_Scaled_5
    620            {
    621              // NOW, Build Data String..
    622              sprintf( (char *)VPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable7_1
   \   00000078   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000007C   0x.... 0x....      BL       sprintf
    623              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000080   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000084   0x....             LDR.N    R1,??DataTable7_1
   \   00000086   0xA801             ADD      R0,SP,#+4
   \   00000088   0x.... 0x....      BL       sprintf
    624              strcat( (char *)VPtr->Raw, (char *)tempBffr2 );
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000092   0x.... 0x....      BL       strcat
    625              //strcat( (char *)VPtr->Raw, "Rw" );
    626              strcat( (char *)tempBffr2, "\r\n" );
   \   00000096   0x....             ADR.N    R1,??DataTable7  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x.... 0x....      BL       strcat
    627            }
    628            else
    629              return Status;
    630          
    631            // Now calculate Bus Voltage.
    632            Bus_V = ((i2cData[0]*256 + i2cData[1])/4) * VOLT_TICK;
   \   0000009E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A2   0xF44F 0x7180      MOV      R1,#+256
   \   000000A6   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000AA   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AE   0x2104             MOVS     R1,#+4
   \   000000B0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000B4   0x.... 0x....      BL       __aeabi_i2d
   \   000000B8   0x....             LDR.N    R2,??DataTable7_12  ;; 0xd2f1a9fc
   \   000000BA   0x....             LDR.N    R3,??DataTable7_13  ;; 0x3f70624d
   \   000000BC   0x.... 0x....      BL       __aeabi_dmul
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
   \   000000C4   0x0005             MOVS     R5,R0
    633            Bus_V = RoadBrd_CAL_ScaleValue( CAL_VOLTAGE, Bus_V);
   \   000000C6   0x0029             MOVS     R1,R5
   \   000000C8   0x2003             MOVS     R0,#+3
   \   000000CA   0x.... 0x....      BL       RoadBrd_CAL_ScaleValue
   \   000000CE   0x0005             MOVS     R5,R0
    634            sprintf( (char *)VPtr->Voltage, "%4.1f", Bus_V );
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x0002             MOVS     R2,R0
   \   000000D8   0x000B             MOVS     R3,R1
   \   000000DA   0x....             LDR.N    R1,??DataTable7_8
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       sprintf
    635            return Status;
   \   000000E2   0x0038             MOVS     R0,R7
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0xE001             B.N      ??RoadBrd_VMonitor_RdVoltage_Scaled_4
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_5: (+1)
   \   000000E8   0x0038             MOVS     R0,R7
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdVoltage_Scaled_4: (+1)
   \   000000EC   0xB004             ADD      SP,SP,#+16
   \   000000EE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    636          }
    637          
    638            /**
    639            * @brief  This function reads the operagtional Bus Voltage to the passed Voltage Structure.
    640            * @param  VoltagePtr VPtr: Ptr to structure to receive the final values of the Bus Voltage.
    641            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    642            *                                HAL_ERROR:    Error found in Tasking or data passed.
    643            *                                HAL_BUSY:     UART is busy.
    644            *                                HAL_TIMEOUT:  UART timed out.
    645            */

   \                                 In section .text, align 2, keep-with-next
    646          HAL_StatusTypeDef RoadBrd_VMonitor_RdVoltage( VoltagePtr VPtr )
    647          {
   \                     RoadBrd_VMonitor_RdVoltage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    648            HAL_StatusTypeDef Status;
    649            int Loop_cnt;
    650            int num_bytes;
    651            uint8_t i2cData[4];  
    652            Loop_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
    653            char tempBffr2[5];
    654            float Bus_V;
    655            
    656            Loop_cnt = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0006             MOVS     R6,R0
    657            while( Loop_cnt < I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdVoltage_0: (+1)
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDA26             BGE.N    ??RoadBrd_VMonitor_RdVoltage_1
    658            {
    659              num_bytes = 0;    // No Data to Pass.
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    660          #ifdef REV_L
    661              Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_BUSV, i2cData, (uint16_t)num_bytes);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0007             MOVS     R7,R0
    662              // 2. If Status was good, Time to get response.
    663              if (Status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD116             BNE.N    ??RoadBrd_VMonitor_RdVoltage_2
    664              {
    665                // Now wait for completion of XMIT.
    666                Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0007             MOVS     R7,R0
    667                if (Status == HAL_OK)
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD10F             BNE.N    ??RoadBrd_VMonitor_RdVoltage_2
    668                {
    669                  Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2);
   \   0000003E   0x2202             MOVS     R2,#+2
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2082             MOVS     R0,#+130
   \   00000044   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000048   0x0007             MOVS     R7,R0
    670                  if (Status == HAL_OK)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD106             BNE.N    ??RoadBrd_VMonitor_RdVoltage_2
    671                  {
    672                    // Now wait for completion of Receive.
    673                    Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000050   0x2064             MOVS     R0,#+100
   \   00000052   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000056   0x0007             MOVS     R7,R0
    674                    if (Status == HAL_OK)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_VMonitor_RdVoltage_1
    675                      break;
    676                  } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    677                } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    678              }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    679          #else
    680              Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)VOLTAGE_MNTR, (uint8_t)VOLTAGE_MNTR_BUSV, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    681              // 2. If Status was good, Time to get response.
    682              if (Status == HAL_OK)
    683              {
    684                Status =  RoadBrd_I2C_Master_Receive((uint16_t)VOLTAGE_MNTR, i2cData, (uint16_t)2, I2C_TIMEOUT);
    685              }
    686              if (Status == HAL_OK)
    687                break;
    688          #endif
    689              Loop_cnt++;
   \                     ??RoadBrd_VMonitor_RdVoltage_2: (+1)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D6             B.N      ??RoadBrd_VMonitor_RdVoltage_0
    690            }
    691            // Test Loop_cnt. If greater or equal, we never were able to get a valid value.
    692            if(Loop_cnt >= I2C_MAX_TRIES)
   \                     ??RoadBrd_VMonitor_RdVoltage_1: (+1)
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xDB02             BLT.N    ??RoadBrd_VMonitor_RdVoltage_3
    693              return Status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE03A             B.N      ??RoadBrd_VMonitor_RdVoltage_4
    694                                
    695            if (Status == HAL_OK)
   \                     ??RoadBrd_VMonitor_RdVoltage_3: (+1)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD135             BNE.N    ??RoadBrd_VMonitor_RdVoltage_5
    696            {
    697              // NOW, Build Data String..
    698              sprintf( (char *)VPtr->Raw, "%02x", i2cData[0]);
   \   00000072   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable7_1
   \   00000078   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000007C   0x.... 0x....      BL       sprintf
    699              sprintf( (char *)tempBffr2, "%02x", i2cData[1]);
   \   00000080   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000084   0x....             LDR.N    R1,??DataTable7_1
   \   00000086   0xA801             ADD      R0,SP,#+4
   \   00000088   0x.... 0x....      BL       sprintf
    700              strcat( (char *)VPtr->Raw, (char *)tempBffr2 );
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000092   0x.... 0x....      BL       strcat
    701              //strcat( (char *)VPtr->Raw, "Rw" );
    702              strcat( (char *)tempBffr2, "\r\n" );
   \   00000096   0x....             ADR.N    R1,??DataTable7  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x.... 0x....      BL       strcat
    703            }
    704            else
    705              return Status;
    706          
    707            // Now calculate Bus Voltage.
    708            Bus_V = ((i2cData[0]*256 + i2cData[1])/4) * VOLT_TICK;
   \   0000009E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A2   0xF44F 0x7180      MOV      R1,#+256
   \   000000A6   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000AA   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AE   0x2104             MOVS     R1,#+4
   \   000000B0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000B4   0x.... 0x....      BL       __aeabi_i2d
   \   000000B8   0x....             LDR.N    R2,??DataTable7_12  ;; 0xd2f1a9fc
   \   000000BA   0x....             LDR.N    R3,??DataTable7_13  ;; 0x3f70624d
   \   000000BC   0x.... 0x....      BL       __aeabi_dmul
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
   \   000000C4   0x4680             MOV      R8,R0
    709            sprintf( (char *)VPtr->Voltage, "%4.1f", Bus_V );
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x.... 0x....      BL       __aeabi_f2d
   \   000000CC   0x0002             MOVS     R2,R0
   \   000000CE   0x000B             MOVS     R3,R1
   \   000000D0   0x....             LDR.N    R1,??DataTable7_8
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       sprintf
    710            return Status;
   \   000000D8   0x0038             MOVS     R0,R7
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0xE001             B.N      ??RoadBrd_VMonitor_RdVoltage_4
   \                     ??RoadBrd_VMonitor_RdVoltage_5: (+1)
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_VMonitor_RdVoltage_4: (+1)
   \   000000E2   0xB004             ADD      SP,SP,#+16
   \   000000E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    711          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x88E368F1         DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x3EE4F8B5         DC32     0x3ee4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x408F4000         DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x9C511DC4         DC32     0x9c511dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x3F300001         DC32     0x3f300001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x1341ADCD         DC32     0x1341adcd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x3EB0624B         DC32     0x3eb0624b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x40C38800         DC32     0x40c38800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x3F70624D         DC32     0x3f70624d

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x25 0x30          DC8 "%02x"
   \              0x32 0x78    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x25 0x32          DC8 "%2.3f"
   \              0x2E 0x33    
   \              0x66 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x25 0x34          DC8 "%4.1f"
   \              0x2E 0x31    
   \              0x66 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    712          
    713          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RoadBrd_Init_VMonitor
        24   -> RoadBrd_Delay
        24   -> RoadBrd_I2C_Master_Receive_IT
        24   -> RoadBrd_I2C_Master_Transmit_CMDData
        24   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        24   -> RoadBrd_WaitForState
      40   RoadBrd_VMonitor_RdCurrent
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdCurrent_Scaled
        40   -> RoadBrd_CAL_ScaleValue
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdPower
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdPower_Scaled
        40   -> RoadBrd_CAL_ScaleValue
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdShntVltg
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdShntVltg_Scaled
        40   -> RoadBrd_CAL_ScaleValue
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdVoltage
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat
      40   RoadBrd_VMonitor_RdVoltage_Scaled
        40   -> RoadBrd_CAL_ScaleValue
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> sprintf
        40   -> strcat


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?_0
       8  ?_1
       8  ?_2
       4  ?_3
     182  RoadBrd_Init_VMonitor
     238  RoadBrd_VMonitor_RdCurrent
     248  RoadBrd_VMonitor_RdCurrent_Scaled
     234  RoadBrd_VMonitor_RdPower
     244  RoadBrd_VMonitor_RdPower_Scaled
     238  RoadBrd_VMonitor_RdShntVltg
     248  RoadBrd_VMonitor_RdShntVltg_Scaled
     232  RoadBrd_VMonitor_RdVoltage
     242  RoadBrd_VMonitor_RdVoltage_Scaled

 
    28 bytes in section .rodata
 2 162 bytes in section .text
 
 2 162 bytes of CODE  memory
    28 bytes of CONST memory

Errors: none
Warnings: none
