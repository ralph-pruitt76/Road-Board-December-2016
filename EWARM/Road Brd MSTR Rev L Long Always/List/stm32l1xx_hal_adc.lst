###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Aug/2017  13:11:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\stm32l1xx_hal_adc.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\stm32l1xx_hal_adc.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC)
      9            *          peripheral:
     10            *           + Initialization and de-initialization functions
     11            *             ++ Initialization and Configuration of ADC
     12            *           + Operation functions
     13            *             ++ Start, stop, get result of conversions of regular
     14            *                group, using 3 possible modes: polling, interruption or DMA.
     15            *           + Control functions
     16            *             ++ Channels configuration on regular group
     17            *             ++ Channels configuration on injected group
     18            *             ++ Analog Watchdog configuration
     19            *           + State functions
     20            *             ++ ADC state machine management
     21            *             ++ Interrupts and flags management
     22            *          Other functions (extended functions) are available in file 
     23            *          "stm32l1xx_hal_adc_ex.c".
     24            *
     25            @verbatim
     26            ==============================================================================
     27                               ##### ADC peripheral features #####
     28            ==============================================================================
     29            [..]
     30            (+) 12-bit, 10-bit, 8-bit or 6-bit configurable resolution
     31          
     32            (+) Interrupt generation at the end of regular conversion, end of injected
     33                conversion, and in case of analog watchdog or overrun events.
     34            
     35            (+) Single and continuous conversion modes.
     36            
     37            (+) Scan mode for conversion of several channels sequentially.
     38            
     39            (+) Data alignment with in-built data coherency.
     40            
     41            (+) Programmable sampling time (channel wise)
     42            
     43            (+) ADC conversion of regular group and injected group.
     44            
     45            (+) External trigger (timer or EXTI) with configurable polarity
     46                for both regular and injected groups.
     47            
     48            (+) DMA request generation for transfer of conversions data of regular group.
     49            
     50            (+) ADC offset on injected channels
     51            
     52            (+) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
     53                slower speed.
     54            
     55            (+) ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to 
     56                Vdda or to an external voltage reference).
     57            
     58            
     59                               ##### How to use this driver #####
     60            ==============================================================================
     61              [..]
     62          
     63               *** Configuration of top level parameters related to ADC ***
     64               ============================================================
     65               [..]
     66          
     67              (#) Enable the ADC interface
     68                (++) As prerequisite, ADC clock must be configured at RCC top level.
     69                     Caution: On STM32L1, ADC clock frequency max is 16MHz (refer
     70                              to device datasheet).
     71                              Therefore, ADC clock prescaler must be configured in 
     72                              function of ADC clock source frequency to remain below
     73                              this maximum frequency.
     74          
     75                  (++) Two clock settings are mandatory: 
     76                       (+++) ADC clock (core clock).
     77                       (+++) ADC clock (conversions clock).
     78                             Only one possible clock source: derived from HSI RC 16MHz oscillator
     79                             (HSI). 
     80                             ADC is connected directly to HSI RC 16MHz oscillator.
     81                             Therefore, RCC PLL setting has no impact on ADC.
     82                             PLL can be disabled (".PLL.PLLState = RCC_PLL_NONE") or 
     83                             enabled with HSI16 as clock source
     84                             (".PLL.PLLSource = RCC_PLLSOURCE_HSI") to be used as device 
     85                             main clock source SYSCLK.
     86                             The only mandatory setting is ".HSIState = RCC_HSI_ON"
     87          
     88                       (+++) Example:
     89                             Into HAL_ADC_MspInit() (recommended code location) or with
     90                             other device clock parameters configuration:
     91                         (+++) __HAL_RCC_ADC1_CLK_ENABLE();
     92          
     93                         (+++) HAL_RCC_GetOscConfig(&RCC_OscInitStructure);
     94                         (+++) RCC_OscInitStructure.OscillatorType = (... | RCC_OSCILLATORTYPE_HSI);
     95                         (+++) RCC_OscInitStructure.HSIState = RCC_HSI_ON;
     96                         (+++) RCC_OscInitStructure.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
     97                         (+++) RCC_OscInitStructure.PLL.PLLState = RCC_PLL_NONE;
     98                         (+++) RCC_OscInitStructure.PLL.PLLSource = ...
     99                         (+++) RCC_OscInitStructure.PLL...
    100                         (+++) HAL_RCC_OscConfig(&RCC_OscInitStructure);
    101          
    102                  (++) ADC clock prescaler is configured at ADC level with
    103                       parameter "ClockPrescaler" using function HAL_ADC_Init().
    104          
    105              (#) ADC pins configuration
    106                   (++) Enable the clock for the ADC GPIOs
    107                        using macro __HAL_RCC_GPIOx_CLK_ENABLE()
    108                   (++) Configure these ADC pins in analog mode
    109                        using function HAL_GPIO_Init()
    110          
    111              (#) Optionally, in case of usage of ADC with interruptions:
    112                   (++) Configure the NVIC for ADC
    113                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    114                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    115                        into the function of corresponding ADC interruption vector 
    116                        ADCx_IRQHandler().
    117          
    118              (#) Optionally, in case of usage of DMA:
    119                   (++) Configure the DMA (DMA channel, mode normal or circular, ...)
    120                        using function HAL_DMA_Init().
    121                   (++) Configure the NVIC for DMA
    122                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    123                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    124                        into the function of corresponding DMA interruption vector 
    125                        DMAx_Channelx_IRQHandler().
    126          
    127               *** Configuration of ADC, groups regular/injected, channels parameters ***
    128               ==========================================================================
    129               [..]
    130          
    131              (#) Configure the ADC parameters (resolution, data alignment, ...)
    132                  and regular group parameters (conversion trigger, sequencer, ...)
    133                  using function HAL_ADC_Init().
    134          
    135              (#) Configure the channels for regular group parameters (channel number, 
    136                  channel rank into sequencer, ..., into regular group)
    137                  using function HAL_ADC_ConfigChannel().
    138          
    139              (#) Optionally, configure the injected group parameters (conversion trigger, 
    140                  sequencer, ..., of injected group)
    141                  and the channels for injected group parameters (channel number, 
    142                  channel rank into sequencer, ..., into injected group)
    143                  using function HAL_ADCEx_InjectedConfigChannel().
    144          
    145              (#) Optionally, configure the analog watchdog parameters (channels
    146                  monitored, thresholds, ...)
    147                  using function HAL_ADC_AnalogWDGConfig().
    148          
    149              (#) Optionally, for devices with several ADC instances: configure the 
    150                  multimode parameters
    151                  using function HAL_ADCEx_MultiModeConfigChannel().
    152          
    153               *** Execution of ADC conversions ***
    154               ====================================
    155               [..]
    156          
    157              (#) ADC driver can be used among three modes: polling, interruption,
    158                  transfer by DMA.
    159          
    160                  (++) ADC conversion by polling:
    161                    (+++) Activate the ADC peripheral and start conversions
    162                          using function HAL_ADC_Start()
    163                    (+++) Wait for ADC conversion completion 
    164                          using function HAL_ADC_PollForConversion()
    165                          (or for injected group: HAL_ADCEx_InjectedPollForConversion() )
    166                    (+++) Retrieve conversion results 
    167                          using function HAL_ADC_GetValue()
    168                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    169                    (+++) Stop conversion and disable the ADC peripheral 
    170                          using function HAL_ADC_Stop()
    171          
    172                  (++) ADC conversion by interruption: 
    173                    (+++) Activate the ADC peripheral and start conversions
    174                          using function HAL_ADC_Start_IT()
    175                    (+++) Wait for ADC conversion completion by call of function
    176                          HAL_ADC_ConvCpltCallback()
    177                          (this function must be implemented in user program)
    178                          (or for injected group: HAL_ADCEx_InjectedConvCpltCallback() )
    179                    (+++) Retrieve conversion results 
    180                          using function HAL_ADC_GetValue()
    181                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    182                    (+++) Stop conversion and disable the ADC peripheral 
    183                          using function HAL_ADC_Stop_IT()
    184          
    185                  (++) ADC conversion with transfer by DMA:
    186                    (+++) Activate the ADC peripheral and start conversions
    187                          using function HAL_ADC_Start_DMA()
    188                    (+++) Wait for ADC conversion completion by call of function
    189                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    190                          (these functions must be implemented in user program)
    191                    (+++) Conversion results are automatically transferred by DMA into
    192                          destination variable address.
    193                    (+++) Stop conversion and disable the ADC peripheral 
    194                          using function HAL_ADC_Stop_DMA()
    195          
    196                  (++) For devices with several ADCs: ADC multimode conversion 
    197                       with transfer by DMA:
    198                    (+++) Activate the ADC peripheral (slave) and start conversions
    199                          using function HAL_ADC_Start()
    200                    (+++) Activate the ADC peripheral (master) and start conversions
    201                          using function HAL_ADCEx_MultiModeStart_DMA()
    202                    (+++) Wait for ADC conversion completion by call of function
    203                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    204                          (these functions must be implemented in user program)
    205                    (+++) Conversion results are automatically transferred by DMA into
    206                          destination variable address.
    207                    (+++) Stop conversion and disable the ADC peripheral (master)
    208                          using function HAL_ADCEx_MultiModeStop_DMA()
    209                    (+++) Stop conversion and disable the ADC peripheral (slave)
    210                          using function HAL_ADC_Stop_IT()
    211          
    212               [..]
    213          
    214              (@) Callback functions must be implemented in user program:
    215                (+@) HAL_ADC_ErrorCallback()
    216                (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
    217                (+@) HAL_ADC_ConvCpltCallback()
    218                (+@) HAL_ADC_ConvHalfCpltCallback
    219                (+@) HAL_ADCEx_InjectedConvCpltCallback()
    220          
    221               *** Deinitialization of ADC ***
    222               ============================================================
    223               [..]
    224          
    225              (#) Disable the ADC interface
    226                (++) ADC clock can be hard reset and disabled at RCC top level.
    227                  (++) Hard reset of ADC peripherals
    228                       using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
    229                  (++) ADC clock disable
    230                       using the equivalent macro/functions as configuration step.
    231                       (+++) Example:
    232                             Into HAL_ADC_MspDeInit() (recommended code location) or with
    233                             other device clock parameters configuration:
    234                         (+++) HAL_RCC_GetOscConfig(&RCC_OscInitStructure);
    235                         (+++) RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    236                         (+++) RCC_OscInitStructure.HSIState = RCC_HSI_OFF; (if not used for system clock)
    237                         (+++) HAL_RCC_OscConfig(&RCC_OscInitStructure);
    238          
    239              (#) ADC pins configuration
    240                   (++) Disable the clock for the ADC GPIOs
    241                        using macro __HAL_RCC_GPIOx_CLK_DISABLE()
    242          
    243              (#) Optionally, in case of usage of ADC with interruptions:
    244                   (++) Disable the NVIC for ADC
    245                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    246          
    247              (#) Optionally, in case of usage of DMA:
    248                   (++) Deinitialize the DMA
    249                        using function HAL_DMA_Init().
    250                   (++) Disable the NVIC for DMA
    251                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    252          
    253              [..]
    254            
    255              @endverbatim
    256            ******************************************************************************
    257            * @attention
    258            *
    259            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    260            *
    261            * Redistribution and use in source and binary forms, with or without modification,
    262            * are permitted provided that the following conditions are met:
    263            *   1. Redistributions of source code must retain the above copyright notice,
    264            *      this list of conditions and the following disclaimer.
    265            *   2. Redistributions in binary form must reproduce the above copyright notice,
    266            *      this list of conditions and the following disclaimer in the documentation
    267            *      and/or other materials provided with the distribution.
    268            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    269            *      may be used to endorse or promote products derived from this software
    270            *      without specific prior written permission.
    271            *
    272            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    273            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    274            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    275            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    276            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    277            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    278            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    279            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    280            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    281            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    282            *
    283            ******************************************************************************  
    284            */
    285          
    286          /* Includes ------------------------------------------------------------------*/
    287          #include "stm32l1xx_hal.h"
    288          
    289          /** @addtogroup STM32L1xx_HAL_Driver
    290            * @{
    291            */
    292          
    293          /** @defgroup ADC ADC
    294            * @brief ADC HAL module driver
    295            * @{
    296            */
    297          
    298          #ifdef HAL_ADC_MODULE_ENABLED
    299          
    300          /* Private typedef -----------------------------------------------------------*/
    301          /* Private define ------------------------------------------------------------*/
    302          /** @defgroup ADC_Private_Constants ADC Private Constants
    303            * @{
    304            */
    305          
    306            /* Timeout values for ADC enable and disable settling time.                 */
    307            /* Values defined to be higher than worst cases: low clocks freq,           */
    308            /* maximum prescaler.                                                       */
    309            /* Ex of profile low frequency : Clock source at 0.1 MHz, ADC clock         */
    310            /* prescaler 4, sampling time 7.5 ADC clock cycles, resolution 12 bits.     */
    311            /* Unit: ms                                                                 */
    312            #define ADC_ENABLE_TIMEOUT              ((uint32_t) 2)
    313            #define ADC_DISABLE_TIMEOUT             ((uint32_t) 2)
    314          
    315            /* Delay for ADC stabilization time.                                        */
    316            /* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */
    317            /* Unit: us                                                                 */
    318            #define ADC_STAB_DELAY_US               ((uint32_t) 3)
    319          
    320            /* Delay for temperature sensor stabilization time.                         */
    321            /* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
    322            /* Unit: us                                                                 */
    323            #define ADC_TEMPSENSOR_DELAY_US         ((uint32_t) 10)
    324          
    325          /**
    326            * @}
    327            */
    328          
    329          /* Private macro -------------------------------------------------------------*/
    330          /* Private variables ---------------------------------------------------------*/
    331          /* Private function prototypes -----------------------------------------------*/
    332          /** @defgroup ADC_Private_Functions ADC Private Functions
    333            * @{
    334            */
    335          static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma);
    336          static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma);
    337          static void ADC_DMAError(DMA_HandleTypeDef *hdma);
    338          /**
    339            * @}
    340            */
    341          
    342          /* Exported functions --------------------------------------------------------*/
    343          
    344          /** @defgroup ADC_Exported_Functions ADC Exported Functions
    345            * @{
    346            */
    347          
    348          /** @defgroup ADC_Exported_Functions_Group1 ADC Initialization/de-initialization functions 
    349            * @brief    ADC Initialization and Configuration functions
    350            *
    351          @verbatim    
    352           ===============================================================================
    353                        ##### Initialization and de-initialization functions #####
    354           ===============================================================================
    355              [..]  This section provides functions allowing to:
    356                (+) Initialize and configure the ADC. 
    357                (+) De-initialize the ADC.
    358          @endverbatim
    359            * @{
    360            */
    361          
    362          /**
    363            * @brief  Initializes the ADC peripheral and regular group according to  
    364            *         parameters specified in structure "ADC_InitTypeDef".
    365            * @note   As prerequisite, ADC clock must be configured at RCC top level
    366            *         (clock source APB2).
    367            *         See commented example code below that can be copied and uncommented 
    368            *         into HAL_ADC_MspInit().
    369            * @note   Possibility to update parameters on the fly:
    370            *         This function initializes the ADC MSP (HAL_ADC_MspInit()) only when
    371            *         coming from ADC state reset. Following calls to this function can
    372            *         be used to reconfigure some parameters of ADC_InitTypeDef  
    373            *         structure on the fly, without modifying MSP configuration. If ADC  
    374            *         MSP has to be modified again, HAL_ADC_DeInit() must be called
    375            *         before HAL_ADC_Init().
    376            *         The setting of these parameters is conditioned to ADC state.
    377            *         For parameters constraints, see comments of structure 
    378            *         "ADC_InitTypeDef".
    379            * @note   This function configures the ADC within 2 scopes: scope of entire 
    380            *         ADC and scope of regular group. For parameters details, see comments 
    381            *         of structure "ADC_InitTypeDef".
    382            * @param  hadc: ADC handle
    383            * @retval HAL status
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
    386          {
   \                     HAL_ADC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    387            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    388            uint32_t tmp_cr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    389            uint32_t tmp_cr2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    390            
    391            /* Check ADC handle */
    392            if(hadc == NULL)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Init_0
    393            {
    394              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE0D8             B.N      ??HAL_ADC_Init_1
    395            }
    396            
    397            /* Check the parameters */
    398            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    399            assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    400            assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    401            assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign)); 
    402            assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    403            assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
    404            assert_param(IS_ADC_AUTOWAIT(hadc->Init.LowPowerAutoWait));
    405            assert_param(IS_ADC_AUTOPOWEROFF(hadc->Init.LowPowerAutoPowerOff));
    406            assert_param(IS_ADC_CHANNELSBANK(hadc->Init.ChannelsBank));
    407            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    408            assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    409            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
    410            
    411            if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
   \                     ??HAL_ADC_Init_0: (+1)
   \   00000012   0x6920             LDR      R0,[R4, #+16]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??HAL_ADC_Init_2
    412            {
    413              assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    414              assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    415              if(hadc->Init.DiscontinuousConvMode != DISABLE)
   \   00000018   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001A   0x2800             CMP      R0,#+0
    416              {
    417                assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    418              }
    419            }
    420                
    421            if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
   \                     ??HAL_ADC_Init_2: (+1)
   \   0000001C   0x6B60             LDR      R0,[R4, #+52]
   \   0000001E   0x2810             CMP      R0,#+16
    422            {
    423              assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    424            }
    425            
    426            
    427            /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
    428            /* at RCC top level.                                                        */
    429            /* Refer to header of this file for more details on clock enabling          */
    430            /* procedure.                                                               */
    431          
    432            /* Actions performed only if ADC is coming from state reset:                */
    433            /* - Initialization of ADC MSP                                              */
    434            if (hadc->State == HAL_ADC_STATE_RESET)
   \                     ??HAL_ADC_Init_3: (+1)
   \   00000020   0x6CE0             LDR      R0,[R4, #+76]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD116             BNE.N    ??HAL_ADC_Init_4
    435            {
    436              /* Initialize ADC error code */
    437              ADC_CLEAR_ERRORCODE(hadc);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6520             STR      R0,[R4, #+80]
    438              
    439              /* Allocate lock resource and initialize it */
    440              hadc->Lock = HAL_UNLOCKED;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF884 0x0048      STRB     R0,[R4, #+72]
    441              
    442              /* Enable SYSCFG clock to control the routing Interface (RI) */
    443              __HAL_RCC_SYSCFG_CLK_ENABLE();
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x40023820
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable7  ;; 0x40023820
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x40023820
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
    444              
    445              /* Init the low level hardware */
    446              HAL_ADC_MspInit(hadc);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       HAL_ADC_MspInit
    447            }
    448            
    449            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    450            /* correctly completed.                                                     */
    451            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \                     ??HAL_ADC_Init_4: (+1)
   \   00000054   0x6CE0             LDR      R0,[R4, #+76]
   \   00000056   0x06C0             LSLS     R0,R0,#+27
   \   00000058   0xF100 0x80B0      BMI.W    ??HAL_ADC_Init_5
    452            {
    453              /* Set ADC state */
    454              ADC_STATE_CLR_SET(hadc->State,
    455                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    456                                HAL_ADC_STATE_BUSY_INTERNAL);
   \   0000005C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000005E   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   00000062   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000066   0x64E0             STR      R0,[R4, #+76]
    457              
    458              /* Set ADC parameters */
    459              
    460              /* Configuration of common ADC clock: clock source HSI with selectable    */
    461              /* prescaler                                                              */
    462              MODIFY_REG(ADC->CCR                 ,
    463                         ADC_CCR_ADCPRE           ,
    464                         hadc->Init.ClockPrescaler );
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x40012704
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   00000072   0x6861             LDR      R1,[R4, #+4]
   \   00000074   0x4308             ORRS     R0,R1,R0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40012704
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    465          
    466              /* Configuration of ADC:                                                  */
    467              /*  - external trigger polarity                                           */
    468              /*  - End of conversion selection                                         */
    469              /*  - DMA continuous request                                              */
    470              /*  - Channels bank (Banks availability depends on devices categories)    */
    471              /*  - continuous conversion mode                                          */
    472              tmp_cr2 |= (hadc->Init.DataAlign                                 |
    473                          hadc->Init.EOCSelection                              |
    474                          ADC_CR2_DMACONTREQ(hadc->Init.DMAContinuousRequests) |
    475                          hadc->Init.ChannelsBank                              |
    476                          ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)     );
   \   0000007C   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000080   0xFAB0 0xF180      CLZ      R1,R0
   \   00000084   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000088   0xFAB0 0xF080      CLZ      R0,R0
   \   0000008C   0x68E2             LDR      R2,[R4, #+12]
   \   0000008E   0x6963             LDR      R3,[R4, #+20]
   \   00000090   0x431A             ORRS     R2,R3,R2
   \   00000092   0x6BE3             LDR      R3,[R4, #+60]
   \   00000094   0xFA13 0xF101      LSLS     R1,R3,R1
   \   00000098   0x4311             ORRS     R1,R1,R2
   \   0000009A   0x6A22             LDR      R2,[R4, #+32]
   \   0000009C   0x4311             ORRS     R1,R2,R1
   \   0000009E   0x6A62             LDR      R2,[R4, #+36]
   \   000000A0   0xFA12 0xF000      LSLS     R0,R2,R0
   \   000000A4   0x4308             ORRS     R0,R0,R1
   \   000000A6   0x4307             ORRS     R7,R0,R7
    477          
    478              /* Enable external trigger if trigger selection is different of software  */
    479              /* start.                                                                 */
    480              /* Note: This configuration keeps the hardware feature of parameter       */
    481              /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    482              /*       software start.                                                  */
    483              if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
   \   000000A8   0x6B60             LDR      R0,[R4, #+52]
   \   000000AA   0x2810             CMP      R0,#+16
   \   000000AC   0xD003             BEQ.N    ??HAL_ADC_Init_6
    484              {
    485                tmp_cr2 |= ( hadc->Init.ExternalTrigConv    |
    486                            hadc->Init.ExternalTrigConvEdge );
   \   000000AE   0x6B60             LDR      R0,[R4, #+52]
   \   000000B0   0x6BA1             LDR      R1,[R4, #+56]
   \   000000B2   0x4308             ORRS     R0,R1,R0
   \   000000B4   0x4307             ORRS     R7,R0,R7
    487              }
    488              
    489              /* Parameters update conditioned to ADC state:                            */
    490              /* Parameters that can be updated only when ADC is disabled:              */
    491              /*  - delay selection (LowPowerAutoWait mode)                             */
    492              /*  - resolution                                                          */
    493              /*  - auto power off (LowPowerAutoPowerOff mode)                          */
    494              /*  - scan mode                                                           */
    495              /*  - discontinuous mode disable/enable                                   */
    496              /*  - discontinuous mode number of conversions                            */
    497              if ((ADC_IS_ENABLE(hadc) == RESET))
   \                     ??HAL_ADC_Init_6: (+1)
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x0640             LSLS     R0,R0,#+25
   \   000000BC   0xD433             BMI.N    ??HAL_ADC_Init_7
    498              {
    499                tmp_cr2 |= hadc->Init.LowPowerAutoWait;
   \   000000BE   0x69A0             LDR      R0,[R4, #+24]
   \   000000C0   0x4307             ORRS     R7,R0,R7
    500                
    501                tmp_cr1 |= (hadc->Init.Resolution                     |
    502                            hadc->Init.LowPowerAutoPowerOff           |
    503                            ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode)  );
   \   000000C2   0x6920             LDR      R0,[R4, #+16]
   \   000000C4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000C8   0xD002             BEQ.N    ??HAL_ADC_Init_8
   \   000000CA   0x6920             LDR      R0,[R4, #+16]
   \   000000CC   0x2801             CMP      R0,#+1
   \   000000CE   0xD102             BNE.N    ??HAL_ADC_Init_9
   \                     ??HAL_ADC_Init_8: (+1)
   \   000000D0   0xF44F 0x7080      MOV      R0,#+256
   \   000000D4   0xE000             B.N      ??HAL_ADC_Init_10
   \                     ??HAL_ADC_Init_9: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Init_10: (+1)
   \   000000D8   0x68A1             LDR      R1,[R4, #+8]
   \   000000DA   0x69E2             LDR      R2,[R4, #+28]
   \   000000DC   0x4311             ORRS     R1,R2,R1
   \   000000DE   0x4308             ORRS     R0,R0,R1
   \   000000E0   0x4306             ORRS     R6,R0,R6
    504                
    505                /* Enable discontinuous mode only if continuous mode is disabled */
    506                /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter  */
    507                /*       discontinuous is set anyway, but has no effect on ADC HW.      */
    508                if (hadc->Init.DiscontinuousConvMode == ENABLE)
   \   000000E2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD116             BNE.N    ??HAL_ADC_Init_11
    509                {
    510                  if (hadc->Init.ContinuousConvMode == DISABLE)
   \   000000E8   0x6A60             LDR      R0,[R4, #+36]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD10B             BNE.N    ??HAL_ADC_Init_12
    511                  {
    512                    /* Enable the selected ADC regular discontinuous mode */
    513                    /* Set the number of channels to be converted in discontinuous mode */
    514                    SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
    515                                     ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
   \   000000EE   0xF45F 0x20E0      MOVS     R0,#+458752
   \   000000F2   0xFAB0 0xF080      CLZ      R0,R0
   \   000000F6   0x6B21             LDR      R1,[R4, #+48]
   \   000000F8   0x1E49             SUBS     R1,R1,#+1
   \   000000FA   0xFA11 0xF000      LSLS     R0,R1,R0
   \   000000FE   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000102   0x4306             ORRS     R6,R0,R6
   \   00000104   0xE007             B.N      ??HAL_ADC_Init_11
    516                  }
    517                  else
    518                  {
    519                    /* ADC regular group settings continuous and sequencer discontinuous*/
    520                    /* cannot be enabled simultaneously.                                */
    521                    
    522                    /* Update ADC state machine to error */
    523                    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADC_Init_12: (+1)
   \   00000106   0x6CE0             LDR      R0,[R4, #+76]
   \   00000108   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000010C   0x64E0             STR      R0,[R4, #+76]
    524                    
    525                    /* Set ADC error code to ADC IP internal error */
    526                    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   0000010E   0x6D20             LDR      R0,[R4, #+80]
   \   00000110   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000114   0x6520             STR      R0,[R4, #+80]
    527                  }
    528                }
    529                
    530                /* Update ADC configuration register CR1 with previous settings */
    531                  MODIFY_REG(hadc->Instance->CR1,
    532                             ADC_CR1_RES     |
    533                             ADC_CR1_PDI     |
    534                             ADC_CR1_PDD     |
    535                             ADC_CR1_DISCNUM |
    536                             ADC_CR1_DISCEN  |
    537                             ADC_CR1_SCAN     ,
    538                             tmp_cr1           );
   \                     ??HAL_ADC_Init_11: (+1)
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x6840             LDR      R0,[R0, #+4]
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0xfcfc16ff
   \   0000011E   0x4008             ANDS     R0,R1,R0
   \   00000120   0x4330             ORRS     R0,R6,R0
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0x6048             STR      R0,[R1, #+4]
    539              }
    540              
    541              /* Update ADC configuration register CR2 with previous settings */
    542              MODIFY_REG(hadc->Instance->CR2    ,
    543                         ADC_CR2_MASK_ADCINIT() ,
    544                         tmp_cr2                 );
   \                     ??HAL_ADC_Init_7: (+1)
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0x6880             LDR      R0,[R0, #+8]
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable7_3  ;; 0xc0fff189
   \   0000012E   0x4008             ANDS     R0,R1,R0
   \   00000130   0x4338             ORRS     R0,R7,R0
   \   00000132   0x6821             LDR      R1,[R4, #+0]
   \   00000134   0x6088             STR      R0,[R1, #+8]
    545              
    546              /* Configuration of regular group sequencer:                              */
    547              /* - if scan mode is disabled, regular channels sequence length is set to */
    548              /*   0x00: 1 channel converted (channel on regular rank 1)                */
    549              /*   Parameter "NbrOfConversion" is discarded.                            */
    550              /*   Note: Scan mode is present by hardware on this device and, if        */
    551              /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
    552              /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    553              /* - if scan mode is enabled, regular channels sequence length is set to  */
    554              /*   parameter "NbrOfConversion"                                          */
    555              if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
   \   00000136   0x6920             LDR      R0,[R4, #+16]
   \   00000138   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000013C   0xD002             BEQ.N    ??HAL_ADC_Init_13
   \   0000013E   0x6920             LDR      R0,[R4, #+16]
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD102             BNE.N    ??HAL_ADC_Init_14
   \                     ??HAL_ADC_Init_13: (+1)
   \   00000144   0xF44F 0x7080      MOV      R0,#+256
   \   00000148   0xE000             B.N      ??HAL_ADC_Init_15
   \                     ??HAL_ADC_Init_14: (+1)
   \   0000014A   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Init_15: (+1)
   \   0000014C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000150   0xD10F             BNE.N    ??HAL_ADC_Init_16
    556              {
    557                MODIFY_REG(hadc->Instance->SQR1                         ,
    558                           ADC_SQR1_L                                   ,
    559                           ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion)  );
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6B00             LDR      R0,[R0, #+48]
   \   00000156   0xF44F 0x6178      MOV      R1,#+3968
   \   0000015A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000015E   0xF030 0x70F8      BICS     R0,R0,#0x1F00000
   \   00000162   0x6AA2             LDR      R2,[R4, #+40]
   \   00000164   0x1E52             SUBS     R2,R2,#+1
   \   00000166   0xFA12 0xF101      LSLS     R1,R2,R1
   \   0000016A   0x4308             ORRS     R0,R1,R0
   \   0000016C   0x6821             LDR      R1,[R4, #+0]
   \   0000016E   0x6308             STR      R0,[R1, #+48]
   \   00000170   0xE005             B.N      ??HAL_ADC_Init_17
    560              }
    561              else
    562              {
    563                MODIFY_REG(hadc->Instance->SQR1,
    564                           ADC_SQR1_L          ,
    565                           0x00000000           );
   \                     ??HAL_ADC_Init_16: (+1)
   \   00000172   0x6820             LDR      R0,[R4, #+0]
   \   00000174   0x6B00             LDR      R0,[R0, #+48]
   \   00000176   0xF030 0x70F8      BICS     R0,R0,#0x1F00000
   \   0000017A   0x6821             LDR      R1,[R4, #+0]
   \   0000017C   0x6308             STR      R0,[R1, #+48]
    566              }
    567              
    568              /* Check back that ADC registers have effectively been configured to      */
    569              /* ensure of no potential problem of ADC core IP clocking.                */
    570              /* Check through register CR2 (excluding execution control bits ADON,     */
    571              /* JSWSTART, SWSTART and injected trigger bits JEXTEN and JEXTSEL).       */
    572              if ((READ_REG(hadc->Instance->CR2) & ~(ADC_CR2_ADON |
    573                                                     ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
    574                                                     ADC_CR2_JEXTEN  | ADC_CR2_JEXTSEL   ))
    575                   == tmp_cr2)
   \                     ??HAL_ADC_Init_17: (+1)
   \   0000017E   0x6820             LDR      R0,[R4, #+0]
   \   00000180   0x6880             LDR      R0,[R0, #+8]
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable7_4  ;; 0xbf80fffe
   \   00000186   0x4008             ANDS     R0,R1,R0
   \   00000188   0x42B8             CMP      R0,R7
   \   0000018A   0xD109             BNE.N    ??HAL_ADC_Init_18
    576              {
    577                /* Set ADC error code to none */
    578                ADC_CLEAR_ERRORCODE(hadc);
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0x6520             STR      R0,[R4, #+80]
    579                
    580                /* Set the ADC state */
    581                ADC_STATE_CLR_SET(hadc->State,
    582                                  HAL_ADC_STATE_BUSY_INTERNAL,
    583                                  HAL_ADC_STATE_READY);
   \   00000190   0x6CE0             LDR      R0,[R4, #+76]
   \   00000192   0xF07F 0x0102      MVNS     R1,#+2
   \   00000196   0x4008             ANDS     R0,R1,R0
   \   00000198   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000019C   0x64E0             STR      R0,[R4, #+76]
   \   0000019E   0xE00F             B.N      ??HAL_ADC_Init_19
    584              }
    585              else
    586              {
    587                /* Update ADC state machine to error */
    588                ADC_STATE_CLR_SET(hadc->State,
    589                                  HAL_ADC_STATE_BUSY_INTERNAL,
    590                                  HAL_ADC_STATE_ERROR_INTERNAL);
   \                     ??HAL_ADC_Init_18: (+1)
   \   000001A0   0x6CE0             LDR      R0,[R4, #+76]
   \   000001A2   0xF07F 0x0102      MVNS     R1,#+2
   \   000001A6   0x4008             ANDS     R0,R1,R0
   \   000001A8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000001AC   0x64E0             STR      R0,[R4, #+76]
    591                
    592                /* Set ADC error code to ADC IP internal error */
    593                SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   000001AE   0x6D20             LDR      R0,[R4, #+80]
   \   000001B0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001B4   0x6520             STR      R0,[R4, #+80]
    594                
    595                tmp_hal_status = HAL_ERROR;
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0x0005             MOVS     R5,R0
   \   000001BA   0xE001             B.N      ??HAL_ADC_Init_19
    596              }
    597              
    598            }
    599            else
    600            {
    601              tmp_hal_status = HAL_ERROR;
   \                     ??HAL_ADC_Init_5: (+1)
   \   000001BC   0x2001             MOVS     R0,#+1
   \   000001BE   0x0005             MOVS     R5,R0
    602            }
    603            
    604            /* Return function status */
    605            return tmp_hal_status;
   \                     ??HAL_ADC_Init_19: (+1)
   \   000001C0   0x0028             MOVS     R0,R5
   \   000001C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Init_1: (+1)
   \   000001C4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    606          }
    607          
    608          /**
    609            * @brief  Deinitialize the ADC peripheral registers to its default reset values.
    610            * @note   To not impact other ADCs, reset of common ADC registers have been
    611            *         left commented below.
    612            *         If needed, the example code can be copied and uncommented into
    613            *         function HAL_ADC_MspDeInit().
    614            * @param  hadc: ADC handle
    615            * @retval HAL status
    616            */

   \                                 In section .text, align 2, keep-with-next
    617          HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
    618          {
   \                     HAL_ADC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    619            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    620            
    621            /* Check ADC handle */
    622            if(hadc == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_ADC_DeInit_0
    623            {
    624              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE091             B.N      ??HAL_ADC_DeInit_1
    625            }
    626            
    627            /* Check the parameters */
    628            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    629            
    630            /* Set ADC state */
    631            SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
   \                     ??HAL_ADC_DeInit_0: (+1)
   \   0000000E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000010   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000014   0x64E0             STR      R0,[R4, #+76]
    632            
    633            /* Stop potential conversion on going, on regular and injected groups */
    634            /* Disable ADC peripheral */
    635            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000001C   0x0005             MOVS     R5,R0
    636            
    637            
    638            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    639            /* correctly completed.                                                     */
    640            if (tmp_hal_status == HAL_OK)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xF040 0x8081      BNE.W    ??HAL_ADC_DeInit_2
    641            {
    642              /* ========== Reset ADC registers ========== */
    643              /* Reset register SR */
    644              __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
    645                                          ADC_FLAG_JSTRT | ADC_FLAG_STRT));
   \   00000026   0xF07F 0x001F      MVNS     R0,#+31
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    646                                   
    647              /* Reset register CR1 */
    648              CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_OVRIE   | ADC_CR1_RES     | ADC_CR1_AWDEN  |
    649                                              ADC_CR1_JAWDEN  | ADC_CR1_PDI     | ADC_CR1_PDD    |
    650                                              ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN |
    651                                              ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN   |
    652                                              ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE  |
    653                                              ADC_CR1_AWDCH                                       ));
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6840             LDR      R0,[R0, #+4]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable7_5  ;; 0xf83c0000
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6048             STR      R0,[R1, #+4]
    654              
    655              /* Reset register CR2 */
    656              ADC_CR2_CLEAR(hadc);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6880             LDR      R0,[R0, #+8]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable7_6  ;; 0x8080f088
   \   00000044   0x4008             ANDS     R0,R1,R0
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6088             STR      R0,[R1, #+8]
    657              
    658              /* Reset register SMPR0 */
    659              ADC_SMPR0_CLEAR(hadc);
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6DC0             LDR      R0,[R0, #+92]
   \   0000004E   0x0980             LSRS     R0,R0,#+6
   \   00000050   0x0180             LSLS     R0,R0,#+6
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x65C8             STR      R0,[R1, #+92]
    660              
    661              /* Reset register SMPR1 */
    662              ADC_SMPR1_CLEAR(hadc);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    663              
    664              /* Reset register SMPR2 */
    665              CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP19 | ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | 
    666                                                ADC_SMPR2_SMP16 | ADC_SMPR2_SMP15 | ADC_SMPR2_SMP14 | 
    667                                                ADC_SMPR2_SMP13 | ADC_SMPR2_SMP12 | ADC_SMPR2_SMP11 |
    668                                                ADC_SMPR2_SMP10                                      ));
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6900             LDR      R0,[R0, #+16]
   \   00000066   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6108             STR      R0,[R1, #+16]
    669              
    670              /* Reset register SMPR3 */
    671              CLEAR_BIT(hadc->Instance->SMPR3, (ADC_SMPR3_SMP9 | ADC_SMPR3_SMP8 | ADC_SMPR3_SMP7 | 
    672                                                ADC_SMPR3_SMP6 | ADC_SMPR3_SMP5 | ADC_SMPR3_SMP4 | 
    673                                                ADC_SMPR3_SMP3 | ADC_SMPR3_SMP2 | ADC_SMPR3_SMP1 |
    674                                                ADC_SMPR3_SMP0                                    ));
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6940             LDR      R0,[R0, #+20]
   \   00000072   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6148             STR      R0,[R1, #+20]
    675              
    676              /* Reset register JOFR1 */
    677              CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6980             LDR      R0,[R0, #+24]
   \   0000007E   0x0B00             LSRS     R0,R0,#+12
   \   00000080   0x0300             LSLS     R0,R0,#+12
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6188             STR      R0,[R1, #+24]
    678              /* Reset register JOFR2 */
    679              CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0x0B00             LSRS     R0,R0,#+12
   \   0000008C   0x0300             LSLS     R0,R0,#+12
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x61C8             STR      R0,[R1, #+28]
    680              /* Reset register JOFR3 */
    681              CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0x0B00             LSRS     R0,R0,#+12
   \   00000098   0x0300             LSLS     R0,R0,#+12
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x6208             STR      R0,[R1, #+32]
    682              /* Reset register JOFR4 */
    683              CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6A40             LDR      R0,[R0, #+36]
   \   000000A2   0x0B00             LSRS     R0,R0,#+12
   \   000000A4   0x0300             LSLS     R0,R0,#+12
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6248             STR      R0,[R1, #+36]
    684              
    685              /* Reset register HTR */
    686              CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6A80             LDR      R0,[R0, #+40]
   \   000000AE   0x0B00             LSRS     R0,R0,#+12
   \   000000B0   0x0300             LSLS     R0,R0,#+12
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0x6288             STR      R0,[R1, #+40]
    687              /* Reset register LTR */
    688              CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6AC0             LDR      R0,[R0, #+44]
   \   000000BA   0x0B00             LSRS     R0,R0,#+12
   \   000000BC   0x0300             LSLS     R0,R0,#+12
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x62C8             STR      R0,[R1, #+44]
    689              
    690              /* Reset register SQR1 */
    691              CLEAR_BIT(hadc->Instance->SQR1, (ADC_SQR1_L | __ADC_SQR1_SQXX));
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6B00             LDR      R0,[R0, #+48]
   \   000000C6   0xF010 0x407E      ANDS     R0,R0,#0xFE000000
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x6308             STR      R0,[R1, #+48]
    692              
    693              /* Reset register SQR2 */
    694              CLEAR_BIT(hadc->Instance->SQR2, (ADC_SQR2_SQ24 | ADC_SQR2_SQ23 | ADC_SQR2_SQ22 | 
    695                                               ADC_SQR2_SQ21 | ADC_SQR2_SQ20 | ADC_SQR2_SQ19  ));
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6B40             LDR      R0,[R0, #+52]
   \   000000D2   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6348             STR      R0,[R1, #+52]
    696              
    697              /* Reset register SQR3 */
    698              CLEAR_BIT(hadc->Instance->SQR3, (ADC_SQR3_SQ18 | ADC_SQR3_SQ17 | ADC_SQR3_SQ16 | 
    699                                               ADC_SQR3_SQ15 | ADC_SQR3_SQ14 | ADC_SQR3_SQ13  ));
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6B80             LDR      R0,[R0, #+56]
   \   000000DE   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x6388             STR      R0,[R1, #+56]
    700              
    701              /* Reset register SQR4 */
    702              CLEAR_BIT(hadc->Instance->SQR4, (ADC_SQR4_SQ12 | ADC_SQR4_SQ11 | ADC_SQR4_SQ10 | 
    703                                               ADC_SQR4_SQ9  | ADC_SQR4_SQ8  | ADC_SQR4_SQ7   ));
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6BC0             LDR      R0,[R0, #+60]
   \   000000EA   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0x63C8             STR      R0,[R1, #+60]
    704              
    705              /* Reset register SQR5 */
    706              CLEAR_BIT(hadc->Instance->SQR5, (ADC_SQR5_SQ6 | ADC_SQR5_SQ5 | ADC_SQR5_SQ4 | 
    707                                               ADC_SQR5_SQ3 | ADC_SQR5_SQ2 | ADC_SQR5_SQ1  ));
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6C00             LDR      R0,[R0, #+64]
   \   000000F6   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   000000FA   0x6821             LDR      R1,[R4, #+0]
   \   000000FC   0x6408             STR      R0,[R1, #+64]
    708              
    709              
    710              /* Reset register JSQR */
    711              CLEAR_BIT(hadc->Instance->JSQR, (ADC_JSQR_JL |
    712                                               ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
    713                                               ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  ));
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6C40             LDR      R0,[R0, #+68]
   \   00000102   0x0D80             LSRS     R0,R0,#+22
   \   00000104   0x0580             LSLS     R0,R0,#+22
   \   00000106   0x6821             LDR      R1,[R4, #+0]
   \   00000108   0x6448             STR      R0,[R1, #+68]
    714              
    715              /* Reset register DR */
    716              /* bits in access mode read only, no direct reset applicable*/
    717              
    718              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    719              /* bits in access mode read only, no direct reset applicable*/
    720              
    721              /* Reset register CCR */
    722              CLEAR_BIT(ADC->CCR, ADC_CCR_TSVREFE);   
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x40012704
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40012704
   \   00000118   0x6008             STR      R0,[R1, #+0]
    723              
    724              /* ========== Hard reset ADC peripheral ========== */
    725              /* Performs a global reset of the entire ADC peripheral: ADC state is     */
    726              /* forced to a similar state after device power-on.                       */
    727              /* If needed, copy-paste and uncomment the following reset code into      */
    728              /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
    729              /*                                                                        */
    730              /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
    731              /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
    732              
    733              /* DeInit the low level hardware */
    734              HAL_ADC_MspDeInit(hadc);
   \   0000011A   0x0020             MOVS     R0,R4
   \   0000011C   0x.... 0x....      BL       HAL_ADC_MspDeInit
    735              
    736              /* Set ADC error code to none */
    737              ADC_CLEAR_ERRORCODE(hadc);
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x6520             STR      R0,[R4, #+80]
    738              
    739              /* Set ADC state */
    740              hadc->State = HAL_ADC_STATE_RESET;
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x64E0             STR      R0,[R4, #+76]
    741              
    742            }
    743            
    744            /* Process unlocked */
    745            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_DeInit_2: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x0048      STRB     R0,[R4, #+72]
    746            
    747            /* Return function status */
    748            return tmp_hal_status;
   \   0000012E   0x0028             MOVS     R0,R5
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_DeInit_1: (+1)
   \   00000132   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    749          }
    750          
    751          /**
    752            * @brief  Initializes the ADC MSP.
    753            * @param  hadc: ADC handle
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
    757          {
    758            /* Prevent unused argument(s) compilation warning */
    759            UNUSED(hadc);
    760          
    761            /* NOTE : This function should not be modified. When the callback is needed,
    762                      function HAL_ADC_MspInit must be implemented in the user file.
    763             */ 
    764          }
   \                     HAL_ADC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    765          
    766          /**
    767            * @brief  DeInitializes the ADC MSP.
    768            * @param  hadc: ADC handle
    769            * @retval None
    770            */

   \                                 In section .text, align 2, keep-with-next
    771          __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
    772          {
    773            /* Prevent unused argument(s) compilation warning */
    774            UNUSED(hadc);
    775          
    776            /* NOTE : This function should not be modified. When the callback is needed,
    777                      function HAL_ADC_MspDeInit must be implemented in the user file.
    778             */ 
    779          }
   \                     HAL_ADC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    780          
    781          /**
    782            * @}
    783            */
    784          
    785          /** @defgroup ADC_Exported_Functions_Group2 ADC Input and Output operation functions
    786           *  @brief    ADC IO operation functions 
    787           *
    788          @verbatim   
    789           ===============================================================================
    790                                ##### IO operation functions #####
    791           ===============================================================================
    792              [..]  This section provides functions allowing to:
    793                (+) Start conversion of regular group.
    794                (+) Stop conversion of regular group.
    795                (+) Poll for conversion complete on regular group.
    796                (+) Poll for conversion event.
    797                (+) Get result of regular channel conversion.
    798                (+) Start conversion of regular group and enable interruptions.
    799                (+) Stop conversion of regular group and disable interruptions.
    800                (+) Handle ADC interrupt request
    801                (+) Start conversion of regular group and enable DMA transfer.
    802                (+) Stop conversion of regular group and disable ADC DMA transfer.
    803          @endverbatim
    804            * @{
    805            */
    806          
    807          /**
    808            * @brief  Enables ADC, starts conversion of regular group.
    809            *         Interruptions enabled in this function: None.
    810            * @param  hadc: ADC handle
    811            * @retval HAL status
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
    814          {
   \                     HAL_ADC_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    815            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    816            
    817            /* Check the parameters */
    818            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    819            
    820            /* Process locked */
    821            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Start_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE039             B.N      ??HAL_ADC_Start_1
   \                     ??HAL_ADC_Start_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    822            
    823            /* Enable the ADC peripheral */
    824            tmp_hal_status = ADC_Enable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_Enable
   \   0000001E   0x0005             MOVS     R5,R0
    825            
    826            /* Start conversion if ADC is effectively enabled */
    827            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD12D             BNE.N    ??HAL_ADC_Start_2
    828            {
    829              /* Set ADC state                                                          */
    830              /* - Clear state bitfield related to regular group conversion results     */
    831              /* - Set state bitfield related to regular group operation                */
    832              ADC_STATE_CLR_SET(hadc->State,
    833                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
    834                                HAL_ADC_STATE_REG_BUSY);
   \   00000026   0x6CE0             LDR      R0,[R4, #+76]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable7_7  ;; 0xfffff9fe
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000032   0x64E0             STR      R0,[R4, #+76]
    835              
    836              /* If conversions on group regular are also triggering group injected,    */
    837              /* update ADC state.                                                      */
    838              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x0540             LSLS     R0,R0,#+21
   \   0000003A   0xD505             BPL.N    ??HAL_ADC_Start_3
    839              {
    840                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   0000003C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000003E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000042   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000046   0x64E0             STR      R0,[R4, #+76]
    841              }
    842              
    843              /* State machine update: Check if an injected conversion is ongoing */
    844              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_3: (+1)
   \   00000048   0x6CE0             LDR      R0,[R4, #+76]
   \   0000004A   0x04C0             LSLS     R0,R0,#+19
   \   0000004C   0xD505             BPL.N    ??HAL_ADC_Start_4
    845              {
    846                /* Reset ADC error code fields related to conversions on group regular */
    847                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   0000004E   0x6D20             LDR      R0,[R4, #+80]
   \   00000050   0xF07F 0x0106      MVNS     R1,#+6
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x6520             STR      R0,[R4, #+80]
   \   00000058   0xE001             B.N      ??HAL_ADC_Start_5
    848              }
    849              else
    850              {
    851                /* Reset ADC all error code fields */
    852                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6520             STR      R0,[R4, #+80]
    853              }
    854              
    855              /* Process unlocked */
    856              /* Unlock before starting ADC conversions: in case of potential           */
    857              /* interruption, to let the process to ADC IRQ Handler.                   */
    858              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_5: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0048      STRB     R0,[R4, #+72]
    859              
    860              /* Clear regular group conversion flag and overrun flag */
    861              /* (To ensure of no unknown state from potential previous ADC operations) */
    862              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   00000064   0xF07F 0x0002      MVNS     R0,#+2
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    863              
    864              /* Enable conversion of regular group.                                    */
    865              /* If software start has been selected, conversion starts immediately.    */
    866              /* If external trigger has been selected, conversion will start at next   */
    867              /* trigger event.                                                         */
    868              if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6880             LDR      R0,[R0, #+8]
   \   00000070   0xF010 0x5F40      TST      R0,#0x30000000
   \   00000074   0xD105             BNE.N    ??HAL_ADC_Start_2
    869              {
    870                /* Start ADC conversion on regular group */
    871                SET_BIT(hadc->Instance->CR2, ADC_CR2_SWSTART);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6880             LDR      R0,[R0, #+8]
   \   0000007A   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6088             STR      R0,[R1, #+8]
    872              }
    873            }
    874            
    875            /* Return function status */
    876            return tmp_hal_status;
   \                     ??HAL_ADC_Start_2: (+1)
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Start_1: (+1)
   \   00000086   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    877          }
    878          
    879          /**
    880            * @brief  Stop ADC conversion of regular group (and injected channels in 
    881            *         case of auto_injection mode), disable ADC peripheral.
    882            * @note:  ADC peripheral disable is forcing stop of potential 
    883            *         conversion on injected group. If injected group is under use, it
    884            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
    885            * @param  hadc: ADC handle
    886            * @retval HAL status.
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
    889          {
   \                     HAL_ADC_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    890            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    891            
    892            /* Check the parameters */
    893            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    894            
    895            /* Process locked */
    896            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Stop_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE014             B.N      ??HAL_ADC_Stop_1
   \                     ??HAL_ADC_Stop_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
    897            
    898            /* Stop potential conversion on going, on regular and injected groups */
    899            /* Disable ADC peripheral */
    900            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000001E   0x0005             MOVS     R5,R0
    901            
    902            /* Check if ADC is effectively disabled */
    903            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD105             BNE.N    ??HAL_ADC_Stop_2
    904            {
    905              /* Set ADC state */
    906              ADC_STATE_CLR_SET(hadc->State,
    907                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    908                                HAL_ADC_STATE_READY);
   \   00000026   0x6CE0             LDR      R0,[R4, #+76]
   \   00000028   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   0000002C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000030   0x64E0             STR      R0,[R4, #+76]
    909            }
    910            
    911            /* Process unlocked */
    912            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_2: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0048      STRB     R0,[R4, #+72]
    913            
    914            /* Return function status */
    915            return tmp_hal_status;
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Stop_1: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    916          }
    917          
    918          /**
    919            * @brief  Wait for regular group conversion to be completed.
    920            * @note   ADC conversion flags EOS (end of sequence) and EOC (end of
    921            *         conversion) are cleared by this function, with an exception:
    922            *         if low power feature "LowPowerAutoWait" is enabled, flags are 
    923            *         not cleared to not interfere with this feature until data register
    924            *         is read using function HAL_ADC_GetValue().
    925            * @note   This function cannot be used in a particular setup: ADC configured 
    926            *         in DMA mode and polling for end of each conversion (ADC init
    927            *         parameter "EOCSelection" set to ADC_EOC_SINGLE_CONV).
    928            *         In this case, DMA resets the flag EOC and polling cannot be
    929            *         performed on each conversion. Nevertheless, polling can still 
    930            *         be performed on the complete sequence (ADC init
    931            *         parameter "EOCSelection" set to ADC_EOC_SEQ_CONV).
    932            * @param  hadc: ADC handle
    933            * @param  Timeout: Timeout value in millisecond.
    934            * @retval HAL status
    935            */

   \                                 In section .text, align 2, keep-with-next
    936          HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    937          {
   \                     HAL_ADC_PollForConversion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    938            uint32_t tickstart = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    939           
    940            /* Check the parameters */
    941            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    942            
    943            /* Verification that ADC configuration is compliant with polling for      */
    944            /* each conversion:                                                       */
    945            /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    946            /* several ranks and polling for end of each conversion.                  */
    947            /* For code simplicity sake, this particular case is generalized to       */
    948            /* ADC configured in DMA mode and and polling for end of each conversion. */
    949            if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
    950                HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x0540             LSLS     R0,R0,#+21
   \   0000000E   0xD50C             BPL.N    ??HAL_ADC_PollForConversion_0
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x05C0             LSLS     R0,R0,#+23
   \   00000016   0xD508             BPL.N    ??HAL_ADC_PollForConversion_0
    951            {
    952              /* Update ADC state machine to error */
    953              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \   00000018   0x6CE0             LDR      R0,[R4, #+76]
   \   0000001A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001E   0x64E0             STR      R0,[R4, #+76]
    954              
    955              /* Process unlocked */
    956              __HAL_UNLOCK(hadc);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x0048      STRB     R0,[R4, #+72]
    957              
    958              return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE041             B.N      ??HAL_ADC_PollForConversion_1
    959            }
    960          
    961            /* Get tick count */
    962            tickstart = HAL_GetTick();
   \                     ??HAL_ADC_PollForConversion_0: (+1)
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x0006             MOVS     R6,R0
    963            
    964            /* Wait until End of Conversion flag is raised */
    965            while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
   \                     ??HAL_ADC_PollForConversion_2: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0780             LSLS     R0,R0,#+30
   \   00000036   0xD412             BMI.N    ??HAL_ADC_PollForConversion_3
    966            {
    967              /* Check if timeout is disabled (set to infinite wait) */
    968              if(Timeout != HAL_MAX_DELAY)
   \   00000038   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000003C   0xD0F8             BEQ.N    ??HAL_ADC_PollForConversion_2
    969              {
    970                if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD004             BEQ.N    ??HAL_ADC_PollForConversion_4
   \   00000042   0x.... 0x....      BL       HAL_GetTick
   \   00000046   0x1B80             SUBS     R0,R0,R6
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD2F1             BCS.N    ??HAL_ADC_PollForConversion_2
    971                {
    972                  /* Update ADC state machine to timeout */
    973                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForConversion_4: (+1)
   \   0000004C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000004E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000052   0x64E0             STR      R0,[R4, #+76]
    974                  
    975                  /* Process unlocked */
    976                  __HAL_UNLOCK(hadc);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x0048      STRB     R0,[R4, #+72]
    977                  
    978                  return HAL_TIMEOUT;
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xE027             B.N      ??HAL_ADC_PollForConversion_1
    979                }
    980              }
    981            }
    982            
    983            /* Clear end of conversion flag of regular group if low power feature     */
    984            /* "Auto Wait" is disabled, to not interfere with this feature until data */
    985            /* register is read using function HAL_ADC_GetValue().                    */
    986            if (hadc->Init.LowPowerAutoWait == DISABLE)
   \                     ??HAL_ADC_PollForConversion_3: (+1)
   \   0000005E   0x69A0             LDR      R0,[R4, #+24]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD103             BNE.N    ??HAL_ADC_PollForConversion_5
    987            {
    988              /* Clear regular group conversion flag */
    989              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \   00000064   0xF07F 0x0012      MVNS     R0,#+18
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    990            }
    991            
    992            /* Update ADC state machine */
    993            SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \                     ??HAL_ADC_PollForConversion_5: (+1)
   \   0000006C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000006E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000072   0x64E0             STR      R0,[R4, #+76]
    994            
    995            /* Determine whether any further conversion upcoming on group regular       */
    996            /* by external trigger, continuous mode or scan sequence on going.          */
    997            /* Note: On STM32L1, there is no independent flag of end of sequence.       */
    998            /*       The test of scan sequence on going is done either with scan        */
    999            /*       sequence disabled or with end of conversion flag set to            */
   1000            /*       of end of sequence.                                                */
   1001            if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   1002               (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1003               (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
   1004                HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6880             LDR      R0,[R0, #+8]
   \   00000078   0xF010 0x5F40      TST      R0,#0x30000000
   \   0000007C   0xD116             BNE.N    ??HAL_ADC_PollForConversion_6
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD113             BNE.N    ??HAL_ADC_PollForConversion_6
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6B00             LDR      R0,[R0, #+48]
   \   00000088   0xF010 0x7FF8      TST      R0,#0x1F00000
   \   0000008C   0xD003             BEQ.N    ??HAL_ADC_PollForConversion_7
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6880             LDR      R0,[R0, #+8]
   \   00000092   0x0540             LSLS     R0,R0,#+21
   \   00000094   0xD40A             BMI.N    ??HAL_ADC_PollForConversion_6
   1005            {
   1006              /* Set ADC state */
   1007              CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \                     ??HAL_ADC_PollForConversion_7: (+1)
   \   00000096   0x6CE0             LDR      R0,[R4, #+76]
   \   00000098   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000009C   0x64E0             STR      R0,[R4, #+76]
   1008              
   1009              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   0000009E   0x6CE0             LDR      R0,[R4, #+76]
   \   000000A0   0x04C0             LSLS     R0,R0,#+19
   \   000000A2   0xD403             BMI.N    ??HAL_ADC_PollForConversion_6
   1010              { 
   1011                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   000000A4   0x6CE0             LDR      R0,[R4, #+76]
   \   000000A6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000AA   0x64E0             STR      R0,[R4, #+76]
   1012              }
   1013            }
   1014            
   1015            /* Return ADC state */
   1016            return HAL_OK;
   \                     ??HAL_ADC_PollForConversion_6: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_PollForConversion_1: (+1)
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
   1017          }
   1018          
   1019          /**
   1020            * @brief  Poll for conversion event.
   1021            * @param  hadc: ADC handle
   1022            * @param  EventType: the ADC event type.
   1023            *          This parameter can be one of the following values:
   1024            *            @arg ADC_AWD_EVENT: ADC Analog watchdog event.
   1025            *            @arg ADC_OVR_EVENT: ADC Overrun event.
   1026            * @param  Timeout: Timeout value in millisecond.
   1027            * @retval HAL status
   1028            */

   \                                 In section .text, align 2, keep-with-next
   1029          HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
   1030          {
   \                     HAL_ADC_PollForEvent: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1031            uint32_t tickstart = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1032            
   1033            /* Check the parameters */
   1034            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1035            assert_param(IS_ADC_EVENT_TYPE(EventType));
   1036            
   1037            /* Get tick count */
   1038            tickstart = HAL_GetTick();
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x0007             MOVS     R7,R0
   1039            
   1040            /* Check selected event flag */
   1041            while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
   \                     ??HAL_ADC_PollForEvent_0: (+1)
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4028             ANDS     R0,R5,R0
   \   00000016   0x42A8             CMP      R0,R5
   \   00000018   0xD012             BEQ.N    ??HAL_ADC_PollForEvent_1
   1042            {
   1043              /* Check if timeout is disabled (set to infinite wait) */
   1044              if(Timeout != HAL_MAX_DELAY)
   \   0000001A   0xF5B6 0x4F00      CMP      R6,#+32768
   \   0000001E   0xD0F7             BEQ.N    ??HAL_ADC_PollForEvent_0
   1045              {
   1046                if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD004             BEQ.N    ??HAL_ADC_PollForEvent_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1BC0             SUBS     R0,R0,R7
   \   0000002A   0x4286             CMP      R6,R0
   \   0000002C   0xD2F0             BCS.N    ??HAL_ADC_PollForEvent_0
   1047                {
   1048                  /* Update ADC state machine to timeout */
   1049                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForEvent_2: (+1)
   \   0000002E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000030   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000034   0x64E0             STR      R0,[R4, #+76]
   1050                  
   1051                  /* Process unlocked */
   1052                  __HAL_UNLOCK(hadc);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0048      STRB     R0,[R4, #+72]
   1053                  
   1054                  return HAL_TIMEOUT;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xE017             B.N      ??HAL_ADC_PollForEvent_3
   1055                }
   1056              }
   1057            }
   1058            
   1059            switch(EventType)
   \                     ??HAL_ADC_PollForEvent_1: (+1)
   \   00000040   0x2D01             CMP      R5,#+1
   \   00000042   0xD108             BNE.N    ??HAL_ADC_PollForEvent_4
   1060            {
   1061            /* Analog watchdog (level out of window) event */
   1062            case ADC_AWD_EVENT:
   1063              /* Set ADC state */
   1064              SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \   00000044   0x6CE0             LDR      R0,[R4, #+76]
   \   00000046   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000004A   0x64E0             STR      R0,[R4, #+76]
   1065                
   1066              /* Clear ADC analog watchdog flag */
   1067              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \   0000004C   0xF07F 0x0001      MVNS     R0,#+1
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1068              break;
   \   00000054   0xE00B             B.N      ??HAL_ADC_PollForEvent_5
   1069            
   1070            /* Overrun event */
   1071            default: /* Case ADC_OVR_EVENT */
   1072              /* Note: On STM32L1, ADC overrun can be set through other parameters      */
   1073              /*       refer to description of parameter "EOCSelection" for more        */
   1074              /*       details.                                                         */
   1075          
   1076              /* Set ADC state */
   1077              SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
   \                     ??HAL_ADC_PollForEvent_4: (+1)
   \   00000056   0x6CE0             LDR      R0,[R4, #+76]
   \   00000058   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000005C   0x64E0             STR      R0,[R4, #+76]
   1078              /* Set ADC error code to overrun */
   1079              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
   \   0000005E   0x6D20             LDR      R0,[R4, #+80]
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x6520             STR      R0,[R4, #+80]
   1080              
   1081              /* Clear ADC overrun flag */
   1082              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \   00000066   0xF07F 0x0020      MVNS     R0,#+32
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1083              break;
   1084            }
   1085            
   1086            /* Return ADC state */
   1087            return HAL_OK;
   \                     ??HAL_ADC_PollForEvent_5: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_PollForEvent_3: (+1)
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1088          }
   1089          
   1090          /**
   1091            * @brief  Enables ADC, starts conversion of regular group with interruption.
   1092            *         Interruptions enabled in this function:
   1093            *          - EOC (end of conversion of regular group)
   1094            *          - overrun
   1095            *         Each of these interruptions has its dedicated callback function.
   1096            * @param  hadc: ADC handle
   1097            * @retval HAL status
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
   1100          {
   \                     HAL_ADC_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1101            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1102            
   1103            /* Check the parameters */
   1104            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1105            
   1106            /* Process locked */
   1107            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Start_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE041             B.N      ??HAL_ADC_Start_IT_1
   \                     ??HAL_ADC_Start_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
   1108            
   1109            /* Enable the ADC peripheral */
   1110            tmp_hal_status = ADC_Enable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_Enable
   \   0000001E   0x0005             MOVS     R5,R0
   1111            
   1112            /* Start conversion if ADC is effectively enabled */
   1113            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD135             BNE.N    ??HAL_ADC_Start_IT_2
   1114            {
   1115              /* Set ADC state                                                          */
   1116              /* - Clear state bitfield related to regular group conversion results     */
   1117              /* - Set state bitfield related to regular group operation                */
   1118              ADC_STATE_CLR_SET(hadc->State,
   1119                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
   1120                                HAL_ADC_STATE_REG_BUSY);
   \   00000026   0x6CE0             LDR      R0,[R4, #+76]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable7_7  ;; 0xfffff9fe
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000032   0x64E0             STR      R0,[R4, #+76]
   1121              
   1122              /* If conversions on group regular are also triggering group injected,    */
   1123              /* update ADC state.                                                      */
   1124              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x0540             LSLS     R0,R0,#+21
   \   0000003A   0xD505             BPL.N    ??HAL_ADC_Start_IT_3
   1125              {
   1126                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   0000003C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000003E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000042   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000046   0x64E0             STR      R0,[R4, #+76]
   1127              }
   1128              
   1129              /* State machine update: Check if an injected conversion is ongoing */
   1130              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_IT_3: (+1)
   \   00000048   0x6CE0             LDR      R0,[R4, #+76]
   \   0000004A   0x04C0             LSLS     R0,R0,#+19
   \   0000004C   0xD505             BPL.N    ??HAL_ADC_Start_IT_4
   1131              {
   1132                /* Reset ADC error code fields related to conversions on group regular */
   1133                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   0000004E   0x6D20             LDR      R0,[R4, #+80]
   \   00000050   0xF07F 0x0106      MVNS     R1,#+6
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x6520             STR      R0,[R4, #+80]
   \   00000058   0xE001             B.N      ??HAL_ADC_Start_IT_5
   1134              }
   1135              else
   1136              {
   1137                /* Reset ADC all error code fields */
   1138                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_IT_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6520             STR      R0,[R4, #+80]
   1139              }
   1140              
   1141              /* Process unlocked */
   1142              /* Unlock before starting ADC conversions: in case of potential           */
   1143              /* interruption, to let the process to ADC IRQ Handler.                   */
   1144              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_IT_5: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0048      STRB     R0,[R4, #+72]
   1145              
   1146              /* Clear regular group conversion flag and overrun flag */
   1147              /* (To ensure of no unknown state from potential previous ADC operations) */
   1148              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   00000064   0xF07F 0x0002      MVNS     R0,#+2
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   1149              
   1150              /* Enable end of conversion interrupt for regular group */
   1151              __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0xF040 0x6080      ORR      R0,R0,#0x4000000
   \   00000074   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6048             STR      R0,[R1, #+4]
   1152              
   1153              /* Enable conversion of regular group.                                    */
   1154              /* If software start has been selected, conversion starts immediately.    */
   1155              /* If external trigger has been selected, conversion will start at next   */
   1156              /* trigger event.                                                         */
   1157              if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6880             LDR      R0,[R0, #+8]
   \   00000080   0xF010 0x5F40      TST      R0,#0x30000000
   \   00000084   0xD105             BNE.N    ??HAL_ADC_Start_IT_2
   1158              {
   1159                /* Start ADC conversion on regular group */
   1160                SET_BIT(hadc->Instance->CR2, ADC_CR2_SWSTART);
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6880             LDR      R0,[R0, #+8]
   \   0000008A   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6088             STR      R0,[R1, #+8]
   1161              }
   1162            }
   1163            
   1164            /* Return function status */
   1165            return tmp_hal_status;
   \                     ??HAL_ADC_Start_IT_2: (+1)
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Start_IT_1: (+1)
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1166          }
   1167          
   1168          /**
   1169            * @brief  Stop ADC conversion of regular group (and injected group in 
   1170            *         case of auto_injection mode), disable interrution of 
   1171            *         end-of-conversion, disable ADC peripheral.
   1172            * @param  hadc: ADC handle
   1173            * @retval None
   1174            */

   \                                 In section .text, align 2, keep-with-next
   1175          HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
   1176          {
   \                     HAL_ADC_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1177            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1178            
   1179            /* Check the parameters */
   1180            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1181            
   1182            /* Process locked */
   1183            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Stop_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01B             B.N      ??HAL_ADC_Stop_IT_1
   \                     ??HAL_ADC_Stop_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
   1184            
   1185            /* Stop potential conversion on going, on regular and injected groups */
   1186            /* Disable ADC peripheral */
   1187            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000001E   0x0005             MOVS     R5,R0
   1188            
   1189            /* Check if ADC is effectively disabled */
   1190            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD10C             BNE.N    ??HAL_ADC_Stop_IT_2
   1191            {
   1192              /* Disable ADC end of conversion interrupt for regular group */
   1193              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF07F 0x0120      MVNS     R1,#+32
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
   1194              
   1195              /* Set ADC state */
   1196              ADC_STATE_CLR_SET(hadc->State,
   1197                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1198                                HAL_ADC_STATE_READY);
   \   00000034   0x6CE0             LDR      R0,[R4, #+76]
   \   00000036   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x64E0             STR      R0,[R4, #+76]
   1199            }
   1200            
   1201            /* Process unlocked */
   1202            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_IT_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0048      STRB     R0,[R4, #+72]
   1203            
   1204            /* Return function status */
   1205            return tmp_hal_status;
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Stop_IT_1: (+1)
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1206          }
   1207          
   1208          /**
   1209            * @brief  Enables ADC, starts conversion of regular group and transfers result
   1210            *         through DMA.
   1211            *         Interruptions enabled in this function:
   1212            *          - DMA transfer complete
   1213            *          - DMA half transfer
   1214            *          - overrun
   1215            *         Each of these interruptions has its dedicated callback function.
   1216            * @param  hadc: ADC handle
   1217            * @param  pData: The destination Buffer address.
   1218            * @param  Length: The length of data to be transferred from ADC peripheral to memory.
   1219            * @retval None
   1220            */

   \                                 In section .text, align 2, keep-with-next
   1221          HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
   1222          {
   \                     HAL_ADC_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1223            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000008   0x2700             MOVS     R7,#+0
   1224            
   1225            /* Check the parameters */
   1226            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1227            
   1228            /* Process locked */
   1229            __HAL_LOCK(hadc);
   \   0000000A   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_ADC_Start_DMA_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE059             B.N      ??HAL_ADC_Start_DMA_1
   \                     ??HAL_ADC_Start_DMA_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x0048      STRB     R0,[R4, #+72]
   1230            
   1231            /* Enable the ADC peripheral */
   1232            tmp_hal_status = ADC_Enable(hadc);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       ADC_Enable
   \   00000022   0x0007             MOVS     R7,R0
   1233            
   1234            /* Start conversion if ADC is effectively enabled */
   1235            if (tmp_hal_status == HAL_OK)
   \   00000024   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD14D             BNE.N    ??HAL_ADC_Start_DMA_2
   1236            {
   1237              /* Set ADC state                                                          */
   1238              /* - Clear state bitfield related to regular group conversion results     */
   1239              /* - Set state bitfield related to regular group operation                */
   1240              ADC_STATE_CLR_SET(hadc->State,
   1241                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
   1242                                HAL_ADC_STATE_REG_BUSY);
   \   0000002A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable7_7  ;; 0xfffff9fe
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000036   0x64E0             STR      R0,[R4, #+76]
   1243              
   1244              /* If conversions on group regular are also triggering group injected,    */
   1245              /* update ADC state.                                                      */
   1246              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x0540             LSLS     R0,R0,#+21
   \   0000003E   0xD505             BPL.N    ??HAL_ADC_Start_DMA_3
   1247              {
   1248                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   00000040   0x6CE0             LDR      R0,[R4, #+76]
   \   00000042   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000046   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000004A   0x64E0             STR      R0,[R4, #+76]
   1249              }
   1250              
   1251              /* State machine update: Check if an injected conversion is ongoing */
   1252              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_DMA_3: (+1)
   \   0000004C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000004E   0x04C0             LSLS     R0,R0,#+19
   \   00000050   0xD505             BPL.N    ??HAL_ADC_Start_DMA_4
   1253              {
   1254                /* Reset ADC error code fields related to conversions on group regular */
   1255                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   00000052   0x6D20             LDR      R0,[R4, #+80]
   \   00000054   0xF07F 0x0106      MVNS     R1,#+6
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x6520             STR      R0,[R4, #+80]
   \   0000005C   0xE001             B.N      ??HAL_ADC_Start_DMA_5
   1256              }
   1257              else
   1258              {
   1259                /* Reset ADC all error code fields */
   1260                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_DMA_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6520             STR      R0,[R4, #+80]
   1261              }
   1262              
   1263              /* Process unlocked */
   1264              /* Unlock before starting ADC conversions: in case of potential           */
   1265              /* interruption, to let the process to ADC IRQ Handler.                   */
   1266              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_DMA_5: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF884 0x0048      STRB     R0,[R4, #+72]
   1267          
   1268              /* Set the DMA transfer complete callback */
   1269              hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
   \   00000068   0x.... 0x....      ADR.W    R0,ADC_DMAConvCplt
   \   0000006C   0x6C61             LDR      R1,[R4, #+68]
   \   0000006E   0x6288             STR      R0,[R1, #+40]
   1270          
   1271              /* Set the DMA half transfer complete callback */
   1272              hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
   \   00000070   0x.... 0x....      ADR.W    R0,ADC_DMAHalfConvCplt
   \   00000074   0x6C61             LDR      R1,[R4, #+68]
   \   00000076   0x62C8             STR      R0,[R1, #+44]
   1273              
   1274              /* Set the DMA error callback */
   1275              hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
   \   00000078   0x.... 0x....      ADR.W    R0,ADC_DMAError
   \   0000007C   0x6C61             LDR      R1,[R4, #+68]
   \   0000007E   0x6308             STR      R0,[R1, #+48]
   1276          
   1277              
   1278              /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
   1279              /* start (in case of SW start):                                           */
   1280              
   1281              /* Clear regular group conversion flag and overrun flag */
   1282              /* (To ensure of no unknown state from potential previous ADC operations) */
   1283              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   00000080   0xF07F 0x0002      MVNS     R0,#+2
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
   1284          
   1285              /* Enable ADC overrun interrupt */
   1286              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6048             STR      R0,[R1, #+4]
   1287              
   1288              /* Enable ADC DMA mode */
   1289              hadc->Instance->CR2 |= ADC_CR2_DMA;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6088             STR      R0,[R1, #+8]
   1290              
   1291              /* Start the DMA channel */
   1292              HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
   \   000000A0   0x0033             MOVS     R3,R6
   \   000000A2   0x002A             MOVS     R2,R5
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0xF110 0x0158      ADDS     R1,R0,#+88
   \   000000AA   0x6C60             LDR      R0,[R4, #+68]
   \   000000AC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1293              
   1294              /* Enable conversion of regular group.                                    */
   1295              /* If software start has been selected, conversion starts immediately.    */
   1296              /* If external trigger has been selected, conversion will start at next   */
   1297              /* trigger event.                                                         */
   1298              /* Note: Alternate trigger for single conversion could be to force an     */
   1299              /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
   1300              if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6880             LDR      R0,[R0, #+8]
   \   000000B4   0xF010 0x5F40      TST      R0,#0x30000000
   \   000000B8   0xD105             BNE.N    ??HAL_ADC_Start_DMA_2
   1301              {
   1302                /* Start ADC conversion on regular group */
   1303                SET_BIT(hadc->Instance->CR2, ADC_CR2_SWSTART);
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6880             LDR      R0,[R0, #+8]
   \   000000BE   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6088             STR      R0,[R1, #+8]
   1304              }
   1305            }
   1306            
   1307            /* Return function status */
   1308            return tmp_hal_status;
   \                     ??HAL_ADC_Start_DMA_2: (+1)
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Start_DMA_1: (+1)
   \   000000CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1309          }
   1310          
   1311          /**
   1312            * @brief  Stop ADC conversion of regular group (and injected group in 
   1313            *         case of auto_injection mode), disable ADC DMA transfer, disable 
   1314            *         ADC peripheral.
   1315            * @note:  ADC peripheral disable is forcing stop of potential 
   1316            *         conversion on injected group. If injected group is under use, it
   1317            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
   1318            * @param  hadc: ADC handle
   1319            * @retval HAL status.
   1320            */

   \                                 In section .text, align 2, keep-with-next
   1321          HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
   1322          {
   \                     HAL_ADC_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1323            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1324            
   1325            /* Check the parameters */
   1326            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1327               
   1328            /* Process locked */
   1329            __HAL_LOCK(hadc);
   \   00000006   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADC_Stop_DMA_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE02C             B.N      ??HAL_ADC_Stop_DMA_1
   \                     ??HAL_ADC_Stop_DMA_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0048      STRB     R0,[R4, #+72]
   1330            
   1331            /* Stop potential conversion on going, on regular and injected groups */
   1332            /* Disable ADC peripheral */
   1333            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   0000001E   0x0005             MOVS     R5,R0
   1334            
   1335            /* Check if ADC is effectively disabled */
   1336            if (tmp_hal_status == HAL_OK)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD11D             BNE.N    ??HAL_ADC_Stop_DMA_2
   1337            {
   1338              /* Disable ADC DMA mode */
   1339              hadc->Instance->CR2 &= ~ADC_CR2_DMA;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6088             STR      R0,[R1, #+8]
   1340              
   1341              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
   1342              /* DMA transfer is on going)                                              */
   1343              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   \   00000032   0x6C60             LDR      R0,[R4, #+68]
   \   00000034   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000038   0x0005             MOVS     R5,R0
   1344              
   1345              /* Check if DMA channel effectively disabled */
   1346              if (tmp_hal_status == HAL_OK)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD106             BNE.N    ??HAL_ADC_Stop_DMA_3
   1347              {
   1348                /* Set ADC state */
   1349                ADC_STATE_CLR_SET(hadc->State,
   1350                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1351                                  HAL_ADC_STATE_READY);
   \   00000040   0x6CE0             LDR      R0,[R4, #+76]
   \   00000042   0xF430 0x5088      BICS     R0,R0,#0x1100
   \   00000046   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004A   0x64E0             STR      R0,[R4, #+76]
   \   0000004C   0xE003             B.N      ??HAL_ADC_Stop_DMA_4
   1352              }
   1353              else
   1354              {
   1355                /* Update ADC state machine to error */
   1356                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   \                     ??HAL_ADC_Stop_DMA_3: (+1)
   \   0000004E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000050   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000054   0x64E0             STR      R0,[R4, #+76]
   1357              }
   1358              
   1359              /* Disable ADC overrun interrupt */
   1360              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
   \                     ??HAL_ADC_Stop_DMA_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6048             STR      R0,[R1, #+4]
   1361            }
   1362            
   1363            /* Process unlocked */
   1364            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_DMA_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF884 0x0048      STRB     R0,[R4, #+72]
   1365            
   1366            /* Return function status */
   1367            return tmp_hal_status;
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_Stop_DMA_1: (+1)
   \   0000006C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1368          }
   1369          
   1370          /**
   1371            * @brief  Get ADC regular group conversion result.
   1372            * @note   Reading register DR automatically clears ADC flag EOC
   1373            *         (ADC group regular end of unitary conversion).
   1374            * @note   This function does not clear ADC flag EOS 
   1375            *         (ADC group regular end of sequence conversion).
   1376            *         Occurrence of flag EOS rising:
   1377            *          - If sequencer is composed of 1 rank, flag EOS is equivalent
   1378            *            to flag EOC.
   1379            *          - If sequencer is composed of several ranks, during the scan
   1380            *            sequence flag EOC only is raised, at the end of the scan sequence
   1381            *            both flags EOC and EOS are raised.
   1382            *         To clear this flag, either use function: 
   1383            *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
   1384            *         model polling: @ref HAL_ADC_PollForConversion() 
   1385            *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
   1386            * @param  hadc: ADC handle
   1387            * @retval ADC group regular conversion data
   1388            */

   \                                 In section .text, align 2, keep-with-next
   1389          uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
   1390          {
   1391            /* Check the parameters */
   1392            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1393          
   1394            /* Note: EOC flag is not cleared here by software because automatically     */
   1395            /*       cleared by hardware when reading register DR.                      */
   1396            
   1397            /* Return ADC converted value */ 
   1398            return hadc->Instance->DR;
   \                     HAL_ADC_GetValue: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6D80             LDR      R0,[R0, #+88]
   \   00000004   0x4770             BX       LR               ;; return
   1399          }
   1400          
   1401          /**
   1402            * @brief  Handles ADC interrupt request  
   1403            * @param  hadc: ADC handle
   1404            * @retval None
   1405            */

   \                                 In section .text, align 2, keep-with-next
   1406          void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
   1407          {
   \                     HAL_ADC_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1408            /* Check the parameters */
   1409            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1410            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1411            assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
   1412          
   1413            
   1414            /* ========== Check End of Conversion flag for regular group ========== */
   1415            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD534             BPL.N    ??HAL_ADC_IRQHandler_0
   1416            {
   1417              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD530             BPL.N    ??HAL_ADC_IRQHandler_0
   1418              {
   1419                /* Update state machine on conversion status if not in error state */
   1420                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \   00000014   0x6CE0             LDR      R0,[R4, #+76]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD403             BMI.N    ??HAL_ADC_IRQHandler_1
   1421                {
   1422                  /* Set ADC state */
   1423                  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
   \   0000001A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000001C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000020   0x64E0             STR      R0,[R4, #+76]
   1424                }
   1425          
   1426                /* Determine whether any further conversion upcoming on group regular   */
   1427                /* by external trigger, continuous mode or scan sequence on going.      */
   1428                /* Note: On STM32L1, there is no independent flag of end of sequence.   */
   1429                /*       The test of scan sequence on going is done either with scan    */
   1430                /*       sequence disabled or with end of conversion flag set to        */
   1431                /*       of end of sequence.                                            */
   1432                if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   1433                   (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1434                   (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   1435                    HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \                     ??HAL_ADC_IRQHandler_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0xF010 0x5F40      TST      R0,#0x30000000
   \   0000002A   0xD11D             BNE.N    ??HAL_ADC_IRQHandler_2
   \   0000002C   0x6A60             LDR      R0,[R4, #+36]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD11A             BNE.N    ??HAL_ADC_IRQHandler_2
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6B00             LDR      R0,[R0, #+48]
   \   00000036   0xF010 0x7FF8      TST      R0,#0x1F00000
   \   0000003A   0xD003             BEQ.N    ??HAL_ADC_IRQHandler_3
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6880             LDR      R0,[R0, #+8]
   \   00000040   0x0540             LSLS     R0,R0,#+21
   \   00000042   0xD411             BMI.N    ??HAL_ADC_IRQHandler_2
   1436                {
   1437                  /* Disable ADC end of single conversion interrupt on group regular */
   1438                  /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   1439                  /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   1440                  /* by overrun IRQ process below.                                      */
   1441                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??HAL_ADC_IRQHandler_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6840             LDR      R0,[R0, #+4]
   \   00000048   0xF07F 0x0120      MVNS     R1,#+32
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6048             STR      R0,[R1, #+4]
   1442                  
   1443                  /* Set ADC state */
   1444                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
   \   00000052   0x6CE0             LDR      R0,[R4, #+76]
   \   00000054   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000058   0x64E0             STR      R0,[R4, #+76]
   1445                  
   1446                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   0000005A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000005C   0x04C0             LSLS     R0,R0,#+19
   \   0000005E   0xD403             BMI.N    ??HAL_ADC_IRQHandler_2
   1447                  {
   1448                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   00000060   0x6CE0             LDR      R0,[R4, #+76]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x64E0             STR      R0,[R4, #+76]
   1449                  }
   1450                }
   1451          
   1452                /* Conversion complete callback */
   1453                HAL_ADC_ConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_2: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   1454                
   1455                /* Clear regular group conversion flag */
   1456                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \   0000006E   0xF07F 0x0012      MVNS     R0,#+18
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
   1457              }
   1458            }
   1459          
   1460            /* ========== Check End of Conversion flag for injected group ========== */
   1461            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
   \                     ??HAL_ADC_IRQHandler_0: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x0600             LSLS     R0,R0,#+24
   \   0000007C   0xD53D             BPL.N    ??HAL_ADC_IRQHandler_4
   1462            {
   1463              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x0740             LSLS     R0,R0,#+29
   \   00000084   0xD539             BPL.N    ??HAL_ADC_IRQHandler_4
   1464              {
   1465                /* Update state machine on conversion status if not in error state */
   1466                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \   00000086   0x6CE0             LDR      R0,[R4, #+76]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD403             BMI.N    ??HAL_ADC_IRQHandler_5
   1467                {
   1468                  /* Set ADC state */
   1469                  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \   0000008C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000008E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000092   0x64E0             STR      R0,[R4, #+76]
   1470                }
   1471          
   1472                /* Determine whether any further conversion upcoming on group injected  */
   1473                /* by external trigger, scan sequence on going or by automatic injected */
   1474                /* conversion from group regular (same conditions as group regular      */
   1475                /* interruption disabling above).                                       */
   1476                if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
   1477                   (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
   1478                    HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
   1479                   (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
   1480                    (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
   1481                    (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
   \                     ??HAL_ADC_IRQHandler_5: (+1)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0xF410 0x1F40      TST      R0,#0x300000
   \   0000009C   0xD126             BNE.N    ??HAL_ADC_IRQHandler_6
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6C40             LDR      R0,[R0, #+68]
   \   000000A2   0xF410 0x1F40      TST      R0,#0x300000
   \   000000A6   0xD003             BEQ.N    ??HAL_ADC_IRQHandler_7
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6880             LDR      R0,[R0, #+8]
   \   000000AC   0x0540             LSLS     R0,R0,#+21
   \   000000AE   0xD41D             BMI.N    ??HAL_ADC_IRQHandler_6
   \                     ??HAL_ADC_IRQHandler_7: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6840             LDR      R0,[R0, #+4]
   \   000000B4   0x0540             LSLS     R0,R0,#+21
   \   000000B6   0xD419             BMI.N    ??HAL_ADC_IRQHandler_6
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6880             LDR      R0,[R0, #+8]
   \   000000BC   0xF010 0x5F40      TST      R0,#0x30000000
   \   000000C0   0xD114             BNE.N    ??HAL_ADC_IRQHandler_6
   \   000000C2   0x6A60             LDR      R0,[R4, #+36]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD111             BNE.N    ??HAL_ADC_IRQHandler_6
   1482                {
   1483                  /* Disable ADC end of single conversion interrupt on group injected */
   1484                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0xF07F 0x0180      MVNS     R1,#+128
   \   000000D0   0x4008             ANDS     R0,R1,R0
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6048             STR      R0,[R1, #+4]
   1485                  
   1486                  /* Set ADC state */
   1487                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
   \   000000D6   0x6CE0             LDR      R0,[R4, #+76]
   \   000000D8   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   000000DC   0x64E0             STR      R0,[R4, #+76]
   1488          
   1489                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   000000DE   0x6CE0             LDR      R0,[R4, #+76]
   \   000000E0   0x05C0             LSLS     R0,R0,#+23
   \   000000E2   0xD403             BMI.N    ??HAL_ADC_IRQHandler_6
   1490                  { 
   1491                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   000000E4   0x6CE0             LDR      R0,[R4, #+76]
   \   000000E6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000EA   0x64E0             STR      R0,[R4, #+76]
   1492                  }
   1493                }
   1494          
   1495                /* Conversion complete callback */ 
   1496                HAL_ADCEx_InjectedConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_6: (+1)
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_ADCEx_InjectedConvCpltCallback
   1497                
   1498                /* Clear injected group conversion flag */
   1499                __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
   \   000000F2   0xF07F 0x000C      MVNS     R0,#+12
   \   000000F6   0x6821             LDR      R1,[R4, #+0]
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   1500              }
   1501            }
   1502             
   1503            /* ========== Check Analog watchdog flags ========== */
   1504            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
   \                     ??HAL_ADC_IRQHandler_4: (+1)
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6840             LDR      R0,[R0, #+4]
   \   000000FE   0x0640             LSLS     R0,R0,#+25
   \   00000100   0xD50E             BPL.N    ??HAL_ADC_IRQHandler_8
   1505            {
   1506              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x07C0             LSLS     R0,R0,#+31
   \   00000108   0xD50A             BPL.N    ??HAL_ADC_IRQHandler_8
   1507              {
   1508                /* Set ADC state */
   1509                SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \   0000010A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000010C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000110   0x64E0             STR      R0,[R4, #+76]
   1510                
   1511                /* Level out of window callback */ 
   1512                HAL_ADC_LevelOutOfWindowCallback(hadc);
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       HAL_ADC_LevelOutOfWindowCallback
   1513                
   1514                /* Clear the ADC analog watchdog flag */
   1515                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \   00000118   0xF07F 0x0001      MVNS     R0,#+1
   \   0000011C   0x6821             LDR      R1,[R4, #+0]
   \   0000011E   0x6008             STR      R0,[R1, #+0]
   1516              }
   1517            }
   1518            
   1519            /* ========== Check Overrun flag ========== */
   1520            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR))
   \                     ??HAL_ADC_IRQHandler_8: (+1)
   \   00000120   0x6820             LDR      R0,[R4, #+0]
   \   00000122   0x6840             LDR      R0,[R0, #+4]
   \   00000124   0x0140             LSLS     R0,R0,#+5
   \   00000126   0xD512             BPL.N    ??HAL_ADC_IRQHandler_9
   1521            {
   1522              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR))
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x0680             LSLS     R0,R0,#+26
   \   0000012E   0xD50E             BPL.N    ??HAL_ADC_IRQHandler_9
   1523              {
   1524                /* Note: On STM32L1, ADC overrun can be set through other parameters    */
   1525                /*       refer to description of parameter "EOCSelection" for more      */
   1526                /*       details.                                                       */
   1527                
   1528                /* Set ADC error code to overrun */
   1529                SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
   \   00000130   0x6D20             LDR      R0,[R4, #+80]
   \   00000132   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000136   0x6520             STR      R0,[R4, #+80]
   1530                
   1531                /* Clear ADC overrun flag */
   1532                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \   00000138   0xF07F 0x0020      MVNS     R0,#+32
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x6008             STR      R0,[R1, #+0]
   1533                
   1534                /* Error callback */ 
   1535                HAL_ADC_ErrorCallback(hadc);
   \   00000140   0x0020             MOVS     R0,R4
   \   00000142   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   1536                
   1537                /* Clear the Overrun flag */
   1538                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \   00000146   0xF07F 0x0020      MVNS     R0,#+32
   \   0000014A   0x6821             LDR      R1,[R4, #+0]
   \   0000014C   0x6008             STR      R0,[R1, #+0]
   1539              }
   1540            }
   1541            
   1542          }
   \                     ??HAL_ADC_IRQHandler_9: (+1)
   \   0000014E   0xBD10             POP      {R4,PC}          ;; return
   1543          
   1544          /**
   1545            * @brief  Conversion complete callback in non blocking mode 
   1546            * @param  hadc: ADC handle
   1547            * @retval None
   1548            */

   \                                 In section .text, align 2, keep-with-next
   1549          __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
   1550          {
   1551            /* Prevent unused argument(s) compilation warning */
   1552            UNUSED(hadc);
   1553          
   1554            /* NOTE : This function should not be modified. When the callback is needed,
   1555                      function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   1556             */
   1557          }
   \                     HAL_ADC_ConvCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1558          
   1559          /**
   1560            * @brief  Conversion DMA half-transfer callback in non blocking mode 
   1561            * @param  hadc: ADC handle
   1562            * @retval None
   1563            */

   \                                 In section .text, align 2, keep-with-next
   1564          __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
   1565          {
   1566            /* Prevent unused argument(s) compilation warning */
   1567            UNUSED(hadc);
   1568          
   1569            /* NOTE : This function should not be modified. When the callback is needed,
   1570                      function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
   1571            */
   1572          }
   \                     HAL_ADC_ConvHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1573          
   1574          /**
   1575            * @brief  Analog watchdog callback in non blocking mode. 
   1576            * @param  hadc: ADC handle
   1577            * @retval None
   1578            */

   \                                 In section .text, align 2, keep-with-next
   1579          __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
   1580          {
   1581            /* Prevent unused argument(s) compilation warning */
   1582            UNUSED(hadc);
   1583          
   1584            /* NOTE : This function should not be modified. When the callback is needed,
   1585                      function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
   1586            */
   1587          }
   \                     HAL_ADC_LevelOutOfWindowCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1588          
   1589          /**
   1590            * @brief  ADC error callback in non blocking mode
   1591            *        (ADC conversion with interruption or transfer by DMA)
   1592            * @param  hadc: ADC handle
   1593            * @retval None
   1594            */

   \                                 In section .text, align 2, keep-with-next
   1595          __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
   1596          {
   1597            /* Prevent unused argument(s) compilation warning */
   1598            UNUSED(hadc);
   1599          
   1600            /* NOTE : This function should not be modified. When the callback is needed,
   1601                      function HAL_ADC_ErrorCallback must be implemented in the user file.
   1602            */
   1603          }
   \                     HAL_ADC_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1604          
   1605          
   1606          /**
   1607            * @}
   1608            */
   1609          
   1610          /** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
   1611           *  @brief    Peripheral Control functions 
   1612           *
   1613          @verbatim   
   1614           ===============================================================================
   1615                       ##### Peripheral Control functions #####
   1616           ===============================================================================  
   1617              [..]  This section provides functions allowing to:
   1618                (+) Configure channels on regular group
   1619                (+) Configure the analog watchdog
   1620                
   1621          @endverbatim
   1622            * @{
   1623            */
   1624          
   1625          /**
   1626            * @brief  Configures the the selected channel to be linked to the regular
   1627            *         group.
   1628            * @note   In case of usage of internal measurement channels:
   1629            *         Vbat/VrefInt/TempSensor.
   1630            *         These internal paths can be be disabled using function 
   1631            *         HAL_ADC_DeInit().
   1632            * @note   Possibility to update parameters on the fly:
   1633            *         This function initializes channel into regular group, following  
   1634            *         calls to this function can be used to reconfigure some parameters 
   1635            *         of structure "ADC_ChannelConfTypeDef" on the fly, without reseting 
   1636            *         the ADC.
   1637            *         The setting of these parameters is conditioned to ADC state.
   1638            *         For parameters constraints, see comments of structure 
   1639            *         "ADC_ChannelConfTypeDef".
   1640            * @param  hadc: ADC handle
   1641            * @param  sConfig: Structure of ADC channel for regular group.
   1642            * @retval HAL status
   1643            */

   \                                 In section .text, align 2, keep-with-next
   1644          HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
   1645          {
   \                     HAL_ADC_ConfigChannel: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   \   00000002   0x0002             MOVS     R2,R0
   1646            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2300             MOVS     R3,#+0
   1647            __IO uint32_t wait_loop_index = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1648            
   1649            /* Check the parameters */
   1650            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1651            assert_param(IS_ADC_CHANNEL(sConfig->Channel));
   1652            assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
   1653            assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
   1654            
   1655            /* Process locked */
   1656            __HAL_LOCK(hadc);
   \   0000000A   0xF892 0x0048      LDRB     R0,[R2, #+72]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_ADC_ConfigChannel_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE0E5             B.N      ??HAL_ADC_ConfigChannel_1
   \                     ??HAL_ADC_ConfigChannel_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF882 0x0048      STRB     R0,[R2, #+72]
   1657            
   1658             
   1659            /* Regular sequence configuration */
   1660            /* For Rank 1 to 6 */
   1661            if (sConfig->Rank < 7)
   \   0000001C   0x6848             LDR      R0,[R1, #+4]
   \   0000001E   0x2807             CMP      R0,#+7
   \   00000020   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_2
   1662            {
   1663              MODIFY_REG(hadc->Instance->SQR5,
   1664                         ADC_SQR5_RK(ADC_SQR5_SQ1, sConfig->Rank),
   1665                         ADC_SQR5_RK(sConfig->Channel, sConfig->Rank) );
   \   00000022   0x6810             LDR      R0,[R2, #+0]
   \   00000024   0x6C00             LDR      R0,[R0, #+64]
   \   00000026   0x241F             MOVS     R4,#+31
   \   00000028   0x684D             LDR      R5,[R1, #+4]
   \   0000002A   0x1E6D             SUBS     R5,R5,#+1
   \   0000002C   0x2605             MOVS     R6,#+5
   \   0000002E   0x4375             MULS     R5,R6,R5
   \   00000030   0x40AC             LSLS     R4,R4,R5
   \   00000032   0x43A0             BICS     R0,R0,R4
   \   00000034   0x680C             LDR      R4,[R1, #+0]
   \   00000036   0x684D             LDR      R5,[R1, #+4]
   \   00000038   0x1E6D             SUBS     R5,R5,#+1
   \   0000003A   0x2605             MOVS     R6,#+5
   \   0000003C   0x4375             MULS     R5,R6,R5
   \   0000003E   0x40AC             LSLS     R4,R4,R5
   \   00000040   0x4320             ORRS     R0,R4,R0
   \   00000042   0x6814             LDR      R4,[R2, #+0]
   \   00000044   0x6420             STR      R0,[R4, #+64]
   \   00000046   0xE053             B.N      ??HAL_ADC_ConfigChannel_3
   1666            }
   1667            /* For Rank 7 to 12 */
   1668            else if (sConfig->Rank < 13)
   \                     ??HAL_ADC_ConfigChannel_2: (+1)
   \   00000048   0x6848             LDR      R0,[R1, #+4]
   \   0000004A   0x280D             CMP      R0,#+13
   \   0000004C   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_4
   1669            {
   1670              MODIFY_REG(hadc->Instance->SQR4,
   1671                         ADC_SQR4_RK(ADC_SQR4_SQ7, sConfig->Rank),
   1672                         ADC_SQR4_RK(sConfig->Channel, sConfig->Rank) );
   \   0000004E   0x6810             LDR      R0,[R2, #+0]
   \   00000050   0x6BC0             LDR      R0,[R0, #+60]
   \   00000052   0x241F             MOVS     R4,#+31
   \   00000054   0x684D             LDR      R5,[R1, #+4]
   \   00000056   0x1FED             SUBS     R5,R5,#+7
   \   00000058   0x2605             MOVS     R6,#+5
   \   0000005A   0x4375             MULS     R5,R6,R5
   \   0000005C   0x40AC             LSLS     R4,R4,R5
   \   0000005E   0x43A0             BICS     R0,R0,R4
   \   00000060   0x680C             LDR      R4,[R1, #+0]
   \   00000062   0x684D             LDR      R5,[R1, #+4]
   \   00000064   0x1FED             SUBS     R5,R5,#+7
   \   00000066   0x2605             MOVS     R6,#+5
   \   00000068   0x4375             MULS     R5,R6,R5
   \   0000006A   0x40AC             LSLS     R4,R4,R5
   \   0000006C   0x4320             ORRS     R0,R4,R0
   \   0000006E   0x6814             LDR      R4,[R2, #+0]
   \   00000070   0x63E0             STR      R0,[R4, #+60]
   \   00000072   0xE03D             B.N      ??HAL_ADC_ConfigChannel_3
   1673            }
   1674            /* For Rank 13 to 18 */
   1675            else if (sConfig->Rank < 19)
   \                     ??HAL_ADC_ConfigChannel_4: (+1)
   \   00000074   0x6848             LDR      R0,[R1, #+4]
   \   00000076   0x2813             CMP      R0,#+19
   \   00000078   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_5
   1676            {
   1677              MODIFY_REG(hadc->Instance->SQR3,
   1678                         ADC_SQR3_RK(ADC_SQR3_SQ13, sConfig->Rank),
   1679                         ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
   \   0000007A   0x6810             LDR      R0,[R2, #+0]
   \   0000007C   0x6B80             LDR      R0,[R0, #+56]
   \   0000007E   0x241F             MOVS     R4,#+31
   \   00000080   0x684D             LDR      R5,[R1, #+4]
   \   00000082   0x3D0D             SUBS     R5,R5,#+13
   \   00000084   0x2605             MOVS     R6,#+5
   \   00000086   0x4375             MULS     R5,R6,R5
   \   00000088   0x40AC             LSLS     R4,R4,R5
   \   0000008A   0x43A0             BICS     R0,R0,R4
   \   0000008C   0x680C             LDR      R4,[R1, #+0]
   \   0000008E   0x684D             LDR      R5,[R1, #+4]
   \   00000090   0x3D0D             SUBS     R5,R5,#+13
   \   00000092   0x2605             MOVS     R6,#+5
   \   00000094   0x4375             MULS     R5,R6,R5
   \   00000096   0x40AC             LSLS     R4,R4,R5
   \   00000098   0x4320             ORRS     R0,R4,R0
   \   0000009A   0x6814             LDR      R4,[R2, #+0]
   \   0000009C   0x63A0             STR      R0,[R4, #+56]
   \   0000009E   0xE027             B.N      ??HAL_ADC_ConfigChannel_3
   1680            }
   1681            /* For Rank 19 to 24 */
   1682            else if (sConfig->Rank < 25)
   \                     ??HAL_ADC_ConfigChannel_5: (+1)
   \   000000A0   0x6848             LDR      R0,[R1, #+4]
   \   000000A2   0x2819             CMP      R0,#+25
   \   000000A4   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_6
   1683            {
   1684              MODIFY_REG(hadc->Instance->SQR2,
   1685                         ADC_SQR2_RK(ADC_SQR2_SQ19, sConfig->Rank),
   1686                         ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
   \   000000A6   0x6810             LDR      R0,[R2, #+0]
   \   000000A8   0x6B40             LDR      R0,[R0, #+52]
   \   000000AA   0x241F             MOVS     R4,#+31
   \   000000AC   0x684D             LDR      R5,[R1, #+4]
   \   000000AE   0x3D13             SUBS     R5,R5,#+19
   \   000000B0   0x2605             MOVS     R6,#+5
   \   000000B2   0x4375             MULS     R5,R6,R5
   \   000000B4   0x40AC             LSLS     R4,R4,R5
   \   000000B6   0x43A0             BICS     R0,R0,R4
   \   000000B8   0x680C             LDR      R4,[R1, #+0]
   \   000000BA   0x684D             LDR      R5,[R1, #+4]
   \   000000BC   0x3D13             SUBS     R5,R5,#+19
   \   000000BE   0x2605             MOVS     R6,#+5
   \   000000C0   0x4375             MULS     R5,R6,R5
   \   000000C2   0x40AC             LSLS     R4,R4,R5
   \   000000C4   0x4320             ORRS     R0,R4,R0
   \   000000C6   0x6814             LDR      R4,[R2, #+0]
   \   000000C8   0x6360             STR      R0,[R4, #+52]
   \   000000CA   0xE011             B.N      ??HAL_ADC_ConfigChannel_3
   1687            }
   1688            /* For Rank 25 to 28 */
   1689            else
   1690            {
   1691              MODIFY_REG(hadc->Instance->SQR1,
   1692                         ADC_SQR1_RK(ADC_SQR1_SQ25, sConfig->Rank),
   1693                         ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
   \                     ??HAL_ADC_ConfigChannel_6: (+1)
   \   000000CC   0x6810             LDR      R0,[R2, #+0]
   \   000000CE   0x6B00             LDR      R0,[R0, #+48]
   \   000000D0   0x241F             MOVS     R4,#+31
   \   000000D2   0x684D             LDR      R5,[R1, #+4]
   \   000000D4   0x3D19             SUBS     R5,R5,#+25
   \   000000D6   0x2605             MOVS     R6,#+5
   \   000000D8   0x4375             MULS     R5,R6,R5
   \   000000DA   0x40AC             LSLS     R4,R4,R5
   \   000000DC   0x43A0             BICS     R0,R0,R4
   \   000000DE   0x680C             LDR      R4,[R1, #+0]
   \   000000E0   0x684D             LDR      R5,[R1, #+4]
   \   000000E2   0x3D19             SUBS     R5,R5,#+25
   \   000000E4   0x2605             MOVS     R6,#+5
   \   000000E6   0x4375             MULS     R5,R6,R5
   \   000000E8   0x40AC             LSLS     R4,R4,R5
   \   000000EA   0x4320             ORRS     R0,R4,R0
   \   000000EC   0x6814             LDR      R4,[R2, #+0]
   \   000000EE   0x6320             STR      R0,[R4, #+48]
   1694            }
   1695            
   1696            
   1697            /* Channel sampling time configuration */
   1698            /* For channels 0 to 9 */
   1699            if (sConfig->Channel < ADC_CHANNEL_10)
   \                     ??HAL_ADC_ConfigChannel_3: (+1)
   \   000000F0   0x6808             LDR      R0,[R1, #+0]
   \   000000F2   0x280A             CMP      R0,#+10
   \   000000F4   0xD210             BCS.N    ??HAL_ADC_ConfigChannel_7
   1700            {
   1701              MODIFY_REG(hadc->Instance->SMPR3,
   1702                         ADC_SMPR3(ADC_SMPR3_SMP0, sConfig->Channel),
   1703                         ADC_SMPR3(sConfig->SamplingTime, sConfig->Channel) );
   \   000000F6   0x6810             LDR      R0,[R2, #+0]
   \   000000F8   0x6940             LDR      R0,[R0, #+20]
   \   000000FA   0x2407             MOVS     R4,#+7
   \   000000FC   0x680D             LDR      R5,[R1, #+0]
   \   000000FE   0x2603             MOVS     R6,#+3
   \   00000100   0x4375             MULS     R5,R6,R5
   \   00000102   0x40AC             LSLS     R4,R4,R5
   \   00000104   0x43A0             BICS     R0,R0,R4
   \   00000106   0x688C             LDR      R4,[R1, #+8]
   \   00000108   0x680D             LDR      R5,[R1, #+0]
   \   0000010A   0x2603             MOVS     R6,#+3
   \   0000010C   0x4375             MULS     R5,R6,R5
   \   0000010E   0x40AC             LSLS     R4,R4,R5
   \   00000110   0x4320             ORRS     R0,R4,R0
   \   00000112   0x6814             LDR      R4,[R2, #+0]
   \   00000114   0x6160             STR      R0,[R4, #+20]
   \   00000116   0xE03D             B.N      ??HAL_ADC_ConfigChannel_8
   1704            }
   1705            /* For channels 10 to 19 */
   1706            else if (sConfig->Channel < ADC_CHANNEL_20)
   \                     ??HAL_ADC_ConfigChannel_7: (+1)
   \   00000118   0x6808             LDR      R0,[R1, #+0]
   \   0000011A   0x2814             CMP      R0,#+20
   \   0000011C   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_9
   1707            {
   1708              MODIFY_REG(hadc->Instance->SMPR2,
   1709                         ADC_SMPR2(ADC_SMPR2_SMP10, sConfig->Channel),
   1710                         ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
   \   0000011E   0x6810             LDR      R0,[R2, #+0]
   \   00000120   0x6900             LDR      R0,[R0, #+16]
   \   00000122   0x2407             MOVS     R4,#+7
   \   00000124   0x680D             LDR      R5,[R1, #+0]
   \   00000126   0x3D0A             SUBS     R5,R5,#+10
   \   00000128   0x2603             MOVS     R6,#+3
   \   0000012A   0x4375             MULS     R5,R6,R5
   \   0000012C   0x40AC             LSLS     R4,R4,R5
   \   0000012E   0x43A0             BICS     R0,R0,R4
   \   00000130   0x688C             LDR      R4,[R1, #+8]
   \   00000132   0x680D             LDR      R5,[R1, #+0]
   \   00000134   0x3D0A             SUBS     R5,R5,#+10
   \   00000136   0x2603             MOVS     R6,#+3
   \   00000138   0x4375             MULS     R5,R6,R5
   \   0000013A   0x40AC             LSLS     R4,R4,R5
   \   0000013C   0x4320             ORRS     R0,R4,R0
   \   0000013E   0x6814             LDR      R4,[R2, #+0]
   \   00000140   0x6120             STR      R0,[R4, #+16]
   \   00000142   0xE027             B.N      ??HAL_ADC_ConfigChannel_8
   1711            }
   1712            /* For channels 20 to 26 for devices Cat.1, Cat.2, Cat.3 */
   1713            /* For channels 20 to 29 for devices Cat4, Cat.5 */
   1714            else if (sConfig->Channel <= ADC_SMPR1_CHANNEL_MAX)
   \                     ??HAL_ADC_ConfigChannel_9: (+1)
   \   00000144   0x6808             LDR      R0,[R1, #+0]
   \   00000146   0x281E             CMP      R0,#+30
   \   00000148   0xD212             BCS.N    ??HAL_ADC_ConfigChannel_10
   1715            {
   1716              MODIFY_REG(hadc->Instance->SMPR1,
   1717                         ADC_SMPR1(ADC_SMPR1_SMP20, sConfig->Channel),
   1718                         ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
   \   0000014A   0x6810             LDR      R0,[R2, #+0]
   \   0000014C   0x68C0             LDR      R0,[R0, #+12]
   \   0000014E   0x2407             MOVS     R4,#+7
   \   00000150   0x680D             LDR      R5,[R1, #+0]
   \   00000152   0x3D14             SUBS     R5,R5,#+20
   \   00000154   0x2603             MOVS     R6,#+3
   \   00000156   0x4375             MULS     R5,R6,R5
   \   00000158   0x40AC             LSLS     R4,R4,R5
   \   0000015A   0x43A0             BICS     R0,R0,R4
   \   0000015C   0x688C             LDR      R4,[R1, #+8]
   \   0000015E   0x680D             LDR      R5,[R1, #+0]
   \   00000160   0x3D14             SUBS     R5,R5,#+20
   \   00000162   0x2603             MOVS     R6,#+3
   \   00000164   0x4375             MULS     R5,R6,R5
   \   00000166   0x40AC             LSLS     R4,R4,R5
   \   00000168   0x4320             ORRS     R0,R4,R0
   \   0000016A   0x6814             LDR      R4,[R2, #+0]
   \   0000016C   0x60E0             STR      R0,[R4, #+12]
   \   0000016E   0xE011             B.N      ??HAL_ADC_ConfigChannel_8
   1719            }
   1720            /* For channels 30 to 31 for devices Cat4, Cat.5 */
   1721            else
   1722            {
   1723              ADC_SMPR0_CHANNEL_SET(hadc, sConfig->SamplingTime, sConfig->Channel);
   \                     ??HAL_ADC_ConfigChannel_10: (+1)
   \   00000170   0x6810             LDR      R0,[R2, #+0]
   \   00000172   0x6DC0             LDR      R0,[R0, #+92]
   \   00000174   0x2407             MOVS     R4,#+7
   \   00000176   0x680D             LDR      R5,[R1, #+0]
   \   00000178   0x3D1E             SUBS     R5,R5,#+30
   \   0000017A   0x2603             MOVS     R6,#+3
   \   0000017C   0x4375             MULS     R5,R6,R5
   \   0000017E   0x40AC             LSLS     R4,R4,R5
   \   00000180   0x43A0             BICS     R0,R0,R4
   \   00000182   0x688C             LDR      R4,[R1, #+8]
   \   00000184   0x680D             LDR      R5,[R1, #+0]
   \   00000186   0x3D1E             SUBS     R5,R5,#+30
   \   00000188   0x2603             MOVS     R6,#+3
   \   0000018A   0x4375             MULS     R5,R6,R5
   \   0000018C   0x40AC             LSLS     R4,R4,R5
   \   0000018E   0x4320             ORRS     R0,R4,R0
   \   00000190   0x6814             LDR      R4,[R2, #+0]
   \   00000192   0x65E0             STR      R0,[R4, #+92]
   1724            }
   1725          
   1726            /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
   1727            /* and VREFINT measurement path.                                            */
   1728            if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
   1729                (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
   \                     ??HAL_ADC_ConfigChannel_8: (+1)
   \   00000194   0x6808             LDR      R0,[R1, #+0]
   \   00000196   0x2810             CMP      R0,#+16
   \   00000198   0xD002             BEQ.N    ??HAL_ADC_ConfigChannel_11
   \   0000019A   0x6808             LDR      R0,[R1, #+0]
   \   0000019C   0x2811             CMP      R0,#+17
   \   0000019E   0xD11B             BNE.N    ??HAL_ADC_ConfigChannel_12
   1730            {
   1731                if (READ_BIT(ADC->CCR, ADC_CCR_TSVREFE) == RESET)
   \                     ??HAL_ADC_ConfigChannel_11: (+1)
   \   000001A0   0x....             LDR.N    R0,??DataTable7_1  ;; 0x40012704
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0x0200             LSLS     R0,R0,#+8
   \   000001A6   0xD417             BMI.N    ??HAL_ADC_ConfigChannel_12
   1732                {
   1733                  SET_BIT(ADC->CCR, ADC_CCR_TSVREFE);
   \   000001A8   0x....             LDR.N    R0,??DataTable7_1  ;; 0x40012704
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   000001B0   0x....             LDR.N    R4,??DataTable7_1  ;; 0x40012704
   \   000001B2   0x6020             STR      R0,[R4, #+0]
   1734                  
   1735                  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
   \   000001B4   0x6808             LDR      R0,[R1, #+0]
   \   000001B6   0x2810             CMP      R0,#+16
   \   000001B8   0xD10E             BNE.N    ??HAL_ADC_ConfigChannel_12
   1736                  {
   1737                    /* Delay for temperature sensor stabilization time */
   1738                    /* Compute number of CPU cycles to wait for */
   1739                    wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
   \   000001BA   0x....             LDR.N    R0,??DataTable7_8
   \   000001BC   0x6800             LDR      R0,[R0, #+0]
   \   000001BE   0x....             LDR.N    R4,??DataTable7_9  ;; 0xf4240
   \   000001C0   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   000001C4   0x240A             MOVS     R4,#+10
   \   000001C6   0x4360             MULS     R0,R4,R0
   \   000001C8   0x9000             STR      R0,[SP, #+0]
   1740                    while(wait_loop_index != 0)
   \                     ??HAL_ADC_ConfigChannel_13: (+1)
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD003             BEQ.N    ??HAL_ADC_ConfigChannel_12
   1741                    {
   1742                      wait_loop_index--;
   \   000001D0   0x9800             LDR      R0,[SP, #+0]
   \   000001D2   0x1E40             SUBS     R0,R0,#+1
   \   000001D4   0x9000             STR      R0,[SP, #+0]
   \   000001D6   0xE7F8             B.N      ??HAL_ADC_ConfigChannel_13
   1743                    }
   1744                  }
   1745              }
   1746            }
   1747            
   1748            /* Process unlocked */
   1749            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_ConfigChannel_12: (+1)
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0xF882 0x0048      STRB     R0,[R2, #+72]
   1750            
   1751            /* Return function status */
   1752            return tmp_hal_status;
   \   000001DE   0x0018             MOVS     R0,R3
   \   000001E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_ADC_ConfigChannel_1: (+1)
   \   000001E2   0xBC72             POP      {R1,R4-R6}
   \   000001E4   0x4770             BX       LR               ;; return
   1753          }
   1754          
   1755          /**
   1756            * @brief  Configures the analog watchdog.
   1757            * @note   Analog watchdog thresholds can be modified while ADC conversion
   1758            *         is on going.
   1759            *         In this case, some constraints must be taken into account:
   1760            *         the programmed threshold values are effective from the next
   1761            *         ADC EOC (end of unitary conversion).
   1762            *         Considering that registers write delay may happen due to
   1763            *         bus activity, this might cause an uncertainty on the
   1764            *         effective timing of the new programmed threshold values.
   1765            * @param  hadc: ADC handle
   1766            * @param  AnalogWDGConfig: Structure of ADC analog watchdog configuration
   1767            * @retval HAL status
   1768            */

   \                                 In section .text, align 2, keep-with-next
   1769          HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
   1770          {
   \                     HAL_ADC_AnalogWDGConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
   1771            /* Check the parameters */
   1772            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1773            assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
   1774            assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
   1775            assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, AnalogWDGConfig->HighThreshold));
   1776            assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, AnalogWDGConfig->LowThreshold));
   1777            
   1778            if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
   1779               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
   1780               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x....             LDR.N    R3,??DataTable7_10  ;; 0x800200
   \   00000008   0x4298             CMP      R0,R3
   \   0000000A   0xD007             BEQ.N    ??HAL_ADC_AnalogWDGConfig_0
   \   0000000C   0x6808             LDR      R0,[R1, #+0]
   \   0000000E   0x....             LDR.N    R3,??DataTable7_11  ;; 0x400200
   \   00000010   0x4298             CMP      R0,R3
   \   00000012   0xD003             BEQ.N    ??HAL_ADC_AnalogWDGConfig_0
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x....             LDR.N    R3,??DataTable7_12  ;; 0xc00200
   \   00000018   0x4298             CMP      R0,R3
   \   0000001A   0xD1FF             BNE.N    ??HAL_ADC_AnalogWDGConfig_1
   1781            {
   1782              assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
   1783            }
   1784            
   1785            /* Process locked */
   1786            __HAL_LOCK(hadc);
   \                     ??HAL_ADC_AnalogWDGConfig_0: (+1)
   \                     ??HAL_ADC_AnalogWDGConfig_1: (+1)
   \   0000001C   0xF892 0x0048      LDRB     R0,[R2, #+72]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD101             BNE.N    ??HAL_ADC_AnalogWDGConfig_2
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE02B             B.N      ??HAL_ADC_AnalogWDGConfig_3
   \                     ??HAL_ADC_AnalogWDGConfig_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF882 0x0048      STRB     R0,[R2, #+72]
   1787            
   1788            /* Analog watchdog configuration */
   1789          
   1790            /* Configure ADC Analog watchdog interrupt */
   1791            if(AnalogWDGConfig->ITMode == ENABLE)
   \   0000002E   0x6888             LDR      R0,[R1, #+8]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD106             BNE.N    ??HAL_ADC_AnalogWDGConfig_4
   1792            {
   1793              /* Enable the ADC Analog watchdog interrupt */
   1794              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
   \   00000034   0x6810             LDR      R0,[R2, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003C   0x6813             LDR      R3,[R2, #+0]
   \   0000003E   0x6058             STR      R0,[R3, #+4]
   \   00000040   0xE006             B.N      ??HAL_ADC_AnalogWDGConfig_5
   1795            }
   1796            else
   1797            {
   1798              /* Disable the ADC Analog watchdog interrupt */
   1799              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
   \                     ??HAL_ADC_AnalogWDGConfig_4: (+1)
   \   00000042   0x6810             LDR      R0,[R2, #+0]
   \   00000044   0x6840             LDR      R0,[R0, #+4]
   \   00000046   0xF07F 0x0340      MVNS     R3,#+64
   \   0000004A   0x4018             ANDS     R0,R3,R0
   \   0000004C   0x6813             LDR      R3,[R2, #+0]
   \   0000004E   0x6058             STR      R0,[R3, #+4]
   1800            }
   1801            
   1802            /* Configuration of analog watchdog:                                        */
   1803            /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
   1804            /*    one or all channels.                                                  */
   1805            /*  - Set the Analog watchdog channel (is not used if watchdog              */
   1806            /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
   1807            hadc->Instance->CR1 &= ~( ADC_CR1_AWDSGL |
   1808                                      ADC_CR1_JAWDEN |
   1809                                      ADC_CR1_AWDEN  |
   1810                                      ADC_CR1_AWDCH   );
   \                     ??HAL_ADC_AnalogWDGConfig_5: (+1)
   \   00000050   0x6810             LDR      R0,[R2, #+0]
   \   00000052   0x6840             LDR      R0,[R0, #+4]
   \   00000054   0x....             LDR.N    R3,??DataTable7_13  ;; 0xff3ffde0
   \   00000056   0x4018             ANDS     R0,R3,R0
   \   00000058   0x6813             LDR      R3,[R2, #+0]
   \   0000005A   0x6058             STR      R0,[R3, #+4]
   1811            
   1812            hadc->Instance->CR1 |= ( AnalogWDGConfig->WatchdogMode |
   1813                                     AnalogWDGConfig->Channel       );
   \   0000005C   0x6810             LDR      R0,[R2, #+0]
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x680B             LDR      R3,[R1, #+0]
   \   00000062   0x684C             LDR      R4,[R1, #+4]
   \   00000064   0x4323             ORRS     R3,R4,R3
   \   00000066   0x4318             ORRS     R0,R3,R0
   \   00000068   0x6813             LDR      R3,[R2, #+0]
   \   0000006A   0x6058             STR      R0,[R3, #+4]
   1814                
   1815            /* Set the high threshold */
   1816            hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
   \   0000006C   0x68C8             LDR      R0,[R1, #+12]
   \   0000006E   0x6813             LDR      R3,[R2, #+0]
   \   00000070   0x6298             STR      R0,[R3, #+40]
   1817            
   1818            /* Set the low threshold */
   1819            hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
   \   00000072   0x6908             LDR      R0,[R1, #+16]
   \   00000074   0x6813             LDR      R3,[R2, #+0]
   \   00000076   0x62D8             STR      R0,[R3, #+44]
   1820          
   1821            /* Process unlocked */
   1822            __HAL_UNLOCK(hadc);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF882 0x0048      STRB     R0,[R2, #+72]
   1823            
   1824            /* Return function status */
   1825            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_AnalogWDGConfig_3: (+1)
   \   00000080   0xBC10             POP      {R4}
   \   00000082   0x4770             BX       LR               ;; return
   1826          }
   1827          
   1828          
   1829          /**
   1830            * @}
   1831            */
   1832          
   1833          
   1834          /** @defgroup ADC_Exported_Functions_Group4 Peripheral State functions
   1835           *  @brief    Peripheral State functions
   1836           *
   1837          @verbatim
   1838           ===============================================================================
   1839                      ##### Peripheral State and Errors functions #####
   1840           ===============================================================================  
   1841              [..]
   1842              This subsection provides functions to get in run-time the status of the  
   1843              peripheral.
   1844                (+) Check the ADC state
   1845                (+) Check the ADC error code
   1846          
   1847          @endverbatim
   1848            * @{
   1849            */
   1850          
   1851          /**
   1852            * @brief  return the ADC state
   1853            * @param  hadc: ADC handle
   1854            * @retval HAL state
   1855            */

   \                                 In section .text, align 2, keep-with-next
   1856          uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
   1857          {
   1858            /* Return ADC state */
   1859            return hadc->State;
   \                     HAL_ADC_GetState: (+1)
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0x4770             BX       LR               ;; return
   1860          }
   1861          
   1862          /**
   1863            * @brief  Return the ADC error code
   1864            * @param  hadc: ADC handle
   1865            * @retval ADC Error Code
   1866            */

   \                                 In section .text, align 2, keep-with-next
   1867          uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
   1868          {
   1869            return hadc->ErrorCode;
   \                     HAL_ADC_GetError: (+1)
   \   00000000   0x6D00             LDR      R0,[R0, #+80]
   \   00000002   0x4770             BX       LR               ;; return
   1870          }
   1871          
   1872          /**
   1873            * @}
   1874            */
   1875          
   1876          /**
   1877            * @}
   1878            */
   1879          
   1880          /** @defgroup ADC_Private_Functions ADC Private Functions
   1881            * @{
   1882            */
   1883          
   1884          /**
   1885            * @brief  Enable the selected ADC.
   1886            * @note   Prerequisite condition to use this function: ADC must be disabled
   1887            *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
   1888            * @note   If low power mode AutoPowerOff is enabled, power-on/off phases are
   1889            *         performed automatically by hardware.
   1890            *         In this mode, this function is useless and must not be called because 
   1891            *         flag ADC_FLAG_RDY is not usable.
   1892            *         Therefore, this function must be called under condition of
   1893            *         "if (hadc->Init.LowPowerAutoPowerOff != ENABLE)".
   1894            * @param  hadc: ADC handle
   1895            * @retval HAL status.
   1896            */

   \                                 In section .text, align 2, keep-with-next
   1897          HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
   1898          {
   \                     ADC_Enable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1899            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1900            __IO uint32_t wait_loop_index = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1901            
   1902            /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
   1903            /* enabling phase not yet completed: flag ADC ready not yet set).           */
   1904            /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
   1905            /* causes: ADC clock not running, ...).                                     */
   1906            if (ADC_IS_ENABLE(hadc) == RESET)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0640             LSLS     R0,R0,#+25
   \   00000010   0xD42D             BMI.N    ??ADC_Enable_0
   1907            {
   1908              /* Enable the Peripheral */
   1909              __HAL_ADC_ENABLE(hadc);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6088             STR      R0,[R1, #+8]
   1910              
   1911              /* Delay for ADC stabilization time */
   1912              /* Compute number of CPU cycles to wait for */
   1913              wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
   \   0000001E   0x....             LDR.N    R0,??DataTable7_8
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x....             LDR.N    R1,??DataTable7_9  ;; 0xf4240
   \   00000024   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000028   0x2103             MOVS     R1,#+3
   \   0000002A   0x4348             MULS     R0,R1,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   1914              while(wait_loop_index != 0)
   \                     ??ADC_Enable_1: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??ADC_Enable_2
   1915              {
   1916                wait_loop_index--;
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0xE7F8             B.N      ??ADC_Enable_1
   1917              }
   1918              
   1919              /* Get tick count */
   1920              tickstart = HAL_GetTick();    
   \                     ??ADC_Enable_2: (+1)
   \   0000003C   0x.... 0x....      BL       HAL_GetTick
   \   00000040   0x0005             MOVS     R5,R0
   1921          
   1922              /* Wait for ADC effectively enabled */
   1923              while(ADC_IS_ENABLE(hadc) == RESET)
   \                     ??ADC_Enable_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0640             LSLS     R0,R0,#+25
   \   00000048   0xD411             BMI.N    ??ADC_Enable_0
   1924              {
   1925                if((HAL_GetTick() - tickstart ) > ADC_ENABLE_TIMEOUT)
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x1B40             SUBS     R0,R0,R5
   \   00000050   0x2803             CMP      R0,#+3
   \   00000052   0xD3F6             BCC.N    ??ADC_Enable_3
   1926                {
   1927                  /* Update ADC state machine to error */
   1928                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   \   00000054   0x6CE0             LDR      R0,[R4, #+76]
   \   00000056   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005A   0x64E0             STR      R0,[R4, #+76]
   1929                
   1930                  /* Set ADC error code to ADC IP internal error */
   1931                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   0000005C   0x6D20             LDR      R0,[R4, #+80]
   \   0000005E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000062   0x6520             STR      R0,[R4, #+80]
   1932                  
   1933                  /* Process unlocked */
   1934                  __HAL_UNLOCK(hadc);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x0048      STRB     R0,[R4, #+72]
   1935                
   1936                  return HAL_ERROR;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE000             B.N      ??ADC_Enable_4
   1937                }
   1938              }
   1939            }
   1940             
   1941            /* Return HAL status */
   1942            return HAL_OK;
   \                     ??ADC_Enable_0: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??ADC_Enable_4: (+1)
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1943          }
   1944          
   1945          /**
   1946            * @brief  Stop ADC conversion and disable the selected ADC
   1947            * @note   Prerequisite condition to use this function: ADC conversions must be
   1948            *         stopped to disable the ADC.
   1949            * @param  hadc: ADC handle
   1950            * @retval HAL status.
   1951            */

   \                                 In section .text, align 2, keep-with-next
   1952          HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
   1953          {
   \                     ADC_ConversionStop_Disable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1954            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1955            
   1956            /* Verification if ADC is not already disabled */
   1957            if (ADC_IS_ENABLE(hadc) != RESET)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0640             LSLS     R0,R0,#+25
   \   0000000C   0xD51B             BPL.N    ??ADC_ConversionStop_Disable_0
   1958            {
   1959              /* Disable the ADC peripheral */
   1960              __HAL_ADC_DISABLE(hadc);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x0840             LSRS     R0,R0,#+1
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x6088             STR      R0,[R1, #+8]
   1961               
   1962              /* Get tick count */
   1963              tickstart = HAL_GetTick();
   \   0000001A   0x.... 0x....      BL       HAL_GetTick
   \   0000001E   0x0005             MOVS     R5,R0
   1964              
   1965              /* Wait for ADC effectively disabled */    
   1966              while(ADC_IS_ENABLE(hadc) != RESET)
   \                     ??ADC_ConversionStop_Disable_1: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0640             LSLS     R0,R0,#+25
   \   00000026   0xD50E             BPL.N    ??ADC_ConversionStop_Disable_0
   1967              {
   1968                if((HAL_GetTick() - tickstart ) > ADC_DISABLE_TIMEOUT)
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B40             SUBS     R0,R0,R5
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD3F6             BCC.N    ??ADC_ConversionStop_Disable_1
   1969                {
   1970                  /* Update ADC state machine to error */
   1971                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   \   00000032   0x6CE0             LDR      R0,[R4, #+76]
   \   00000034   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000038   0x64E0             STR      R0,[R4, #+76]
   1972                
   1973                  /* Set ADC error code to ADC IP internal error */
   1974                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   0000003A   0x6D20             LDR      R0,[R4, #+80]
   \   0000003C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000040   0x6520             STR      R0,[R4, #+80]
   1975                  
   1976                  return HAL_ERROR;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE000             B.N      ??ADC_ConversionStop_Disable_2
   1977                }
   1978              }
   1979            }
   1980            
   1981            /* Return HAL status */
   1982            return HAL_OK;
   \                     ??ADC_ConversionStop_Disable_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??ADC_ConversionStop_Disable_2: (+1)
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1983          }
   1984          
   1985          /**
   1986            * @brief  DMA transfer complete callback. 
   1987            * @param  hdma: pointer to DMA handle.
   1988            * @retval None
   1989            */

   \                                 In section .text, align 4, keep-with-next
   1990          static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
   1991          {
   \                     ADC_DMAConvCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1992            /* Retrieve ADC handle corresponding to current DMA handle */
   1993            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1994            
   1995            /* Update state machine on conversion status if not in error state */
   1996            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   \   00000006   0x6CE8             LDR      R0,[R5, #+76]
   \   00000008   0xF010 0x0F50      TST      R0,#0x50
   \   0000000C   0xD12A             BNE.N    ??ADC_DMAConvCplt_0
   1997            {
   1998              /* Update ADC state machine */
   1999              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \   0000000E   0x6CE8             LDR      R0,[R5, #+76]
   \   00000010   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000014   0x64E8             STR      R0,[R5, #+76]
   2000              
   2001              /* Determine whether any further conversion upcoming on group regular   */
   2002              /* by external trigger, continuous mode or scan sequence on going.      */
   2003              /* Note: On STM32L1, there is no independent flag of end of sequence.   */
   2004              /*       The test of scan sequence on going is done either with scan    */
   2005              /*       sequence disabled or with end of conversion flag set to        */
   2006              /*       of end of sequence.                                            */
   2007              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   2008                 (hadc->Init.ContinuousConvMode == DISABLE)            &&
   2009                 (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   2010                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0xF010 0x5F40      TST      R0,#0x30000000
   \   0000001E   0xD11D             BNE.N    ??ADC_DMAConvCplt_1
   \   00000020   0x6A68             LDR      R0,[R5, #+36]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD11A             BNE.N    ??ADC_DMAConvCplt_1
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x6B00             LDR      R0,[R0, #+48]
   \   0000002A   0xF010 0x7FF8      TST      R0,#0x1F00000
   \   0000002E   0xD003             BEQ.N    ??ADC_DMAConvCplt_2
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x6880             LDR      R0,[R0, #+8]
   \   00000034   0x0540             LSLS     R0,R0,#+21
   \   00000036   0xD411             BMI.N    ??ADC_DMAConvCplt_1
   2011              {
   2012                /* Disable ADC end of single conversion interrupt on group regular */
   2013                /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   2014                /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   2015                /* by overrun IRQ process below.                                      */
   2016                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??ADC_DMAConvCplt_2: (+1)
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xF07F 0x0120      MVNS     R1,#+32
   \   00000040   0x4008             ANDS     R0,R1,R0
   \   00000042   0x6829             LDR      R1,[R5, #+0]
   \   00000044   0x6048             STR      R0,[R1, #+4]
   2017                
   2018                /* Set ADC state */
   2019                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \   00000046   0x6CE8             LDR      R0,[R5, #+76]
   \   00000048   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000004C   0x64E8             STR      R0,[R5, #+76]
   2020                
   2021                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   0000004E   0x6CE8             LDR      R0,[R5, #+76]
   \   00000050   0x04C0             LSLS     R0,R0,#+19
   \   00000052   0xD403             BMI.N    ??ADC_DMAConvCplt_1
   2022                {
   2023                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   00000054   0x6CE8             LDR      R0,[R5, #+76]
   \   00000056   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005A   0x64E8             STR      R0,[R5, #+76]
   2024                }
   2025              }
   2026              
   2027              /* Conversion complete callback */
   2028              HAL_ADC_ConvCpltCallback(hadc);
   \                     ??ADC_DMAConvCplt_1: (+1)
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   \   00000062   0xE003             B.N      ??ADC_DMAConvCplt_3
   2029            }
   2030            else
   2031            {
   2032              /* Call DMA error callback */
   2033              hadc->DMA_Handle->XferErrorCallback(hdma);
   \                     ??ADC_DMAConvCplt_0: (+1)
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x6C69             LDR      R1,[R5, #+68]
   \   00000068   0x6B09             LDR      R1,[R1, #+48]
   \   0000006A   0x4788             BLX      R1
   2034            }
   2035          }
   \                     ??ADC_DMAConvCplt_3: (+1)
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2036          
   2037          /**
   2038            * @brief  DMA half transfer complete callback. 
   2039            * @param  hdma: pointer to DMA handle.
   2040            * @retval None
   2041            */

   \                                 In section .text, align 4, keep-with-next
   2042          static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   2043          {
   \                     ADC_DMAHalfConvCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2044            /* Retrieve ADC handle corresponding to current DMA handle */
   2045            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2046            
   2047            /* Half conversion callback */
   2048            HAL_ADC_ConvHalfCpltCallback(hadc); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_ADC_ConvHalfCpltCallback
   2049          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2050          
   2051          /**
   2052            * @brief  DMA error callback 
   2053            * @param  hdma: pointer to DMA handle.
   2054            * @retval None
   2055            */

   \                                 In section .text, align 4, keep-with-next
   2056          static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
   2057          {
   \                     ADC_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2058            /* Retrieve ADC handle corresponding to current DMA handle */
   2059            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2060            
   2061            /* Set ADC state */
   2062            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   \   00000006   0x6CE8             LDR      R0,[R5, #+76]
   \   00000008   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000000C   0x64E8             STR      R0,[R5, #+76]
   2063            
   2064            /* Set ADC error code to DMA error */
   2065            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
   \   0000000E   0x6D28             LDR      R0,[R5, #+80]
   \   00000010   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000014   0x6528             STR      R0,[R5, #+80]
   2066            
   2067            /* Error callback */
   2068            HAL_ADC_ErrorCallback(hadc); 
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   2069          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40012704         DC32     0x40012704

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0xFCFC16FF         DC32     0xfcfc16ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0xC0FFF189         DC32     0xc0fff189

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0xBF80FFFE         DC32     0xbf80fffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0xF83C0000         DC32     0xf83c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x8080F088         DC32     0x8080f088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0xFFFFF9FE         DC32     0xfffff9fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x00800200         DC32     0x800200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x00400200         DC32     0x400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x00C00200         DC32     0xc00200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0xFF3FFDE0         DC32     0xff3ffde0
   2070          
   2071          /**
   2072            * @}
   2073            */
   2074          
   2075          #endif /* HAL_ADC_MODULE_ENABLED */
   2076          /**
   2077            * @}
   2078            */
   2079          
   2080          /**
   2081            * @}
   2082            */
   2083          
   2084          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_ConversionStop_Disable
        16   -> HAL_GetTick
      16   ADC_DMAConvCplt
        16   -- Indirect call
        16   -> HAL_ADC_ConvCpltCallback
      16   ADC_DMAError
        16   -> HAL_ADC_ErrorCallback
      16   ADC_DMAHalfConvCplt
        16   -> HAL_ADC_ConvHalfCpltCallback
      16   ADC_Enable
        16   -> HAL_GetTick
       4   HAL_ADC_AnalogWDGConfig
      16   HAL_ADC_ConfigChannel
       0   HAL_ADC_ConvCpltCallback
       0   HAL_ADC_ConvHalfCpltCallback
      16   HAL_ADC_DeInit
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_ADC_MspDeInit
       0   HAL_ADC_ErrorCallback
       0   HAL_ADC_GetError
       0   HAL_ADC_GetState
       0   HAL_ADC_GetValue
       8   HAL_ADC_IRQHandler
         8   -> HAL_ADCEx_InjectedConvCpltCallback
         8   -> HAL_ADC_ConvCpltCallback
         8   -> HAL_ADC_ErrorCallback
         8   -> HAL_ADC_LevelOutOfWindowCallback
      24   HAL_ADC_Init
        24   -> HAL_ADC_MspInit
       0   HAL_ADC_LevelOutOfWindowCallback
       0   HAL_ADC_MspDeInit
       0   HAL_ADC_MspInit
      16   HAL_ADC_PollForConversion
        16   -> HAL_GetTick
      24   HAL_ADC_PollForEvent
        24   -> HAL_GetTick
      16   HAL_ADC_Start
        16   -> ADC_Enable
      24   HAL_ADC_Start_DMA
        24   -> ADC_Enable
        24   -> HAL_DMA_Start_IT
      16   HAL_ADC_Start_IT
        16   -> ADC_Enable
      16   HAL_ADC_Stop
        16   -> ADC_ConversionStop_Disable
      16   HAL_ADC_Stop_DMA
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_DMA_Abort
      16   HAL_ADC_Stop_IT
        16   -> ADC_ConversionStop_Disable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      74  ADC_ConversionStop_Disable
     110  ADC_DMAConvCplt
      30  ADC_DMAError
      14  ADC_DMAHalfConvCplt
     114  ADC_Enable
     132  HAL_ADC_AnalogWDGConfig
     486  HAL_ADC_ConfigChannel
       2  HAL_ADC_ConvCpltCallback
       2  HAL_ADC_ConvHalfCpltCallback
     308  HAL_ADC_DeInit
       2  HAL_ADC_ErrorCallback
       4  HAL_ADC_GetError
       4  HAL_ADC_GetState
       6  HAL_ADC_GetValue
     336  HAL_ADC_IRQHandler
     454  HAL_ADC_Init
       2  HAL_ADC_LevelOutOfWindowCallback
       2  HAL_ADC_MspDeInit
       2  HAL_ADC_MspInit
     176  HAL_ADC_PollForConversion
     114  HAL_ADC_PollForEvent
     136  HAL_ADC_Start
     204  HAL_ADC_Start_DMA
     152  HAL_ADC_Start_IT
      62  HAL_ADC_Stop
     110  HAL_ADC_Stop_DMA
      76  HAL_ADC_Stop_IT

 
 3 170 bytes in section .text
 
 3 170 bytes of CODE memory

Errors: none
Warnings: none
