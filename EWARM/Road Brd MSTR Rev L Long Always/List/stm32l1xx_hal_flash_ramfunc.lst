###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       17/Jul/2017  15:20:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ramfunc.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ramfunc.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\stm32l1xx_hal_flash_ramfunc.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\stm32l1xx_hal_flash_ramfunc.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ramfunc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_flash_ramfunc.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   FLASH RAMFUNC driver.
      8            *          This file provides a Flash firmware functions which should be 
      9            *          executed from internal SRAM
     10            *
     11            *  @verbatim
     12          
     13              *** ARM Compiler ***
     14              --------------------
     15              [..] RAM functions are defined using the toolchain options. 
     16                   Functions that are be executed in RAM should reside in a separate
     17                   source module. Using the 'Options for File' dialog you can simply change
     18                   the 'Code / Const' area of a module to a memory space in physical RAM.
     19                   Available memory areas are declared in the 'Target' tab of the 
     20                   Options for Target' dialog.
     21          
     22              *** ICCARM Compiler ***
     23              -----------------------
     24              [..] RAM functions are defined using a specific toolchain keyword "__ramfunc".
     25          
     26              *** GNU Compiler ***
     27              --------------------
     28              [..] RAM functions are defined using a specific toolchain attribute
     29                   "__attribute__((section(".RamFunc")))".
     30          
     31          @endverbatim
     32            ******************************************************************************
     33            * @attention
     34            *
     35            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     36            *
     37            * Redistribution and use in source and binary forms, with or without modification,
     38            * are permitted provided that the following conditions are met:
     39            *   1. Redistributions of source code must retain the above copyright notice,
     40            *      this list of conditions and the following disclaimer.
     41            *   2. Redistributions in binary form must reproduce the above copyright notice,
     42            *      this list of conditions and the following disclaimer in the documentation
     43            *      and/or other materials provided with the distribution.
     44            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     45            *      may be used to endorse or promote products derived from this software
     46            *      without specific prior written permission.
     47            *
     48            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     49            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     50            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     51            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     52            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     53            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     54            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     55            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     56            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     57            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     58            *
     59            ******************************************************************************
     60            */
     61          
     62          /* Includes ------------------------------------------------------------------*/
     63          #include "stm32l1xx_hal.h"
     64          
     65          /** @addtogroup STM32L1xx_HAL_Driver
     66            * @{
     67            */
     68          
     69          #ifdef HAL_FLASH_MODULE_ENABLED
     70          
     71          /** @defgroup FLASH_RAMFUNC FLASH_RAMFUNC
     72            * @brief FLASH functions executed from RAM
     73            * @{
     74            */ 
     75          
     76          
     77          /* Private typedef -----------------------------------------------------------*/
     78          /* Private define ------------------------------------------------------------*/
     79          /* Private macro -------------------------------------------------------------*/
     80          /* Private variables ---------------------------------------------------------*/
     81          /* Private function prototypes -----------------------------------------------*/
     82          /** @defgroup FLASH_RAMFUNC_Private_Functions Private Functions
     83           * @{
     84           */
     85          
     86          static __RAM_FUNC FLASHRAM_WaitForLastOperation(uint32_t Timeout);
     87          
     88          /**
     89            * @}
     90            */
     91          
     92          /* Private functions ---------------------------------------------------------*/
     93           
     94          /** @defgroup FLASH_RAMFUNC_Exported_Functions Exported Functions
     95           *
     96          @verbatim  
     97           ===============================================================================
     98                                ##### ramfunc functions #####
     99           ===============================================================================  
    100              [..]
    101              This subsection provides a set of functions that should be executed from RAM 
    102              transfers.
    103          
    104          @endverbatim
    105            * @{
    106            */ 
    107          
    108          /** @defgroup FLASH_RAMFUNC_Exported_Functions_Group1 Peripheral features functions 
    109            * @{
    110            */  
    111          
    112          /**
    113            * @brief  Enable  the power down mode during RUN mode.
    114            * @note  This function can be used only when the user code is running from Internal SRAM.
    115            * @retval None
    116            */

   \                                 In section .textrw, align 2, keep-with-next
    117          __RAM_FUNC HAL_FLASHEx_EnableRunPowerDown(void)
    118          {
    119            /* Enable the Power Down in Run mode*/
    120            __HAL_FLASH_POWER_DOWN_ENABLE();
   \                     HAL_FLASHEx_EnableRunPowerDown: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x4152637
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40023c08
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0xfafbfcfd
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40023c08
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable7_3  ;; 0x40023c00
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable7_3  ;; 0x40023c00
   \   00000022   0x6008             STR      R0,[R1, #+0]
    121            
    122            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    123          }
    124          
    125          
    126          /**
    127            * @brief  Disable the power down mode during RUN mode.
    128            * @note  This function can be used only when the user code is running from Internal SRAM.
    129            * @retval None
    130            */

   \                                 In section .textrw, align 2, keep-with-next
    131          __RAM_FUNC HAL_FLASHEx_DisableRunPowerDown(void)
    132          {
    133            /* Disable the Power Down in Run mode*/
    134            __HAL_FLASH_POWER_DOWN_DISABLE();
   \                     HAL_FLASHEx_DisableRunPowerDown: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x4152637
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40023c08
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0xfafbfcfd
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x40023c08
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable7_3  ;; 0x40023c00
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF07F 0x0110      MVNS     R1,#+16
   \   0000001E   0x4008             ANDS     R0,R1,R0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable7_3  ;; 0x40023c00
   \   00000024   0x6008             STR      R0,[R1, #+0]
    135          
    136            return HAL_OK;  
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    137          }
    138          
    139          /**
    140            * @}
    141            */
    142          
    143          /** @defgroup FLASH_RAMFUNC_Exported_Functions_Group2 Programming and erasing operation functions 
    144           *
    145          @verbatim  
    146          @endverbatim
    147            * @{
    148            */
    149          
    150          #if defined(FLASH_PECR_PARALLBANK)
    151          /**
    152            * @brief  Erases a specified 2 page in program memory in parallel.
    153            * @note   This function can be used only for STM32L151xD, STM32L152xD), STM32L162xD and Cat5  devices.
    154            *         To correctly run this function, the HAL_FLASH_Unlock() function
    155            *         must be called before.
    156            *         Call the HAL_FLASH_Lock() to disable the flash memory access 
    157            *        (recommended to protect the FLASH memory against possible unwanted operation).
    158            * @param  Page_Address1: The page address in program memory to be erased in 
    159            *         the first Bank (BANK1). This parameter should be between FLASH_BASE
    160            *         and FLASH_BANK1_END.
    161            * @param  Page_Address2: The page address in program memory to be erased in 
    162            *         the second Bank (BANK2). This parameter should be between FLASH_BANK2_BASE
    163            *         and FLASH_BANK2_END.
    164            * @note   A Page is erased in the Program memory only if the address to load 
    165            *         is the start address of a page (multiple of 256 bytes).
    166            * @retval HAL Status: The returned value can be: 
    167            *          HAL_ERROR, HAL_OK or HAL_TIMEOUT.
    168            */

   \                                 In section .textrw, align 2, keep-with-next
    169          __RAM_FUNC HAL_FLASHEx_EraseParallelPage(uint32_t Page_Address1, uint32_t Page_Address2)
    170          {
   \                     HAL_FLASHEx_EraseParallelPage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    171            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    172          
    173            /* Wait for last operation to be completed */
    174            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
    175            
    176            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD12D             BNE.N    ??HAL_FLASHEx_EraseParallelPage_0
    177            {
    178              /* If the previous operation is completed, proceed to erase the page */
    179          
    180              /* Set the PARALLBANK bit */
    181              FLASH->PECR |= FLASH_PECR_PARALLBANK;
   \   00000018   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000020   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000022   0x6008             STR      R0,[R1, #+0]
    182              
    183              /* Set the ERASE bit */
    184              FLASH->PECR |= FLASH_PECR_ERASE;
   \   00000024   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002C   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    185          
    186              /* Set PROG bit */
    187              FLASH->PECR |= FLASH_PECR_PROG;
   \   00000030   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000038   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    188            
    189              /* Write 00000000h to the first word of the first program page to erase */
    190              *(__IO uint32_t *)Page_Address1 = 0x00000000;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6020             STR      R0,[R4, #+0]
    191              /* Write 00000000h to the first word of the second program page to erase */    
    192              *(__IO uint32_t *)Page_Address2 = 0x00000000;    
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6028             STR      R0,[R5, #+0]
    193           
    194              /* Wait for last operation to be completed */
    195              status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000044   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000048   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000004C   0x0006             MOVS     R6,R0
    196          
    197              /* If the erase operation is completed, disable the ERASE, PROG and PARALLBANK bits */
    198              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
   \   0000004E   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF07F 0x0108      MVNS     R1,#+8
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    199              FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);
   \   0000005C   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000064   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000066   0x6008             STR      R0,[R1, #+0]
    200              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PARALLBANK);   
   \   00000068   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000070   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000072   0x6008             STR      R0,[R1, #+0]
    201            }     
    202            /* Return the Erase Status */
    203            return status;
   \                     ??HAL_FLASHEx_EraseParallelPage_0: (+1)
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    204          }
    205          
    206          /**
    207            * @brief  Programs 2 half page in program memory in parallel.
    208            * @note   This function can be used only for STM32L151xD, STM32L152xD), STM32L162xD and Cat5  devices.
    209            * @param  Address1: specifies the first address to be written in the first bank 
    210            *        (BANK1). This parameter should be between FLASH_BASE and (FLASH_BANK1_END - FLASH_PAGE_SIZE).
    211            * @param  pBuffer1: pointer to the buffer  containing the data to be  written 
    212            *         to the first half page in the first bank.
    213            * @param  Address2: specifies the second address to be written in the second bank
    214            *        (BANK2). This parameter should be between FLASH_BANK2_BASE and (FLASH_BANK2_END - FLASH_PAGE_SIZE).
    215            * @param  pBuffer2: pointer to the buffer containing the data to be  written 
    216            *         to the second half page in the second bank.
    217            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    218            *         must be called before.
    219            *         Call the HAL_FLASH_Lock() to disable the flash memory access  
    220            *         (recommended to protect the FLASH memory against possible unwanted operation).
    221            * @note   Half page write is possible only from SRAM.
    222            * @note   If there are more than 32 words to write, after 32 words another 
    223            *         Half Page programming operation starts and has to be finished.
    224            * @note   A half page is written to the program memory only if the first 
    225            *         address to load is the start address of a half page (multiple of 128 
    226            *         bytes) and the 31 remaining words to load are in the same half page.
    227            * @note   During the Program memory half page write all read operations are 
    228            *         forbidden (this includes DMA read operations and debugger read 
    229            *         operations such as breakpoints, periodic updates, etc.).
    230            * @note   If a PGAERR is set during a Program memory half page write, the 
    231            *         complete write operation is aborted. Software should then reset the 
    232            *         FPRG and PROG/DATA bits and restart the write operation from the 
    233            *         beginning.
    234            * @retval HAL Status: The returned value can be:  
    235            *          HAL_ERROR, HAL_OK or HAL_TIMEOUT.
    236            */

   \                                 In section .textrw, align 2, keep-with-next
    237          __RAM_FUNC HAL_FLASHEx_ProgramParallelHalfPage(uint32_t Address1, uint32_t* pBuffer1, uint32_t Address2, uint32_t* pBuffer2)
    238          {
   \                     HAL_FLASHEx_ProgramParallelHalfPage: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    239            uint32_t count = 0; 
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    240             
    241            HAL_StatusTypeDef status = HAL_OK;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    242          
    243            /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
    244               This bit prevents the interruption of multicycle instructions and therefore 
    245               will increase the interrupt latency. of Cortex-M3. */
    246            SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
   \   00000014   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    247          
    248            /* Wait for last operation to be completed */
    249            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000024   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   00000028   0x4681             MOV      R9,R0
    250            
    251            if(status == HAL_OK)
   \   0000002A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000032   0xD14B             BNE.N    ??HAL_FLASHEx_ProgramParallelHalfPage_0
    252            {
    253              /* If the previous operation is completed, proceed to program the new  
    254                 half page */
    255              FLASH->PECR |= FLASH_PECR_PARALLBANK;
   \   00000034   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000003C   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    256              FLASH->PECR |= FLASH_PECR_FPRG;
   \   00000040   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000048   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    257              FLASH->PECR |= FLASH_PECR_PROG;
   \   0000004C   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000054   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000056   0x6008             STR      R0,[R1, #+0]
    258              
    259            /* Wait for last operation to be completed */
    260            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000058   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000005C   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   00000060   0x4681             MOV      R9,R0
    261            if(status == HAL_OK)
   \   00000062   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000066   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006A   0xD11C             BNE.N    ??HAL_FLASHEx_ProgramParallelHalfPage_1
    262            {
    263              /* Write the first half page directly with 32 different words */
    264              while(count < 32)
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_2: (+1)
   \   0000006C   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000070   0xD207             BCS.N    ??HAL_FLASHEx_ProgramParallelHalfPage_3
    265              {
    266                *(__IO uint32_t*) ((uint32_t)(Address1 + (4 * count))) = *(pBuffer1++);
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0xEB14 0x0188      ADDS     R1,R4,R8, LSL #+2
   \   00000078   0x6008             STR      R0,[R1, #+0]
   \   0000007A   0x1D2D             ADDS     R5,R5,#+4
    267                count ++;  
   \   0000007C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000080   0xE7F4             B.N      ??HAL_FLASHEx_ProgramParallelHalfPage_2
    268              }
    269              count = 0;
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_3: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x4680             MOV      R8,R0
    270          
    271              /* Write the second half page directly with 32 different words */
    272              while(count < 32)
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_4: (+1)
   \   00000086   0xF1B8 0x0F20      CMP      R8,#+32
   \   0000008A   0xD207             BCS.N    ??HAL_FLASHEx_ProgramParallelHalfPage_5
    273              {
    274                *(__IO uint32_t*) ((uint32_t)(Address2 + (4 * count))) = *(pBuffer2++);
   \   0000008C   0x6838             LDR      R0,[R7, #+0]
   \   0000008E   0xEB16 0x0188      ADDS     R1,R6,R8, LSL #+2
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0x1D3F             ADDS     R7,R7,#+4
    275                count ++;  
   \   00000096   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000009A   0xE7F4             B.N      ??HAL_FLASHEx_ProgramParallelHalfPage_4
    276              }
    277              /* Wait for last operation to be completed */
    278              status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_5: (+1)
   \   0000009C   0xF24C 0x3050      MOVW     R0,#+50000
   \   000000A0   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   000000A4   0x4681             MOV      R9,R0
    279            } 
    280              /* if the write operation is completed, disable the PROG, FPRG and PARALLBANK bits */
    281              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_1: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0xF07F 0x0108      MVNS     R1,#+8
   \   000000AE   0x4008             ANDS     R0,R1,R0
   \   000000B0   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    282              FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
   \   000000B4   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000BC   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    283              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PARALLBANK);
   \   000000C0   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   000000C8   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    284            }
    285          
    286            SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
   \                     ??HAL_FLASHEx_ProgramParallelHalfPage_0: (+1)
   \   000000CC   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x0840             LSRS     R0,R0,#+1
   \   000000D2   0x0040             LSLS     R0,R0,#+1
   \   000000D4   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    287              
    288            /* Return the Write Status */
    289            return status;
   \   000000D8   0x4648             MOV      R0,R9
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    290          }
    291          #endif /* FLASH_PECR_PARALLBANK */
    292          
    293          /**
    294            * @brief  Programs a half page in program memory.
    295            * @param  Address: specifies the address to be written.
    296            * @param  pBuffer: pointer to the buffer  containing the data to be  written to 
    297            *         the half page.
    298            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    299            *         must be called before.
    300            *         Call the HAL_FLASH_Lock() to disable the flash memory access  
    301            *         (recommended to protect the FLASH memory against possible unwanted operation)
    302            * @note   Half page write is possible only from SRAM.
    303            * @note   If there are more than 32 words to write, after 32 words another 
    304            *         Half Page programming operation starts and has to be finished.
    305            * @note   A half page is written to the program memory only if the first 
    306            *         address to load is the start address of a half page (multiple of 128 
    307            *         bytes) and the 31 remaining words to load are in the same half page.
    308            * @note   During the Program memory half page write all read operations are 
    309            *         forbidden (this includes DMA read operations and debugger read 
    310            *         operations such as breakpoints, periodic updates, etc.).
    311            * @note   If a PGAERR is set during a Program memory half page write, the 
    312            *         complete write operation is aborted. Software should then reset the 
    313            *         FPRG and PROG/DATA bits and restart the write operation from the 
    314            *         beginning.
    315            * @retval HAL Status: The returned value can be:  
    316            *    HAL_ERROR, HAL_OK or HAL_TIMEOUT. 
    317            */

   \                                 In section .textrw, align 2, keep-with-next
    318          __RAM_FUNC HAL_FLASHEx_HalfPageProgram(uint32_t Address, uint32_t* pBuffer)
    319          {
   \                     HAL_FLASHEx_HalfPageProgram: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    320            uint32_t count = 0; 
   \   00000006   0x2600             MOVS     R6,#+0
    321             
    322            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2700             MOVS     R7,#+0
    323          
    324            /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
    325               This bit prevents the interruption of multicycle instructions and therefore 
    326               will increase the interrupt latency. of Cortex-M3. */
    327            SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   00000014   0x6008             STR      R0,[R1, #+0]
    328            
    329            /* Wait for last operation to be completed */
    330            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000016   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001A   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000001E   0x0007             MOVS     R7,R0
    331            
    332            if(status == HAL_OK)
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD126             BNE.N    ??HAL_FLASHEx_HalfPageProgram_0
    333            {
    334              /* if the previous operation is completed, proceed to program the new  
    335              half page */
    336              FLASH->PECR |= FLASH_PECR_FPRG;
   \   00000026   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000002E   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000030   0x6008             STR      R0,[R1, #+0]
    337              FLASH->PECR |= FLASH_PECR_PROG;
   \   00000032   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003A   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    338              
    339              /* Write one half page directly with 32 different words */
    340              while(count < 32)
   \                     ??HAL_FLASHEx_HalfPageProgram_1: (+1)
   \   0000003E   0x2E20             CMP      R6,#+32
   \   00000040   0xD206             BCS.N    ??HAL_FLASHEx_HalfPageProgram_2
    341              {
    342                *(__IO uint32_t*) ((uint32_t)(Address + (4 * count))) = *(pBuffer++);
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xEB14 0x0186      ADDS     R1,R4,R6, LSL #+2
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0x1D2D             ADDS     R5,R5,#+4
    343                count ++;  
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \   0000004E   0xE7F6             B.N      ??HAL_FLASHEx_HalfPageProgram_1
    344              }
    345              /* Wait for last operation to be completed */
    346              status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASHEx_HalfPageProgram_2: (+1)
   \   00000050   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000054   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   00000058   0x0007             MOVS     R7,R0
    347           
    348              /* if the write operation is completed, disable the PROG and FPRG bits */
    349              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
   \   0000005A   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF07F 0x0108      MVNS     R1,#+8
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000066   0x6008             STR      R0,[R1, #+0]
    350              FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
   \   00000068   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000070   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000072   0x6008             STR      R0,[R1, #+0]
    351            }
    352          
    353            SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
   \                     ??HAL_FLASHEx_HalfPageProgram_0: (+1)
   \   00000074   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0840             LSRS     R0,R0,#+1
   \   0000007A   0x0040             LSLS     R0,R0,#+1
   \   0000007C   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    354              
    355            /* Return the Write Status */
    356            return status;
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    357          }
    358          
    359          /**
    360            * @}
    361            */
    362          
    363          /** @defgroup FLASH_RAMFUNC_Exported_Functions_Group3 DATA EEPROM functions
    364            *
    365            * @{
    366            */
    367          
    368          /**
    369            * @brief  Erase a double word in data memory.
    370            * @param  Address: specifies the address to be erased.
    371            * @note   To correctly run this function, the HAL_FLASH_EEPROM_Unlock() function
    372            *         must be called before.
    373            *         Call the HAL_FLASH_EEPROM_Lock() to he data EEPROM access
    374            *         and Flash program erase control register access(recommended to protect 
    375            *         the DATA_EEPROM against possible unwanted operation).
    376            * @note   Data memory double word erase is possible only from SRAM.
    377            * @note   A double word is erased to the data memory only if the first address 
    378            *         to load is the start address of a double word (multiple of 8 bytes).
    379            * @note   During the Data memory double word erase, all read operations are 
    380            *         forbidden (this includes DMA read operations and debugger read 
    381            *         operations such as breakpoints, periodic updates, etc.).
    382            * @retval HAL Status: The returned value can be: 
    383            *    HAL_ERROR, HAL_OK or HAL_TIMEOUT.
    384            */
    385          

   \                                 In section .textrw, align 2, keep-with-next
    386          __RAM_FUNC HAL_FLASHEx_DATAEEPROM_EraseDoubleWord(uint32_t Address)
    387          {
   \                     HAL_FLASHEx_DATAEEPROM_EraseDoubleWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    388            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    389            
    390            /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
    391               This bit prevents the interruption of multicycle instructions and therefore 
    392               will increase the interrupt latency. of Cortex-M3. */
    393            SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
   \   00000006   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000E   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   00000010   0x6008             STR      R0,[R1, #+0]
    394              
    395            /* Wait for last operation to be completed */
    396            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000012   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000016   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000001A   0x0005             MOVS     R5,R0
    397            
    398            if(status == HAL_OK)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD122             BNE.N    ??HAL_FLASHEx_DATAEEPROM_EraseDoubleWord_0
    399            {
    400              /* If the previous operation is completed, proceed to erase the next double word */
    401              /* Set the ERASE bit */
    402              FLASH->PECR |= FLASH_PECR_ERASE;
   \   00000022   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002A   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    403          
    404              /* Set DATA bit */
    405              FLASH->PECR |= FLASH_PECR_DATA;
   \   0000002E   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000036   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000038   0x6008             STR      R0,[R1, #+0]
    406             
    407              /* Write 00000000h to the 2 words to erase */
    408              *(__IO uint32_t *)Address = 0x00000000;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6020             STR      R0,[R4, #+0]
    409              Address += 4;
   \   0000003E   0x1D24             ADDS     R4,R4,#+4
    410              *(__IO uint32_t *)Address = 0x00000000;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6020             STR      R0,[R4, #+0]
    411             
    412              /* Wait for last operation to be completed */
    413              status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000044   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000048   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000004C   0x0005             MOVS     R5,R0
    414              
    415              /* If the erase operation is completed, disable the ERASE and DATA bits */
    416              FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);
   \   0000004E   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000056   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000058   0x6008             STR      R0,[R1, #+0]
    417              FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);
   \   0000005A   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF07F 0x0110      MVNS     R1,#+16
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000066   0x6008             STR      R0,[R1, #+0]
    418            }  
    419            
    420            SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
   \                     ??HAL_FLASHEx_DATAEEPROM_EraseDoubleWord_0: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   00000072   0x6008             STR      R0,[R1, #+0]
    421              
    422            /* Return the erase status */
    423            return status;
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    424          }
    425          
    426          /**
    427            * @brief  Write a double word in data memory without erase.
    428            * @param  Address: specifies the address to be written.
    429            * @param  Data: specifies the data to be written.
    430            * @note   To correctly run this function, the HAL_FLASH_EEPROM_Unlock() function
    431            *         must be called before.
    432            *         Call the HAL_FLASH_EEPROM_Lock() to he data EEPROM access
    433            *         and Flash program erase control register access(recommended to protect 
    434            *         the DATA_EEPROM against possible unwanted operation).
    435            * @note   Data memory double word write is possible only from SRAM.
    436            * @note   A data memory double word is written to the data memory only if the 
    437            *         first address to load is the start address of a double word (multiple 
    438            *         of double word).
    439            * @note   During the Data memory double word write, all read operations are 
    440            *         forbidden (this includes DMA read operations and debugger read 
    441            *         operations such as breakpoints, periodic updates, etc.).
    442            * @retval HAL Status: The returned value can be: 
    443            *    HAL_ERROR, HAL_OK or HAL_TIMEOUT. 
    444            */ 

   \                                 In section .textrw, align 2, keep-with-next
    445          __RAM_FUNC HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    446          {
   \                     HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    447            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2700             MOVS     R7,#+0
    448          
    449            /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
    450               This bit prevents the interruption of multicycle instructions and therefore 
    451               will increase the interrupt latency. of Cortex-M3. */
    452            SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   00000014   0x6008             STR      R0,[R1, #+0]
    453              
    454            /* Wait for last operation to be completed */
    455            status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000016   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001A   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000001E   0x0007             MOVS     R7,R0
    456            
    457            if(status == HAL_OK)
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD120             BNE.N    ??HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord_0
    458            {
    459              /* If the previous operation is completed, proceed to program the new data*/
    460              FLASH->PECR |= FLASH_PECR_FPRG;
   \   00000026   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000002E   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000030   0x6008             STR      R0,[R1, #+0]
    461              FLASH->PECR |= FLASH_PECR_DATA;
   \   00000032   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000003A   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    462              
    463              /* Write the 2 words */  
    464               *(__IO uint32_t *)Address = (uint32_t) Data;
   \   0000003E   0x6034             STR      R4,[R6, #+0]
    465               Address += 4;
   \   00000040   0x1D36             ADDS     R6,R6,#+4
    466               *(__IO uint32_t *)Address = (uint32_t) (Data >> 32);
   \   00000042   0x6035             STR      R5,[R6, #+0]
    467              
    468              /* Wait for last operation to be completed */
    469              status = FLASHRAM_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000044   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000048   0x.... 0x....      BL       FLASHRAM_WaitForLastOperation
   \   0000004C   0x0007             MOVS     R7,R0
    470              
    471              /* If the write operation is completed, disable the FPRG and DATA bits */
    472              FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
   \   0000004E   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000056   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000058   0x6008             STR      R0,[R1, #+0]
    473              FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);     
   \   0000005A   0x....             LDR.N    R0,??DataTable7_4  ;; 0x40023c04
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF07F 0x0110      MVNS     R1,#+16
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40023c04
   \   00000066   0x6008             STR      R0,[R1, #+0]
    474            }
    475            
    476            SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
   \                     ??HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord_0: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable7_5  ;; 0xe000e008
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e008
   \   00000072   0x6008             STR      R0,[R1, #+0]
    477              
    478            /* Return the Write Status */
    479            return status;
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    480          }
    481          
    482          /**
    483            * @}
    484            */
    485          
    486          /**
    487            * @}
    488            */
    489          
    490          /** @addtogroup FLASH_RAMFUNC_Private_Functions
    491            * @{
    492            */ 
    493          
    494          /**
    495            * @brief  Wait for a FLASH operation to complete.
    496            * @param  Timeout: maximum flash operationtimeout
    497            * @retval HAL status
    498            */

   \                                 In section .textrw, align 2, keep-with-next
    499          static __RAM_FUNC   FLASHRAM_WaitForLastOperation(uint32_t Timeout)
    500          { 
   \                     FLASHRAM_WaitForLastOperation: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    501              /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    502                 Even if the FLASH operation fails, the BUSY flag will be reset and an error
    503                 flag will be set */
    504                 
    505              while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) && (Timeout != 0x00)) 
   \                     ??FLASHRAM_WaitForLastOperation_0: (+1)
   \   00000002   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD503             BPL.N    ??FLASHRAM_WaitForLastOperation_1
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD001             BEQ.N    ??FLASHRAM_WaitForLastOperation_1
    506              { 
    507                Timeout--;
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0xE7F7             B.N      ??FLASHRAM_WaitForLastOperation_0
    508              }
    509              
    510              if(Timeout == 0x00 )
   \                     ??FLASHRAM_WaitForLastOperation_1: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD101             BNE.N    ??FLASHRAM_WaitForLastOperation_2
    511              {
    512                return HAL_TIMEOUT;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE01D             B.N      ??FLASHRAM_WaitForLastOperation_3
    513              }
    514              
    515              /* Check FLASH End of Operation flag  */
    516              if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASHRAM_WaitForLastOperation_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0780             LSLS     R0,R0,#+30
   \   00000020   0xD502             BPL.N    ??FLASHRAM_WaitForLastOperation_4
    517              {
    518                /* Clear FLASH End of Operation pending bit */
    519                __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x....             LDR.N    R2,??DataTable7_6  ;; 0x40023c18
   \   00000026   0x6010             STR      R0,[R2, #+0]
    520              }
    521            
    522              if( (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     != RESET) || 
    523                  (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     != RESET) || 
    524                  (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     != RESET) || 
    525          #if defined(FLASH_SR_RDERR)
    526                  (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      != RESET) || 
    527          #endif /* FLASH_SR_RDERR */
    528          #if defined(FLASH_SR_OPTVERRUSR)
    529                  (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) != RESET) || 
    530          #endif /* FLASH_SR_OPTVERRUSR */
    531                  (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    != RESET) )
   \                     ??FLASHRAM_WaitForLastOperation_4: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x05C0             LSLS     R0,R0,#+23
   \   0000002E   0xD40F             BMI.N    ??FLASHRAM_WaitForLastOperation_5
   \   00000030   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0580             LSLS     R0,R0,#+22
   \   00000036   0xD40B             BMI.N    ??FLASHRAM_WaitForLastOperation_5
   \   00000038   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0540             LSLS     R0,R0,#+21
   \   0000003E   0xD407             BMI.N    ??FLASHRAM_WaitForLastOperation_5
   \   00000040   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x04C0             LSLS     R0,R0,#+19
   \   00000046   0xD403             BMI.N    ??FLASHRAM_WaitForLastOperation_5
   \   00000048   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40023c18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0500             LSLS     R0,R0,#+20
   \   0000004E   0xD501             BPL.N    ??FLASHRAM_WaitForLastOperation_6
    532              {
    533                return HAL_ERROR;
   \                     ??FLASHRAM_WaitForLastOperation_5: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE000             B.N      ??FLASHRAM_WaitForLastOperation_3
    534              }
    535            
    536              /* If there is an error flag set */
    537              return HAL_OK;
   \                     ??FLASHRAM_WaitForLastOperation_6: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??FLASHRAM_WaitForLastOperation_3: (+1)
   \   00000056   0x4770             BX       LR               ;; return
    538          }

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x04152637         DC32     0x4152637

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0xFAFBFCFD         DC32     0xfafbfcfd

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0xE000E008         DC32     0xe000e008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x40023C18         DC32     0x40023c18
    539          
    540            
    541          /**
    542            * @}
    543            */
    544          
    545          /**
    546            * @}
    547            */
    548          
    549          #endif /* HAL_FLASH_MODULE_ENABLED */
    550          /**
    551            * @}
    552            */
    553          
    554               
    555          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASHRAM_WaitForLastOperation
      16   HAL_FLASHEx_DATAEEPROM_EraseDoubleWord
        16   -> FLASHRAM_WaitForLastOperation
      24   HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord
        24   -> FLASHRAM_WaitForLastOperation
       0   HAL_FLASHEx_DisableRunPowerDown
       0   HAL_FLASHEx_EnableRunPowerDown
      16   HAL_FLASHEx_EraseParallelPage
        16   -> FLASHRAM_WaitForLastOperation
      24   HAL_FLASHEx_HalfPageProgram
        24   -> FLASHRAM_WaitForLastOperation
      32   HAL_FLASHEx_ProgramParallelHalfPage
        32   -> FLASHRAM_WaitForLastOperation


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
      88  FLASHRAM_WaitForLastOperation
     122  HAL_FLASHEx_DATAEEPROM_EraseDoubleWord
     122  HAL_FLASHEx_DATAEEPROM_ProgramDoubleWord
      42  HAL_FLASHEx_DisableRunPowerDown
      40  HAL_FLASHEx_EnableRunPowerDown
     122  HAL_FLASHEx_EraseParallelPage
     134  HAL_FLASHEx_HalfPageProgram
     224  HAL_FLASHEx_ProgramParallelHalfPage

 
 922 bytes in section .textrw
 
 922 bytes of CODE memory

Errors: none
Warnings: none
