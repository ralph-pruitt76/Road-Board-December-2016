###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Aug/2017  13:10:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\event_groups.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\event_groups.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
      1          /*
      2              FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          /* FreeRTOS includes. */
     79          #include "FreeRTOS.h"
     80          #include "task.h"
     81          #include "timers.h"
     82          #include "event_groups.h"
     83          
     84          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     85          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     86          header files above, but not in this file, in order to generate the correct
     87          privileged Vs unprivileged linkage and placement. */
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     89          
     90          #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( configUSE_TIMERS == 0 )
     91          	#error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function available.
     92          #endif
     93          
     94          #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
     95          	#error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBitFromISR() function available.
     96          #endif
     97          
     98          /* The following bit fields convey control information in a task's event list
     99          item value.  It is important they don't clash with the
    100          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
    101          #if configUSE_16_BIT_TICKS == 1
    102          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
    103          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
    104          	#define eventWAIT_FOR_ALL_BITS			0x0400U
    105          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
    106          #else
    107          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
    108          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
    109          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
    110          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
    111          #endif
    112          
    113          typedef struct xEventGroupDefinition
    114          {
    115          	EventBits_t uxEventBits;
    116          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
    117          
    118          	#if( configUSE_TRACE_FACILITY == 1 )
    119          		UBaseType_t uxEventGroupNumber;
    120          	#endif
    121          
    122          } EventGroup_t;
    123          
    124          /*-----------------------------------------------------------*/
    125          
    126          /*
    127           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
    128           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
    129           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
    130           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
    131           * wait condition is met if any of the bits set in uxBitsToWait for are also set
    132           * in uxCurrentEventBits.
    133           */
    134          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );
    135          
    136          /*-----------------------------------------------------------*/
    137          

   \                                 In section .text, align 2, keep-with-next
    138          EventGroupHandle_t xEventGroupCreate( void )
    139          {
   \                     xEventGroupCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    140          EventGroup_t *pxEventBits;
    141          
    142          	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
   \   00000002   0x201C             MOVS     R0,#+28
   \   00000004   0x.... 0x....      BL       pvPortMalloc
   \   00000008   0x0004             MOVS     R4,R0
    143          	if( pxEventBits != NULL )
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??xEventGroupCreate_0
    144          	{
    145          		pxEventBits->uxEventBits = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6020             STR      R0,[R4, #+0]
    146          		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \   00000012   0x1D20             ADDS     R0,R4,#+4
   \   00000014   0x.... 0x....      BL       vListInitialise
    147          		traceEVENT_GROUP_CREATE( pxEventBits );
    148          	}
    149          	else
    150          	{
    151          		traceEVENT_GROUP_CREATE_FAILED();
    152          	}
    153          
    154          	return ( EventGroupHandle_t ) pxEventBits;
   \                     ??xEventGroupCreate_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    155          }
    156          /*-----------------------------------------------------------*/
    157          

   \                                 In section .text, align 2, keep-with-next
    158          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    159          {
   \                     xEventGroupSync: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    160          EventBits_t uxOriginalBitValue, uxReturn;
    161          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   0000000C   0x46A2             MOV      R10,R4
    162          BaseType_t xAlreadyYielded;
    163          BaseType_t xTimeoutOccurred = pdFALSE;
   \   0000000E   0xF05F 0x0B00      MOVS     R11,#+0
    164          
    165          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \   00000012   0xF016 0x4F7F      TST      R6,#0xFF000000
   \   00000016   0xD002             BEQ.N    ??xEventGroupSync_0
   \   00000018   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupSync_1: (+1)
   \   0000001C   0xE7FE             B.N      ??xEventGroupSync_1
    166          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupSync_0: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD102             BNE.N    ??xEventGroupSync_2
   \   00000022   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupSync_3: (+1)
   \   00000026   0xE7FE             B.N      ??xEventGroupSync_3
    167          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    168          	{
    169          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupSync_2: (+1)
   \   00000028   0x.... 0x....      BL       xTaskGetSchedulerState
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??xEventGroupSync_4
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD101             BNE.N    ??xEventGroupSync_5
   \                     ??xEventGroupSync_4: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??xEventGroupSync_6
   \                     ??xEventGroupSync_5: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??xEventGroupSync_6: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD102             BNE.N    ??xEventGroupSync_7
   \   00000040   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupSync_8: (+1)
   \   00000044   0xE7FE             B.N      ??xEventGroupSync_8
    170          	}
    171          	#endif
    172          
    173          	vTaskSuspendAll();
   \                     ??xEventGroupSync_7: (+1)
   \   00000046   0x.... 0x....      BL       vTaskSuspendAll
    174          	{
    175          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \   0000004A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000004E   0x4680             MOV      R8,R0
    176          
    177          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       xEventGroupSetBits
    178          
    179          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \   00000058   0xEA55 0x0008      ORRS     R0,R5,R8
   \   0000005C   0x4030             ANDS     R0,R6,R0
   \   0000005E   0x42B0             CMP      R0,R6
   \   00000060   0xD10A             BNE.N    ??xEventGroupSync_9
    180          		{
    181          			/* All the rendezvous bits are now set - no need to block. */
    182          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   \   00000062   0xEA55 0x0008      ORRS     R0,R5,R8
   \   00000066   0x4681             MOV      R9,R0
    183          
    184          			/* Rendezvous always clear the bits.  They will have been cleared
    185          			already unless this is the only task in the rendezvous. */
    186          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \   00000068   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000006C   0x43B0             BICS     R0,R0,R6
   \   0000006E   0xF8CA 0x0000      STR      R0,[R10, #+0]
    187          
    188          			xTicksToWait = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x0007             MOVS     R7,R0
   \   00000076   0xE00E             B.N      ??xEventGroupSync_10
    189          		}
    190          		else
    191          		{
    192          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_9: (+1)
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD009             BEQ.N    ??xEventGroupSync_11
    193          			{
    194          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    195          
    196          				/* Store the bits that the calling task is waiting for in the
    197          				task's event list item so the kernel knows when a match is
    198          				found.  Then enter the blocked state. */
    199          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \   0000007C   0x003A             MOVS     R2,R7
   \   0000007E   0xF056 0x61A0      ORRS     R1,R6,#0x5000000
   \   00000082   0xF11A 0x0004      ADDS     R0,R10,#+4
   \   00000086   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    200          
    201          				/* This assignment is obsolete as uxReturn will get set after
    202          				the task unblocks, but some compilers mistakenly generate a
    203          				warning about uxReturn being returned without being set if the
    204          				assignment is omitted. */
    205          				uxReturn = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4681             MOV      R9,R0
   \   0000008E   0xE002             B.N      ??xEventGroupSync_10
    206          			}
    207          			else
    208          			{
    209          				/* The rendezvous bits were not set, but no block time was
    210          				specified - just return the current event bit value. */
    211          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_11: (+1)
   \   00000090   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000094   0x4681             MOV      R9,R0
    212          			}
    213          		}
    214          	}
    215          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_10: (+1)
   \   00000096   0x.... 0x....      BL       xTaskResumeAll
   \   0000009A   0x9000             STR      R0,[SP, #+0]
    216          
    217          	if( xTicksToWait != ( TickType_t ) 0 )
   \   0000009C   0x2F00             CMP      R7,#+0
   \   0000009E   0xD01E             BEQ.N    ??xEventGroupSync_12
    218          	{
    219          		if( xAlreadyYielded == pdFALSE )
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD101             BNE.N    ??xEventGroupSync_13
    220          		{
    221          			portYIELD_WITHIN_API();
   \   000000A6   0x.... 0x....      BL       vPortYield
    222          		}
    223          		else
    224          		{
    225          			mtCOVERAGE_TEST_MARKER();
    226          		}
    227          
    228          		/* The task blocked to wait for its required bits to be set - at this
    229          		point either the required bits were set or the block time expired.  If
    230          		the required bits were set they will have been stored in the task's
    231          		event list item, and they should now be retrieved then cleared. */
    232          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_13: (+1)
   \   000000AA   0x.... 0x....      BL       uxTaskResetEventItemValue
   \   000000AE   0x4681             MOV      R9,R0
    233          
    234          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \   000000B0   0xEA5F 0x1089      LSLS     R0,R9,#+6
   \   000000B4   0xD411             BMI.N    ??xEventGroupSync_14
    235          		{
    236          			/* The task timed out, just return the current event bit value. */
    237          			taskENTER_CRITICAL();
   \   000000B6   0x.... 0x....      BL       vPortEnterCritical
    238          			{
    239          				uxReturn = pxEventBits->uxEventBits;
   \   000000BA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000BE   0x4681             MOV      R9,R0
    240          
    241          				/* Although the task got here because it timed out before the
    242          				bits it was waiting for were set, it is possible that since it
    243          				unblocked another task has set the bits.  If this is the case
    244          				then it needs to clear the bits before exiting. */
    245          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \   000000C0   0xEA16 0x0009      ANDS     R0,R6,R9
   \   000000C4   0x42B0             CMP      R0,R6
   \   000000C6   0xD104             BNE.N    ??xEventGroupSync_15
    246          				{
    247          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \   000000C8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000CC   0x43B0             BICS     R0,R0,R6
   \   000000CE   0xF8CA 0x0000      STR      R0,[R10, #+0]
    248          				}
    249          				else
    250          				{
    251          					mtCOVERAGE_TEST_MARKER();
    252          				}
    253          			}
    254          			taskEXIT_CRITICAL();
   \                     ??xEventGroupSync_15: (+1)
   \   000000D2   0x.... 0x....      BL       vPortExitCritical
    255          
    256          			xTimeoutOccurred = pdTRUE;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x4683             MOV      R11,R0
    257          		}
    258          		else
    259          		{
    260          			/* The task unblocked because the bits were set. */
    261          		}
    262          
    263          		/* Control bits might be set as the task had blocked should not be
    264          		returned. */
    265          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_14: (+1)
   \   000000DA   0xF029 0x497F      BIC      R9,R9,#0xFF000000
    266          	}
    267          
    268          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    269          
    270          	return uxReturn;
   \                     ??xEventGroupSync_12: (+1)
   \   000000DE   0x4648             MOV      R0,R9
   \   000000E0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    271          }
    272          /*-----------------------------------------------------------*/
    273          

   \                                 In section .text, align 2, keep-with-next
    274          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    275          {
   \                     xEventGroupWaitBits: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F0E             LDR      R7,[SP, #+56]
    276          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   0000000E   0xF8DD 0x8010      LDR      R8,[SP, #+16]
    277          EventBits_t uxReturn, uxControlBits = 0;
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    278          BaseType_t xWaitConditionMet, xAlreadyYielded;
    279          BaseType_t xTimeoutOccurred = pdFALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x9000             STR      R0,[SP, #+0]
    280          
    281          	/* Check the user is not attempting to wait on the bits used by the kernel
    282          	itself, and that at least one bit is being requested. */
    283          	configASSERT( xEventGroup );
   \   0000001A   0x9804             LDR      R0,[SP, #+16]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD102             BNE.N    ??xEventGroupWaitBits_0
   \   00000020   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupWaitBits_1: (+1)
   \   00000024   0xE7FE             B.N      ??xEventGroupWaitBits_1
    284          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupWaitBits_0: (+1)
   \   00000026   0xF014 0x4F7F      TST      R4,#0xFF000000
   \   0000002A   0xD002             BEQ.N    ??xEventGroupWaitBits_2
   \   0000002C   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupWaitBits_3: (+1)
   \   00000030   0xE7FE             B.N      ??xEventGroupWaitBits_3
    285          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupWaitBits_2: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD102             BNE.N    ??xEventGroupWaitBits_4
   \   00000036   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupWaitBits_5: (+1)
   \   0000003A   0xE7FE             B.N      ??xEventGroupWaitBits_5
    286          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    287          	{
    288          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupWaitBits_4: (+1)
   \   0000003C   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD101             BNE.N    ??xEventGroupWaitBits_6
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD101             BNE.N    ??xEventGroupWaitBits_7
   \                     ??xEventGroupWaitBits_6: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??xEventGroupWaitBits_8
   \                     ??xEventGroupWaitBits_7: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??xEventGroupWaitBits_8: (+1)
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD102             BNE.N    ??xEventGroupWaitBits_9
   \   00000054   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupWaitBits_10: (+1)
   \   00000058   0xE7FE             B.N      ??xEventGroupWaitBits_10
    289          	}
    290          	#endif
    291          
    292          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_9: (+1)
   \   0000005A   0x.... 0x....      BL       vTaskSuspendAll
    293          	{
    294          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \   0000005E   0xF8D8 0xB000      LDR      R11,[R8, #+0]
    295          
    296          		/* Check to see if the wait condition is already met or not. */
    297          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
   \   00000062   0x0032             MOVS     R2,R6
   \   00000064   0x0021             MOVS     R1,R4
   \   00000066   0x4658             MOV      R0,R11
   \   00000068   0x.... 0x....      BL       prvTestWaitCondition
   \   0000006C   0x9002             STR      R0,[SP, #+8]
    298          
    299          		if( xWaitConditionMet != pdFALSE )
   \   0000006E   0x9802             LDR      R0,[SP, #+8]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00A             BEQ.N    ??xEventGroupWaitBits_11
    300          		{
    301          			/* The wait condition has already been met so there is no need to
    302          			block. */
    303          			uxReturn = uxCurrentEventBits;
   \   00000074   0x46D9             MOV      R9,R11
    304          			xTicksToWait = ( TickType_t ) 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x0007             MOVS     R7,R0
    305          
    306          			/* Clear the wait bits if requested to do so. */
    307          			if( xClearOnExit != pdFALSE )
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD01A             BEQ.N    ??xEventGroupWaitBits_12
    308          			{
    309          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \   0000007E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000082   0x43A0             BICS     R0,R0,R4
   \   00000084   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   00000088   0xE014             B.N      ??xEventGroupWaitBits_12
    310          			}
    311          			else
    312          			{
    313          				mtCOVERAGE_TEST_MARKER();
    314          			}
    315          		}
    316          		else if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xEventGroupWaitBits_11: (+1)
   \   0000008A   0x2F00             CMP      R7,#+0
   \   0000008C   0xD101             BNE.N    ??xEventGroupWaitBits_13
    317          		{
    318          			/* The wait condition has not been met, but no block time was
    319          			specified, so just return the current value. */
    320          			uxReturn = uxCurrentEventBits;
   \   0000008E   0x46D9             MOV      R9,R11
   \   00000090   0xE010             B.N      ??xEventGroupWaitBits_12
    321          		}
    322          		else
    323          		{
    324          			/* The task is going to block to wait for its required bits to be
    325          			set.  uxControlBits are used to remember the specified behaviour of
    326          			this call to xEventGroupWaitBits() - for use when the event bits
    327          			unblock the task. */
    328          			if( xClearOnExit != pdFALSE )
   \                     ??xEventGroupWaitBits_13: (+1)
   \   00000092   0x2D00             CMP      R5,#+0
   \   00000094   0xD001             BEQ.N    ??xEventGroupWaitBits_14
    329          			{
    330          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \   00000096   0xF05A 0x7A80      ORRS     R10,R10,#0x1000000
    331          			}
    332          			else
    333          			{
    334          				mtCOVERAGE_TEST_MARKER();
    335          			}
    336          
    337          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_14: (+1)
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD001             BEQ.N    ??xEventGroupWaitBits_15
    338          			{
    339          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   \   0000009E   0xF05A 0x6A80      ORRS     R10,R10,#0x4000000
    340          			}
    341          			else
    342          			{
    343          				mtCOVERAGE_TEST_MARKER();
    344          			}
    345          
    346          			/* Store the bits that the calling task is waiting for in the
    347          			task's event list item so the kernel knows when a match is
    348          			found.  Then enter the blocked state. */
    349          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \                     ??xEventGroupWaitBits_15: (+1)
   \   000000A2   0x003A             MOVS     R2,R7
   \   000000A4   0xEA5A 0x0104      ORRS     R1,R10,R4
   \   000000A8   0xF118 0x0004      ADDS     R0,R8,#+4
   \   000000AC   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    350          
    351          			/* This is obsolete as it will get set after the task unblocks, but
    352          			some compilers mistakenly generate a warning about the variable
    353          			being returned without being set if it is not done. */
    354          			uxReturn = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x4681             MOV      R9,R0
    355          
    356          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    357          		}
    358          	}
    359          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_12: (+1)
   \   000000B4   0x.... 0x....      BL       xTaskResumeAll
   \   000000B8   0x9001             STR      R0,[SP, #+4]
    360          
    361          	if( xTicksToWait != ( TickType_t ) 0 )
   \   000000BA   0x2F00             CMP      R7,#+0
   \   000000BC   0xD023             BEQ.N    ??xEventGroupWaitBits_16
    362          	{
    363          		if( xAlreadyYielded == pdFALSE )
   \   000000BE   0x9801             LDR      R0,[SP, #+4]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD101             BNE.N    ??xEventGroupWaitBits_17
    364          		{
    365          			portYIELD_WITHIN_API();
   \   000000C4   0x.... 0x....      BL       vPortYield
    366          		}
    367          		else
    368          		{
    369          			mtCOVERAGE_TEST_MARKER();
    370          		}
    371          
    372          		/* The task blocked to wait for its required bits to be set - at this
    373          		point either the required bits were set or the block time expired.  If
    374          		the required bits were set they will have been stored in the task's
    375          		event list item, and they should now be retrieved then cleared. */
    376          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_17: (+1)
   \   000000C8   0x.... 0x....      BL       uxTaskResetEventItemValue
   \   000000CC   0x4681             MOV      R9,R0
    377          
    378          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \   000000CE   0xEA5F 0x1089      LSLS     R0,R9,#+6
   \   000000D2   0xD416             BMI.N    ??xEventGroupWaitBits_18
    379          		{
    380          			taskENTER_CRITICAL();
   \   000000D4   0x.... 0x....      BL       vPortEnterCritical
    381          			{
    382          				/* The task timed out, just return the current event bit value. */
    383          				uxReturn = pxEventBits->uxEventBits;
   \   000000D8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000DC   0x4681             MOV      R9,R0
    384          
    385          				/* It is possible that the event bits were updated between this
    386          				task leaving the Blocked state and running again. */
    387          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \   000000DE   0x0032             MOVS     R2,R6
   \   000000E0   0x0021             MOVS     R1,R4
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       prvTestWaitCondition
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD006             BEQ.N    ??xEventGroupWaitBits_19
    388          				{
    389          					if( xClearOnExit != pdFALSE )
   \   000000EC   0x2D00             CMP      R5,#+0
   \   000000EE   0xD004             BEQ.N    ??xEventGroupWaitBits_19
    390          					{
    391          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \   000000F0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000F4   0x43A0             BICS     R0,R0,R4
   \   000000F6   0xF8C8 0x0000      STR      R0,[R8, #+0]
    392          					}
    393          					else
    394          					{
    395          						mtCOVERAGE_TEST_MARKER();
    396          					}
    397          				}
    398          				else
    399          				{
    400          					mtCOVERAGE_TEST_MARKER();
    401          				}
    402          			}
    403          			taskEXIT_CRITICAL();
   \                     ??xEventGroupWaitBits_19: (+1)
   \   000000FA   0x.... 0x....      BL       vPortExitCritical
    404          
    405          			/* Prevent compiler warnings when trace macros are not used. */
    406          			xTimeoutOccurred = pdFALSE;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9000             STR      R0,[SP, #+0]
    407          		}
    408          		else
    409          		{
    410          			/* The task unblocked because the bits were set. */
    411          		}
    412          
    413          		/* The task blocked so control bits may have been set. */
    414          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_18: (+1)
   \   00000102   0xF029 0x497F      BIC      R9,R9,#0xFF000000
    415          	}
    416          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    417          
    418          	return uxReturn;
   \                     ??xEventGroupWaitBits_16: (+1)
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0xB005             ADD      SP,SP,#+20
   \   0000010A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    419          }
    420          /*-----------------------------------------------------------*/
    421          

   \                                 In section .text, align 2, keep-with-next
    422          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    423          {
   \                     xEventGroupClearBits: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    424          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   00000006   0x0026             MOVS     R6,R4
    425          EventBits_t uxReturn;
    426          
    427          	/* Check the user is not attempting to clear the bits used by the kernel
    428          	itself. */
    429          	configASSERT( xEventGroup );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD102             BNE.N    ??xEventGroupClearBits_0
   \   0000000C   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupClearBits_1: (+1)
   \   00000010   0xE7FE             B.N      ??xEventGroupClearBits_1
    430          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupClearBits_0: (+1)
   \   00000012   0xF015 0x4F7F      TST      R5,#0xFF000000
   \   00000016   0xD002             BEQ.N    ??xEventGroupClearBits_2
   \   00000018   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupClearBits_3: (+1)
   \   0000001C   0xE7FE             B.N      ??xEventGroupClearBits_3
    431          
    432          	taskENTER_CRITICAL();
   \                     ??xEventGroupClearBits_2: (+1)
   \   0000001E   0x.... 0x....      BL       vPortEnterCritical
    433          	{
    434          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    435          
    436          		/* The value returned is the event group value prior to the bits being
    437          		cleared. */
    438          		uxReturn = pxEventBits->uxEventBits;
   \   00000022   0x6830             LDR      R0,[R6, #+0]
   \   00000024   0x0007             MOVS     R7,R0
    439          
    440          		/* Clear the bits. */
    441          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \   00000026   0x6830             LDR      R0,[R6, #+0]
   \   00000028   0x43A8             BICS     R0,R0,R5
   \   0000002A   0x6030             STR      R0,[R6, #+0]
    442          	}
    443          	taskEXIT_CRITICAL();
   \   0000002C   0x.... 0x....      BL       vPortExitCritical
    444          
    445          	return uxReturn;
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    446          }
    447          /*-----------------------------------------------------------*/
    448          
    449          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    450          
    451          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    452          	{
    453          		BaseType_t xReturn;
    454          
    455          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    456          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
    457          
    458          		return xReturn;
    459          	}
    460          
    461          #endif
    462          /*-----------------------------------------------------------*/
    463          

   \                                 In section .text, align 2, keep-with-next
    464          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    465          {
   \                     xEventGroupGetBitsFromISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    466          UBaseType_t uxSavedInterruptStatus;
    467          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    468          EventBits_t uxReturn;
    469          
    470          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000004   0x.... 0x....      BL       ulPortSetInterruptMask
   \   00000008   0x0005             MOVS     R5,R0
    471          	{
    472          		uxReturn = pxEventBits->uxEventBits;
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x0006             MOVS     R6,R0
    473          	}
    474          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       vPortClearInterruptMask
    475          
    476          	return uxReturn;
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    477          }
    478          /*-----------------------------------------------------------*/
    479          

   \                                 In section .text, align 2, keep-with-next
    480          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    481          {
   \                     xEventGroupSetBits: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    482          ListItem_t *pxListItem, *pxNext;
    483          ListItem_t const *pxListEnd;
    484          List_t *pxList;
    485          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    486          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   0000000C   0x46A2             MOV      R10,R4
    487          BaseType_t xMatchFound = pdFALSE;
   \   0000000E   0xF05F 0x0B00      MOVS     R11,#+0
    488          
    489          	/* Check the user is not attempting to set the bits used by the kernel
    490          	itself. */
    491          	configASSERT( xEventGroup );
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD102             BNE.N    ??xEventGroupSetBits_0
   \   00000016   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupSetBits_1: (+1)
   \   0000001A   0xE7FE             B.N      ??xEventGroupSetBits_1
    492          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupSetBits_0: (+1)
   \   0000001C   0xF015 0x4F7F      TST      R5,#0xFF000000
   \   00000020   0xD002             BEQ.N    ??xEventGroupSetBits_2
   \   00000022   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??xEventGroupSetBits_3: (+1)
   \   00000026   0xE7FE             B.N      ??xEventGroupSetBits_3
    493          
    494          	pxList = &( pxEventBits->xTasksWaitingForBits );
   \                     ??xEventGroupSetBits_2: (+1)
   \   00000028   0xF11A 0x0004      ADDS     R0,R10,#+4
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    495          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x3008             ADDS     R0,R0,#+8
   \   00000032   0x9001             STR      R0,[SP, #+4]
    496          	vTaskSuspendAll();
   \   00000034   0x.... 0x....      BL       vTaskSuspendAll
    497          	{
    498          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    499          
    500          		pxListItem = listGET_HEAD_ENTRY( pxList );
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x68C0             LDR      R0,[R0, #+12]
   \   0000003C   0x0006             MOVS     R6,R0
    501          
    502          		/* Set the bits. */
    503          		pxEventBits->uxEventBits |= uxBitsToSet;
   \   0000003E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000042   0x4328             ORRS     R0,R5,R0
   \   00000044   0xF8CA 0x0000      STR      R0,[R10, #+0]
    504          
    505          		/* See if the new bit value should unblock any tasks. */
    506          		while( pxListItem != pxListEnd )
   \                     ??xEventGroupSetBits_4: (+1)
   \   00000048   0x9801             LDR      R0,[SP, #+4]
   \   0000004A   0x4286             CMP      R6,R0
   \   0000004C   0xD02D             BEQ.N    ??xEventGroupSetBits_5
    507          		{
    508          			pxNext = listGET_NEXT( pxListItem );
   \   0000004E   0x6870             LDR      R0,[R6, #+4]
   \   00000050   0x9002             STR      R0,[SP, #+8]
    509          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0x0007             MOVS     R7,R0
    510          			xMatchFound = pdFALSE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4683             MOV      R11,R0
    511          
    512          			/* Split the bits waited for from the control bits. */
    513          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   \   0000005A   0xF017 0x407F      ANDS     R0,R7,#0xFF000000
   \   0000005E   0x4680             MOV      R8,R0
    514          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   \   00000060   0xF027 0x477F      BIC      R7,R7,#0xFF000000
    515          
    516          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   \   00000064   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   00000068   0xD406             BMI.N    ??xEventGroupSetBits_6
    517          			{
    518          				/* Just looking for single bit being set. */
    519          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
   \   0000006A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000006E   0x4207             TST      R7,R0
   \   00000070   0xD009             BEQ.N    ??xEventGroupSetBits_7
    520          				{
    521          					xMatchFound = pdTRUE;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x4683             MOV      R11,R0
   \   00000076   0xE006             B.N      ??xEventGroupSetBits_7
    522          				}
    523          				else
    524          				{
    525          					mtCOVERAGE_TEST_MARKER();
    526          				}
    527          			}
    528          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \                     ??xEventGroupSetBits_6: (+1)
   \   00000078   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000007C   0x4038             ANDS     R0,R0,R7
   \   0000007E   0x42B8             CMP      R0,R7
   \   00000080   0xD101             BNE.N    ??xEventGroupSetBits_7
    529          			{
    530          				/* All bits are set. */
    531          				xMatchFound = pdTRUE;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x4683             MOV      R11,R0
    532          			}
    533          			else
    534          			{
    535          				/* Need all bits to be set, but not all the bits were set. */
    536          			}
    537          
    538          			if( xMatchFound != pdFALSE )
   \                     ??xEventGroupSetBits_7: (+1)
   \   00000086   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000008A   0xD00B             BEQ.N    ??xEventGroupSetBits_8
    539          			{
    540          				/* The bits match.  Should the bits be cleared on exit? */
    541          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \   0000008C   0xEA5F 0x10C8      LSLS     R0,R8,#+7
   \   00000090   0xD501             BPL.N    ??xEventGroupSetBits_9
    542          				{
    543          					uxBitsToClear |= uxBitsWaitedFor;
   \   00000092   0xEA57 0x0909      ORRS     R9,R7,R9
    544          				}
    545          				else
    546          				{
    547          					mtCOVERAGE_TEST_MARKER();
    548          				}
    549          
    550          				/* Store the actual event flag value in the task's event list
    551          				item before removing the task from the event list.  The
    552          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    553          				that is was unblocked due to its required bits matching, rather
    554          				than because it timed out. */
    555          				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??xEventGroupSetBits_9: (+1)
   \   00000096   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000009A   0xF050 0x7100      ORRS     R1,R0,#0x2000000
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
    556          			}
    557          
    558          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    559          			used here as the list item may have been removed from the event list
    560          			and inserted into the ready/pending reading list. */
    561          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_8: (+1)
   \   000000A4   0x9802             LDR      R0,[SP, #+8]
   \   000000A6   0x0006             MOVS     R6,R0
   \   000000A8   0xE7CE             B.N      ??xEventGroupSetBits_4
    562          		}
    563          
    564          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    565          		bit was set in the control word. */
    566          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_5: (+1)
   \   000000AA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000AE   0xEA30 0x0009      BICS     R0,R0,R9
   \   000000B2   0xF8CA 0x0000      STR      R0,[R10, #+0]
    567          	}
    568          	( void ) xTaskResumeAll();
   \   000000B6   0x.... 0x....      BL       xTaskResumeAll
    569          
    570          	return pxEventBits->uxEventBits;
   \   000000BA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000BE   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    571          }
    572          /*-----------------------------------------------------------*/
    573          

   \                                 In section .text, align 2, keep-with-next
    574          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    575          {
   \                     vEventGroupDelete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    576          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   00000004   0x0025             MOVS     R5,R4
    577          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   \   00000006   0x1D2E             ADDS     R6,R5,#+4
    578          
    579          	vTaskSuspendAll();
   \   00000008   0x.... 0x....      BL       vTaskSuspendAll
    580          	{
    581          		traceEVENT_GROUP_DELETE( xEventGroup );
    582          
    583          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
   \                     ??vEventGroupDelete_0: (+1)
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00D             BEQ.N    ??vEventGroupDelete_1
    584          		{
    585          			/* Unblock the task, returning 0 as the event list is being deleted
    586          			and	cannot therefore have any bits set. */
    587          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
   \   00000012   0x68F0             LDR      R0,[R6, #+12]
   \   00000014   0xF116 0x0108      ADDS     R1,R6,#+8
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD102             BNE.N    ??vEventGroupDelete_2
   \   0000001C   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??vEventGroupDelete_3: (+1)
   \   00000020   0xE7FE             B.N      ??vEventGroupDelete_3
    588          			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??vEventGroupDelete_2: (+1)
   \   00000022   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000026   0x68F0             LDR      R0,[R6, #+12]
   \   00000028   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
   \   0000002C   0xE7EE             B.N      ??vEventGroupDelete_0
    589          		}
    590          
    591          		vPortFree( pxEventBits );
   \                     ??vEventGroupDelete_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       vPortFree
    592          	}
    593          	( void ) xTaskResumeAll();
   \   00000034   0x.... 0x....      BL       xTaskResumeAll
    594          }
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    595          /*-----------------------------------------------------------*/
    596          
    597          /* For internal use only - execute a 'set bits' command that was pended from
    598          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    599          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    600          {
   \                     vEventGroupSetBitsCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    601          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       xEventGroupSetBits
    602          }
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    603          /*-----------------------------------------------------------*/
    604          
    605          /* For internal use only - execute a 'clear bits' command that was pended from
    606          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    607          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    608          {
   \                     vEventGroupClearBitsCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    609          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       xEventGroupClearBits
    610          }
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    611          /*-----------------------------------------------------------*/
    612          

   \                                 In section .text, align 2, keep-with-next
    613          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    614          {
   \                     prvTestWaitCondition: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    615          BaseType_t xWaitConditionMet = pdFALSE;
   \   00000004   0x2000             MOVS     R0,#+0
    616          
    617          	if( xWaitForAllBits == pdFALSE )
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD104             BNE.N    ??prvTestWaitCondition_0
    618          	{
    619          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    620          		set.  Is one already set? */
    621          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \   0000000A   0x420B             TST      R3,R1
   \   0000000C   0xD008             BEQ.N    ??prvTestWaitCondition_1
    622          		{
    623          			xWaitConditionMet = pdTRUE;
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xE005             B.N      ??prvTestWaitCondition_1
    624          		}
    625          		else
    626          		{
    627          			mtCOVERAGE_TEST_MARKER();
    628          		}
    629          	}
    630          	else
    631          	{
    632          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    633          		Are they set already? */
    634          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \   00000014   0xEA11 0x0403      ANDS     R4,R1,R3
   \   00000018   0x428C             CMP      R4,R1
   \   0000001A   0xD101             BNE.N    ??prvTestWaitCondition_1
    635          		{
    636          			xWaitConditionMet = pdTRUE;
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x0020             MOVS     R0,R4
    637          		}
    638          		else
    639          		{
    640          			mtCOVERAGE_TEST_MARKER();
    641          		}
    642          	}
    643          
    644          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    645          }
    646          /*-----------------------------------------------------------*/
    647          
    648          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    649          
    650          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    651          	{
    652          	BaseType_t xReturn;
    653          
    654          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    655          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
    656          
    657          		return xReturn;
    658          	}
    659          
    660          #endif
    661          /*-----------------------------------------------------------*/
    662          
    663          #if (configUSE_TRACE_FACILITY == 1)
    664          

   \                                 In section .text, align 2, keep-with-next
    665          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    666          	{
   \                     uxEventGroupGetNumber: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    667          	UBaseType_t xReturn;
    668          	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \   00000002   0x000A             MOVS     R2,R1
    669          
    670          		if( xEventGroup == NULL )
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE.N    ??uxEventGroupGetNumber_0
    671          		{
    672          			xReturn = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0018             MOVS     R0,R3
   \   0000000C   0xE001             B.N      ??uxEventGroupGetNumber_1
    673          		}
    674          		else
    675          		{
    676          			xReturn = pxEventBits->uxEventGroupNumber;
   \                     ??uxEventGroupGetNumber_0: (+1)
   \   0000000E   0x6993             LDR      R3,[R2, #+24]
   \   00000010   0x0018             MOVS     R0,R3
    677          		}
    678          
    679          		return xReturn;
   \                     ??uxEventGroupGetNumber_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    680          	}
    681          
    682          #endif
    683          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   prvTestWaitCondition
       0   uxEventGroupGetNumber
      16   vEventGroupClearBitsCallback
        16   -> xEventGroupClearBits
      16   vEventGroupDelete
        16   -> ulPortSetInterruptMask
        16   -> vPortFree
        16   -> vTaskSuspendAll
        16   -> xTaskRemoveFromUnorderedEventList
        16   -> xTaskResumeAll
      16   vEventGroupSetBitsCallback
        16   -> xEventGroupSetBits
      24   xEventGroupClearBits
        24   -> ulPortSetInterruptMask
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
      16   xEventGroupGetBitsFromISR
        16   -> ulPortSetInterruptMask
        16   -> vPortClearInterruptMask
      48   xEventGroupSetBits
        48   -> ulPortSetInterruptMask
        48   -> vTaskSuspendAll
        48   -> xTaskRemoveFromUnorderedEventList
        48   -> xTaskResumeAll
      40   xEventGroupSync
        40   -> ulPortSetInterruptMask
        40   -> uxTaskResetEventItemValue
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYield
        40   -> vTaskPlaceOnUnorderedEventList
        40   -> vTaskSuspendAll
        40   -> xEventGroupSetBits
        40   -> xTaskGetSchedulerState
        40   -> xTaskResumeAll
      56   xEventGroupWaitBits
        56   -> prvTestWaitCondition
        56   -> ulPortSetInterruptMask
        56   -> uxTaskResetEventItemValue
        56   -> vPortEnterCritical
        56   -> vPortExitCritical
        56   -> vPortYield
        56   -> vTaskPlaceOnUnorderedEventList
        56   -> vTaskSuspendAll
        56   -> xTaskGetSchedulerState
        56   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  prvTestWaitCondition
      20  uxEventGroupGetNumber
      16  vEventGroupClearBitsCallback
      58  vEventGroupDelete
      16  vEventGroupSetBitsCallback
      52  xEventGroupClearBits
      28  xEventGroupCreate
      24  xEventGroupGetBitsFromISR
     194  xEventGroupSetBits
     228  xEventGroupSync
     270  xEventGroupWaitBits

 
 942 bytes in section .text
 
 942 bytes of CODE memory

Errors: none
Warnings: none
