###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       26/Jul/2017  13:52:32
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\List\usart.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\Road
#        Brd MSTR Rev L Long Always\Obj\usart.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : USART.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the USART instances.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "usart.h"
     37          #include <string.h>
     38          
     39          #include "gpio.h"
     40          
     41          /* USER CODE BEGIN 0 */
     42          /* Buffer used for transmission */

   \                                 In section .bss, align 4
     43          uint8_t aTxBuffer[TXBUFFERSIZE];
   \                     aTxBuffer:
   \   00000000                      DS8 120
     44          
     45          /* Buffer used for reception */

   \                                 In section .bss, align 4
     46          uint8_t aRxBuffer[RXBUFFERSIZE];
   \                     aRxBuffer:
   \   00000000                      DS8 120
     47          

   \                                 In section .bss, align 1
     48          __IO ITStatus Uart2Ready = RESET;
   \                     Uart2Ready:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     49          __IO ITStatus Uart3Ready = RESET;
   \                     Uart3Ready:
   \   00000000                      DS8 1
     50          
     51          /* USER CODE END 0 */
     52          

   \                                 In section .bss, align 4
     53          UART_HandleTypeDef huart2;
   \                     huart2:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     54          UART_HandleTypeDef huart3;
   \                     huart3:
   \   00000000                      DS8 64
     55          
     56          #ifndef PATCH_UART

   \                                 In section .bss, align 4
     57            static uint8_t bgm1data[40];
   \                     bgm1data:
   \   00000000                      DS8 40

   \                                 In section .bss, align 1
     58            static bool bffr1Flag = false;
   \                     bffr1Flag:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
     59            static int saveLen = 3;
   \                     saveLen:
   \   00000000   0x00000003         DC32 3
     60          #endif
     61          
     62          /* USART2 init function */
     63          

   \                                 In section .text, align 2, keep-with-next
     64          void MX_USART2_UART_Init(void)
     65          {
   \                     MX_USART2_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     66          
     67            huart2.Instance = USART2;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40004400
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     68            huart2.Init.BaudRate = 19200;  // 9600Baud
   \   0000000C   0xF44F 0x4096      MOV      R0,#+19200
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000014   0x6048             STR      R0,[R1, #+4]
     69            huart2.Init.WordLength = UART_WORDLENGTH_8B;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     70            huart2.Init.StopBits = UART_STOPBITS_1;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     71            huart2.Init.Parity = UART_PARITY_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000002C   0x6108             STR      R0,[R1, #+16]
     72            huart2.Init.Mode = UART_MODE_TX_RX;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000034   0x6148             STR      R0,[R1, #+20]
     73            huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000003C   0x6188             STR      R0,[R1, #+24]
     74            huart2.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000044   0x61C8             STR      R0,[R1, #+28]
     75            if (HAL_UART_Init(&huart2) != HAL_OK)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000004A   0x.... 0x....      BL       HAL_UART_Init
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??MX_USART2_UART_Init_0
     76            {
     77              Error_Handler();
   \   00000052   0x.... 0x....      BL       Error_Handler
     78            }
     79          
     80          }
   \                     ??MX_USART2_UART_Init_0: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
     81          /* USART3 init function */
     82          

   \                                 In section .text, align 2, keep-with-next
     83          void MX_USART3_UART_Init(void)
     84          {
   \                     MX_USART3_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     85          
     86            huart3.Instance = USART3;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40004800
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     87            huart3.Init.BaudRate = 115200;  // 9600Baud
   \   0000000C   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000014   0x6048             STR      R0,[R1, #+4]
     88            huart3.Init.WordLength = UART_WORDLENGTH_8B;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     89            huart3.Init.StopBits = UART_STOPBITS_1;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     90            huart3.Init.Parity = UART_PARITY_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000002C   0x6108             STR      R0,[R1, #+16]
     91            huart3.Init.Mode = UART_MODE_TX_RX;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000034   0x6148             STR      R0,[R1, #+20]
     92          #ifdef TEST2
     93            huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
     94          #else
     95            #ifdef PATCH_UART
     96              huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
     97            #else
     98              huart3.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
   \   00000036   0xF44F 0x7040      MOV      R0,#+768
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000003E   0x6188             STR      R0,[R1, #+24]
     99            #endif
    100          //  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    101          #endif
    102            huart3.Init.OverSampling = UART_OVERSAMPLING_16;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000046   0x61C8             STR      R0,[R1, #+28]
    103            if (HAL_UART_Init(&huart3) != HAL_OK)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000004C   0x.... 0x....      BL       HAL_UART_Init
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD001             BEQ.N    ??MX_USART3_UART_Init_0
    104            {
    105              Error_Handler();
   \   00000054   0x.... 0x....      BL       Error_Handler
    106            }
    107          
    108          }
   \                     ??MX_USART3_UART_Init_0: (+1)
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
    111          {
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    112          
    113            GPIO_InitTypeDef GPIO_InitStruct;
    114            if(uartHandle->Instance==USART2)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40004400
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD11E             BNE.N    ??HAL_UART_MspInit_0
    115            {
    116            /* USER CODE BEGIN USART2_MspInit 0 */
    117          
    118            /* USER CODE END USART2_MspInit 0 */
    119              /* Peripheral clock enable */
    120              __HAL_RCC_USART2_CLK_ENABLE();
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF410 0x3000      ANDS     R0,R0,#0x20000
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
    121            
    122              /**USART2 GPIO Configuration    
    123              PA2     ------> USART2_TX
    124              PA3     ------> USART2_RX 
    125              */
    126              GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x9001             STR      R0,[SP, #+4]
    127              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
    128              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9003             STR      R0,[SP, #+12]
    129              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    130              GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
   \   0000003E   0x2007             MOVS     R0,#+7
   \   00000040   0x9005             STR      R0,[SP, #+20]
    131              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40020000
   \   00000048   0x.... 0x....      BL       HAL_GPIO_Init
   \   0000004C   0xE033             B.N      ??HAL_UART_MspInit_1
    132          
    133            /* USER CODE BEGIN USART2_MspInit 1 */
    134          
    135            /* USER CODE END USART2_MspInit 1 */
    136            }
    137            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40004800
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD12E             BNE.N    ??HAL_UART_MspInit_1
    138            {
    139            /* USER CODE BEGIN USART3_MspInit 0 */
    140          
    141            /* USER CODE END USART3_MspInit 0 */
    142              /* Peripheral clock enable */
    143              __HAL_RCC_USART3_CLK_ENABLE();
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF410 0x2080      ANDS     R0,R0,#0x40000
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x9800             LDR      R0,[SP, #+0]
    144            
    145              /**USART3 GPIO Configuration    
    146              PB10     ------> USART3_TX
    147              PB11     ------> USART3_RX
    148              PB13     ------> USART3_CTS
    149              PB14     ------> USART3_RTS 
    150              */
    151              GPIO_InitStruct.Pin = TX_BGM111_Pin|RX_BGM111_Pin;
   \   00000076   0xF44F 0x6040      MOV      R0,#+3072
   \   0000007A   0x9001             STR      R0,[SP, #+4]
    152              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x9002             STR      R0,[SP, #+8]
    153              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x9003             STR      R0,[SP, #+12]
    154              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x9004             STR      R0,[SP, #+16]
    155              GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
   \   00000088   0x2007             MOVS     R0,#+7
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    156              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   00000092   0x.... 0x....      BL       HAL_GPIO_Init
    157          
    158              GPIO_InitStruct.Pin = CTS_BGM111_Pin|RTS_BGM111_Pin;
   \   00000096   0xF44F 0x40C0      MOV      R0,#+24576
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    159              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    160              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9003             STR      R0,[SP, #+12]
    161              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x9004             STR      R0,[SP, #+16]
    162              GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
   \   000000A8   0x2007             MOVS     R0,#+7
   \   000000AA   0x9005             STR      R0,[SP, #+20]
    163              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_Init
    164          
    165            /* USER CODE BEGIN USART3_MspInit 1 */
    166          
    167            /* USER CODE END USART3_MspInit 1 */
    168            }
    169          }
   \                     ??HAL_UART_MspInit_1: (+1)
   \   000000B6   0xB006             ADD      SP,SP,#+24
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    170          

   \                                 In section .text, align 2, keep-with-next
    171          void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
    172          {
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173          
    174            if(uartHandle->Instance==USART2)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40004400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD10D             BNE.N    ??HAL_UART_MspDeInit_0
    175            {
    176            /* USER CODE BEGIN USART2_MspDeInit 0 */
    177          
    178            /* USER CODE END USART2_MspDeInit 0 */
    179              /* Peripheral clock disable */
    180              __HAL_RCC_USART2_CLK_DISABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    181            
    182              /**USART2 GPIO Configuration    
    183              PA2     ------> USART2_TX
    184              PA3     ------> USART2_RX 
    185              */
    186              HAL_GPIO_DeInit(GPIOA, USART_TX_Pin|USART_RX_Pin);
   \   0000001E   0x210C             MOVS     R1,#+12
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40020000
   \   00000024   0x.... 0x....      BL       HAL_GPIO_DeInit
   \   00000028   0xE012             B.N      ??HAL_UART_MspDeInit_1
    187          
    188            /* USER CODE BEGIN USART2_MspDeInit 1 */
    189          
    190            /* USER CODE END USART2_MspDeInit 1 */
    191            }
    192            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_MspDeInit_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40004800
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD10D             BNE.N    ??HAL_UART_MspDeInit_1
    193            {
    194            /* USER CODE BEGIN USART3_MspDeInit 0 */
    195          
    196            /* USER CODE END USART3_MspDeInit 0 */
    197              /* Peripheral clock disable */
    198              __HAL_RCC_USART3_CLK_DISABLE();
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   00000042   0x6008             STR      R0,[R1, #+0]
    199            
    200              /**USART3 GPIO Configuration    
    201              PB10     ------> USART3_TX
    202              PB11     ------> USART3_RX
    203              PB13     ------> USART3_CTS
    204              PB14     ------> USART3_RTS 
    205              */
    206              HAL_GPIO_DeInit(GPIOB, TX_BGM111_Pin|RX_BGM111_Pin|CTS_BGM111_Pin|RTS_BGM111_Pin);
   \   00000044   0xF44F 0x41D8      MOV      R1,#+27648
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_DeInit
    207          
    208            /* USER CODE BEGIN USART3_MspDeInit 1 */
    209          
    210            /* USER CODE END USART3_MspDeInit 1 */
    211            }
    212          } 
   \                     ??HAL_UART_MspDeInit_1: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    213          
    214          /* USER CODE BEGIN 1 */
    215          /**
    216            * @brief  RoadBrd_UART_Transmit
    217            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    218            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel
    219            *         in a blocking mode. 
    220            *         It does wait for completion.
    221            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    222            *                                HAL_ERROR:    Error found in Tasking or data passed.
    223            *                                HAL_BUSY:     UART is busy.
    224            *                                HAL_TIMEOUT:  UART timed out.
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          HAL_StatusTypeDef RoadBrd_UART_Transmit(RoadBrd_uart_TypeDef Port, uint8_t *pData)
    227          {
   \                     RoadBrd_UART_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    228            HAL_StatusTypeDef Status;
    229            uint16_t Size;
    230            
    231            Size = strlen((char *)pData);  
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0007             MOVS     R7,R0
    232            // Test parameters before starting process
    233            if (Size > TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F79             CMP      R7,#+121
   \   00000012   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_0
    234              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE03A             B.N      ??RoadBrd_UART_Transmit_1
    235            
    236            // Test Port to determine which uart to use for this transfer.
    237            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD119             BNE.N    ??RoadBrd_UART_Transmit_2
    238            {
    239              // Is UART Busy right now?
    240              if (Uart2Ready != RESET)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_3
    241                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE030             B.N      ??RoadBrd_UART_Transmit_1
    242              else
    243              {
    244                Status = HAL_UART_Transmit(&huart2, (uint8_t*)pData, Size, HAL_MAX_DELAY);
   \                     ??RoadBrd_UART_Transmit_3: (+1)
   \   0000002C   0xF44F 0x4300      MOV      R3,#+32768
   \   00000030   0x003A             MOVS     R2,R7
   \   00000032   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000003A   0x.... 0x....      BL       HAL_UART_Transmit
   \   0000003E   0x0006             MOVS     R6,R0
    245                if(Status != HAL_OK)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_4
    246                {
    247                  return Status;
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xE020             B.N      ??RoadBrd_UART_Transmit_1
    248                }
    249                else
    250                {
    251                   return Status;
   \                     ??RoadBrd_UART_Transmit_4: (+1)
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE01D             B.N      ??RoadBrd_UART_Transmit_1
    252                }
    253              }
    254            }
    255            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_2: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C01             CMP      R4,#+1
   \   00000056   0xD119             BNE.N    ??RoadBrd_UART_Transmit_5
    256            {
    257              // Is UART Busy right now?
    258              if (Uart3Ready != RESET)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_6
    259                return HAL_BUSY;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xE013             B.N      ??RoadBrd_UART_Transmit_1
    260              else
    261              {
    262                Status = HAL_UART_Transmit(&huart3, (uint8_t*)pData, Size, HAL_MAX_DELAY);
   \                     ??RoadBrd_UART_Transmit_6: (+1)
   \   00000066   0xF44F 0x4300      MOV      R3,#+32768
   \   0000006A   0x003A             MOVS     R2,R7
   \   0000006C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000074   0x.... 0x....      BL       HAL_UART_Transmit
   \   00000078   0x0006             MOVS     R6,R0
    263                if(Status != HAL_OK)
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_7
    264                {
    265                  return Status;
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xE003             B.N      ??RoadBrd_UART_Transmit_1
    266                }
    267                else
    268                {
    269                   return Status;
   \                     ??RoadBrd_UART_Transmit_7: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xE000             B.N      ??RoadBrd_UART_Transmit_1
    270                }
    271              }
    272            }
    273            else 
    274              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_5: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_1: (+1)
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    275          }
    276          
    277          /**
    278            * @brief  RoadBrd_UART_Transmit_ITSZ
    279            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    280            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel. 
    281            *         It does not wait for completion and must be tested for completion.
    282            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    283            *                                HAL_ERROR:    Error found in Tasking or data passed.
    284            *                                HAL_BUSY:     UART is busy.
    285            *                                HAL_TIMEOUT:  UART timed out.
    286            */

   \                                 In section .text, align 2, keep-with-next
    287          HAL_StatusTypeDef RoadBrd_UART_Transmit_ITSZ(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    288          {
   \                     RoadBrd_UART_Transmit_ITSZ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    289            HAL_StatusTypeDef Status;
    290            
    291            //Size = strlen((char *)pData);  
    292            // Test parameters before starting process
    293            if (Size > TXBUFFERSIZE)
   \   00000008   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000A   0x2E79             CMP      R6,#+121
   \   0000000C   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_ITSZ_0
    294              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE036             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    295            
    296            // Test Port to determine which uart to use for this transfer.
    297            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_ITSZ_0: (+1)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD117             BNE.N    ??RoadBrd_UART_Transmit_ITSZ_2
    298            {
    299              // Is UART Busy right now?
    300              if (Uart2Ready != RESET)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_3
    301                return HAL_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE02C             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    302              else
    303              {
    304                Status = HAL_UART_Transmit_IT(&huart2, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_ITSZ_3: (+1)
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000030   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   00000034   0x0007             MOVS     R7,R0
    305                if(Status != HAL_OK)
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_4
    306                {
    307                  return Status;
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE01E             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    308                }
    309                else
    310                {
    311                   return Status;
   \                     ??RoadBrd_UART_Transmit_ITSZ_4: (+1)
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01B             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    312                }
    313              }
    314            }
    315            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_ITSZ_2: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD117             BNE.N    ??RoadBrd_UART_Transmit_ITSZ_5
    316            {
    317              // Is UART Busy right now?
    318              if (Uart3Ready != RESET)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_6
    319                return HAL_BUSY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xE011             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    320              else
    321              {
    322                Status = HAL_UART_Transmit_IT(&huart3, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_ITSZ_6: (+1)
   \   0000005C   0x0032             MOVS     R2,R6
   \   0000005E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000066   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   0000006A   0x0007             MOVS     R7,R0
    323                if(Status != HAL_OK)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_7
    324                {
    325                  return Status;
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xE003             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    326                }
    327                else
    328                {
    329                   return Status;
   \                     ??RoadBrd_UART_Transmit_ITSZ_7: (+1)
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xE000             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    330                }
    331              }
    332            }
    333            else 
    334              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_ITSZ_5: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_ITSZ_1: (+1)
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    335          }
    336          
    337          /**
    338            * @brief  RoadBrd_UART_Transmit_IT
    339            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    340            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel. 
    341            *         It does not wait for completion and must be tested for completion.
    342            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    343            *                                HAL_ERROR:    Error found in Tasking or data passed.
    344            *                                HAL_BUSY:     UART is busy.
    345            *                                HAL_TIMEOUT:  UART timed out.
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          HAL_StatusTypeDef RoadBrd_UART_Transmit_IT(RoadBrd_uart_TypeDef Port, uint8_t *pData)
    348          {
   \                     RoadBrd_UART_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    349            HAL_StatusTypeDef Status;
    350            uint16_t Size;
    351            
    352            Size = strlen((char *)pData);  
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0007             MOVS     R7,R0
    353            // Test parameters before starting process
    354            if (Size > TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F79             CMP      R7,#+121
   \   00000012   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_IT_0
    355              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE036             B.N      ??RoadBrd_UART_Transmit_IT_1
    356            
    357            // Test Port to determine which uart to use for this transfer.
    358            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_IT_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD117             BNE.N    ??RoadBrd_UART_Transmit_IT_2
    359            {
    360              // Is UART Busy right now?
    361              if (Uart2Ready != RESET)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_IT_3
    362                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE02C             B.N      ??RoadBrd_UART_Transmit_IT_1
    363              else
    364              {
    365                Status = HAL_UART_Transmit_IT(&huart2, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_IT_3: (+1)
   \   0000002C   0x003A             MOVS     R2,R7
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000036   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   0000003A   0x0006             MOVS     R6,R0
    366                if(Status != HAL_OK)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_IT_4
    367                {
    368                  return Status;
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01E             B.N      ??RoadBrd_UART_Transmit_IT_1
    369                }
    370                else
    371                {
    372                   return Status;
   \                     ??RoadBrd_UART_Transmit_IT_4: (+1)
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xE01B             B.N      ??RoadBrd_UART_Transmit_IT_1
    373                }
    374              }
    375            }
    376            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_IT_2: (+1)
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x2C01             CMP      R4,#+1
   \   00000052   0xD117             BNE.N    ??RoadBrd_UART_Transmit_IT_5
    377            {
    378              // Is UART Busy right now?
    379              if (Uart3Ready != RESET)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_IT_6
    380                return HAL_BUSY;
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0xE011             B.N      ??RoadBrd_UART_Transmit_IT_1
    381              else
    382              {
    383                Status = HAL_UART_Transmit_IT(&huart3, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_IT_6: (+1)
   \   00000062   0x003A             MOVS     R2,R7
   \   00000064   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000006C   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   00000070   0x0006             MOVS     R6,R0
    384                if(Status != HAL_OK)
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_IT_7
    385                {
    386                  return Status;
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xE003             B.N      ??RoadBrd_UART_Transmit_IT_1
    387                }
    388                else
    389                {
    390                   return Status;
   \                     ??RoadBrd_UART_Transmit_IT_7: (+1)
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE000             B.N      ??RoadBrd_UART_Transmit_IT_1
    391                }
    392              }
    393            }
    394            else 
    395              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_IT_5: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_IT_1: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    396          }
    397          
    398          #ifndef PATCH_UART
    399          /**
    400            * @brief  RoadBrd_UART_Receive_ITBG
    401            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint16_t Size: Number of  bytes to wait for completion. 
    402            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    403            *         It does not wait for completion and must be tested for completion.
    404            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    405            *                                HAL_ERROR:    Error found in Tasking or data passed.
    406            *                                HAL_BUSY:     UART is busy.
    407            *                                HAL_TIMEOUT:  UART timed out.
    408            */

   \                                 In section .text, align 2, keep-with-next
    409          HAL_StatusTypeDef RoadBrd_UART_Receive_ITBG(RoadBrd_uart_TypeDef Port, uint16_t Size)
    410          {
   \                     RoadBrd_UART_Receive_ITBG: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    411            HAL_StatusTypeDef Status;
    412            
    413            // Test parameters before starting process
    414            if (Size > RXBUFFERSIZE)
   \   00000006   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000008   0x2D79             CMP      R5,#+121
   \   0000000A   0xDB01             BLT.N    ??RoadBrd_UART_Receive_ITBG_0
    415              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE038             B.N      ??RoadBrd_UART_Receive_ITBG_1
    416            
    417            // Test Port to determine which uart to use for this transfer.
    418            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_ITBG_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD118             BNE.N    ??RoadBrd_UART_Receive_ITBG_2
    419            {
    420              // Is UART Busy right now?
    421              if (Uart2Ready != RESET)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??RoadBrd_UART_Receive_ITBG_3
    422                return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE02E             B.N      ??RoadBrd_UART_Receive_ITBG_1
    423              else
    424              {
    425                Status = HAL_UART_Receive_IT(&huart2, (uint8_t*)bgm1data, Size);
   \                     ??RoadBrd_UART_Receive_ITBG_3: (+1)
   \   00000024   0x002A             MOVS     R2,R5
   \   00000026   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000030   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000034   0x0006             MOVS     R6,R0
    426                if(Status != HAL_OK)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_UART_Receive_ITBG_4
    427                {
    428                  return Status;
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE01F             B.N      ??RoadBrd_UART_Receive_ITBG_1
    429                }
    430                else
    431                {
    432                   return Status;
   \                     ??RoadBrd_UART_Receive_ITBG_4: (+1)
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01C             B.N      ??RoadBrd_UART_Receive_ITBG_1
    433                }
    434              }
    435            }
    436            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_ITBG_2: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD118             BNE.N    ??RoadBrd_UART_Receive_ITBG_5
    437            {
    438              // Is UART Busy right now?
    439              if (Uart3Ready != RESET)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??RoadBrd_UART_Receive_ITBG_6
    440                return HAL_BUSY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xE012             B.N      ??RoadBrd_UART_Receive_ITBG_1
    441              else
    442              {
    443                Status = HAL_UART_Receive_IT(&huart3, (uint8_t*)bgm1data, Size);
   \                     ??RoadBrd_UART_Receive_ITBG_6: (+1)
   \   0000005C   0x002A             MOVS     R2,R5
   \   0000005E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000068   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   0000006C   0x0006             MOVS     R6,R0
    444                if(Status != HAL_OK)
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD002             BEQ.N    ??RoadBrd_UART_Receive_ITBG_7
    445                {
    446                  return Status;
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xE003             B.N      ??RoadBrd_UART_Receive_ITBG_1
    447                }
    448                else
    449                {
    450                   return Status;
   \                     ??RoadBrd_UART_Receive_ITBG_7: (+1)
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xE000             B.N      ??RoadBrd_UART_Receive_ITBG_1
    451                }
    452              }
    453            }
    454            else 
    455              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_ITBG_5: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_ITBG_1: (+1)
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    456          }
    457          
    458          /**
    459            * @brief  Returns the pointer to the bgm1data buffer.
    460            * @param  None
    461            * @retval uint8_t*:     address of bgm1data buffer
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          uint8_t *RoadBrd_GetBGPtr( void )
    464          {
    465            return &bgm1data[0];
   \                     RoadBrd_GetBGPtr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_9
   \   00000004   0x4770             BX       LR               ;; return
    466          }
    467          
    468          /**
    469            * @brief  Sets the Buffer Flag for BGM Traffic.
    470            * @param  None
    471            * @retval None.
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          void RoadBrd_SetBffrFlg( void )
    474          {
    475            bffr1Flag = true;
   \                     RoadBrd_SetBffrFlg: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    476          }
   \   00000008   0x4770             BX       LR               ;; return
    477          
    478          /**
    479            * @brief  Clears the Buffer Flag for BGM Traffic.
    480            * @param  None
    481            * @retval None.
    482            */

   \                                 In section .text, align 2, keep-with-next
    483          void RoadBrd_ClrBffrFlg( void )
    484          {
    485            bffr1Flag = false;
   \                     RoadBrd_ClrBffrFlg: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable20_10
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    486          }
   \   00000006   0x4770             BX       LR               ;; return
    487          
    488          /**
    489            * @brief  Returns the Buffer Flag for BGM Traffic.
    490            * @param  None
    491            * @retval uint8_t*:     address of bgm1data buffer
    492            */

   \                                 In section .text, align 2, keep-with-next
    493          bool RoadBrd_GetBffrFlg( void )
    494          {
    495            return bffr1Flag;
   \                     RoadBrd_GetBffrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_10
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    496          }
    497          
    498          /**
    499            * @brief  Return saveLen Variable
    500            * @param  NONE. 
    501            * @note   This is needed to allow the next IT transfer to usart. 
    502          * @retval int: saveLen
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          int RoadBrd_getSaveLen( void )
    505          {
    506            return saveLen;
   \                     RoadBrd_getSaveLen: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_11
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    507          }
    508          #endif
    509          
    510          /**
    511            * @brief  RoadBrd_UART_Receive_IT
    512            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit, uint16_t Size: Number of  bytes to wait for completion. 
    513            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    514            *         It does not wait for completion and must be tested for completion.
    515            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    516            *                                HAL_ERROR:    Error found in Tasking or data passed.
    517            *                                HAL_BUSY:     UART is busy.
    518            *                                HAL_TIMEOUT:  UART timed out.
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef RoadBrd_UART_Receive_IT(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    521          {
   \                     RoadBrd_UART_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    522            HAL_StatusTypeDef Status;
    523            
    524            // Test parameters before starting process
    525            if (Size > RXBUFFERSIZE)
   \   00000008   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000A   0x2E79             CMP      R6,#+121
   \   0000000C   0xDB01             BLT.N    ??RoadBrd_UART_Receive_IT_0
    526              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE032             B.N      ??RoadBrd_UART_Receive_IT_1
    527            
    528            // Test Port to determine which uart to use for this transfer.
    529            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_IT_0: (+1)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD115             BNE.N    ??RoadBrd_UART_Receive_IT_2
    530            {
    531              // Is UART Busy right now?
    532              if (Uart2Ready != RESET)
   \   00000018   0x....             LDR.N    R0,??DataTable20_7
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??RoadBrd_UART_Receive_IT_3
    533                return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE029             B.N      ??RoadBrd_UART_Receive_IT_1
    534              else
    535              {
    536                Status = HAL_UART_Receive_IT(&huart2, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Receive_IT_3: (+1)
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x....             LDR.N    R0,??DataTable20_1
   \   0000002C   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000030   0x0007             MOVS     R7,R0
    537                if(Status != HAL_OK)
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD002             BEQ.N    ??RoadBrd_UART_Receive_IT_4
    538                {
    539                  return Status;
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xE01C             B.N      ??RoadBrd_UART_Receive_IT_1
    540                }
    541                else
    542                {
    543                   return Status;
   \                     ??RoadBrd_UART_Receive_IT_4: (+1)
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xE019             B.N      ??RoadBrd_UART_Receive_IT_1
    544                }
    545              }
    546            }
    547            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_IT_2: (+1)
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C01             CMP      R4,#+1
   \   00000048   0xD115             BNE.N    ??RoadBrd_UART_Receive_IT_5
    548            {
    549              // Is UART Busy right now?
    550              if (Uart3Ready != RESET)
   \   0000004A   0x....             LDR.N    R0,??DataTable20_8
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??RoadBrd_UART_Receive_IT_6
    551                return HAL_BUSY;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xE010             B.N      ??RoadBrd_UART_Receive_IT_1
    552              else
    553              {
    554                Status = HAL_UART_Receive_IT(&huart3, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Receive_IT_6: (+1)
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005A   0x0029             MOVS     R1,R5
   \   0000005C   0x....             LDR.N    R0,??DataTable20_3
   \   0000005E   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000062   0x0007             MOVS     R7,R0
    555                if(Status != HAL_OK)
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2F00             CMP      R7,#+0
   \   00000068   0xD002             BEQ.N    ??RoadBrd_UART_Receive_IT_7
    556                {
    557                  return Status;
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE003             B.N      ??RoadBrd_UART_Receive_IT_1
    558                }
    559                else
    560                {
    561                   return Status;
   \                     ??RoadBrd_UART_Receive_IT_7: (+1)
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE000             B.N      ??RoadBrd_UART_Receive_IT_1
    562                }
    563              }
    564            }
    565            else 
    566              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_IT_5: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_IT_1: (+1)
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    567          }
    568          
    569          /**
    570            * @brief  RoadBrd_UART_Receive
    571            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit, uint16_t Size: Number of  bytes to wait for completion. 
    572            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    573            *         It DOES wait for completion OR a termination character of 0x0a or 0x0d.
    574            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    575            *                                HAL_ERROR:    Error found in Tasking or data passed.
    576            *                                HAL_BUSY:     UART is busy.
    577            *                                HAL_TIMEOUT:  UART timed out.
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          HAL_StatusTypeDef RoadBrd_UART_Receive(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    580          {
   \                     RoadBrd_UART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    581            HAL_StatusTypeDef Status;
    582            uint16_t tmpSize;
    583            uint8_t tmpData[2];
    584            
    585            
    586            // Test parameters before starting process
    587            if (Size > RXBUFFERSIZE)
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0x2E79             CMP      R6,#+121
   \   00000010   0xDB01             BLT.N    ??RoadBrd_UART_Receive_0
    588              return HAL_ERROR;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE062             B.N      ??RoadBrd_UART_Receive_1
    589            
    590            // Test Port to determine which uart to use for this transfer.
    591            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_0: (+1)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD12D             BNE.N    ??RoadBrd_UART_Receive_2
    592            {
    593              // Is UART Busy right now?
    594              if (Uart2Ready != RESET)
   \   0000001C   0x....             LDR.N    R0,??DataTable20_7
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??RoadBrd_UART_Receive_3
    595                return HAL_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE059             B.N      ??RoadBrd_UART_Receive_1
    596              else
    597              {
    598                tmpSize = Size;
   \                     ??RoadBrd_UART_Receive_3: (+1)
   \   00000028   0x46B0             MOV      R8,R6
    599                while ( tmpSize>0 )
   \                     ??RoadBrd_UART_Receive_4: (+1)
   \   0000002A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000002E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000032   0xD01E             BEQ.N    ??RoadBrd_UART_Receive_5
    600                {
    601                  Status = HAL_UART_Receive(&huart2, (uint8_t*)tmpData, 1, HAL_MAX_DELAY);
   \   00000034   0xF44F 0x4300      MOV      R3,#+32768
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x....             LDR.N    R0,??DataTable20_1
   \   0000003E   0x.... 0x....      BL       HAL_UART_Receive
   \   00000042   0x0007             MOVS     R7,R0
    602                  if(Status == HAL_OK)
   \   00000044   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD1EF             BNE.N    ??RoadBrd_UART_Receive_4
    603                  {
    604                    // Watch for termination characters.
    605                    if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x280A             CMP      R0,#+10
   \   00000050   0xD003             BEQ.N    ??RoadBrd_UART_Receive_6
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x280D             CMP      R0,#+13
   \   00000058   0xD104             BNE.N    ??RoadBrd_UART_Receive_7
    606                    {
    607                      *pData = 0x00;
   \                     ??RoadBrd_UART_Receive_6: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
    608                      // Yes..We are done.
    609                      return Status;
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xE03B             B.N      ??RoadBrd_UART_Receive_1
    610                    }
    611                    else
    612                    {
    613                      // Move new character into passed buffer.
    614                      *pData = tmpData[0];
   \                     ??RoadBrd_UART_Receive_7: (+1)
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x7028             STRB     R0,[R5, #+0]
    615                      tmpSize--;                          // Decrement Count
   \   0000006A   0xF1B8 0x0801      SUBS     R8,R8,#+1
    616                      pData++;                            // Move pointer to next buffer location.
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \   00000070   0xE7DB             B.N      ??RoadBrd_UART_Receive_4
    617                    }
    618                  }
    619                }
    620                return Status;
   \                     ??RoadBrd_UART_Receive_5: (+1)
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xE031             B.N      ??RoadBrd_UART_Receive_1
    621              }
    622            }
    623            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_2: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C01             CMP      R4,#+1
   \   0000007C   0xD12D             BNE.N    ??RoadBrd_UART_Receive_8
    624            {
    625              // Is UART Busy right now?
    626              if (Uart3Ready != RESET)
   \   0000007E   0x....             LDR.N    R0,??DataTable20_8
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??RoadBrd_UART_Receive_9
    627                return HAL_BUSY;
   \   00000086   0x2002             MOVS     R0,#+2
   \   00000088   0xE028             B.N      ??RoadBrd_UART_Receive_1
    628              else
    629              {
    630                tmpSize = Size;
   \                     ??RoadBrd_UART_Receive_9: (+1)
   \   0000008A   0x46B0             MOV      R8,R6
    631                while ( tmpSize>0 )
   \                     ??RoadBrd_UART_Receive_10: (+1)
   \   0000008C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000090   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000094   0xD01E             BEQ.N    ??RoadBrd_UART_Receive_11
    632                {
    633                  Status = HAL_UART_Receive(&huart3, (uint8_t*)tmpData, 1, HAL_MAX_DELAY);
   \   00000096   0xF44F 0x4300      MOV      R3,#+32768
   \   0000009A   0x2201             MOVS     R2,#+1
   \   0000009C   0x4669             MOV      R1,SP
   \   0000009E   0x....             LDR.N    R0,??DataTable20_3
   \   000000A0   0x.... 0x....      BL       HAL_UART_Receive
   \   000000A4   0x0007             MOVS     R7,R0
    634                  if(Status == HAL_OK)
   \   000000A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A8   0x2F00             CMP      R7,#+0
   \   000000AA   0xD1EF             BNE.N    ??RoadBrd_UART_Receive_10
    635                  {
    636                    // Watch for termination characters.
    637                    if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   \   000000AC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B0   0x280A             CMP      R0,#+10
   \   000000B2   0xD003             BEQ.N    ??RoadBrd_UART_Receive_12
   \   000000B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B8   0x280D             CMP      R0,#+13
   \   000000BA   0xD104             BNE.N    ??RoadBrd_UART_Receive_13
    638                    {
    639                      *pData = 0x00;
   \                     ??RoadBrd_UART_Receive_12: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
    640                      // Yes..We are done.
    641                      return Status;
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xE00A             B.N      ??RoadBrd_UART_Receive_1
    642                    }
    643                    else
    644                    {
    645                      // Move new character into passed buffer.
    646                      *pData = tmpData[0];
   \                     ??RoadBrd_UART_Receive_13: (+1)
   \   000000C6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000CA   0x7028             STRB     R0,[R5, #+0]
    647                      tmpSize--;                          // Decrement Count
   \   000000CC   0xF1B8 0x0801      SUBS     R8,R8,#+1
    648                      pData++;                            // Move pointer to next buffer location.
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \   000000D2   0xE7DB             B.N      ??RoadBrd_UART_Receive_10
    649                    }
    650                  }
    651                }
    652                return Status;
   \                     ??RoadBrd_UART_Receive_11: (+1)
   \   000000D4   0x0038             MOVS     R0,R7
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0xE000             B.N      ??RoadBrd_UART_Receive_1
    653              }
    654            }
    655            else 
    656              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_8: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_1: (+1)
   \   000000DC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    657          }
    658          
    659          /**
    660            * @brief  RoadBrd_Uart_Status
    661            * @param  RoadBrd_uart_TypeDef Port: USART Port.
    662            * @note   This routine returns the current state of the UART passed.
    663            * @retval ITStatus:     RESET:       Last transaction complete
    664            *                       SET:         UART Channel busy.
    665            */

   \                                 In section .text, align 2, keep-with-next
    666          ITStatus RoadBrd_Uart_Status(RoadBrd_uart_TypeDef Port)
    667          {
   \                     RoadBrd_Uart_Status: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    668            // Test Port to determine which uart to use for this transfer.
    669            if ( RoadBrd_Uart_GetState(Port) != HAL_UART_STATE_READY)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       RoadBrd_Uart_GetState
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??RoadBrd_Uart_Status_0
    670              return RESET;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B.N      ??RoadBrd_Uart_Status_1
    671            else
    672              return SET;
   \                     ??RoadBrd_Uart_Status_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Uart_Status_1: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    673          }
    674            
    675          /**
    676            * @brief  RoadBrd_Uart_GetState
    677            * @param  RoadBrd_uart_TypeDef Port: USART Port.
    678            * @note   This routine returns the current state of the UART passed.
    679            * @retval ITStatus:     RESET:       Last transaction complete
    680            *   HAL_UART_STATE_RESET             = 0x00,    < Peripheral is not initialized                      
    681            *   HAL_UART_STATE_READY             = 0x01,    < Peripheral Initialized and ready for use           
    682            *   HAL_UART_STATE_BUSY              = 0x02,    < an internal process is ongoing                     
    683            *   HAL_UART_STATE_BUSY_TX           = 0x12,    < Data Transmission process is ongoing               
    684            *   HAL_UART_STATE_BUSY_RX           = 0x22,    < Data Reception process is ongoing                  
    685            *   HAL_UART_STATE_BUSY_TX_RX        = 0x32,    < Data Transmission and Reception process is ongoing 
    686            *   HAL_UART_STATE_TIMEOUT           = 0x03,    < Timeout state                                      
    687            *   HAL_UART_STATE_ERROR             = 0x04     < Error                                              
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          HAL_UART_StateTypeDef RoadBrd_Uart_GetState(RoadBrd_uart_TypeDef Port)
    690          {
   \                     RoadBrd_Uart_GetState: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    691            // Test Port to determine which uart to use for this transfer.
    692            if (Port == USART_2)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD103             BNE.N    ??RoadBrd_Uart_GetState_0
    693              return huart2.State;
   \   00000008   0x....             LDR.N    R0,??DataTable20_1
   \   0000000A   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   0000000E   0xE007             B.N      ??RoadBrd_Uart_GetState_1
    694            else if (Port == USART_3)
   \                     ??RoadBrd_Uart_GetState_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD103             BNE.N    ??RoadBrd_Uart_GetState_2
    695              return huart3.State;
   \   00000016   0x....             LDR.N    R0,??DataTable20_3
   \   00000018   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   0000001C   0xE000             B.N      ??RoadBrd_Uart_GetState_1
    696            else
    697              //return huart3.State;
    698              return HAL_UART_STATE_ERROR;
   \                     ??RoadBrd_Uart_GetState_2: (+1)
   \   0000001E   0x2004             MOVS     R0,#+4
   \                     ??RoadBrd_Uart_GetState_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    699          }
    700            
    701          /**
    702            * @brief  Tx Transfer completed callback
    703            * @param  UartHandle: UART handle. 
    704            * @note   This example shows a simple way to report end of IT Tx transfer, and 
    705            *         you can add your own implementation. 
    706            * @retval None
    707            */

   \                                 In section .text, align 2, keep-with-next
    708          void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
    709          {
    710            // Set transmission flag: trasfer complete for correct USART
    711            //RoadBrd_gpio_On( BLUE_LED );
    712            if(UartHandle->Instance==USART2)
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x....             LDR.N    R2,??DataTable20  ;; 0x40004400
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0xD103             BNE.N    ??HAL_UART_TxCpltCallback_0
    713            {
    714              Uart2Ready = SET;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x....             LDR.N    R2,??DataTable20_7
   \   0000000C   0x7011             STRB     R1,[R2, #+0]
   \   0000000E   0xE006             B.N      ??HAL_UART_TxCpltCallback_1
    715            }
    716            else if(UartHandle->Instance==USART3)
   \                     ??HAL_UART_TxCpltCallback_0: (+1)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable20_2  ;; 0x40004800
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD102             BNE.N    ??HAL_UART_TxCpltCallback_1
    717            {
    718              Uart3Ready = SET;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x....             LDR.N    R2,??DataTable20_8
   \   0000001C   0x7011             STRB     R1,[R2, #+0]
    719            }
    720          }
   \                     ??HAL_UART_TxCpltCallback_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    721          
    722          /**
    723            * @brief  Clear Usart Ready Flag
    724            * @param  NONE. 
    725            * @note   This is needed to allow the next IT transfer to usart. 
    726            * @retval None
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          void clrUsartState( RoadBrd_uart_TypeDef Port )
    729          {
    730            // Test Port to determine which uart to use for this transfer.
    731            if (Port == USART_2)
   \                     clrUsartState: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD103             BNE.N    ??clrUsartState_0
    732            {
    733              Uart2Ready = RESET;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable20_7
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   \   0000000C   0xE005             B.N      ??clrUsartState_1
    734            }
    735            else if (Port == USART_3)
   \                     ??clrUsartState_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD102             BNE.N    ??clrUsartState_1
    736            {
    737              Uart3Ready = RESET;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R2,??DataTable20_8
   \   00000018   0x7011             STRB     R1,[R2, #+0]
    738            }
    739          }
   \                     ??clrUsartState_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    740          
    741          /**
    742            * @brief  Rx Transfer completed callback
    743            * @param  UartHandle: UART handle
    744            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    745            *         you can add your own implementation.
    746            * @retval None
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          void HAL_UART_RxCpltCallback(UART_HandleTypeDef* uartHandle)
    749          {
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    750          #ifndef PATCH_UART
    751            int x;
    752            static uint8_t *temp_ptr;
    753            static int len;
    754            int newLen;
    755          #endif
    756          
    757            /* Set transmission flag: trasfer complete for correct USART*/
    758             if(uartHandle->Instance==USART2)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable20  ;; 0x40004400
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD103             BNE.N    ??HAL_UART_RxCpltCallback_0
    759            {
    760              Uart2Ready = SET;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable20_7
   \   00000010   0x7008             STRB     R0,[R1, #+0]
   \   00000012   0xE04C             B.N      ??HAL_UART_RxCpltCallback_1
    761            }
    762            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_RxCpltCallback_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x....             LDR.N    R1,??DataTable20_2  ;; 0x40004800
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD148             BNE.N    ??HAL_UART_RxCpltCallback_1
    763            {
    764          #ifndef TEST2
    765          #ifndef PATCH_UART
    766          #ifndef LED_OFF
    767              //RoadBrd_gpio_On( BGM_LED );
    768          #endif
    769                //if (bffrFlag)
    770              if (RoadBrd_GetBffrFlg())
   \   0000001C   0x.... 0x....      BL       RoadBrd_GetBffrFlg
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD024             BEQ.N    ??HAL_UART_RxCpltCallback_2
    771              {
    772                len = 3;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x....             LDR.N    R1,??DataTable20_12
   \   00000028   0x6008             STR      R0,[R1, #+0]
    773                // Process BGM Byte received.
    774                temp_ptr = RoadBrd_GetBGPtr();
   \   0000002A   0x.... 0x....      BL       RoadBrd_GetBGPtr
   \   0000002E   0x....             LDR.N    R1,??DataTable20_13
   \   00000030   0x6008             STR      R0,[R1, #+0]
    775                newLen = temp_ptr[1]+1;
   \   00000032   0x....             LDR.N    R0,??DataTable20_13
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x7840             LDRB     R0,[R0, #+1]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x0006             MOVS     R6,R0
    776                for (x=0; x<len; x++)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0005             MOVS     R5,R0
   \                     ??HAL_UART_RxCpltCallback_3: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable20_12
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xDA0B             BGE.N    ??HAL_UART_RxCpltCallback_4
    777                {
    778                  RoadBrd_ProcessBGMChar(*temp_ptr);
   \   00000048   0x....             LDR.N    R0,??DataTable20_13
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       RoadBrd_ProcessBGMChar
    779                  temp_ptr++;
   \   00000052   0x....             LDR.N    R0,??DataTable20_13
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable20_13
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    780                  //Status = RoadBrd_ProcessBGMChar(bgmdata[x]);
    781                }
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0xE7EF             B.N      ??HAL_UART_RxCpltCallback_3
    782                len = newLen;
   \                     ??HAL_UART_RxCpltCallback_4: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable20_12
   \   00000062   0x6006             STR      R6,[R0, #+0]
    783                saveLen = len;
   \   00000064   0x....             LDR.N    R0,??DataTable20_12
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x....             LDR.N    R1,??DataTable20_11
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   \   0000006C   0xE01C             B.N      ??HAL_UART_RxCpltCallback_5
    784              }
    785              else
    786              {
    787                // Process BGM Byte received.
    788                temp_ptr = RoadBrd_GetBGPtr();
   \                     ??HAL_UART_RxCpltCallback_2: (+1)
   \   0000006E   0x.... 0x....      BL       RoadBrd_GetBGPtr
   \   00000072   0x....             LDR.N    R1,??DataTable20_13
   \   00000074   0x6008             STR      R0,[R1, #+0]
    789                for (x=0; x<len; x++)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x0005             MOVS     R5,R0
   \                     ??HAL_UART_RxCpltCallback_6: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable20_12
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x4285             CMP      R5,R0
   \   00000080   0xDA0B             BGE.N    ??HAL_UART_RxCpltCallback_7
    790                {
    791                  RoadBrd_ProcessBGMChar(*temp_ptr);
   \   00000082   0x....             LDR.N    R0,??DataTable20_13
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       RoadBrd_ProcessBGMChar
    792                  temp_ptr++;
   \   0000008C   0x....             LDR.N    R0,??DataTable20_13
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x....             LDR.N    R1,??DataTable20_13
   \   00000094   0x6008             STR      R0,[R1, #+0]
    793                  //Status = RoadBrd_ProcessBGMChar(bgmdata[x]);
    794                 }
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   \   00000098   0xE7EF             B.N      ??HAL_UART_RxCpltCallback_6
    795                len = 3;
   \                     ??HAL_UART_RxCpltCallback_7: (+1)
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0x....             LDR.N    R1,??DataTable20_12
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    796                saveLen = len;
   \   000000A0   0x....             LDR.N    R0,??DataTable20_12
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x....             LDR.N    R1,??DataTable20_11
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    797                //Status = RoadBrd_ProcessBGMChar(bgmdata[0]);
    798              }
    799          #endif
    800          #endif
    801              Uart3Ready = SET;
   \                     ??HAL_UART_RxCpltCallback_5: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x....             LDR.N    R1,??DataTable20_8
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    802            }
    803          }
   \                     ??HAL_UART_RxCpltCallback_1: (+1)
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     `HAL_UART_RxCpltCallback::temp_ptr`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `HAL_UART_RxCpltCallback::len`:
   \   00000000                      DS8 4
    804          
    805          /**
    806            * @brief  UART error callbacks
    807            * @param  UartHandle: UART handle
    808            * @note   This example shows a simple way to report transfer error, and you can
    809            *         add your own implementation.
    810            * @retval None
    811            */

   \                                 In section .text, align 2, keep-with-next
    812          void HAL_UART_ErrorCallback(UART_HandleTypeDef* uartHandle)
    813          {
    814              //Error_Handler();
    815          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    816          
    817          #ifndef PATCH_UART
    818          /**
    819            * @brief  Enable UART3 for TX.
    820            * @param  none
    821            * @retval None
    822            */

   \                                 In section .text, align 2, keep-with-next
    823          void HAL_UART_EnableBGM_TXE( void )
    824          {
    825            __HAL_UART_ENABLE_IT(&huart3, UART_IT_TXE);
   \                     HAL_UART_EnableBGM_TXE: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000000A   0x....             LDR.N    R1,??DataTable20_3
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
    826          }
   \   00000010   0x4770             BX       LR               ;; return
    827          
    828          /**
    829            * @brief  Enable UART3 for RX.
    830            * @param  none
    831            * @retval None
    832            */

   \                                 In section .text, align 2, keep-with-next
    833          void HAL_UART_EnableBGM_RX( void )
    834          {
    835            /* Enable the UART Parity Error Interrupt */
    836            __HAL_UART_ENABLE_IT(&huart3, UART_IT_PE);
   \                     HAL_UART_EnableBGM_RX: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x....             LDR.N    R1,??DataTable20_3
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
    837          
    838            /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    839            __HAL_UART_ENABLE_IT(&huart3, UART_IT_ERR);
   \   00000010   0x....             LDR.N    R0,??DataTable20_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001A   0x....             LDR.N    R1,??DataTable20_3
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6148             STR      R0,[R1, #+20]
    840          
    841            /* Enable the UART Data Register not empty Interrupt */
    842            __HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);
   \   00000020   0x....             LDR.N    R0,??DataTable20_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002A   0x....             LDR.N    R1,??DataTable20_3
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
    843          }
   \   00000030   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     huart2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     huart3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     Uart2Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     Uart3Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x........         DC32     bgm1data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     bffr1Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     saveLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     `HAL_UART_RxCpltCallback::len`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     `HAL_UART_RxCpltCallback::temp_ptr`
    844          
    845          #endif
    846          
    847          
    848          /* USER CODE END 1 */
    849          
    850          /**
    851            * @}
    852            */
    853          
    854          /**
    855            * @}
    856            */
    857          
    858          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_UART_EnableBGM_RX
       0   HAL_UART_EnableBGM_TXE
       0   HAL_UART_ErrorCallback
       8   HAL_UART_MspDeInit
         8   -> HAL_GPIO_DeInit
      32   HAL_UART_MspInit
        32   -> HAL_GPIO_Init
      16   HAL_UART_RxCpltCallback
        16   -> RoadBrd_GetBGPtr
        16   -> RoadBrd_GetBffrFlg
        16   -> RoadBrd_ProcessBGMChar
       0   HAL_UART_TxCpltCallback
       8   MX_USART2_UART_Init
         8   -> Error_Handler
         8   -> HAL_UART_Init
       8   MX_USART3_UART_Init
         8   -> Error_Handler
         8   -> HAL_UART_Init
       0   RoadBrd_ClrBffrFlg
       0   RoadBrd_GetBGPtr
       0   RoadBrd_GetBffrFlg
       0   RoadBrd_SetBffrFlg
      32   RoadBrd_UART_Receive
        32   -> HAL_UART_Receive
      24   RoadBrd_UART_Receive_IT
        24   -> HAL_UART_Receive_IT
      16   RoadBrd_UART_Receive_ITBG
        16   -> HAL_UART_Receive_IT
      24   RoadBrd_UART_Transmit
        24   -> HAL_UART_Transmit
        24   -> strlen
      24   RoadBrd_UART_Transmit_IT
        24   -> HAL_UART_Transmit_IT
        24   -> strlen
      24   RoadBrd_UART_Transmit_ITSZ
        24   -> HAL_UART_Transmit_IT
       0   RoadBrd_Uart_GetState
       8   RoadBrd_Uart_Status
         8   -> RoadBrd_Uart_GetState
       0   RoadBrd_getSaveLen
       0   clrUsartState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      50  HAL_UART_EnableBGM_RX
      18  HAL_UART_EnableBGM_TXE
       2  HAL_UART_ErrorCallback
      82  HAL_UART_MspDeInit
     186  HAL_UART_MspInit
     176  HAL_UART_RxCpltCallback
      32  HAL_UART_TxCpltCallback
      88  MX_USART2_UART_Init
      90  MX_USART3_UART_Init
       8  RoadBrd_ClrBffrFlg
       6  RoadBrd_GetBGPtr
       6  RoadBrd_GetBffrFlg
      10  RoadBrd_SetBffrFlg
     224  RoadBrd_UART_Receive
     122  RoadBrd_UART_Receive_IT
     132  RoadBrd_UART_Receive_ITBG
     144  RoadBrd_UART_Transmit
     136  RoadBrd_UART_Transmit_IT
     130  RoadBrd_UART_Transmit_ITSZ
      34  RoadBrd_Uart_GetState
      24  RoadBrd_Uart_Status
       6  RoadBrd_getSaveLen
       1  Uart2Ready
       1  Uart3Ready
     120  aRxBuffer
     120  aTxBuffer
       1  bffr1Flag
      40  bgm1data
      28  clrUsartState
      64  huart2
      64  huart3
       4  len
       4  saveLen
       4  temp_ptr

 
   419 bytes in section .bss
     4 bytes in section .data
 1 790 bytes in section .text
 
 1 790 bytes of CODE memory
   423 bytes of DATA memory

Errors: none
Warnings: none
