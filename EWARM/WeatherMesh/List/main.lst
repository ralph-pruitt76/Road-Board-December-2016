###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       30/Jan/2018  09:25:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -D WM -lCN
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List
#        -o
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.4\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List\main.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj\main.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : main.c
      4            * Description        : Main program body
      5            ******************************************************************************
      6            *
      7            * COPYRIGHT(c) 2016 STMicroelectronics
      8            *
      9            * Redistribution and use in source and binary forms, with or without modification,
     10            * are permitted provided that the following conditions are met:
     11            *   1. Redistributions of source code must retain the above copyright notice,
     12            *      this list of conditions and the following disclaimer.
     13            *   2. Redistributions in binary form must reproduce the above copyright notice,
     14            *      this list of conditions and the following disclaimer in the documentation
     15            *      and/or other materials provided with the distribution.
     16            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     17            *      may be used to endorse or promote products derived from this software
     18            *      without specific prior written permission.
     19            *
     20            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     21            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     22            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     24            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     25            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     26            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     27            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     28            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     29            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30            *
     31            ******************************************************************************
     32            */
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "stm32l1xx_hal.h"
     35          #include "cmsis_os.h"
     36          #include "adc.h"
     37          #include "dma.h"
     38          #include "i2c.h"
     39          #include "tim.h"
     40          #include "usart.h"
     41          #include "usb_device.h"
     42          #include "wwdg.h"
     43          #include "Flash.h"
     44          
     45          /* USER CODE BEGIN Includes */
     46          #include "stm32l1xx_nucleo.h"
     47          #ifdef REV_L
     48            #include "bgm111.h"
     49            #include "app_data.h"
     50          #endif
     51          #include "gpio.h"
     52          #include "main.h"
     53          #include "parser.h"
     54          #include "BootMonitor.h"
     55          #include "stdbool.h"
     56          #include "ErrorCodes.h"
     57              
     58          /* USER CODE END Includes */
     59          
     60          /* Private variables ---------------------------------------------------------*/
     61          
     62          /* USER CODE BEGIN PV */
     63          /* Private variables ---------------------------------------------------------*/
     64          
     65          /* USER CODE END PV */
     66          
     67          /* Private function prototypes -----------------------------------------------*/
     68          void SystemClock_Config(void);
     69          void Error_Handler(void);
     70          void MX_FREERTOS_Init(void);
     71          
     72          /* USER CODE BEGIN PFP */
     73          /* Private function prototypes -----------------------------------------------*/
     74          
     75          /* USER CODE END PFP */
     76          
     77          /* USER CODE BEGIN 0 */
     78          
     79          /* USER CODE END 0 */

   \                                 In section .text, align 2, keep-with-next
     80          int main(void)
     81          {
   \                     main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0B4             SUB      SP,SP,#+208
     82            /* USER CODE BEGIN 1 */
     83          #ifdef TEST2
     84            #define RECEIVE_SZ      5
     85            uint8_t tempBffr[RECEIVE_SZ];
     86            char tempBffr2[5];
     87            HAL_StatusTypeDef Status;
     88          #else
     89            #ifdef TEST
     90              #define RECEIVE_SZ      5
     91            #else
     92          //HERE
     93              #define RECEIVE_SZ      125
     94              uint8_t tempBffr[RECEIVE_SZ];
     95              uint8_t tempBffr2[80];
     96              HAL_StatusTypeDef Status;
     97            #endif
     98          #endif
     99          
    100          #ifdef REV_L
    101            //N uint16_t tmpSize = RECEIVE_SZ;
    102            //N uint8_t tmpData[2];
    103          //  uint8_t tmpData[RECEIVE_SZ];
    104          #ifdef WM
    105          #ifdef TEMPSENSOR
    106            Temperature   Temp;
    107          #endif
    108          #else
    109            Temperature   Temp;
    110          #endif
    111          #ifndef PATCH_UART
    112            bool firstTime = true;
   \   00000004   0x2501             MOVS     R5,#+1
    113          #endif
    114            //N uint8_t *pData = tempBffr;
    115          #endif
    116          
    117          //ITStatus PStatus;
    118          
    119            /* USER CODE END 1 */
    120          
    121            /* MCU Configuration----------------------------------------------------------*/
    122          
    123          #ifdef REV_L
    124            // Turn Off Power Supplies
    125            //RoadBrd_gpio_Off(gTAM_PWR);    // Turn Off 5V Power
    126            //RoadBrd_gpio_Off(gVDD_PWR);    // Turn Off 3.3V Power
    127          #endif
    128          
    129            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    130            HAL_Init();
   \   00000006   0x.... 0x....      BL       HAL_Init
    131          
    132            /* Configure the system clock */
    133            SystemClock_Config();
   \   0000000A   0x.... 0x....      BL       SystemClock_Config
    134          
    135            /* Initialize all configured peripherals */
    136            MX_GPIO_Init();
   \   0000000E   0x.... 0x....      BL       MX_GPIO_Init
    137            MX_DMA_Init();
   \   00000012   0x.... 0x....      BL       MX_DMA_Init
    138            MX_ADC_Init();
   \   00000016   0x.... 0x....      BL       MX_ADC_Init
    139            ADC_Config();
   \   0000001A   0x.... 0x....      BL       ADC_Config
    140            MX_USART2_UART_Init();
   \   0000001E   0x.... 0x....      BL       MX_USART2_UART_Init
    141            MX_USART3_UART_Init();
   \   00000022   0x.... 0x....      BL       MX_USART3_UART_Init
    142            MX_TIM2_Init();
   \   00000026   0x.... 0x....      BL       MX_TIM2_Init
    143            MX_TIM3_Init();
   \   0000002A   0x.... 0x....      BL       MX_TIM3_Init
    144          
    145            /* USER CODE BEGIN 2 */
    146          #ifdef REV_L
    147            // Wait for power to stabilize off...200msec
    148            //RoadBrd_Delay( 200 );
    149            // Turn on Power Supplies.
    150            RoadBrd_gpio_On(gTAM_PWR);    // Turn on 5V Power
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      BL       RoadBrd_gpio_On
    151            RoadBrd_gpio_On(gVDD_PWR);    // Turn on 3.3V Power
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0x.... 0x....      BL       RoadBrd_gpio_On
    152            // Wait for power to stabilize...200msec
    153            RoadBrd_Delay( 200 );
   \   0000003A   0x20C8             MOVS     R0,#+200
   \   0000003C   0x.... 0x....      BL       RoadBrd_Delay
    154            // Reset all Drivers to Off before starting init process.
    155            Reset_DriverStates();
   \   00000040   0x.... 0x....      BL       Reset_DriverStates
    156          
    157            // Enable Interrupts
    158            //---UART
    159            HAL_NVIC_EnableIRQ(USART2_IRQn);
   \   00000044   0x2026             MOVS     R0,#+38
   \   00000046   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    160            HAL_NVIC_EnableIRQ(USART3_IRQn);
   \   0000004A   0x2027             MOVS     R0,#+39
   \   0000004C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    161          
    162            // Flush I2C Channel before testing...
    163            RoadBrd_I2CRepair();
   \   00000050   0x.... 0x....      BL       RoadBrd_I2CRepair
    164            
    165            // Test I2C Channel and see if we even have a working I2C.
    166            RoadBrd_TestI2C();
   \   00000054   0x.... 0x....      BL       RoadBrd_TestI2C
    167            
    168            // Test for I2C Failure then attempt a repair.
    169            if ( !(Get_DriverStates( I2C_STATE )) )
   \   00000058   0x2007             MOVS     R0,#+7
   \   0000005A   0x.... 0x....      BL       Get_DriverStates
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD117             BNE.N    ??main_0
    170            {
    171              if ((RoadBrd_I2CRepair()) == HAL_OK)
   \   00000062   0x.... 0x....      BL       RoadBrd_I2CRepair
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD10A             BNE.N    ??main_1
    172              {
    173                RdBrd_ErrCdLogErrCd( REPAIR_I2C, MODULE_main );
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x2014             MOVS     R0,#+20
   \   0000006E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    174                Set_DriverStates( I2C_STATE, DRIVER_ON );
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x2007             MOVS     R0,#+7
   \   00000076   0x.... 0x....      BL       Set_DriverStates
    175                // Now..Initialize I2C and test Drivers.
    176                MX_I2C1_Init();
   \   0000007A   0x.... 0x....      BL       MX_I2C1_Init
   \   0000007E   0xE00A             B.N      ??main_2
    177              }
    178              else
    179              {
    180                // OK...It is hung.
    181                Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \                     ??main_1: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x2007             MOVS     R0,#+7
   \   00000084   0x.... 0x....      BL       Set_DriverStates
    182                RdBrd_ErrCdLogErrCd( ERROR_I2CBUSY, MODULE_main );
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
   \   00000090   0xE001             B.N      ??main_2
    183              }
    184            }
    185            else
    186            {
    187              // Now..Initialize I2C and test Drivers.
    188              MX_I2C1_Init();
   \                     ??main_0: (+1)
   \   00000092   0x.... 0x....      BL       MX_I2C1_Init
    189            }
    190            
    191            //---I2C1
    192            HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
   \                     ??main_2: (+1)
   \   00000096   0x201F             MOVS     R0,#+31
   \   00000098   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    193            HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
   \   0000009C   0x2020             MOVS     R0,#+32
   \   0000009E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    194            //---TIM
    195          #ifndef PATCH_UART
    196            HAL_TIM_StartTimer2();
   \   000000A2   0x.... 0x....      BL       HAL_TIM_StartTimer2
    197            HAL_TIM_StartTimer3();
   \   000000A6   0x.... 0x....      BL       HAL_TIM_StartTimer3
    198            HAL_NVIC_EnableIRQ(TIM2_IRQn);
   \   000000AA   0x201C             MOVS     R0,#+28
   \   000000AC   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    199            HAL_NVIC_EnableIRQ(TIM3_IRQn);
   \   000000B0   0x201D             MOVS     R0,#+29
   \   000000B2   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    200          #endif
    201            // Test I2C State.
    202          
    203            // Test I2C Status and Task init I2C if Active driver.
    204            if ( !(Get_DriverStates( I2C_STATE )) )
   \   000000B6   0x2007             MOVS     R0,#+7
   \   000000B8   0x.... 0x....      BL       Get_DriverStates
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD11A             BNE.N    ??main_3
    205            {
    206              // Wait 35  ms. For Busy flag to drop.
    207              if(I2C_WaitBusyFlag() != HAL_OK)
   \   000000C0   0x.... 0x....      BL       I2C_WaitBusyFlag
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD016             BEQ.N    ??main_3
    208              {
    209                // One More try at repairing hung I2C Channel.
    210                if ((RoadBrd_I2CRepair()) == HAL_OK)
   \   000000C8   0x.... 0x....      BL       RoadBrd_I2CRepair
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD10A             BNE.N    ??main_4
    211                {
    212                  Set_DriverStates( I2C_STATE, DRIVER_ON );
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x2007             MOVS     R0,#+7
   \   000000D4   0x.... 0x....      BL       Set_DriverStates
    213                  RdBrd_ErrCdLogErrCd( REPAIR_I2C, MODULE_main );
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x2014             MOVS     R0,#+20
   \   000000DC   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    214                  // Now..Initialize I2C and test Drivers.
    215                  MX_I2C1_Init();
   \   000000E0   0x.... 0x....      BL       MX_I2C1_Init
   \   000000E4   0xE007             B.N      ??main_3
    216                }
    217                else
    218                {
    219                  // OK...It is hung.
    220                  Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \                     ??main_4: (+1)
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0x.... 0x....      BL       Set_DriverStates
    221                  RdBrd_ErrCdLogErrCd( ERROR_I2CBUSY, MODULE_main );
   \   000000EE   0x2101             MOVS     R1,#+1
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    222                }
    223              }
    224            }
    225          
    226            //BGM Initialization
    227          #ifndef TEST2
    228          #ifndef PATCH_UART
    229            BGM111_Init();
   \                     ??main_3: (+1)
   \   000000F6   0x.... 0x....      BL       BGM111_Init
    230          #else
    231            RoadBrd_gpio_Off(gRESET_BGM111);
    232          #endif
    233          #endif
    234            
    235            // Test I2C Status and Task init I2C if Active driver.
    236            if ( Get_DriverStates( I2C_STATE ) )
   \   000000FA   0x2007             MOVS     R0,#+7
   \   000000FC   0x.... 0x....      BL       Get_DriverStates
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD061             BEQ.N    ??main_5
    237            {
    238          #ifdef WM
    239          #ifdef RGBSENSOR
    240              Status = RoadBrd_RGBInit();
    241          #else
    242              Status = HAL_ERROR;
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x0004             MOVS     R4,R0
    243          #endif
    244              if (Status == HAL_OK)
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0x2C00             CMP      R4,#+0
   \   0000010C   0xD104             BNE.N    ??main_6
    245              {
    246                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_ON );
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x2002             MOVS     R0,#+2
   \   00000112   0x.... 0x....      BL       Set_DriverStates
   \   00000116   0xE003             B.N      ??main_7
    247              }
    248              else
    249              {
    250          #ifndef WM
    251                RdBrd_ErrCdLogErrCd( ERROR_RGB_INIT, MODULE_main );
    252          #endif
    253                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_6: (+1)
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0x.... 0x....      BL       Set_DriverStates
    254              }
    255          
    256              // Initialize Voltage Monitor Hardware
    257          #ifdef POWERSENSOR
    258              Status = RoadBrd_Init_VMonitor();
    259          #else
    260              Status = HAL_ERROR;
   \                     ??main_7: (+1)
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x0004             MOVS     R4,R0
    261          #endif
    262              if (Status == HAL_OK)
   \   00000124   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000126   0x2C00             CMP      R4,#+0
   \   00000128   0xD104             BNE.N    ??main_8
    263              {
    264                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_ON );
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x.... 0x....      BL       Set_DriverStates
   \   00000132   0xE003             B.N      ??main_9
    265              }
    266              else
    267              {
    268          #ifndef WM
    269                RdBrd_ErrCdLogErrCd( ERROR_VMNTR_INIT, MODULE_main );
    270          #endif
    271                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_8: (+1)
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x.... 0x....      BL       Set_DriverStates
    272              }
    273          
    274              // Initialize Grid Eye Hardware
    275          #ifdef GRIDEYESENSOR
    276              Status = RoadBrd_GridEyeInit();
    277          #else
    278              Status = HAL_ERROR;
   \                     ??main_9: (+1)
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0x0004             MOVS     R4,R0
    279          #endif
    280              if (Status == HAL_OK)
   \   00000140   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000142   0x2C00             CMP      R4,#+0
   \   00000144   0xD104             BNE.N    ??main_10
    281              {
    282                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_ON );
   \   00000146   0x2101             MOVS     R1,#+1
   \   00000148   0x2005             MOVS     R0,#+5
   \   0000014A   0x.... 0x....      BL       Set_DriverStates
   \   0000014E   0xE011             B.N      ??main_11
    283              }
    284              else
    285              {
    286          #ifndef WM
    287                RdBrd_ErrCdLogErrCd( ERROR_GDEYE_INIT, MODULE_main );
    288          #endif
    289                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_10: (+1)
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x2005             MOVS     R0,#+5
   \   00000154   0x.... 0x....      BL       Set_DriverStates
    290                // OK, We have no Grid Eye...Do we have a Cool Eye?
    291          #ifdef GRIDEYESENSOR
    292                Status = RoadBrd_CoolEyeInit();
    293          #else
    294                Status = HAL_ERROR;
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x0004             MOVS     R4,R0
    295          #endif
    296                if (Status == HAL_OK)
   \   0000015C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015E   0x2C00             CMP      R4,#+0
   \   00000160   0xD104             BNE.N    ??main_12
    297                {
    298                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_ON );
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x2006             MOVS     R0,#+6
   \   00000166   0x.... 0x....      BL       Set_DriverStates
   \   0000016A   0xE003             B.N      ??main_11
    299                }
    300                else
    301                {
    302          #ifndef WM
    303                  RdBrd_ErrCdLogErrCd( ERROR_CLEYE_INIT, MODULE_main );
    304          #endif
    305                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_12: (+1)
   \   0000016C   0x2100             MOVS     R1,#+0
   \   0000016E   0x2006             MOVS     R0,#+6
   \   00000170   0x.... 0x....      BL       Set_DriverStates
    306                }
    307              }
    308          
    309              // Initialize Pressure Sensor Hardware
    310          #ifdef PRESSURESENSOR
    311              Status = RoadBrd_Init_Barometer();
    312          #else
    313              Status = HAL_ERROR;
   \                     ??main_11: (+1)
   \   00000174   0x2001             MOVS     R0,#+1
   \   00000176   0x0004             MOVS     R4,R0
    314          #endif
    315              if (Status == HAL_OK)
   \   00000178   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000017A   0x2C00             CMP      R4,#+0
   \   0000017C   0xD104             BNE.N    ??main_13
    316              {
    317                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_ON );
   \   0000017E   0x2101             MOVS     R1,#+1
   \   00000180   0x2003             MOVS     R0,#+3
   \   00000182   0x.... 0x....      BL       Set_DriverStates
   \   00000186   0xE003             B.N      ??main_14
    318              }
    319              else
    320              {
    321          #ifndef WM
    322                RdBrd_ErrCdLogErrCd( ERROR_PRESSURE_INIT, MODULE_main );
    323          #endif
    324                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_13: (+1)
   \   00000188   0x2100             MOVS     R1,#+0
   \   0000018A   0x2003             MOVS     R0,#+3
   \   0000018C   0x.... 0x....      BL       Set_DriverStates
    325              }
    326          
    327              // Initialize Humidity Sensor Hardware
    328          #ifdef HUMIDITYSENSOR
    329              Status = RoadBrd_HumidityInit();
    330          #else
    331              Status = HAL_ERROR;
   \                     ??main_14: (+1)
   \   00000190   0x2001             MOVS     R0,#+1
   \   00000192   0x0004             MOVS     R4,R0
    332          #endif
    333              if (Status == HAL_OK)
   \   00000194   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000196   0x2C00             CMP      R4,#+0
   \   00000198   0xD104             BNE.N    ??main_15
    334              {
    335                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_ON );
   \   0000019A   0x2101             MOVS     R1,#+1
   \   0000019C   0x2004             MOVS     R0,#+4
   \   0000019E   0x.... 0x....      BL       Set_DriverStates
   \   000001A2   0xE003             B.N      ??main_16
    336              }
    337              else
    338              {
    339          #ifndef WM
    340                RdBrd_ErrCdLogErrCd( ERROR_HUMIDITY_INIT, MODULE_main );
    341          #endif
    342                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_OFF );
   \                     ??main_15: (+1)
   \   000001A4   0x2100             MOVS     R1,#+0
   \   000001A6   0x2004             MOVS     R0,#+4
   \   000001A8   0x.... 0x....      BL       Set_DriverStates
    343              }
    344            
    345              // Test Temperature Sensor Hardware
    346          #ifdef TEMPSENSOR
    347              Status = RoadBrd_ReadTemp( &Temp );
    348          #else
    349              Status = HAL_ERROR;
   \                     ??main_16: (+1)
   \   000001AC   0x2001             MOVS     R0,#+1
   \   000001AE   0x0004             MOVS     R4,R0
    350          #endif
    351              if (Status == HAL_OK)
   \   000001B0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B2   0x2C00             CMP      R4,#+0
   \   000001B4   0xD104             BNE.N    ??main_17
    352              {
    353                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_ON );
   \   000001B6   0x2101             MOVS     R1,#+1
   \   000001B8   0x2001             MOVS     R0,#+1
   \   000001BA   0x.... 0x....      BL       Set_DriverStates
   \   000001BE   0xE003             B.N      ??main_5
    354              }
    355              else
    356              {
    357          #ifndef WM
    358                RdBrd_ErrCdLogErrCd( ERROR_TEMP_INIT, MODULE_main );
    359          #endif
    360                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_OFF );
   \                     ??main_17: (+1)
   \   000001C0   0x2100             MOVS     R1,#+0
   \   000001C2   0x2001             MOVS     R0,#+1
   \   000001C4   0x.... 0x....      BL       Set_DriverStates
    361              }
    362          #else
    363              Status = RoadBrd_RGBInit();
    364              if (Status == HAL_OK)
    365              {
    366                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_ON );
    367              }
    368              else
    369              {
    370          #ifndef WM
    371                RdBrd_ErrCdLogErrCd( ERROR_RGB_INIT, MODULE_main );
    372          #endif
    373                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_OFF );
    374              }
    375          
    376              // Initialize Voltage Monitor Hardware
    377              Status = RoadBrd_Init_VMonitor();
    378              if (Status == HAL_OK)
    379              {
    380                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_ON );
    381              }
    382              else
    383              {
    384          #ifndef WM
    385                RdBrd_ErrCdLogErrCd( ERROR_VMNTR_INIT, MODULE_main );
    386          #endif
    387                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_OFF );
    388              }
    389          
    390              // Initialize Grid Eye Hardware
    391              Status = RoadBrd_GridEyeInit();
    392              if (Status == HAL_OK)
    393              {
    394                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_ON );
    395              }
    396              else
    397              {
    398                RdBrd_ErrCdLogErrCd( ERROR_GDEYE_INIT, MODULE_main );
    399                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_OFF );
    400                // OK, We have no Grid Eye...Do we have a Cool Eye?
    401                Status = RoadBrd_CoolEyeInit();
    402                if (Status == HAL_OK)
    403                {
    404                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_ON );
    405                }
    406                else
    407                {
    408          #ifndef WM
    409                  RdBrd_ErrCdLogErrCd( ERROR_CLEYE_INIT, MODULE_main );
    410          #endif
    411                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_OFF );
    412                }
    413              }
    414          
    415              // Initialize Pressure Sensor Hardware
    416              Status = RoadBrd_Init_Barometer();
    417              if (Status == HAL_OK)
    418              {
    419                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_ON );
    420              }
    421              else
    422              {
    423          #ifndef WM
    424                RdBrd_ErrCdLogErrCd( ERROR_PRESSURE_INIT, MODULE_main );
    425          #endif
    426                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_OFF );
    427              }
    428          
    429              // Initialize Humidity Sensor Hardware
    430              Status = RoadBrd_HumidityInit();
    431              if (Status == HAL_OK)
    432              {
    433                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_ON );
    434              }
    435              else
    436              {
    437          #ifndef WM
    438                RdBrd_ErrCdLogErrCd( ERROR_HUMIDITY_INIT, MODULE_main );
    439          #endif
    440                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_OFF );
    441              }
    442            
    443              // Test Temperature Sensor Hardware
    444              Status = RoadBrd_ReadTemp( &Temp );
    445              if (Status == HAL_OK)
    446              {
    447                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_ON );
    448              }
    449              else
    450              {
    451          #ifndef WM
    452                RdBrd_ErrCdLogErrCd( ERROR_TEMP_INIT, MODULE_main );
    453          #endif
    454                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_OFF );
    455              }
    456          #endif
    457            } //EndIf ( Get_DriverStates( I2C_STATE )
    458            
    459            // Initialize key app vars.
    460            InitSensors();
   \                     ??main_5: (+1)
   \   000001C8   0x.... 0x....      BL       InitSensors
    461            RoadBrd_ParserInit();                         // This initializes the Parse Tasking Structure.
   \   000001CC   0x.... 0x....      BL       RoadBrd_ParserInit
    462            RoadBrd_WWDG_InitializeDateString();          // Initialize Date Tag From Server as NULL.
   \   000001D0   0x.... 0x....      BL       RoadBrd_WWDG_InitializeDateString
    463            RoadBrd_WWDG_InitializeTickString();          // Initialize Tick Tag From as NULL.
   \   000001D4   0x.... 0x....      BL       RoadBrd_WWDG_InitializeTickString
    464            //**
    465            //**
    466            //** Initialize all Flash Structures.
    467            //**
    468            //**
    469            //*******1. Initializ WWDG Flash Structure
    470            // 1a. Is WWDG Flash Frame Initialized?
    471            if (RoadBrd_WWDG_VerifyFrame())
   \   000001D8   0x.... 0x....      BL       RoadBrd_WWDG_VerifyFrame
   \   000001DC   0x2800             CMP      R0,#+0
   \   000001DE   0xD004             BEQ.N    ??main_18
    472            {
    473              //Yes....Set FRAME_TASK Bit in Driver State Variable.
    474              Set_DriverStates( FRAME_TASK, DRIVER_ON );
   \   000001E0   0x2101             MOVS     R1,#+1
   \   000001E2   0x2008             MOVS     R0,#+8
   \   000001E4   0x.... 0x....      BL       Set_DriverStates
   \   000001E8   0xE010             B.N      ??main_19
    475            } // EndIf (RoadBrd_WWDG_VerifyFrame())
    476            else
    477            {
    478              //No....1b. Attempt to Initialize WWDG Flash Frame.
    479              if (RoadBrd_WWDG_InitializeFrmFlash() != HAL_OK)
   \                     ??main_18: (+1)
   \   000001EA   0x.... 0x....      BL       RoadBrd_WWDG_InitializeFrmFlash
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD008             BEQ.N    ??main_20
    480              {
    481                //FAILED....Indicate Error Code and Fail Driver State.
    482                RdBrd_ErrCdLogErrCd( ERROR_FRAME_INIT, MODULE_main );
   \   000001F2   0x2101             MOVS     R1,#+1
   \   000001F4   0x2010             MOVS     R0,#+16
   \   000001F6   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    483                Set_DriverStates( FRAME_TASK, DRIVER_OFF );
   \   000001FA   0x2100             MOVS     R1,#+0
   \   000001FC   0x2008             MOVS     R0,#+8
   \   000001FE   0x.... 0x....      BL       Set_DriverStates
   \   00000202   0xE003             B.N      ??main_19
    484              }
    485              else
    486              {
    487                //SUCCESS....Set FRAME_TASK Bit in Driver State Variable.
    488                Set_DriverStates( FRAME_TASK, DRIVER_ON );
   \                     ??main_20: (+1)
   \   00000204   0x2101             MOVS     R1,#+1
   \   00000206   0x2008             MOVS     R0,#+8
   \   00000208   0x.... 0x....      BL       Set_DriverStates
    489              }
    490            } // EndElse (RoadBrd_WWDG_VerifyFrame())
    491            
    492            //*******2. Initializ Calibration Flash Structure
    493            // 2a. Is Calibration Flash Frame Initialized?
    494            if (RoadBrd_CAL_VerifyFrame())
   \                     ??main_19: (+1)
   \   0000020C   0x.... 0x....      BL       RoadBrd_CAL_VerifyFrame
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD004             BEQ.N    ??main_21
    495            {
    496              //Yes....Set CAL_TASK Bit in Driver State Variable.
    497              Set_DriverStates( CAL_TASK, DRIVER_ON );
   \   00000214   0x2101             MOVS     R1,#+1
   \   00000216   0x2009             MOVS     R0,#+9
   \   00000218   0x.... 0x....      BL       Set_DriverStates
   \   0000021C   0xE010             B.N      ??main_22
    498            } // EndIf (RoadBrd_WWDG_VerifyFrame())
    499            else
    500            {
    501              //No....2b. Attempt to Initialize Structure Flash Structure.
    502              if (RoadBrd_CAL_InitializeFrmFlash() != HAL_OK)
   \                     ??main_21: (+1)
   \   0000021E   0x.... 0x....      BL       RoadBrd_CAL_InitializeFrmFlash
   \   00000222   0x2800             CMP      R0,#+0
   \   00000224   0xD008             BEQ.N    ??main_23
    503              {
    504                //FAILED....Indicate Error Code and Fail Driver State.
    505                RdBrd_ErrCdLogErrCd( ERROR_CAL_INIT, MODULE_main );
   \   00000226   0x2101             MOVS     R1,#+1
   \   00000228   0x2013             MOVS     R0,#+19
   \   0000022A   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    506                Set_DriverStates( CAL_TASK, DRIVER_OFF );
   \   0000022E   0x2100             MOVS     R1,#+0
   \   00000230   0x2009             MOVS     R0,#+9
   \   00000232   0x.... 0x....      BL       Set_DriverStates
   \   00000236   0xE003             B.N      ??main_22
    507              }
    508              else
    509              {
    510                //SUCCESS....Set FRAME_TASK Bit in Driver State Variable.
    511                Set_DriverStates( CAL_TASK, DRIVER_ON );
   \                     ??main_23: (+1)
   \   00000238   0x2101             MOVS     R1,#+1
   \   0000023A   0x2009             MOVS     R0,#+9
   \   0000023C   0x.... 0x....      BL       Set_DriverStates
    512              }
    513            } // EndElse (RoadBrd_WWDG_VerifyFrame())
    514            
    515            
    516          // Initialize Key Vars once Flash has been validated.
    517            // Initialize Key Timer Sampling Vars.
    518            Set_TickCounts( RoadBrd_Get_RdSndTickCnt(), RoadBrd_Get_SnsrTickCnt() );
   \                     ??main_22: (+1)
   \   00000240   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   00000244   0x0006             MOVS     R6,R0
   \   00000246   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   0000024A   0x0031             MOVS     R1,R6
   \   0000024C   0x.... 0x....      BL       Set_TickCounts
    519              
    520            // Time to start WWDG..
    521            HAL_NVIC_EnableIRQ(WWDG_IRQn);
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    522            MX_WWDG_Init();
   \   00000256   0x.... 0x....      BL       MX_WWDG_Init
    523            RoadBrd_WWDG_Start();
   \   0000025A   0x.... 0x....      BL       RoadBrd_WWDG_Start
    524          
    525          #endif
    526          
    527          #ifdef TASKING
    528            /* USER CODE END 2 */
    529          
    530            /* Call init function for freertos objects (in freertos.c) */
    531            MX_FREERTOS_Init();
    532          
    533            /* Start scheduler */
    534            osKernelStart();
    535            
    536            /* We should never get here as control is now taken by the scheduler */
    537          
    538            /* Infinite loop */
    539            /* USER CODE BEGIN WHILE */
    540          #else
    541            
    542            #ifdef TEST
    543                // Turn On Bluetooth Interface for Debug.
    544                RoadBrd_gpio_On( gRESET_BGM111 );
    545            #else
    546          //    #ifndef TEST2
    547                #ifdef ASCII
    548                  // Send Opening Banner for Monitor Code.
    549                  #ifdef NUCLEO
    550          //        strcpy( (char *)tempBffr2, "*********************  WEATHERCLOUD *********************\r\n\r\n");
    551                    strcpy( (char *)tempBffr2, "\r\n\r\n");
    552                    // Send string to UART..
    553          #ifdef REV_L
    554                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    555                    // Wait for msg to be completed.
    556                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    557                    {
    558                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    559                    }
    560                    // Clear State for Next Transfer.
    561                    clrUsartState( NUCLEO_USART );
    562          #else
    563                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    564                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    565          #endif
    566                    if (Status != HAL_OK)
    567                      Error_Handler();
    568          #ifdef WM
    569                    sprintf( (char *)tempBffr2, "     Weather Mesh Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
    570          #else
    571                    sprintf( (char *)tempBffr2, "     Road Board Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
    572          #endif
    573                    //strcpy( (char *)tempBffr2, "     Road Board Monitor Rev K Hardware Version 1.0 \r\n");
    574                    // Send string to UART..
    575          #ifdef REV_L
    576                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    577                    // Wait for msg to be completed.
    578                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    579                    {
    580                    }
    581                    // Clear State for Next Transfer.
    582                    clrUsartState( NUCLEO_USART );
    583          #else
    584                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    585          #endif
    586                    if (Status != HAL_OK)
    587                      Error_Handler();
    588                    sprintf( (char *)tempBffr2, "                  Copyright %s. \r\n\r\n", REL_DATE);
    589                    //strcpy( (char *)tempBffr2, "                  Copyright August 9, 2016. \r\n\r\n\r\n> ");
    590                    // Send string to UART..
    591                    // *******Time to Build Extra Information...
    592          #ifdef REV_L
    593                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    594                    // Wait for msg to be completed.
    595                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    596                    {
    597                    }
    598                    // Clear State for Next Transfer.
    599                    clrUsartState( NUCLEO_USART );
    600          #else
    601                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    602          #endif
    603                    if (Status != HAL_OK)
    604                      Error_Handler();
    605                    sprintf( (char *)tempBffr2, "RdSnd Sample Rate:  %3.1f Seconds.\r\n", ((float)RoadBrd_Get_RdSndTickCnt()/10));
    606          #ifdef REV_L
    607                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    608                    // Wait for msg to be completed.
    609                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    610                    {
    611                    }
    612                    // Clear State for Next Transfer.
    613                    clrUsartState( NUCLEO_USART );
    614          #else
    615                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    616          #endif
    617                    if (Status != HAL_OK)
    618                      Error_Handler();
    619                    sprintf( (char *)tempBffr2, "Sensor Sample Rate: %3.1f Seconds.\r\n\r\n> ", ((float)RoadBrd_Get_SnsrTickCnt()/10));
    620          #ifdef REV_L
    621                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    622                    // Wait for msg to be completed.
    623                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    624                    {
    625                    }
    626                    // Clear State for Next Transfer.
    627                    clrUsartState( NUCLEO_USART );
    628          #else
    629                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    630          #endif
    631                    if (Status != HAL_OK)
    632                      Error_Handler();
    633                  #else
    634                    strcpy( (char *)tempBffr2, "*********************  WEATHERCLOUD *********************\r\n\r\n");
   \   0000025E   0x.... 0x....      LDR.W    R1,??DataTable1_1
   \   00000262   0x4668             MOV      R0,SP
   \   00000264   0x.... 0x....      BL       strcpy
    635                    // Send string to UART..
    636          #ifdef REV_L
    637                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   00000268   0x4669             MOV      R1,SP
   \   0000026A   0x2000             MOVS     R0,#+0
   \   0000026C   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   00000270   0x0004             MOVS     R4,R0
    638                    // Wait for msg to be completed.
    639                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_24: (+1)
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000278   0x2801             CMP      R0,#+1
   \   0000027A   0xD002             BEQ.N    ??main_25
    640                    {
    641                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   0000027C   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   00000280   0xE7F7             B.N      ??main_24
    642                    }
    643                    // Clear State for Next Transfer.
    644                    clrUsartState( MONITOR_UART );
   \                     ??main_25: (+1)
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x.... 0x....      BL       clrUsartState
    645          #else
    646                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    647                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    648          #endif
    649                    if (Status != HAL_OK)
   \   00000288   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000028A   0x2C00             CMP      R4,#+0
   \   0000028C   0xD001             BEQ.N    ??main_26
    650                      Error_Handler();
   \   0000028E   0x.... 0x....      BL       Error_Handler
    651          #ifdef WM
    652                    sprintf( (char *)tempBffr2, "     Weather Mesh Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
   \                     ??main_26: (+1)
   \   00000292   0x.... 0x....      LDR.W    R3,??DataTable1_2
   \   00000296   0x.... 0x....      LDR.W    R2,??DataTable1_3
   \   0000029A   0x.... 0x....      LDR.W    R1,??DataTable1_4
   \   0000029E   0x4668             MOV      R0,SP
   \   000002A0   0x.... 0x....      BL       sprintf
    653          #else
    654                    sprintf( (char *)tempBffr2, "     Road Board Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
    655          #endif
    656                    //strcpy( (char *)tempBffr2, "     Road Board Monitor Rev K Hardware Version 1.0 \r\n");
    657                    // Send string to UART..
    658          #ifdef REV_L
    659                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000002A4   0x4669             MOV      R1,SP
   \   000002A6   0x2000             MOVS     R0,#+0
   \   000002A8   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000002AC   0x0004             MOVS     R4,R0
    660                    // Wait for msg to be completed.
    661                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_27: (+1)
   \   000002AE   0x2000             MOVS     R0,#+0
   \   000002B0   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000002B4   0x2801             CMP      R0,#+1
   \   000002B6   0xD002             BEQ.N    ??main_28
    662                    {
    663                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   000002B8   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   000002BC   0xE7F7             B.N      ??main_27
    664                    }
    665                    // Clear State for Next Transfer.
    666                    clrUsartState( MONITOR_UART );
   \                     ??main_28: (+1)
   \   000002BE   0x2000             MOVS     R0,#+0
   \   000002C0   0x.... 0x....      BL       clrUsartState
    667          #else
    668                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    669                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    670          #endif
    671                    if (Status != HAL_OK)
   \   000002C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002C6   0x2C00             CMP      R4,#+0
   \   000002C8   0xD001             BEQ.N    ??main_29
    672                      Error_Handler();
   \   000002CA   0x.... 0x....      BL       Error_Handler
    673                    sprintf( (char *)tempBffr2, "                  Copyright %s. \r\n\r\n", REL_DATE);
   \                     ??main_29: (+1)
   \   000002CE   0x.... 0x....      LDR.W    R2,??DataTable1_5
   \   000002D2   0x.... 0x....      LDR.W    R1,??DataTable1_6
   \   000002D6   0x4668             MOV      R0,SP
   \   000002D8   0x.... 0x....      BL       sprintf
    674                    //strcpy( (char *)tempBffr2, "                  Copyright August 9, 2016. \r\n\r\n\r\n> ");
    675                    // Send string to UART..
    676          #ifdef REV_L
    677                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000002DC   0x4669             MOV      R1,SP
   \   000002DE   0x2000             MOVS     R0,#+0
   \   000002E0   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000002E4   0x0004             MOVS     R4,R0
    678                    // Wait for msg to be completed.
    679                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_30: (+1)
   \   000002E6   0x2000             MOVS     R0,#+0
   \   000002E8   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000002EC   0x2801             CMP      R0,#+1
   \   000002EE   0xD002             BEQ.N    ??main_31
    680                    {
    681                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   000002F0   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   000002F4   0xE7F7             B.N      ??main_30
    682                    }
    683                    // Clear State for Next Transfer.
    684                    clrUsartState( MONITOR_UART );
   \                     ??main_31: (+1)
   \   000002F6   0x2000             MOVS     R0,#+0
   \   000002F8   0x.... 0x....      BL       clrUsartState
    685          #else
    686                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    687                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    688          #endif
    689                    if (Status != HAL_OK)
   \   000002FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002FE   0x2C00             CMP      R4,#+0
   \   00000300   0xD001             BEQ.N    ??main_32
    690                      Error_Handler();
   \   00000302   0x.... 0x....      BL       Error_Handler
    691                    // *******Time to Build Extra Information...
    692                    sprintf( (char *)tempBffr2, "RdSnd Sample Rate:  %3.1f Seconds.\r\n", ((float)RoadBrd_Get_RdSndTickCnt()/10));
   \                     ??main_32: (+1)
   \   00000306   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   0000030A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000030E   0x.... 0x....      LDR.W    R1,??DataTable1_7  ;; 0x41200000
   \   00000312   0x.... 0x....      BL       __aeabi_fdiv
   \   00000316   0x.... 0x....      BL       __aeabi_f2d
   \   0000031A   0x0002             MOVS     R2,R0
   \   0000031C   0x000B             MOVS     R3,R1
   \   0000031E   0x.... 0x....      LDR.W    R1,??DataTable1_8
   \   00000322   0x4668             MOV      R0,SP
   \   00000324   0x.... 0x....      BL       sprintf
    693          #ifdef REV_L
    694                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   00000328   0x4669             MOV      R1,SP
   \   0000032A   0x2000             MOVS     R0,#+0
   \   0000032C   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   00000330   0x0004             MOVS     R4,R0
    695                    // Wait for msg to be completed.
    696                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_33: (+1)
   \   00000332   0x2000             MOVS     R0,#+0
   \   00000334   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000338   0x2801             CMP      R0,#+1
   \   0000033A   0xD1FA             BNE.N    ??main_33
    697                    {
    698                    }
    699                    // Clear State for Next Transfer.
    700                    clrUsartState( NUCLEO_USART );
   \   0000033C   0x2000             MOVS     R0,#+0
   \   0000033E   0x.... 0x....      BL       clrUsartState
    701          #else
    702                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    703          #endif
    704                    if (Status != HAL_OK)
   \   00000342   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000344   0x2C00             CMP      R4,#+0
   \   00000346   0xD001             BEQ.N    ??main_34
    705                      Error_Handler();
   \   00000348   0x.... 0x....      BL       Error_Handler
    706                    sprintf( (char *)tempBffr2, "Sensor Sample Rate: %3.1f Seconds.\r\n", ((float)RoadBrd_Get_SnsrTickCnt()/10));
   \                     ??main_34: (+1)
   \   0000034C   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   00000350   0x.... 0x....      BL       __aeabi_ui2f
   \   00000354   0x....             LDR.N    R1,??DataTable1_7  ;; 0x41200000
   \   00000356   0x.... 0x....      BL       __aeabi_fdiv
   \   0000035A   0x.... 0x....      BL       __aeabi_f2d
   \   0000035E   0x0002             MOVS     R2,R0
   \   00000360   0x000B             MOVS     R3,R1
   \   00000362   0x....             LDR.N    R1,??DataTable1_9
   \   00000364   0x4668             MOV      R0,SP
   \   00000366   0x.... 0x....      BL       sprintf
    707          #ifdef REV_L
    708                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   0000036A   0x4669             MOV      R1,SP
   \   0000036C   0x2000             MOVS     R0,#+0
   \   0000036E   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   00000372   0x0004             MOVS     R4,R0
    709                    // Wait for msg to be completed.
    710                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_35: (+1)
   \   00000374   0x2000             MOVS     R0,#+0
   \   00000376   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   0000037A   0x2801             CMP      R0,#+1
   \   0000037C   0xD1FA             BNE.N    ??main_35
    711                    {
    712                    }
    713                    // Clear State for Next Transfer.
    714                    clrUsartState( NUCLEO_USART );
   \   0000037E   0x2000             MOVS     R0,#+0
   \   00000380   0x.... 0x....      BL       clrUsartState
    715          #else
    716                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    717          #endif
    718                    if (Status != HAL_OK)
   \   00000384   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000386   0x2C00             CMP      R4,#+0
   \   00000388   0xD001             BEQ.N    ??main_36
    719                      Error_Handler();
   \   0000038A   0x.... 0x....      BL       Error_Handler
    720                    sprintf( (char *)tempBffr2, "TACK Limit: %d.\r\n", RoadBrd_Get_TackLimit() );
   \                     ??main_36: (+1)
   \   0000038E   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   00000392   0x0002             MOVS     R2,R0
   \   00000394   0x....             LDR.N    R1,??DataTable1_10
   \   00000396   0x4668             MOV      R0,SP
   \   00000398   0x.... 0x....      BL       sprintf
    721          #ifdef REV_L
    722                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   0000039C   0x4669             MOV      R1,SP
   \   0000039E   0x2000             MOVS     R0,#+0
   \   000003A0   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000003A4   0x0004             MOVS     R4,R0
    723                    // Wait for msg to be completed.
    724                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_37: (+1)
   \   000003A6   0x2000             MOVS     R0,#+0
   \   000003A8   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000003AC   0x2801             CMP      R0,#+1
   \   000003AE   0xD1FA             BNE.N    ??main_37
    725                    {
    726                    }
    727                    // Clear State for Next Transfer.
    728                    clrUsartState( NUCLEO_USART );
   \   000003B0   0x2000             MOVS     R0,#+0
   \   000003B2   0x.... 0x....      BL       clrUsartState
    729          #else
    730                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    731          #endif
    732                    if (Status != HAL_OK)
   \   000003B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003B8   0x2C00             CMP      R4,#+0
   \   000003BA   0xD001             BEQ.N    ??main_38
    733                      Error_Handler();
   \   000003BC   0x.... 0x....      BL       Error_Handler
    734                    sprintf( (char *)tempBffr2, "Boot Delay: %d Seconds.\r\n", RoadBrd_Get_BootDelay() );
   \                     ??main_38: (+1)
   \   000003C0   0x.... 0x....      BL       RoadBrd_Get_BootDelay
   \   000003C4   0x0002             MOVS     R2,R0
   \   000003C6   0x....             LDR.N    R1,??DataTable1_11
   \   000003C8   0x4668             MOV      R0,SP
   \   000003CA   0x.... 0x....      BL       sprintf
    735          #ifdef REV_L
    736                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   000003CE   0x4669             MOV      R1,SP
   \   000003D0   0x2000             MOVS     R0,#+0
   \   000003D2   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000003D6   0x0004             MOVS     R4,R0
    737                    // Wait for msg to be completed.
    738                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_39: (+1)
   \   000003D8   0x2000             MOVS     R0,#+0
   \   000003DA   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000003DE   0x2801             CMP      R0,#+1
   \   000003E0   0xD1FA             BNE.N    ??main_39
    739                    {
    740                    }
    741                    // Clear State for Next Transfer.
    742                    clrUsartState( NUCLEO_USART );
   \   000003E2   0x2000             MOVS     R0,#+0
   \   000003E4   0x.... 0x....      BL       clrUsartState
    743          #else
    744                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    745          #endif
    746                    if (Status != HAL_OK)
   \   000003E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003EA   0x2C00             CMP      R4,#+0
   \   000003EC   0xD001             BEQ.N    ??main_40
    747                      Error_Handler();
   \   000003EE   0x.... 0x....      BL       Error_Handler
    748                    // Now Display the Units Enabled State.
    749                    if (RoadBrd_Get_UnitsFlag())
   \                     ??main_40: (+1)
   \   000003F2   0x.... 0x....      BL       RoadBrd_Get_UnitsFlag
   \   000003F6   0x2800             CMP      R0,#+0
   \   000003F8   0xD004             BEQ.N    ??main_41
    750                    {
    751                      sprintf( (char *)tempBffr2, "Units XML State: ENABLED\r\n\r\n> ");
   \   000003FA   0x....             LDR.N    R1,??DataTable1_12
   \   000003FC   0x4668             MOV      R0,SP
   \   000003FE   0x.... 0x....      BL       sprintf
   \   00000402   0xE003             B.N      ??main_42
    752                    }
    753                    else
    754                    {
    755                      sprintf( (char *)tempBffr2, "Units XML State: DISABLED\r\n\r\n> ");
   \                     ??main_41: (+1)
   \   00000404   0x....             LDR.N    R1,??DataTable1_13
   \   00000406   0x4668             MOV      R0,SP
   \   00000408   0x.... 0x....      BL       sprintf
    756                    }
    757          #ifdef REV_L
    758                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \                     ??main_42: (+1)
   \   0000040C   0x4669             MOV      R1,SP
   \   0000040E   0x2000             MOVS     R0,#+0
   \   00000410   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   00000414   0x0004             MOVS     R4,R0
    759                    // Wait for msg to be completed.
    760                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_43: (+1)
   \   00000416   0x2000             MOVS     R0,#+0
   \   00000418   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   0000041C   0x2801             CMP      R0,#+1
   \   0000041E   0xD1FA             BNE.N    ??main_43
    761                    {
    762                    }
    763                    // Clear State for Next Transfer.
    764                    clrUsartState( NUCLEO_USART );
   \   00000420   0x2000             MOVS     R0,#+0
   \   00000422   0x.... 0x....      BL       clrUsartState
    765          #else
    766                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    767          #endif
    768                    if (Status != HAL_OK)
   \   00000426   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000428   0x2C00             CMP      R4,#+0
   \   0000042A   0xD001             BEQ.N    ??main_44
    769                      Error_Handler();
   \   0000042C   0x.... 0x....      BL       Error_Handler
    770          #ifdef BUG_ENABLE
    771                    SCB->CCR |= 0x10;
    772                    int a = 10;
    773                    int b = 0;
    774                    int c;
    775                    c = a/b;
    776                    sprintf( (char *)tempBffr2, "Bug Value Dump: %d\r\n\r\n> ",c);
    777            #ifdef REV_L
    778                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    779                    // Wait for msg to be completed.
    780                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    781                    {
    782                    }
    783                    // Clear State for Next Transfer.
    784                    clrUsartState( NUCLEO_USART );
    785            #else
    786                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    787            #endif
    788          #endif          
    789                 #endif
    790          //      #endif
    791              #endif
    792            #endif
    793            while (1)
    794            {
    795            /* USER CODE END WHILE */
    796          
    797            /* USER CODE BEGIN 3 */
    798            /****************************************************************************
    799              * TEST CODE....Blinks LEDs for both Road Board and Nucleo Board.
    800              **************************************************************************/
    801            #ifdef TEST
    802              #ifdef NUCLEO
    803                // Turn On NUCLEO_LED_GREEN LED.
    804                RoadBrd_gpio_On( NUCLEO_LED_GREEN );
    805                // Wait 500msec.
    806                RoadBrd_Delay( 500 );
    807                // Turn Off NUCLEO_LED_GREEN LED.
    808                RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    809              #else
    810                // Turn On Blue LED and turn off Yellow LED.
    811                RoadBrd_gpio_On( BLUE_LED );
    812                RoadBrd_gpio_Off( YELLOW_LED );
    813                // Wait 500msec.
    814                RoadBrd_Delay( 500 );
    815                // Turn On Green LED and turn off Blue LED.
    816                RoadBrd_gpio_On( GREEN_LED );
    817                RoadBrd_gpio_Off( BLUE_LED );
    818                // Wait 500msec.
    819                RoadBrd_Delay( 500 );
    820                // Turn On Yellow LED and turn off Green LED.
    821                RoadBrd_gpio_On( YELLOW_LED );
    822                RoadBrd_gpio_Off( GREEN_LED );
    823              #endif
    824              // Wait 500msec.
    825              RoadBrd_Delay( 500 );
    826            //******************Endif TEST
    827            #else
    828            //******************Else TEST
    829          
    830            /****************************************************************************
    831             * TEST2 CODE....Reads COM port and translates back to sender. Simple COMM test.
    832             **************************************************************************/
    833              #ifdef TEST2
    834                #ifdef NUCLEO
    835                  // Turn Off NUCLEO_LED_GREEN LED.
    836                  RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    837                  // Wait on a character from Nucleo COM Port.
    838          #ifdef REV_L
    839                  Status = RoadBrd_UART_Receive_IT(NUCLEO_USART, tempBffr, 1);
    840                  // Wait for msg to be completed.
    841                  while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    842                  {
    843                  }
    844                  // Clear State for Next Transfer.
    845                  clrUsartState( NUCLEO_USART );
    846          #else
    847                  Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, 1);
    848          #endif
    849                  // Turn On NUCLEO_LED_GREEN LED.
    850                  RoadBrd_gpio_On( NUCLEO_LED_GREEN );
    851                  switch(  Status)
    852                  {
    853                    case HAL_OK:
    854                      // We have a good character. Time to build a response string.
    855                      tempBffr2[0] = '(';
    856                      tempBffr2[1] = tempBffr[0];
    857                      tempBffr2[2] = ')';
    858                      tempBffr2[3] = 0x00;
    859                      // Send string to UART..
    860          #ifdef REV_L
    861                      Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    862                      // Wait for msg to be completed.
    863                      while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    864                      {
    865                      }
    866                      // Clear State for Next Transfer.
    867                      clrUsartState( NUCLEO_USART );
    868          #else
    869                      Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    870          #endif
    871                      if (Status != HAL_OK)
    872                        Error_Handler();
    873                      /*Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    874                      if (Status != HAL_OK)
    875                        Error_Handler();
    876                      // Now wait for completion of Transmit
    877                      PStatus = RESET;
    878                      while (PStatus == RESET)
    879                      {
    880                        PStatus = RoadBrd_Uart_Status(NUCLEO_USART);
    881                      } */
    882                      break;
    883                    case HAL_ERROR:
    884                      // ERROR. We are done.
    885                      Error_Handler();
    886                      break;
    887                    case HAL_BUSY:
    888                      // ERROR. We are done.
    889                      Error_Handler();
    890                      break;
    891                    case HAL_TIMEOUT:
    892                      // Nothing to do. Try again.
    893                      break;
    894                    default:
    895                      // ERROR. We are done.
    896                      Error_Handler();
    897                      break;
    898                    
    899                  }
    900                // Wait 500msec.
    901                RoadBrd_Delay( 50 );
    902                #else
    903                  // Turn Off BGM_LED LED.
    904                  RoadBrd_gpio_Off( BGM_LED );
    905                  // Wait on a character from Nucleo COM Port.
    906           #ifdef REV_L
    907                  Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, 1);
    908                  // Wait for msg to be completed.
    909                  while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    910                  {
    911                  }
    912                  // Clear State for Next Transfer.
    913                  clrUsartState( MONITOR_UART );
    914          #else
    915                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, 1);
    916          #endif
    917                  // Turn On BGM_LED LED.
    918                  RoadBrd_gpio_On( BGM_LED );
    919                  switch(  Status)
    920                  {
    921                    case HAL_OK:
    922                      // We have a good character. Time to build a response string.
    923                      tempBffr2[0] = '(';
    924                      tempBffr2[1] = tempBffr[0];
    925                      tempBffr2[2] = ')';
    926                      tempBffr2[3] = 0x00;
    927                      // Send string to UART..
    928          #ifdef REV_L
    929                      Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
    930                      // Wait for msg to be completed.
    931                      while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    932                      {
    933                      }
    934                      // Clear State for Next Transfer.
    935                      clrUsartState( MONITOR_UART );
    936          #else
    937                      Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    938          #endif
    939                      if (Status != HAL_OK)
    940                        Error_Handler();
    941                      /*Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    942                      if (Status != HAL_OK)
    943                        Error_Handler();
    944                      // Now wait for completion of Transmit
    945                      PStatus = RESET;
    946                      while (PStatus == RESET)
    947                      {
    948                        PStatus = RoadBrd_Uart_Status(NUCLEO_USART);
    949                      } */
    950                      break;
    951                    case HAL_ERROR:
    952                      // ERROR. We are done.
    953                      Error_Handler();
    954                      break;
    955                    case HAL_BUSY:
    956                      // ERROR. We are done.
    957                      Error_Handler();
    958                      break;
    959                    case HAL_TIMEOUT:
    960                      // Nothing to do. Try again.
    961                      break;
    962                    default:
    963                      // ERROR. We are done.
    964                      Error_Handler();
    965                      break;
    966                    
    967                  }
    968                // Wait 500msec.
    969                RoadBrd_Delay( 50 );
    970                #endif
    971              //******************Endif TEST2
    972              #else
    973              //******************Else TEST2
    974            /*****************************************************************************
    975             *    NORMAL FLOW HERE
    976             ****************************************************************************/
    977          //         RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    978          //         Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, 1);
    979                #ifdef NUCLEO
    980                
    981                //************************* NUCLEO VERSION *************************************   
    982                   // Turn Off NUCLEO_LED_GREEN LED.
    983                  RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    984                  // Wait on a character from Nucleo COM Port.
    985          #ifdef REV_L
    986                  tmpSize = Size;
    987                  pData = tempBffr;
    988                  while ( tmpSize>0 )
    989                  {
    990                    Status = RoadBrd_UART_Receive_IT(NUCLEO_USART, tempBffr, RECEIVE_SZ);
    991                    // Wait for msg to be completed.
    992                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    993                    {
    994                    }
    995                    // Clear State for Next Transfer.
    996                    clrUsartState( NUCLEO_USART );
    997                    if(Status == HAL_OK)
    998                    {
    999                      // Watch for termination characters.
   1000                      if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   1001                      {
   1002                        *pData = 0x00;
   1003                        // Yes..We are done.
   1004                        return Status;
   1005                      }
   1006                      else
   1007                      {
   1008                        // Move new character into passed buffer.
   1009                        *pData = tmpData[0];
   1010                        tmpSize--;                          // Decrement Count
   1011                        pData++;                            // Move pointer to next buffer location.
   1012                      }
   1013                    }
   1014                    else
   1015                      Error_Handler();
   1016                  } // EndWhile ( tmpSize>0 )
   1017          #else
   1018                  Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, RECEIVE_SZ);
   1019          #endif
   1020                  // Turn On NUCLEO_LED_GREEN LED.
   1021          #ifndef LED_OFF
   1022                  RoadBrd_gpio_On( NUCLEO_LED_GREEN );
   1023          #endif
   1024          #ifdef ASCII
   1025                  // Send <CR><LF> to UART..
   1026                  strcpy( (char *)tempBffr2, "\r\n");
   1027          #ifdef REV_L
   1028                      Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   1029                      // Wait for msg to be completed.
   1030                      while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   1031                      {
   1032                      }
   1033                      // Clear State for Next Transfer.
   1034                      clrUsartState( NUCLEO_USART );
   1035          #else
   1036                  Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
   1037          #endif
   1038                  if (Status != HAL_OK)
   1039                    Error_Handler();
   1040          #endif
   1041                  switch(  Status )
   1042                  {
   1043                    case HAL_OK:
   1044                      Status = RoadBrd_ParseString((char *)tempBffr);
   1045                      // We have a good Tasking String. Time to determine action.
   1046                      if (Status != HAL_OK)
   1047                        Error_Handler();
   1048                      
   1049                      break;
   1050                    case HAL_ERROR:
   1051                      // ERROR. We are done.
   1052                      Error_Handler();
   1053                      break;
   1054                    case HAL_BUSY:
   1055                      // ERROR. We are done.
   1056                      Error_Handler();
   1057                      break;
   1058                    case HAL_TIMEOUT:
   1059                      // Nothing to do. Try again.
   1060                      break;
   1061                    default:
   1062                      // ERROR. We are done.
   1063                      Error_Handler();
   1064                      break;
   1065                  }
   1066                // Wait 500msec.
   1067                RoadBrd_Delay( 50 );
   1068                //************************* END NUCLEO VERSION *************************************   
   1069                
   1070                #else
   1071          
   1072                //************************* ROAD BRD VERSION *************************************   
   1073                  // Wait on a character from Nucleo COM Port.
   1074          //********************PATCH_UART ACTIVE*******************************************
   1075          #ifdef PATCH_UART
   1076          #ifdef REV_L
   1077                  // Turn Off MICRO_LED LED.
   1078                  RoadBrd_gpio_Off( MICRO_LED );
   1079                  tmpSize = RECEIVE_SZ;
   1080                  pData = tempBffr;
   1081                  while ( tmpSize>0 )
   1082                  {
   1083                    Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
   1084                    // Wait for msg to be completed.
   1085                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   1086                    {
   1087                     }
   1088                    // Clear State for Next Transfer.
   1089                    clrUsartState( MONITOR_UART );
   1090                    if(Status == HAL_OK)
   1091                    {
   1092                      // Watch for termination characters.
   1093                      if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   1094                      {
   1095                        *pData = 0x00;
   1096                        // Yes..We are done.
   1097                        break;
   1098                      }
   1099                      else
   1100                      {
   1101                        // Move new character into passed buffer.
   1102                        *pData = tmpData[0];
   1103                        tmpSize--;                          // Decrement Count
   1104                        pData++;                            // Move pointer to next buffer location.
   1105                      }
   1106                    }
   1107                    else
   1108                      Error_Handler();
   1109                  } // EndWhile ( tmpSize>0 )
   1110          #ifndef LED_OFF
   1111                  RoadBrd_gpio_On( MICRO_LED );
   1112          #endif
   1113                  // Send <CR><LF> to UART..
   1114                  strcpy( (char *)tempBffr2, "\r\n");
   1115                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   1116                  if (Status != HAL_OK)
   1117                    Error_Handler();
   1118                  switch(  Status )
   1119                  {
   1120                    case HAL_OK:
   1121                      // We have a good Tasking String. Time to determine action.
   1122                      Status = RoadBrd_ParseString((char *)tempBffr);
   1123                      // We have a good Tasking String. Time to determine action.
   1124                      if (Status != HAL_OK)
   1125                        Error_Handler();
   1126                      break;
   1127                    case HAL_ERROR:
   1128                      // ERROR. We are done.
   1129                      Error_Handler();
   1130                      break;
   1131                    case HAL_BUSY:
   1132                      // ERROR. We are done.
   1133                      Error_Handler();
   1134                      break;
   1135                    case HAL_TIMEOUT:
   1136                      // Nothing to do. Try again.
   1137                      break;
   1138                    default:
   1139                      // ERROR. We are done.
   1140                      Error_Handler();
   1141                      break;
   1142                    
   1143                  } // EndSwitch (  Status )
   1144          #else
   1145                  // Turn Off BGM_LED LED.
   1146                  RoadBrd_gpio_Off( MICRO_LED );
   1147                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, RECEIVE_SZ);
   1148                  // Process Buffer Now.
   1149                  // Turn On BGM_LED LED.
   1150          #ifndef LED_OFF
   1151                  RoadBrd_gpio_On( MICRO_LED );
   1152          #endif
   1153                  // Send <CR><LF> to UART..
   1154                  strcpy( (char *)tempBffr2, "\r\n");
   1155          #ifdef REV_L
   1156                      Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   1157                      // Wait for msg to be completed.
   1158                      while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   1159                      {
   1160                      }
   1161                      // Clear State for Next Transfer.
   1162                      clrUsartState( MONITOR_UART );
   1163          #else
   1164                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   1165          #endif
   1166                  if (Status != HAL_OK)
   1167                    Error_Handler();
   1168                  switch(  Status )
   1169                  {
   1170                    case HAL_OK:
   1171                      // We have a good Tasking String. Time to determine action.
   1172                      Status = RoadBrd_ParseString((char *)tempBffr, false);
   1173                      // We have a good Tasking String. Time to determine action.
   1174                      if (Status != HAL_OK)
   1175                        Error_Handler();
   1176                      break;
   1177                    case HAL_ERROR:
   1178                      // ERROR. We are done.
   1179                      Error_Handler();
   1180                      break;
   1181                    case HAL_BUSY:
   1182                      // ERROR. We are done.
   1183                      Error_Handler();
   1184                      break;
   1185                    case HAL_TIMEOUT:
   1186                      // Nothing to do. Try again.
   1187                      break;
   1188                    default:
   1189                      // ERROR. We are done.
   1190                      Error_Handler();
   1191                      break;
   1192                    
   1193                  } // EndSwitch (  Status )
   1194          #endif
   1195          //********************END PATCH_UART ACTIVE*******************************************
   1196          #else
   1197          //********************PATCH_UART NOT ACTIVE*******************************************
   1198          #ifdef REV_L
   1199                    /* Process BLE input */
   1200                    BGM111_ProcessInput();
   \                     ??main_44: (+1)
   \   00000430   0x.... 0x....      BL       BGM111_ProcessInput
   1201                  
   1202                    // Process Timer Stimulus for Timer 2.
   1203                    Status = Proc_Timer2();
   \   00000434   0x.... 0x....      BL       Proc_Timer2
   \   00000438   0x0004             MOVS     R4,R0
   1204                    if(Status != HAL_OK)
   \   0000043A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000043C   0x2C00             CMP      R4,#+0
   \   0000043E   0xD00D             BEQ.N    ??main_45
   1205                    {
   1206                      strcpy( (char *)tempBffr2, "BGM111_ProcessInput ERROR: Sensors reported Background error.\r\n");
   \   00000440   0x....             LDR.N    R1,??DataTable1_14
   \   00000442   0x4668             MOV      R0,SP
   \   00000444   0x.... 0x....      BL       strcpy
   1207          #ifdef NUCLEO
   1208                      Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
   1209          #else
   1210                      Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);                   
   \   00000448   0x4669             MOV      R1,SP
   \   0000044A   0x2000             MOVS     R0,#+0
   \   0000044C   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000450   0x0004             MOVS     R4,R0
   1211          #endif
   1212                      if (Status != HAL_OK)
   \   00000452   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000454   0x2C00             CMP      R4,#+0
   \   00000456   0xD001             BEQ.N    ??main_45
   1213                        Error_Handler();
   \   00000458   0x.... 0x....      BL       Error_Handler
   1214                    }
   1215                    // Process any Outstanding Parse Tasks.
   1216                    RoadBrd_ProcessParserTsk();
   \                     ??main_45: (+1)
   \   0000045C   0x.... 0x....      BL       RoadBrd_ProcessParserTsk
   1217                    
   1218                    // Test to process CMD mode.
   1219                    Process_CmdMode();
   \   00000460   0x.... 0x....      BL       Process_CmdMode
   1220                    
   1221                    /* Process the sensor state machine if the BLE module is ready */
   1222                      if ((BGM111_Ready()) &&
   1223                          (BGM111_Connected()) &&
   1224                          (BGM111_DataConnected()) &&
   1225                          (BGM111_SyncModeTest()) )
   \   00000464   0x.... 0x....      BL       BGM111_Ready
   \   00000468   0x2800             CMP      R0,#+0
   \   0000046A   0xD00F             BEQ.N    ??main_46
   \   0000046C   0x.... 0x....      BL       BGM111_Connected
   \   00000470   0x2800             CMP      R0,#+0
   \   00000472   0xD00B             BEQ.N    ??main_46
   \   00000474   0x.... 0x....      BL       BGM111_DataConnected
   \   00000478   0x2800             CMP      R0,#+0
   \   0000047A   0xD007             BEQ.N    ??main_46
   \   0000047C   0x.... 0x....      BL       BGM111_SyncModeTest
   \   00000480   0x2800             CMP      R0,#+0
   \   00000482   0xD003             BEQ.N    ??main_46
   1226                    {
   1227                      ProcessSensorState();
   \   00000484   0x.... 0x....      BL       ProcessSensorState
   1228                      Process_RdSound();
   \   00000488   0x.... 0x....      BL       Process_RdSound
   1229                    }
   1230                    /* Sleep when we have nothing to process */
   1231                    //PWR_EnterSleepMode(PWR_Regulator_ON, PWR_SLEEPEntry_WFI);
   1232                    // Only Process the first Time
   1233                    if (firstTime)
   \                     ??main_46: (+1)
   \   0000048C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048E   0x2D00             CMP      R5,#+0
   \   00000490   0xD00E             BEQ.N    ??main_47
   1234                    {
   1235                      firstTime = false;
   \   00000492   0x2000             MOVS     R0,#+0
   \   00000494   0x0005             MOVS     R5,R0
   1236                      Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
   \   00000496   0x227D             MOVS     R2,#+125
   \   00000498   0xA914             ADD      R1,SP,#+80
   \   0000049A   0x2000             MOVS     R0,#+0
   \   0000049C   0x.... 0x....      BL       RoadBrd_UART_Receive_IT
   \   000004A0   0x0004             MOVS     R4,R0
   1237                      // Enable BGM Serial Traffic.
   1238                      HAL_UART_EnableBGM_RX();
   \   000004A2   0x.... 0x....      BL       HAL_UART_EnableBGM_RX
   1239                      RoadBrd_SetBffrFlg();
   \   000004A6   0x.... 0x....      BL       RoadBrd_SetBffrFlg
   1240                      // Clear bffrFlag..Only Processing one character.
   1241          //            bffrFlag = false;
   1242                      // Turn Off BGM_LED and MICRO_LED.
   1243                      RoadBrd_gpio_Off( MICRO_LED );
   \   000004AA   0x2002             MOVS     R0,#+2
   \   000004AC   0x.... 0x....      BL       RoadBrd_gpio_Off
   1244                    }
   1245                    // Service Watchdog
   1246                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \                     ??main_47: (+1)
   \   000004B0   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   1247                    // Wait for msg to be completed.
   1248                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_48: (+1)
   \   000004B4   0x2000             MOVS     R0,#+0
   \   000004B6   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000004BA   0x2801             CMP      R0,#+1
   \   000004BC   0xD02E             BEQ.N    ??main_49
   1249                    {
   1250                      // Process Timer Stimulus for Timer 2.
   1251                      Status = Proc_Timer2();
   \   000004BE   0x.... 0x....      BL       Proc_Timer2
   \   000004C2   0x0004             MOVS     R4,R0
   1252                      if(Status != HAL_OK)
   \   000004C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004C6   0x2C00             CMP      R4,#+0
   \   000004C8   0xD00D             BEQ.N    ??main_50
   1253                      {
   1254                        strcpy( (char *)tempBffr2, "BGM111_ProcessInput ERROR: Sensors reported Background error.\r\n");
   \   000004CA   0x....             LDR.N    R1,??DataTable1_14
   \   000004CC   0x4668             MOV      R0,SP
   \   000004CE   0x.... 0x....      BL       strcpy
   1255          #ifdef NUCLEO
   1256                        Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
   1257          #else
   1258                        Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);                   
   \   000004D2   0x4669             MOV      R1,SP
   \   000004D4   0x2000             MOVS     R0,#+0
   \   000004D6   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000004DA   0x0004             MOVS     R4,R0
   1259          #endif
   1260                        if (Status != HAL_OK)
   \   000004DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004DE   0x2C00             CMP      R4,#+0
   \   000004E0   0xD001             BEQ.N    ??main_50
   1261                          Error_Handler();
   \   000004E2   0x.... 0x....      BL       Error_Handler
   1262                      }
   1263                      // Process any Outstanding Parse Tasks.
   1264                      RoadBrd_ProcessParserTsk();
   \                     ??main_50: (+1)
   \   000004E6   0x.... 0x....      BL       RoadBrd_ProcessParserTsk
   1265                      
   1266                      // Test to process CMD mode.
   1267                      Process_CmdMode();
   \   000004EA   0x.... 0x....      BL       Process_CmdMode
   1268                      
   1269                      /* Process the sensor state machine if the BLE module is ready */
   1270                      if ((BGM111_Ready()) &&
   1271                          (BGM111_Connected()) &&
   1272                          (BGM111_DataConnected()) &&
   1273                          (BGM111_SyncModeTest()) )
   \   000004EE   0x.... 0x....      BL       BGM111_Ready
   \   000004F2   0x2800             CMP      R0,#+0
   \   000004F4   0xD0DE             BEQ.N    ??main_48
   \   000004F6   0x.... 0x....      BL       BGM111_Connected
   \   000004FA   0x2800             CMP      R0,#+0
   \   000004FC   0xD0DA             BEQ.N    ??main_48
   \   000004FE   0x.... 0x....      BL       BGM111_DataConnected
   \   00000502   0x2800             CMP      R0,#+0
   \   00000504   0xD0D6             BEQ.N    ??main_48
   \   00000506   0x.... 0x....      BL       BGM111_SyncModeTest
   \   0000050A   0x2800             CMP      R0,#+0
   \   0000050C   0xD0D2             BEQ.N    ??main_48
   1274                      {
   1275                        // Service Watchdog
   1276                        RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   0000050E   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   1277                        ProcessSensorState();
   \   00000512   0x.... 0x....      BL       ProcessSensorState
   1278                        Process_RdSound();
   \   00000516   0x.... 0x....      BL       Process_RdSound
   \   0000051A   0xE7CB             B.N      ??main_48
   1279                      }
   1280                      // Test to see if we have any BGM Traffic to process.
   1281                      //BGM111_ProcessInput();
   1282                    }
   1283                    // Test if BGM or Monitor Character received.
   1284                    if (RoadBrd_Uart_Status(MONITOR_UART) == SET)
   \                     ??main_49: (+1)
   \   0000051C   0x2000             MOVS     R0,#+0
   \   0000051E   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000522   0x2801             CMP      R0,#+1
   \   00000524   0xD15E             BNE.N    ??main_51
   1285                    {
   1286                      // Clear State for Next Transfer.
   1287                      clrUsartState( MONITOR_UART );
   \   00000526   0x2000             MOVS     R0,#+0
   \   00000528   0x.... 0x....      BL       clrUsartState
   1288                      if(Status == HAL_OK)
   \   0000052C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000052E   0x2C00             CMP      R4,#+0
   \   00000530   0xD14D             BNE.N    ??main_52
   1289                      {
   1290          //***** START HERE
   1291                        // Test Boot Monitor Flag...If Set, we ae in special Boot monitor mode.
   1292                        if (Tst_Boot_Bypass())
   \   00000532   0x.... 0x....      BL       Tst_Boot_Bypass
   \   00000536   0x2800             CMP      R0,#+0
   \   00000538   0xD00D             BEQ.N    ??main_53
   1293                        {
   1294                          // We have a good Tasking String. Time to determine action.
   1295                          // Turn On BGM_LED LED.
   1296            #ifndef LED_OFF
   1297                          RoadBrd_gpio_On( GREEN_LED );
   \   0000053A   0x2002             MOVS     R0,#+2
   \   0000053C   0x.... 0x....      BL       RoadBrd_gpio_On
   1298            #endif
   1299                          Status = Parse_BootString((char *)tempBffr, false);
   \   00000540   0x2100             MOVS     R1,#+0
   \   00000542   0xA814             ADD      R0,SP,#+80
   \   00000544   0x.... 0x....      BL       Parse_BootString
   \   00000548   0x0004             MOVS     R4,R0
   1300                          // We have a good Tasking String. Time to determine action.
   1301                          if (Status != HAL_OK)
   \   0000054A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000054C   0x2C00             CMP      R4,#+0
   \   0000054E   0xD040             BEQ.N    ??main_54
   1302                            Error_Handler();
   \   00000550   0x.... 0x....      BL       Error_Handler
   \   00000554   0xE03D             B.N      ??main_54
   1303                        } // EndIf (Tst_Bypass())
   1304                        // Test Bypass Flag...If Set, we ae in special monitor mode.
   1305                        else if (Tst_Bypass())
   \                     ??main_53: (+1)
   \   00000556   0x.... 0x....      BL       Tst_Bypass
   \   0000055A   0x2800             CMP      R0,#+0
   \   0000055C   0xD00D             BEQ.N    ??main_55
   1306                        {
   1307                          // We have a good Tasking String. Time to determine action.
   1308                          // Turn On BGM_LED LED.
   1309            #ifndef LED_OFF
   1310                          RoadBrd_gpio_On( GREEN_LED );
   \   0000055E   0x2002             MOVS     R0,#+2
   \   00000560   0x.... 0x....      BL       RoadBrd_gpio_On
   1311            #endif
   1312                          Status = RoadBrd_ParseString((char *)tempBffr, false);
   \   00000564   0x2100             MOVS     R1,#+0
   \   00000566   0xA814             ADD      R0,SP,#+80
   \   00000568   0x.... 0x....      BL       RoadBrd_ParseString
   \   0000056C   0x0004             MOVS     R4,R0
   1313                          // We have a good Tasking String. Time to determine action.
   1314                          if (Status != HAL_OK)
   \   0000056E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000570   0x2C00             CMP      R4,#+0
   \   00000572   0xD02E             BEQ.N    ??main_54
   1315                            Error_Handler();
   \   00000574   0x.... 0x....      BL       Error_Handler
   \   00000578   0xE02B             B.N      ??main_54
   1316                        } // EndIf (Tst_Bypass())
   1317                        else {
   1318                          // Yes..We are done.
   1319                          // Process Buffer NOW.
   1320                          // Send <CR><LF> to UART..
   1321                          strcpy( (char *)tempBffr2, "\r\n");
   \                     ??main_55: (+1)
   \   0000057A   0x....             ADR.N    R1,??DataTable1  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000057C   0x4668             MOV      R0,SP
   \   0000057E   0x.... 0x....      BL       strcpy
   1322                          Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   00000582   0x4669             MOV      R1,SP
   \   00000584   0x2000             MOVS     R0,#+0
   \   00000586   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   0000058A   0x0004             MOVS     R4,R0
   1323                          // Wait for msg to be completed.
   1324                          while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_56: (+1)
   \   0000058C   0x2000             MOVS     R0,#+0
   \   0000058E   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000592   0x2801             CMP      R0,#+1
   \   00000594   0xD1FA             BNE.N    ??main_56
   1325                          {
   1326                          }
   1327                          // Clear State for Next Transfer.
   1328                          clrUsartState( MONITOR_UART );
   \   00000596   0x2000             MOVS     R0,#+0
   \   00000598   0x.... 0x....      BL       clrUsartState
   1329                          if (Status != HAL_OK)
   \   0000059C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000059E   0x2C00             CMP      R4,#+0
   \   000005A0   0xD001             BEQ.N    ??main_57
   1330                            Error_Handler();
   \   000005A2   0x.... 0x....      BL       Error_Handler
   1331                          if(Status == HAL_OK)
   \                     ??main_57: (+1)
   \   000005A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005A8   0x2C00             CMP      R4,#+0
   \   000005AA   0xD10D             BNE.N    ??main_58
   1332                          {
   1333                            // We have a good Tasking String. Time to determine action.
   1334                            // Turn On BGM_LED LED.
   1335            #ifndef LED_OFF
   1336                            RoadBrd_gpio_On( GREEN_LED );
   \   000005AC   0x2002             MOVS     R0,#+2
   \   000005AE   0x.... 0x....      BL       RoadBrd_gpio_On
   1337            #endif
   1338                            Status = RoadBrd_ParseString((char *)tempBffr, false);
   \   000005B2   0x2100             MOVS     R1,#+0
   \   000005B4   0xA814             ADD      R0,SP,#+80
   \   000005B6   0x.... 0x....      BL       RoadBrd_ParseString
   \   000005BA   0x0004             MOVS     R4,R0
   1339                            // We have a good Tasking String. Time to determine action.
   1340                            if (Status != HAL_OK)
   \   000005BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005BE   0x2C00             CMP      R4,#+0
   \   000005C0   0xD007             BEQ.N    ??main_54
   1341                              Error_Handler();
   \   000005C2   0x.... 0x....      BL       Error_Handler
   \   000005C6   0xE004             B.N      ??main_54
   1342                          }
   1343                          else
   1344                            Error_Handler();
   \                     ??main_58: (+1)
   \   000005C8   0x.... 0x....      BL       Error_Handler
   \   000005CC   0xE001             B.N      ??main_54
   1345                        } // EndElse (Tst_Bypass())
   1346                      }
   1347          //***** END HERE
   1348                      else
   1349                        Error_Handler();
   \                     ??main_52: (+1)
   \   000005CE   0x.... 0x....      BL       Error_Handler
   1350                    Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
   \                     ??main_54: (+1)
   \   000005D2   0x227D             MOVS     R2,#+125
   \   000005D4   0xA914             ADD      R1,SP,#+80
   \   000005D6   0x2000             MOVS     R0,#+0
   \   000005D8   0x.... 0x....      BL       RoadBrd_UART_Receive_IT
   \   000005DC   0x0004             MOVS     R4,R0
   1351                    // Turn Off MICRO_LED.
   1352                    RoadBrd_gpio_Off( MICRO_LED );
   \   000005DE   0x2002             MOVS     R0,#+2
   \   000005E0   0x.... 0x....      BL       RoadBrd_gpio_Off
   1353                  } // EndIf (RoadBrd_Uart_Status(MONITOR_UART) == SET)
   1354          
   1355          #else
   1356                  // Turn Off BGM_LED LED.
   1357                  RoadBrd_gpio_Off( MICRO_LED );
   1358                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, RECEIVE_SZ);
   1359                  // Turn On BGM_LED LED.
   1360          #ifndef LED_OFF
   1361                  RoadBrd_gpio_On( MICRO_LED );
   1362          #endif
   1363                  // Send <CR><LF> to UART..
   1364                  strcpy( (char *)tempBffr2, "\r\n");
   1365                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   1366                  if (Status != HAL_OK)
   1367                    Error_Handler();
   1368                  switch(  Status )
   1369                  {
   1370                    case HAL_OK:
   1371                      // We have a good Tasking String. Time to determine action.
   1372                      Status = RoadBrd_ParseString((char *)tempBffr, false);
   1373                      // We have a good Tasking String. Time to determine action.
   1374                      if (Status != HAL_OK)
   1375                        Error_Handler();
   1376                      break;
   1377                    case HAL_ERROR:
   1378                      // ERROR. We are done.
   1379                      Error_Handler();
   1380                      break;
   1381                    case HAL_BUSY:
   1382                      // ERROR. We are done.
   1383                      Error_Handler();
   1384                      break;
   1385                    case HAL_TIMEOUT:
   1386                      // Nothing to do. Try again.
   1387                      break;
   1388                    default:
   1389                      // ERROR. We are done.
   1390                      Error_Handler();
   1391                      break;
   1392                    
   1393                  } // EndSwitch (  Status )
   1394          #endif
   1395          //********************END PATCH_UART NOT ACTIVE*******************************************
   1396          #endif
   1397                // Wait 50msec.
   1398                RoadBrd_Delay( 50 );
   \                     ??main_51: (+1)
   \   000005E4   0x2032             MOVS     R0,#+50
   \   000005E6   0x.... 0x....      BL       RoadBrd_Delay
   \   000005EA   0xE721             B.N      ??main_44
   1399                //************************* END Road BRD VERSION *************************************   
   1400                #endif
   1401            /*****************************************************************************
   1402             *    END NORMAL FLOW HERE
   1403             ****************************************************************************/
   1404              //******************EndElse TEST2
   1405              #endif
   1406          
   1407            //******************EndElse TEST
   1408            #endif
   1409            } // EndWhile (1)
   1410          //********************ENDIF TASKING
   1411          #endif
   1412            /* USER CODE END 3 */
   1413          
   1414          }
   1415          
   1416          /** System Clock Configuration
   1417          */

   \                                 In section .text, align 2, keep-with-next
   1418          void SystemClock_Config(void)
   1419          {
   \                     SystemClock_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   1420          
   1421            RCC_OscInitTypeDef RCC_OscInitStruct;
   1422            RCC_ClkInitTypeDef RCC_ClkInitStruct;
   1423          
   1424            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000004   0x....             LDR.N    R0,??DataTable1_15  ;; 0x40023824
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000C   0x....             LDR.N    R1,??DataTable1_15  ;; 0x40023824
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x....             LDR.N    R0,??DataTable1_15  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   1425          
   1426            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   \   0000001C   0x....             LDR.N    R0,??DataTable1_16  ;; 0x40007000
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x50C0      BICS     R0,R0,#0x1800
   \   00000024   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000028   0x....             LDR.N    R1,??DataTable1_16  ;; 0x40007000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1427          
   1428            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   1429            RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x9007             STR      R0,[SP, #+28]
   1430            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9009             STR      R0,[SP, #+36]
   1431            RCC_OscInitStruct.HSICalibrationValue = 16;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x900A             STR      R0,[SP, #+40]
   1432            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x900F             STR      R0,[SP, #+60]
   1433            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   \   00000040   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000044   0x9010             STR      R0,[SP, #+64]
   1434            RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
   \   00000046   0xF45F 0x1080      MOVS     R0,#+1048576
   \   0000004A   0x9011             STR      R0,[SP, #+68]
   1435            RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3;
   \   0000004C   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000050   0x9012             STR      R0,[SP, #+72]
   1436            if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \   00000052   0xA806             ADD      R0,SP,#+24
   \   00000054   0x.... 0x....      BL       HAL_RCC_OscConfig
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??SystemClock_Config_0
   1437            {
   1438              Error_Handler();
   \   0000005C   0x.... 0x....      BL       Error_Handler
   1439            }
   1440          
   1441            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1442                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   \                     ??SystemClock_Config_0: (+1)
   \   00000060   0x200F             MOVS     R0,#+15
   \   00000062   0x9001             STR      R0,[SP, #+4]
   1443            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x9002             STR      R0,[SP, #+8]
   1444            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9003             STR      R0,[SP, #+12]
   1445            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x9004             STR      R0,[SP, #+16]
   1446            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9005             STR      R0,[SP, #+20]
   1447            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x.... 0x....      BL       HAL_RCC_ClockConfig
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ.N    ??SystemClock_Config_1
   1448            {
   1449              Error_Handler();
   \   00000080   0x.... 0x....      BL       Error_Handler
   1450            }
   1451          
   1452            HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
   \                     ??SystemClock_Config_1: (+1)
   \   00000084   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000088   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000090   0x.... 0x....      BL       HAL_SYSTICK_Config
   1453          
   1454            HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x.... 0x....      BL       HAL_SYSTICK_CLKSourceConfig
   1455          
   1456            /* SysTick_IRQn interrupt configuration */
   1457            HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
   \   0000009A   0x2200             MOVS     R2,#+0
   \   0000009C   0x210F             MOVS     R1,#+15
   \   0000009E   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000A2   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1458          }
   \   000000A6   0xB013             ADD      SP,SP,#+76
   \   000000A8   0xBD00             POP      {PC}             ;; return
   1459          
   1460          /* USER CODE BEGIN 4 */
   1461          
   1462          /* USER CODE END 4 */
   1463          
   1464          /**
   1465            * @brief  This function is executed in case of error occurrence.
   1466            * @param  None
   1467            * @retval None
   1468            */

   \                                 In section .text, align 2, keep-with-next
   1469          void Error_Handler(void)
   1470          {
   \                     Error_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1471            /* USER CODE BEGIN Error_Handler */
   1472            /* User can add his own implementation to report the HAL error return state */
   1473            // Turn LED2 on
   1474          #ifdef NUCLEO
   1475            BSP_LED_On(LED2);
   1476          #else
   1477            RoadBrd_LED_On(BLUE_LED);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       RoadBrd_LED_On
   1478            RoadBrd_LED_On(GREEN_LED);
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       RoadBrd_LED_On
   1479            RoadBrd_LED_On(YELLOW_LED);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_LED_On
   1480          #endif
   1481            while(1) 
   1482            {
   1483              // Error if LED2 is slowly blinking (1 sec. period)
   1484          #ifdef NUCLEO
   1485              BSP_LED_Toggle(LED2); 
   1486          #else
   1487              RoadBrd_LED_Toggle(BLUE_LED); 
   \                     ??Error_Handler_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1488              RoadBrd_LED_Toggle(GREEN_LED); 
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1489              RoadBrd_LED_Toggle(YELLOW_LED); 
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1490          #endif
   1491              HAL_Delay(50); 
   \   00000026   0x2032             MOVS     R0,#+50
   \   00000028   0x.... 0x....      BL       HAL_Delay
   \   0000002C   0xE7F2             B.N      ??Error_Handler_0
   1492            }
   1493            /* USER CODE END Error_Handler */ 
   1494          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_12:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_13:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_14:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_15:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_16:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000008   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000010   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 20H, 20H, 57H
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x20 0x57    
   \   00000018   0x45 0x41          DC8 45H, 41H, 54H, 48H, 45H, 52H, 43H, 4CH
   \              0x54 0x48    
   \              0x45 0x52    
   \              0x43 0x4C    
   \   00000020   0x4F 0x55          DC8 4FH, 55H, 44H, 20H, 2AH, 2AH, 2AH, 2AH
   \              0x44 0x20    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000028   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000038   0x2A 0x0D          DC8 2AH, 0DH, 0AH, 0DH, 0AH, 0
   \              0x0A 0x0D    
   \              0x0A 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 57H, 65H, 61H
   \              0x20 0x20    
   \              0x20 0x57    
   \              0x65 0x61    
   \   00000008   0x74 0x68          DC8 74H, 68H, 65H, 72H, 20H, 4DH, 65H, 73H
   \              0x65 0x72    
   \              0x20 0x4D    
   \              0x65 0x73    
   \   00000010   0x68 0x20          DC8 68H, 20H, 4DH, 6FH, 6EH, 69H, 74H, 6FH
   \              0x4D 0x6F    
   \              0x6E 0x69    
   \              0x74 0x6F    
   \   00000018   0x72 0x20          DC8 72H, 20H, 25H, 73H, 20H, 48H, 61H, 72H
   \              0x25 0x73    
   \              0x20 0x48    
   \              0x61 0x72    
   \   00000020   0x64 0x77          DC8 64H, 77H, 61H, 72H, 65H, 20H, 56H, 65H
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x56 0x65    
   \   00000028   0x72 0x73          DC8 72H, 73H, 69H, 6FH, 6EH, 20H, 25H, 73H
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x25 0x73    
   \   00000030   0x20 0x0D          DC8 20H, 0DH, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x57 0x2E          DC8 "W.1.0"
   \              0x31 0x2E    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x52 0x65          DC8 "Rev M"
   \              0x76 0x20    
   \              0x4D 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x20 0x20          DC8 "                  Copyright %s. \015\012\015\012"
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x43 0x6F    
   \              0x70 0x79    
   \              0x72 0x69    
   \              0x67 0x68    
   \              0x74 0x20    
   \              0x25 0x73    
   \              0x2E 0x20    
   \              0x0D 0x0A    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x4A 0x61          DC8 "Jan 30, 2018"
   \              0x6E 0x20    
   \              0x33 0x30    
   \              0x2C 0x20    
   \              0x32 0x30    
   \              0x31 0x38    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x52 0x64          DC8 "RdSnd Sample Rate:  %3.1f Seconds.\015\012"
   \              0x53 0x6E    
   \              0x64 0x20    
   \              0x53 0x61    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x20 0x52    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x20    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x20    
   \              0x53 0x65    
   \              0x63 0x6F    
   \              0x6E 0x64    
   \              0x73 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x53 0x65          DC8 "Sensor Sample Rate: %3.1f Seconds.\015\012"
   \              0x6E 0x73    
   \              0x6F 0x72    
   \              0x20 0x53    
   \              0x61 0x6D    
   \              0x70 0x6C    
   \              0x65 0x20    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x20    
   \              0x53 0x65    
   \              0x63 0x6F    
   \              0x6E 0x64    
   \              0x73 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x54 0x41          DC8 "TACK Limit: %d.\015\012"
   \              0x43 0x4B    
   \              0x20 0x4C    
   \              0x69 0x6D    
   \              0x69 0x74    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x42 0x6F          DC8 "Boot Delay: %d Seconds.\015\012"
   \              0x6F 0x74    
   \              0x20 0x44    
   \              0x65 0x6C    
   \              0x61 0x79    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x53    
   \              0x65 0x63    
   \              0x6F 0x6E    
   \              0x64 0x73    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x55 0x6E          DC8 "Units XML State: ENABLED\015\012\015\012> "
   \              0x69 0x74    
   \              0x73 0x20    
   \              0x58 0x4D    
   \              0x4C 0x20    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x45    
   \              0x4E 0x41    
   \              0x42 0x4C    
   \              0x45 0x44    
   \              0x0D 0x0A    
   \              0x0D 0x0A    
   \              0x3E 0x20    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x55 0x6E          DC8 "Units XML State: DISABLED\015\012\015\012> "
   \              0x69 0x74    
   \              0x73 0x20    
   \              0x58 0x4D    
   \              0x4C 0x20    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x44    
   \              0x49 0x53    
   \              0x41 0x42    
   \              0x4C 0x45    
   \              0x44 0x0D    
   \              0x0A 0x0D    
   \              0x0A 0x3E    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x42 0x47          DC8 42H, 47H, 4DH, 31H, 31H, 31H, 5FH, 50H
   \              0x4D 0x31    
   \              0x31 0x31    
   \              0x5F 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 63H, 65H, 73H, 73H, 49H, 6EH
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x49 0x6E    
   \   00000010   0x70 0x75          DC8 70H, 75H, 74H, 20H, 45H, 52H, 52H, 4FH
   \              0x74 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \   00000018   0x52 0x3A          DC8 52H, 3AH, 20H, 53H, 65H, 6EH, 73H, 6FH
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x73 0x6F    
   \   00000020   0x72 0x73          DC8 72H, 73H, 20H, 72H, 65H, 70H, 6FH, 72H
   \              0x20 0x72    
   \              0x65 0x70    
   \              0x6F 0x72    
   \   00000028   0x74 0x65          DC8 74H, 65H, 64H, 20H, 42H, 61H, 63H, 6BH
   \              0x64 0x20    
   \              0x42 0x61    
   \              0x63 0x6B    
   \   00000030   0x67 0x72          DC8 67H, 72H, 6FH, 75H, 6EH, 64H, 20H, 65H
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x20 0x65    
   \   00000038   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 2EH, 0DH, 0AH, 0
   \              0x6F 0x72    
   \              0x2E 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0
   1495          
   1496          #ifdef USE_FULL_ASSERT
   1497          
   1498          /**
   1499             * @brief Reports the name of the source file and the source line number
   1500             * where the assert_param error has occurred.
   1501             * @param file: pointer to the source file name
   1502             * @param line: assert_param error line source number
   1503             * @retval None
   1504             */
   1505          void assert_failed(uint8_t* file, uint32_t line)
   1506          {
   1507            /* USER CODE BEGIN 6 */
   1508            /* User can add his own implementation to report the file name and line number,
   1509              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1510            /* USER CODE END 6 */
   1511          
   1512          }
   1513          #endif
   1514          
   1515          /**
   1516            * @}
   1517            */ 
   1518          
   1519          /**
   1520            * @}
   1521          */ 
   1522          
   1523          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Error_Handler
         8   -> HAL_Delay
         8   -> RoadBrd_LED_On
         8   -> RoadBrd_LED_Toggle
      80   SystemClock_Config
        80   -> Error_Handler
        80   -> HAL_NVIC_SetPriority
        80   -> HAL_RCC_ClockConfig
        80   -> HAL_RCC_GetHCLKFreq
        80   -> HAL_RCC_OscConfig
        80   -> HAL_SYSTICK_CLKSourceConfig
        80   -> HAL_SYSTICK_Config
     224   main
       224   -> ADC_Config
       224   -> BGM111_Connected
       224   -> BGM111_DataConnected
       224   -> BGM111_Init
       224   -> BGM111_ProcessInput
       224   -> BGM111_Ready
       224   -> BGM111_SyncModeTest
       224   -> Error_Handler
       224   -> Get_DriverStates
       224   -> HAL_Init
       224   -> HAL_NVIC_EnableIRQ
       224   -> HAL_TIM_StartTimer2
       224   -> HAL_TIM_StartTimer3
       224   -> HAL_UART_EnableBGM_RX
       224   -> I2C_WaitBusyFlag
       224   -> InitSensors
       224   -> MX_ADC_Init
       224   -> MX_DMA_Init
       224   -> MX_GPIO_Init
       224   -> MX_I2C1_Init
       224   -> MX_TIM2_Init
       224   -> MX_TIM3_Init
       224   -> MX_USART2_UART_Init
       224   -> MX_USART3_UART_Init
       224   -> MX_WWDG_Init
       224   -> Parse_BootString
       224   -> Proc_Timer2
       224   -> ProcessSensorState
       224   -> Process_CmdMode
       224   -> Process_RdSound
       224   -> RdBrd_ErrCdLogErrCd
       224   -> Reset_DriverStates
       224   -> RoadBrd_CAL_InitializeFrmFlash
       224   -> RoadBrd_CAL_VerifyFrame
       224   -> RoadBrd_Delay
       224   -> RoadBrd_Get_BootDelay
       224   -> RoadBrd_Get_RdSndTickCnt
       224   -> RoadBrd_Get_SnsrTickCnt
       224   -> RoadBrd_Get_TackLimit
       224   -> RoadBrd_Get_UnitsFlag
       224   -> RoadBrd_I2CRepair
       224   -> RoadBrd_ParseString
       224   -> RoadBrd_ParserInit
       224   -> RoadBrd_ProcessParserTsk
       224   -> RoadBrd_SetBffrFlg
       224   -> RoadBrd_TestI2C
       224   -> RoadBrd_UART_Receive_IT
       224   -> RoadBrd_UART_Transmit
       224   -> RoadBrd_UART_Transmit_IT
       224   -> RoadBrd_Uart_Status
       224   -> RoadBrd_WWDG_InitializeDateString
       224   -> RoadBrd_WWDG_InitializeFrmFlash
       224   -> RoadBrd_WWDG_InitializeTickString
       224   -> RoadBrd_WWDG_Refresh
       224   -> RoadBrd_WWDG_Start
       224   -> RoadBrd_WWDG_VerifyFrame
       224   -> RoadBrd_gpio_Off
       224   -> RoadBrd_gpio_On
       224   -> Set_DriverStates
       224   -> Set_TickCounts
       224   -> SystemClock_Config
       224   -> Tst_Boot_Bypass
       224   -> Tst_Bypass
       224   -> __aeabi_f2d
       224   -> __aeabi_fdiv
       224   -> __aeabi_ui2f
       224   -> clrUsartState
       224   -> sprintf
       224   -> strcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_14
       4  ??DataTable1_15
       4  ??DataTable1_16
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      64  ?_0
      52  ?_1
      32  ?_10
      32  ?_11
      64  ?_12
       4  ?_13
       8  ?_2
       8  ?_3
      40  ?_4
      16  ?_5
      40  ?_6
      40  ?_7
      20  ?_8
      28  ?_9
      46  Error_Handler
     170  SystemClock_Config
    1516  main

 
   448 bytes in section .rodata
 1 800 bytes in section .text
 
 1 800 bytes of CODE  memory
   448 bytes of CONST memory

Errors: none
Warnings: none
