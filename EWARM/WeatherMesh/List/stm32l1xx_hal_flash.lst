###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       29/Jan/2018  07:47:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -D WM -lCN
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List
#        -o
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.4\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List\stm32l1xx_hal_flash.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj\stm32l1xx_hal_flash.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   FLASH HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the internal FLASH memory:
     10            *           + Program operations functions
     11            *           + Memory Control functions 
     12            *           + Peripheral State functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### FLASH peripheral features #####
     17            ==============================================================================
     18            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     19                 to the Flash memory. It implements the erase and program Flash memory operations 
     20                 and the read and write protection mechanisms.
     21          
     22            [..] The Flash memory interface accelerates code execution with a system of instruction
     23                prefetch. 
     24          
     25            [..] The FLASH main features are:
     26                (+) Flash memory read operations
     27                (+) Flash memory program/erase operations
     28                (+) Read / write protections
     29                (+) Prefetch on I-Code
     30                (+) Option Bytes programming
     31          
     32          
     33                               ##### How to use this driver #####
     34            ==============================================================================
     35            [..]                             
     36                This driver provides functions and macros to configure and program the FLASH 
     37                memory of all STM32L1xx devices.
     38              
     39                (#) FLASH Memory I/O Programming functions: this group includes all needed
     40                    functions to erase and program the main memory:
     41                  (++) Lock and Unlock the FLASH interface
     42                  (++) Erase function: Erase page
     43                  (++) Program functions: Fast Word and Half Page(should be 
     44                  executed from internal SRAM).
     45            
     46                (#) DATA EEPROM Programming functions: this group includes all 
     47                    needed functions to erase and program the DATA EEPROM memory:
     48                  (++) Lock and Unlock the DATA EEPROM interface.
     49                  (++) Erase function: Erase Byte, erase HalfWord, erase Word, erase 
     50                       Double Word (should be executed from internal SRAM).
     51                  (++) Program functions: Fast Program Byte, Fast Program Half-Word, 
     52                       FastProgramWord, Program Byte, Program Half-Word, 
     53                       Program Word and Program Double-Word (should be executed 
     54                       from internal SRAM).
     55            
     56              
     57                (#) FLASH Option Bytes Programming functions: this group includes all needed
     58                    functions to manage the Option Bytes:
     59                  (++) Lock and Unlock the Option Bytes
     60                  (++) Set/Reset the write protection
     61                  (++) Set the Read protection Level
     62                  (++) Program the user Option Bytes
     63                  (++) Launch the Option Bytes loader
     64                  (++) Set/Get the Read protection Level.
     65                  (++) Set/Get the BOR level.
     66                  (++) Get the Write protection.
     67                  (++) Get the user option bytes.
     68              
     69                (#) Interrupts and flags management functions : this group 
     70                    includes all needed functions to:
     71                  (++) Handle FLASH interrupts
     72                  (++) Wait for last FLASH operation according to its status
     73                  (++) Get error flag status
     74          
     75              (#) FLASH Interface configuration functions: this group includes 
     76                the management of following features:
     77                (++) Enable/Disable the RUN PowerDown mode.
     78                (++) Enable/Disable the SLEEP PowerDown mode.  
     79            
     80              (#) FLASH Peripheral State methods: this group includes 
     81                the management of following features:
     82                (++) Wait for the FLASH operation
     83                (++)  Get the specific FLASH error flag
     84              
     85            [..] In addition to these function, this driver includes a set of macros allowing
     86                 to handle the following operations:
     87                
     88                (+) Set/Get the latency
     89                (+) Enable/Disable the prefetch buffer
     90                (+) Enable/Disable the 64 bit Read Access. 
     91                (+) Enable/Disable the Flash power-down
     92                (+) Enable/Disable the FLASH interrupts
     93                (+) Monitor the FLASH flags status
     94                    
     95                           ##### Programming operation functions #####
     96            ===============================================================================  
     97               [..]
     98               This subsection provides a set of functions allowing to manage the FLASH 
     99               program operations.
    100            
    101              [..] The FLASH Memory Programming functions, includes the following functions:
    102               (+) HAL_FLASH_Unlock(void);
    103               (+) HAL_FLASH_Lock(void);
    104               (+) HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    105               (+) HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    106              
    107               [..] Any operation of erase or program should follow these steps:
    108               (#) Call the HAL_FLASH_Unlock() function to enable the flash control register and 
    109                   program memory access.
    110               (#) Call the desired function to erase page or program data.
    111               (#) Call the HAL_FLASH_Lock() to disable the flash program memory access 
    112                  (recommended to protect the FLASH memory against possible unwanted operation).
    113            
    114                         ##### Option Bytes Programming functions ##### 
    115             ==============================================================================  
    116            
    117               [..] The FLASH_Option Bytes Programming_functions, includes the following functions:
    118               (+) HAL_FLASH_OB_Unlock(void);
    119               (+) HAL_FLASH_OB_Lock(void);
    120               (+) HAL_FLASH_OB_Launch(void);
    121               (+) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
    122               (+) HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
    123              
    124               [..] Any operation of erase or program should follow these steps:
    125               (#) Call the HAL_FLASH_OB_Unlock() function to enable the Flash option control 
    126                   register access.
    127               (#) Call the following functions to program the desired option bytes.
    128                   (++) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);      
    129               (#) Once all needed option bytes to be programmed are correctly written, call the
    130                   HAL_FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    131               (#) Call the HAL_FLASH_OB_Lock() to disable the Flash option control register access (recommended
    132                   to protect the option Bytes against possible unwanted operations).
    133            
    134              [..] Proprietary code Read Out Protection (PcROP):    
    135              (#) The PcROP sector is selected by using the same option bytes as the Write
    136                  protection. As a result, these 2 options are exclusive each other.
    137              (#) To activate PCROP mode for Flash sectors(s), you need to follow the sequence below:
    138                  (++) Use this function HAL_FLASHEx_AdvOBProgram with PCROPState = OB_PCROP_STATE_ENABLE.
    139          
    140            @endverbatim
    141            ******************************************************************************
    142            * @attention
    143            *
    144            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    145            *
    146            * Redistribution and use in source and binary forms, with or without modification,
    147            * are permitted provided that the following conditions are met:
    148            *   1. Redistributions of source code must retain the above copyright notice,
    149            *      this list of conditions and the following disclaimer.
    150            *   2. Redistributions in binary form must reproduce the above copyright notice,
    151            *      this list of conditions and the following disclaimer in the documentation
    152            *      and/or other materials provided with the distribution.
    153            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    154            *      may be used to endorse or promote products derived from this software
    155            *      without specific prior written permission.
    156            *
    157            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    158            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    159            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    160            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    161            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    162            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    163            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    164            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    165            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    166            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    167            *
    168            ******************************************************************************  
    169            */
    170          
    171          /* Includes ------------------------------------------------------------------*/
    172          #include "stm32l1xx_hal.h"
    173          
    174          /** @addtogroup STM32L1xx_HAL_Driver
    175            * @{
    176            */
    177          
    178          #ifdef HAL_FLASH_MODULE_ENABLED
    179          
    180          /** @defgroup FLASH FLASH
    181            * @brief FLASH HAL module driver
    182            * @{
    183            */
    184          
    185          /* Private typedef -----------------------------------------------------------*/
    186          /* Private define ------------------------------------------------------------*/
    187          /** @defgroup FLASH_Private_Constants FLASH Private Constants
    188            * @{
    189            */
    190          /**
    191            * @}
    192            */
    193          
    194          /* Private macro ---------------------------- ---------------------------------*/
    195          /** @defgroup FLASH_Private_Macros FLASH Private Macros
    196            * @{
    197            */
    198           
    199          /**
    200            * @}
    201            */
    202          
    203          /* Private variables ---------------------------------------------------------*/
    204          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    205            * @{
    206            */
    207          /* Variables used for Erase pages under interruption*/

   \                                 In section .bss, align 4
    208          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 24
    209          /**
    210            * @}
    211            */
    212          
    213          /* Private function prototypes -----------------------------------------------*/
    214          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    215            * @{
    216            */
    217          static  void   FLASH_SetErrorCode(void);
    218          /**
    219            * @}
    220            */
    221          
    222          /* Exported functions ---------------------------------------------------------*/
    223          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    224            * @{
    225            */
    226            
    227          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    228            *  @brief   Programming operation functions 
    229            *
    230          @verbatim   
    231          @endverbatim
    232            * @{
    233            */
    234          
    235          /**
    236            * @brief  Program word at a specified address
    237            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    238            *         must be called before.
    239            *         Call the HAL_FLASH_Lock() to disable the flash memory access
    240            *         (recommended to protect the FLASH memory against possible unwanted operation).
    241            *
    242            * @param  TypeProgram:  Indicate the way to program at a specified address.
    243            *                       This parameter can be a value of @ref FLASH_Type_Program
    244            * @param  Address:      Specifies the address to be programmed.
    245            * @param  Data:         Specifies the data to be programmed
    246            * 
    247            * @retval HAL_StatusTypeDef HAL Status
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    250          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    251            HAL_StatusTypeDef status = HAL_ERROR;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    252            
    253            /* Process Locked */
    254            __HAL_LOCK(&pFlash);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000014   0x7C00             LDRB     R0,[R0, #+16]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE01C             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000024   0x7408             STRB     R0,[R1, #+16]
    255          
    256            /* Check the parameters */
    257            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    258            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    259          
    260            /* Wait for last operation to be completed */
    261            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x4680             MOV      R8,R0
    262            
    263            if(status == HAL_OK)
   \   00000030   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000034   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000038   0xD109             BNE.N    ??HAL_FLASH_Program_2
    264            {
    265              /* Clean the error context */
    266              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000040   0x6148             STR      R0,[R1, #+20]
    267          
    268              /*Program word (32-bit) at a specified address.*/
    269              *(__IO uint32_t *)Address = Data;
   \   00000042   0x603C             STR      R4,[R7, #+0]
    270          
    271              /* Wait for last operation to be completed */
    272              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000044   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000048   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004C   0x4680             MOV      R8,R0
    273            }
    274          
    275            /* Process Unlocked */
    276            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x....             LDR.N    R1,??DataTable10
   \   00000052   0x7408             STRB     R0,[R1, #+16]
    277          
    278            return status;
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_1: (+1)
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    279          }
    280          
    281          /**
    282            * @brief   Program word at a specified address  with interrupt enabled.
    283            *
    284            * @param  TypeProgram: Indicate the way to program at a specified address.
    285            *                      This parameter can be a value of @ref FLASH_Type_Program
    286            * @param  Address:     Specifies the address to be programmed.
    287            * @param  Data:        Specifies the data to be programmed
    288            * 
    289            * @retval HAL_StatusTypeDef HAL Status
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    292          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    293            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    294            
    295            /* Process Locked */
    296            __HAL_LOCK(&pFlash);
   \   00000006   0x....             LDR.N    R0,??DataTable10
   \   00000008   0x7C00             LDRB     R0,[R0, #+16]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE015             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x....             LDR.N    R6,??DataTable10
   \   00000016   0x7430             STRB     R0,[R6, #+16]
    297          
    298            /* Check the parameters */
    299            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    300            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    301          
    302            /* Enable End of FLASH Operation and Error source interrupts */
    303            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   00000018   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF450 0x3040      ORRS     R0,R0,#0x30000
   \   00000020   0x....             LDR.N    R6,??DataTable10_1  ;; 0x40023c04
   \   00000022   0x6030             STR      R0,[R6, #+0]
    304            
    305            pFlash.Address = Address;
   \   00000024   0x....             LDR.N    R0,??DataTable10
   \   00000026   0x6081             STR      R1,[R0, #+8]
    306            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x....             LDR.N    R6,??DataTable10
   \   0000002C   0x7030             STRB     R0,[R6, #+0]
    307            /* Clean the error context */
    308            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R6,??DataTable10
   \   00000032   0x6170             STR      R0,[R6, #+20]
    309          
    310            if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \   00000034   0x2C02             CMP      R4,#+2
   \   00000036   0xD100             BNE.N    ??HAL_FLASH_Program_IT_2
    311            {
    312              /*Program word (32-bit) at a specified address.*/
    313              *(__IO uint32_t *)Address = Data;
   \   00000038   0x600A             STR      R2,[R1, #+0]
    314            }
    315            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0x4770             BX       LR               ;; return
    316          }
    317          
    318          /**
    319            * @brief This function handles FLASH interrupt request.
    320            * @retval None
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          void HAL_FLASH_IRQHandler(void)
    323          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    324            uint32_t addresstmp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    325            
    326            /* Check FLASH operation error flags */
    327            if( (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     != RESET) || 
    328                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     != RESET) || 
    329                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     != RESET) || 
    330          #if defined(FLASH_SR_RDERR)
    331                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      != RESET) || 
    332          #endif /* FLASH_SR_RDERR */
    333          #if defined(FLASH_SR_OPTVERRUSR)
    334                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) != RESET) || 
    335          #endif /* FLASH_SR_OPTVERRUSR */
    336                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    != RESET) )
   \   00000004   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40F             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000000C   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0580             LSLS     R0,R0,#+22
   \   00000012   0xD40B             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   00000014   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0540             LSLS     R0,R0,#+21
   \   0000001A   0xD407             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000001C   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x04C0             LSLS     R0,R0,#+19
   \   00000022   0xD403             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   00000024   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0500             LSLS     R0,R0,#+20
   \   0000002A   0xD516             BPL.N    ??HAL_FLASH_IRQHandler_1
    337            {
    338              if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable10
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD107             BNE.N    ??HAL_FLASH_IRQHandler_2
    339              {
    340                /*return the faulty sector*/
    341                addresstmp = pFlash.Page;
   \   00000034   0x....             LDR.N    R0,??DataTable10
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x0004             MOVS     R4,R0
    342                pFlash.Page = 0xFFFFFFFF;
   \   0000003A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003E   0x....             LDR.N    R1,??DataTable10
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   \   00000042   0xE002             B.N      ??HAL_FLASH_IRQHandler_3
    343              }
    344              else
    345              {
    346                /*return the faulty address*/
    347                addresstmp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable10
   \   00000046   0x6880             LDR      R0,[R0, #+8]
   \   00000048   0x0004             MOVS     R4,R0
    348              }
    349              /*Save the Error code*/
    350              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   0000004A   0x.... 0x....      BL       FLASH_SetErrorCode
    351              
    352              /* FLASH error interrupt user callback */
    353              HAL_FLASH_OperationErrorCallback(addresstmp);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    354          
    355              /* Stop the procedure ongoing*/
    356              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x....             LDR.N    R1,??DataTable10
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    357            }
    358          
    359            /* Check FLASH End of Operation flag  */
    360            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD548             BPL.N    ??HAL_FLASH_IRQHandler_4
    361            {
    362              /* Clear FLASH End of Operation pending bit */
    363              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000066   0x6008             STR      R0,[R1, #+0]
    364              
    365              /* Process can continue only if no error detected */
    366              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   00000068   0x....             LDR.N    R0,??DataTable10
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD041             BEQ.N    ??HAL_FLASH_IRQHandler_4
    367              {
    368                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \   00000070   0x....             LDR.N    R0,??DataTable10
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD12B             BNE.N    ??HAL_FLASH_IRQHandler_5
    369                {
    370                  /* Nb of pages to erased can be decreased */
    371                  pFlash.NbPagesToErase--;
   \   00000078   0x....             LDR.N    R0,??DataTable10
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x....             LDR.N    R1,??DataTable10
   \   00000080   0x6048             STR      R0,[R1, #+4]
    372          
    373                  /* Check if there are still pages to erase*/
    374                  if(pFlash.NbPagesToErase != 0)
   \   00000082   0x....             LDR.N    R0,??DataTable10
   \   00000084   0x6840             LDR      R0,[R0, #+4]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD016             BEQ.N    ??HAL_FLASH_IRQHandler_6
    375                  {
    376                    addresstmp = pFlash.Page;
   \   0000008A   0x....             LDR.N    R0,??DataTable10
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x0004             MOVS     R4,R0
    377                    /*Indicate user which sector has been erased*/
    378                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    379          
    380                    /*Increment sector number*/
    381                    addresstmp = pFlash.Page + FLASH_PAGE_SIZE;
   \   00000096   0x....             LDR.N    R0,??DataTable10
   \   00000098   0x68C0             LDR      R0,[R0, #+12]
   \   0000009A   0xF510 0x7080      ADDS     R0,R0,#+256
   \   0000009E   0x0004             MOVS     R4,R0
    382                    pFlash.Page = addresstmp;
   \   000000A0   0x....             LDR.N    R0,??DataTable10
   \   000000A2   0x60C4             STR      R4,[R0, #+12]
    383          
    384                    /* If the erase operation is completed, disable the ERASE Bit */
    385                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   000000A4   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF430 0x7000      BICS     R0,R0,#0x200
   \   000000AC   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    386          
    387                    FLASH_PageErase(addresstmp);
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       FLASH_PageErase
   \   000000B6   0xE01D             B.N      ??HAL_FLASH_IRQHandler_4
    388                  }
    389                  else
    390                  {
    391                    /*No more pages to Erase, user callback can be called.*/
    392                    /*Reset Sector and stop Erase pages procedure*/
    393                    pFlash.Page = addresstmp = 0xFFFFFFFF;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   000000B8   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000BC   0x0004             MOVS     R4,R0
   \   000000BE   0x....             LDR.N    R0,??DataTable10
   \   000000C0   0x60C4             STR      R4,[R0, #+12]
    394                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x....             LDR.N    R1,??DataTable10
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    395                    /* FLASH EOP interrupt user callback */
    396                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   000000CE   0xE011             B.N      ??HAL_FLASH_IRQHandler_4
    397                  }
    398                }
    399                else
    400                {
    401                    /* If the program operation is completed, disable the PROG Bit */
    402                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0xF07F 0x0108      MVNS     R1,#+8
   \   000000D8   0x4008             ANDS     R0,R1,R0
   \   000000DA   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    403          
    404                    /*Program ended. Return the selected address*/
    405                    /* FLASH EOP interrupt user callback */
    406                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \   000000DE   0x....             LDR.N    R0,??DataTable10
   \   000000E0   0x6880             LDR      R0,[R0, #+8]
   \   000000E2   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    407                  
    408                    /* Reset Address and stop Program procedure*/
    409                    pFlash.Address = 0xFFFFFFFF;
   \   000000E6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000EA   0x....             LDR.N    R1,??DataTable10
   \   000000EC   0x6088             STR      R0,[R1, #+8]
    410                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x....             LDR.N    R1,??DataTable10
   \   000000F2   0x7008             STRB     R0,[R1, #+0]
    411                }
    412              }
    413            }
    414            
    415          
    416            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   000000F4   0x....             LDR.N    R0,??DataTable10
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD10E             BNE.N    ??HAL_FLASH_IRQHandler_7
    417            {
    418              /* Operation is completed, disable the PROG and ERASE */
    419              CLEAR_BIT(FLASH->PECR, (FLASH_PECR_ERASE | FLASH_PECR_PROG));
   \   000000FC   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF430 0x7002      BICS     R0,R0,#0x208
   \   00000104   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   00000106   0x6008             STR      R0,[R1, #+0]
    420          
    421              /* Disable End of FLASH Operation and Error source interrupts */
    422              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   00000108   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   00000110   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   00000112   0x6008             STR      R0,[R1, #+0]
    423          
    424              /* Process Unlocked */
    425              __HAL_UNLOCK(&pFlash);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x....             LDR.N    R1,??DataTable10
   \   00000118   0x7408             STRB     R0,[R1, #+16]
    426            }
    427          }
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   0000011A   0xBD10             POP      {R4,PC}          ;; return
    428          
    429          
    430          /**
    431            * @brief  FLASH end of operation interrupt callback
    432            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    433            *                 - Pages Erase: Address of the page which has been erased 
    434            *                    (if 0xFFFFFFFF, it means that all the selected pages have been erased)
    435            *                 - Program: Address which was selected for data program
    436            * @retval none
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    439          {
    440            /* Prevent unused argument(s) compilation warning */
    441            UNUSED(ReturnValue);
    442          
    443            /* NOTE : This function Should not be modified, when the callback is needed,
    444                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    445             */ 
    446          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    447          
    448          /**
    449            * @brief  FLASH operation error interrupt callback
    450            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    451            *                 - Pages Erase: Address of the page which returned an error
    452            *                 - Program: Address which was selected for data program
    453            * @retval none
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    456          {
    457            /* Prevent unused argument(s) compilation warning */
    458            UNUSED(ReturnValue);
    459          
    460            /* NOTE : This function Should not be modified, when the callback is needed,
    461                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    462             */ 
    463          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @}
    467            */
    468          
    469          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    470           *  @brief   management functions 
    471           *
    472          @verbatim   
    473           ===============================================================================
    474                                ##### Peripheral Control functions #####
    475           ===============================================================================  
    476              [..]
    477              This subsection provides a set of functions allowing to control the FLASH 
    478              memory operations.
    479          
    480          @endverbatim
    481            * @{
    482            */
    483          
    484          /**
    485            * @brief  Unlock the FLASH control register access
    486            * @retval HAL Status
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    489          {
    490            if (HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PRGLOCK))
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0780             LSLS     R0,R0,#+30
   \   00000006   0xD511             BPL.N    ??HAL_FLASH_Unlock_0
    491            {
    492              /* Unlocking FLASH_PECR register access*/
    493              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \   00000008   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD505             BPL.N    ??HAL_FLASH_Unlock_1
    494              {  
    495                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \   00000010   0x....             LDR.N    R0,??DataTable10_3  ;; 0x89abcdef
   \   00000012   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    496                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \   00000016   0x....             LDR.N    R0,??DataTable10_5  ;; 0x2030405
   \   00000018   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    497              }
    498              
    499              /* Unlocking the program memory access */
    500              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY1);
   \                     ??HAL_FLASH_Unlock_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10_6  ;; 0x8c9daebf
   \   0000001E   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023c10
   \   00000020   0x6008             STR      R0,[R1, #+0]
    501              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY2);  
   \   00000022   0x....             LDR.N    R0,??DataTable10_8  ;; 0x13141516
   \   00000024   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023c10
   \   00000026   0x6008             STR      R0,[R1, #+0]
    502            }
    503            else
    504            {
    505              return HAL_ERROR;
    506            }
    507          
    508            return HAL_OK; 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_FLASH_Unlock_2
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_Unlock_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    509          }
    510          
    511          /**
    512            * @brief  Locks the FLASH control register access
    513            * @retval HAL Status
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    516          {
    517            /* Set the PRGLOCK Bit to lock the FLASH Registers access */
    518            SET_BIT(FLASH->PECR, FLASH_PECR_PRGLOCK);
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    519            
    520          
    521            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    522          }
    523          
    524          
    525          /**
    526            * @brief  Unlock the FLASH Option Control Registers access.
    527            * @retval HAL Status
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    530          {
    531            if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_OPTLOCK))
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0740             LSLS     R0,R0,#+29
   \   00000006   0xD511             BPL.N    ??HAL_FLASH_OB_Unlock_0
    532            {
    533              /* Unlocking FLASH_PECR register access*/
    534              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \   00000008   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD505             BPL.N    ??HAL_FLASH_OB_Unlock_1
    535              {  
    536                /* Unlocking FLASH_PECR register access*/
    537                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \   00000010   0x....             LDR.N    R0,??DataTable10_3  ;; 0x89abcdef
   \   00000012   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    538                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \   00000016   0x....             LDR.N    R0,??DataTable10_5  ;; 0x2030405
   \   00000018   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    539              }
    540          
    541              /* Unlocking the option bytes block access */
    542              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10_9  ;; 0xfbead9c8
   \   0000001E   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40023c14
   \   00000020   0x6008             STR      R0,[R1, #+0]
    543              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
   \   00000022   0x....             LDR.N    R0,??DataTable10_11  ;; 0x24252627
   \   00000024   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40023c14
   \   00000026   0x6008             STR      R0,[R1, #+0]
    544            }
    545            else
    546            {
    547              return HAL_ERROR;
    548            }  
    549            
    550            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_FLASH_OB_Unlock_2
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_OB_Unlock_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    551          }
    552          
    553          /**
    554            * @brief  Lock the FLASH Option Control Registers access.
    555            * @retval HAL Status 
    556            */

   \                                 In section .text, align 2, keep-with-next
    557          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    558          {
    559            /* Set the OPTLOCK Bit to lock the option bytes block access */
    560            SET_BIT(FLASH->PECR, FLASH_PECR_OPTLOCK);
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    561            
    562            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    563          }
    564            
    565          /**
    566            * @brief  Launch the option byte loading.
    567            * @note   This function will reset automatically the MCU.
    568            * @retval HAL_StatusTypeDef HAL Status
    569            */

   \                                 In section .text, align 2, keep-with-next
    570          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    571          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    572            /* Set the OBL_Launch bit to launch the option byte loading */
    573            SET_BIT(FLASH->PECR, FLASH_PECR_OBL_LAUNCH);
   \   00000002   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   0000000A   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    574            
    575            /* Wait for last operation to be completed */
    576            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE));  
   \   0000000E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000012   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    577          }
    578          
    579          /**
    580            * @}
    581            */  
    582          
    583          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State functions 
    584           *  @brief   Peripheral State functions 
    585           *
    586          @verbatim   
    587           ===============================================================================
    588                                ##### Peripheral State functions #####
    589           ===============================================================================  
    590              [..]
    591              This subsection permit to get in run-time the status of the FLASH peripheral.
    592          
    593          @endverbatim
    594            * @{
    595            */
    596          
    597          /**
    598            * @brief  Get the specific FLASH error flag.
    599            * @retval FLASH_ErrorCode: The returned value can be:
    600            *            @ref FLASH_Error_Codes
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          uint32_t HAL_FLASH_GetError(void)
    603          { 
    604             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x4770             BX       LR               ;; return
    605          }  
    606          /**
    607            * @}
    608            */
    609          
    610          /**
    611            * @}
    612            */
    613          
    614          /** @addtogroup FLASH_Private_Functions
    615           * @{
    616           */
    617          
    618          
    619          /**
    620            * @brief  Wait for a FLASH operation to complete.
    621            * @param  Timeout: maximum flash operation timeout
    622            * @retval HAL_StatusTypeDef HAL Status
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    625          {
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    626            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    627               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    628               flag will be set */
    629               
    630            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x0005             MOVS     R5,R0
    631               
    632            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
    633            { 
    634              if (Timeout != HAL_MAX_DELAY)
   \   00000012   0xF5B4 0x4F00      CMP      R4,#+32768
   \   00000016   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
    635              {
    636                if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
    637                {
    638                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE01B             B.N      ??FLASH_WaitForLastOperation_3
    639                }
    640              }
    641            }
    642            
    643            /* Check FLASH End of Operation flag  */
    644            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD502             BPL.N    ??FLASH_WaitForLastOperation_4
    645            {
    646              /* Clear FLASH End of Operation pending bit */
    647              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000036   0x6008             STR      R0,[R1, #+0]
    648            }
    649            
    650            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    651               __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
    652          #if defined(FLASH_SR_RDERR)
    653                __HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) || 
    654          #endif /* FLASH_SR_RDERR */
    655          #if defined(FLASH_SR_OPTVERRUSR)
    656                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) || 
    657          #endif /* FLASH_SR_OPTVERRUSR */
    658               __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x05C0             LSLS     R0,R0,#+23
   \   0000003E   0xD40B             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000040   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0500             LSLS     R0,R0,#+20
   \   00000046   0xD407             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000048   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x04C0             LSLS     R0,R0,#+19
   \   0000004E   0xD403             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000050   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0580             LSLS     R0,R0,#+22
   \   00000056   0xD503             BPL.N    ??FLASH_WaitForLastOperation_6
    659            {
    660              /*Save the error code*/
    661              FLASH_SetErrorCode();
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \   00000058   0x.... 0x....      BL       FLASH_SetErrorCode
    662              return HAL_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE000             B.N      ??FLASH_WaitForLastOperation_3
    663            }
    664          
    665            /* If there is no error flag set */
    666            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_6: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    667          }
    668          
    669          
    670          /**
    671            * @brief  Set the specific FLASH error flag.
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          static void FLASH_SetErrorCode(void)
    675          { 
    676            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x05C0             LSLS     R0,R0,#+23
   \   00000006   0xD505             BPL.N    ??FLASH_SetErrorCode_0
    677            {
    678              pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   00000008   0x....             LDR.N    R0,??DataTable10
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000010   0x....             LDR.N    R1,??DataTable10
   \   00000012   0x6148             STR      R0,[R1, #+20]
    679            }
    680            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0580             LSLS     R0,R0,#+22
   \   0000001A   0xD505             BPL.N    ??FLASH_SetErrorCode_1
    681            {
    682               pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   0000001C   0x....             LDR.N    R0,??DataTable10
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000024   0x....             LDR.N    R1,??DataTable10
   \   00000026   0x6148             STR      R0,[R1, #+20]
    683            }
    684          
    685            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0500             LSLS     R0,R0,#+20
   \   0000002E   0xD509             BPL.N    ??FLASH_SetErrorCode_2
    686            {
    687               pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
   \   00000030   0x....             LDR.N    R0,??DataTable10
   \   00000032   0x6940             LDR      R0,[R0, #+20]
   \   00000034   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000038   0x....             LDR.N    R1,??DataTable10
   \   0000003A   0x6148             STR      R0,[R1, #+20]
    688               __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
   \   0000003C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000040   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000042   0x6008             STR      R0,[R1, #+0]
    689            }
    690          
    691          #if defined(FLASH_SR_RDERR)
    692            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))
    693            {
    694              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
    695              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);  
    696            }
    697          #endif /* FLASH_SR_RDERR */
    698          
    699          #if defined(FLASH_SR_OPTVERRUSR)
    700            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR))
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x04C0             LSLS     R0,R0,#+19
   \   0000004A   0xD509             BPL.N    ??FLASH_SetErrorCode_3
    701            {
    702              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTVUSR;
   \   0000004C   0x....             LDR.N    R0,??DataTable10
   \   0000004E   0x6940             LDR      R0,[R0, #+20]
   \   00000050   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000054   0x....             LDR.N    R1,??DataTable10
   \   00000056   0x6148             STR      R0,[R1, #+20]
    703              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERRUSR);  
   \   00000058   0xF44F 0x5080      MOV      R0,#+4096
   \   0000005C   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    704            }
    705          #endif /* FLASH_SR_OPTVERRUSR */
    706          
    707            /* Clear FLASH error pending bits */
    708            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR);
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   00000060   0xF44F 0x7040      MOV      R0,#+768
   \   00000064   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000066   0x6008             STR      R0,[R1, #+0]
    709          }  
   \   00000068   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40023C18         DC32     0x40023c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x89ABCDEF         DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x02030405         DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x8C9DAEBF         DC32     0x8c9daebf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x13141516         DC32     0x13141516

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0xFBEAD9C8         DC32     0xfbead9c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x24252627         DC32     0x24252627
    710          /**
    711            * @}
    712            */
    713          
    714          /**
    715            * @}
    716            */
    717          
    718          #endif /* HAL_FLASH_MODULE_ENABLED */
    719          
    720          /**
    721            * @}
    722            */
    723          
    724          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
       8   HAL_FLASH_IRQHandler
         8   -> FLASH_PageErase
         8   -> FLASH_SetErrorCode
         8   -> HAL_FLASH_EndOfOperationCallback
         8   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      24   HAL_FLASH_Program
        24   -> FLASH_WaitForLastOperation
      12   HAL_FLASH_Program_IT
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     106  FLASH_SetErrorCode
     100  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     284  HAL_FLASH_IRQHandler
      16  HAL_FLASH_Lock
      24  HAL_FLASH_OB_Launch
      16  HAL_FLASH_OB_Lock
      48  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
      92  HAL_FLASH_Program
      66  HAL_FLASH_Program_IT
      48  HAL_FLASH_Unlock
      24  pFlash

 
  24 bytes in section .bss
 858 bytes in section .text
 
 858 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
