###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       30/Jan/2018  13:45:49
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_i2c.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -D WM -lCN
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List
#        -o
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.4\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List\stm32l1xx_hal_i2c.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj\stm32l1xx_hal_i2c.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19              The I2C HAL driver can be used as follows:
     20              
     21              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     22                  I2C_HandleTypeDef  hi2c; 
     23          
     24              (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:
     25                  (##) Enable the I2Cx interface clock
     26                  (##) I2C pins configuration
     27                      (+++) Enable the clock for the I2C GPIOs
     28                      (+++) Configure I2C pins as alternate function open-drain
     29                  (##) NVIC configuration if you need to use interrupt process
     30                      (+++) Configure the I2Cx interrupt priority
     31                      (+++) Enable the NVIC I2C IRQ Channel
     32                  (##) DMA Configuration if you need to use DMA process
     33                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     34                      (+++) Enable the DMAx interface clock using
     35                      (+++) Configure the DMA handle parameters
     36                      (+++) Configure the DMA Tx or Rx channel
     37                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     38                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on 
     39                            the DMA Tx or Rx channel
     40          
     41              (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
     42                  Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.
     43          
     44              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     45                  (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.
     46          
     47              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     48          
     49              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     50          
     51              *** Polling mode IO operation ***
     52              =================================
     53              [..]
     54                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     55                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     56                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     57                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     58          
     59              *** Polling mode IO MEM operation ***
     60              =====================================
     61              [..]
     62                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     63                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     64          
     65          
     66              *** Interrupt mode IO operation ***
     67              ===================================
     68              [..]
     69                (+) Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT()
     70                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can
     71                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
     72                (+) Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT()
     73                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can
     74                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
     75                (+) Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT()
     76                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can
     77                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
     78                (+) Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT()
     79                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can
     80                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
     81                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     82                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
     83          
     84              *** Interrupt mode IO MEM operation ***
     85              =======================================
     86              [..]
     87                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
     88                    HAL_I2C_Mem_Write_IT()
     89                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and user can
     90                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
     91                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
     92                    HAL_I2C_Mem_Read_IT()
     93                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and user can
     94                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
     95                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     96                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
     97          
     98              *** DMA mode IO operation ***
     99              ==============================
    100              [..]
    101                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    102                    HAL_I2C_Master_Transmit_DMA()
    103                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can
    104                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
    105                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    106                    HAL_I2C_Master_Receive_DMA()
    107                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can
    108                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
    109                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    110                    HAL_I2C_Slave_Transmit_DMA()
    111                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can
    112                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
    113                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    114                    HAL_I2C_Slave_Receive_DMA()
    115                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can
    116                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
    117                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    118                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    119          
    120              *** DMA mode IO MEM operation ***
    121              =================================
    122              [..]
    123                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    124                    HAL_I2C_Mem_Write_DMA()
    125                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and user can
    126                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
    127                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    128                    HAL_I2C_Mem_Read_DMA()
    129                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and user can
    130                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
    131                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    132                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    133          
    134          
    135               *** I2C HAL driver macros list ***
    136               ==================================
    137               [..]
    138                 Below the list of most used macros in I2C HAL driver.
    139          
    140                (+) __HAL_I2C_ENABLE:      Enable the I2C peripheral
    141                (+) __HAL_I2C_DISABLE:     Disable the I2C peripheral
    142                (+) __HAL_I2C_GET_FLAG:    Check whether the specified I2C flag is set or not
    143                (+) __HAL_I2C_CLEAR_FLAG:  Clear the specified I2C pending flag
    144                (+) __HAL_I2C_ENABLE_IT:   Enable the specified I2C interrupt
    145                (+) __HAL_I2C_DISABLE_IT:  Disable the specified I2C interrupt
    146          
    147               [..]
    148                 (@) You can refer to the I2C HAL driver header file for more useful macros
    149          
    150          
    151            @endverbatim
    152            ******************************************************************************
    153            * @attention
    154            *
    155            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    156            *
    157            * Redistribution and use in source and binary forms, with or without modification,
    158            * are permitted provided that the following conditions are met:
    159            *   1. Redistributions of source code must retain the above copyright notice,
    160            *      this list of conditions and the following disclaimer.
    161            *   2. Redistributions in binary form must reproduce the above copyright notice,
    162            *      this list of conditions and the following disclaimer in the documentation
    163            *      and/or other materials provided with the distribution.
    164            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    165            *      may be used to endorse or promote products derived from this software
    166            *      without specific prior written permission.
    167            *
    168            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    169            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    170            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    171            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    172            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    173            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    174            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    175            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    176            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    177            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    178            *
    179            ******************************************************************************  
    180            */
    181          
    182          /* Includes ------------------------------------------------------------------*/
    183          #include "stm32l1xx_hal.h"
    184          
    185          /** @addtogroup STM32L1xx_HAL_Driver
    186            * @{
    187            */
    188          
    189          /** @defgroup I2C I2C
    190            * @brief I2C HAL module driver
    191            * @{
    192            */
    193          
    194          #ifdef HAL_I2C_MODULE_ENABLED
    195          
    196          /* Private typedef -----------------------------------------------------------*/
    197          /* Private define ------------------------------------------------------------*/
    198          /** @defgroup I2C_Private_Constants I2C Private Constants
    199            * @{
    200            */
    201          #define I2C_TIMEOUT_FLAG          ((uint32_t)35)      /* 35 ms */
    202          #define I2C_TIMEOUT_ADDR_SLAVE    ((uint32_t)10000)   /* 10 s  */
    203          #define I2C_TIMEOUT_BUSY_FLAG     ((uint32_t)10000)   /* 10 s  */
    204          
    205          #define I2C_MIN_PCLK_FREQ         ((uint32_t)2000000) /* 2 MHz*/
    206          /**
    207            * @}
    208            */
    209          
    210          
    211          /* Private macro -------------------------------------------------------------*/
    212          /* Private variables ---------------------------------------------------------*/
    213          /* Private function prototypes -----------------------------------------------*/
    214          /** @defgroup I2C_Private_Functions I2C Private Functions
    215            * @{
    216            */
    217          
    218          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    219          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    220          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    221          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    222          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma);
    223          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma);
    224          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    225          
    226          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout);
    227          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout);
    228          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    229          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    230          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    231          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout);
    232          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    233          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    234          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    235          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c);
    236          
    237          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c);
    238          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c);
    239          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c);
    240          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c);
    241          
    242          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c);
    243          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c);
    244          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c);
    245          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c);
    246          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c);
    247          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c);
    248          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c);
    249          /**
    250            * @}
    251            */
    252          
    253          
    254          /* Exported functions ---------------------------------------------------------*/
    255          
    256          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    257            * @{
    258            */
    259          
    260          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    261           *  @brief    Initialization and Configuration functions 
    262           *
    263          @verbatim    
    264           ===============================================================================
    265                        ##### Initialization and de-initialization functions #####
    266           ===============================================================================
    267              [..]  This subsection provides a set of functions allowing to initialize and 
    268                    deinitialize the I2Cx peripheral:
    269          
    270                (+) User must Implement HAL_I2C_MspInit() function in which he configures 
    271                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    272          
    273                (+) Call the function HAL_I2C_Init() to configure the selected device with 
    274                    the selected configuration:
    275                  (++) Communication Speed
    276                  (++) Duty cycle
    277                  (++) Addressing mode
    278                  (++) Own Address 1
    279                  (++) Dual Addressing mode
    280                  (++) Own Address 2
    281                  (++) General call mode
    282                  (++) Nostretch mode
    283          
    284                (+) Call the function HAL_I2C_DeInit() to restore the default configuration 
    285                    of the selected I2Cx peripheral.       
    286          
    287          @endverbatim
    288            * @{
    289            */
    290          
    291          /**
    292            * @brief  Initializes the I2C according to the specified parameters 
    293            *         in the I2C_InitTypeDef and initialize the associated handle.
    294            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    295            *                the configuration information for the specified I2C.
    296            * @retval HAL status
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    299          {
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    300            uint32_t freqrange = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    301            uint32_t pclk1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    302          
    303            /* Check the I2C handle allocation */
    304            if(hi2c == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_I2C_Init_0
    305            {
    306              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE0AF             B.N      ??HAL_I2C_Init_1
    307            }
    308            
    309            /* Check the parameters */
    310            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    311            assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
    312            assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
    313            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    314            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    315            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    316            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    317            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    318            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    319          
    320            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   00000010   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_I2C_Init_2
    321            {
    322              /* Allocate lock resource and initialize it */
    323              hi2c->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0034      STRB     R0,[R4, #+52]
    324              
    325              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    326              HAL_I2C_MspInit(hi2c);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_I2C_MspInit
    327            }
    328          
    329            /* Get PCLK1 frequency */
    330            pclk1 = HAL_RCC_GetPCLK1Freq();
   \                     ??HAL_I2C_Init_2: (+1)
   \   00000024   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000028   0x0006             MOVS     R6,R0
    331          
    332            /* The minimum allowed frequency is 2 MHz */
    333            if(pclk1 < I2C_MIN_PCLK_FREQ)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x1e8480
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD201             BCS.N    ??HAL_I2C_Init_3
    334            {
    335              return HAL_ERROR;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE09C             B.N      ??HAL_I2C_Init_1
    336            }
    337          
    338            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_3: (+1)
   \   00000036   0x2024             MOVS     R0,#+36
   \   00000038   0xF884 0x0035      STRB     R0,[R4, #+53]
    339            
    340            /* Disable the selected I2C peripheral */
    341            __HAL_I2C_DISABLE(hi2c);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0840             LSRS     R0,R0,#+1
   \   00000042   0x0040             LSLS     R0,R0,#+1
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
    342          
    343            /* Calculate frequency range */
    344            freqrange = I2C_FREQ_RANGE(pclk1);
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0xf4240
   \   0000004C   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000050   0x0005             MOVS     R5,R0
    345          
    346            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    347            /* Configure I2Cx: Frequency range */
    348            MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6840             LDR      R0,[R0, #+4]
   \   00000056   0x0980             LSRS     R0,R0,#+6
   \   00000058   0x0180             LSLS     R0,R0,#+6
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6048             STR      R0,[R1, #+4]
    349          
    350            /*---------------------------- I2Cx TRISE Configuration --------------------*/
    351            /* Configure I2Cx: Rise Time */
    352            MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6A00             LDR      R0,[R0, #+32]
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x186a1
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xD201             BCS.N    ??HAL_I2C_Init_4
   \   0000006E   0x1C69             ADDS     R1,R5,#+1
   \   00000070   0xE008             B.N      ??HAL_I2C_Init_5
   \                     ??HAL_I2C_Init_4: (+1)
   \   00000072   0xF44F 0x7196      MOV      R1,#+300
   \   00000076   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000007A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000007E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_I2C_Init_5: (+1)
   \   00000084   0x0980             LSRS     R0,R0,#+6
   \   00000086   0x0180             LSLS     R0,R0,#+6
   \   00000088   0x4308             ORRS     R0,R1,R0
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6208             STR      R0,[R1, #+32]
    353          
    354            /*---------------------------- I2Cx CCR Configuration ----------------------*/
    355            /* Configure I2Cx: Speed */
    356            MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x69C0             LDR      R0,[R0, #+28]
   \   00000092   0x6861             LDR      R1,[R4, #+4]
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x186a1
   \   00000098   0x4291             CMP      R1,R2
   \   0000009A   0xD20E             BCS.N    ??HAL_I2C_Init_6
   \   0000009C   0x6861             LDR      R1,[R4, #+4]
   \   0000009E   0x0049             LSLS     R1,R1,#+1
   \   000000A0   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000A4   0x0509             LSLS     R1,R1,#+20       ;; ZeroExtS R1,R1,#+20,#+20
   \   000000A6   0x0D09             LSRS     R1,R1,#+20
   \   000000A8   0x2904             CMP      R1,#+4
   \   000000AA   0xD201             BCS.N    ??HAL_I2C_Init_7
   \   000000AC   0x2104             MOVS     R1,#+4
   \   000000AE   0xE02A             B.N      ??HAL_I2C_Init_8
   \                     ??HAL_I2C_Init_7: (+1)
   \   000000B0   0x6861             LDR      R1,[R4, #+4]
   \   000000B2   0x0049             LSLS     R1,R1,#+1
   \   000000B4   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000B8   0xE025             B.N      ??HAL_I2C_Init_8
   \                     ??HAL_I2C_Init_6: (+1)
   \   000000BA   0x68A1             LDR      R1,[R4, #+8]
   \   000000BC   0x2900             CMP      R1,#+0
   \   000000BE   0xD105             BNE.N    ??HAL_I2C_Init_9
   \   000000C0   0x6861             LDR      R1,[R4, #+4]
   \   000000C2   0x2203             MOVS     R2,#+3
   \   000000C4   0x4351             MULS     R1,R2,R1
   \   000000C6   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000CA   0xE006             B.N      ??HAL_I2C_Init_10
   \                     ??HAL_I2C_Init_9: (+1)
   \   000000CC   0x6861             LDR      R1,[R4, #+4]
   \   000000CE   0x2219             MOVS     R2,#+25
   \   000000D0   0x4351             MULS     R1,R2,R1
   \   000000D2   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000D6   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \                     ??HAL_I2C_Init_10: (+1)
   \   000000DA   0x0509             LSLS     R1,R1,#+20
   \   000000DC   0xD101             BNE.N    ??HAL_I2C_Init_11
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0xE011             B.N      ??HAL_I2C_Init_8
   \                     ??HAL_I2C_Init_11: (+1)
   \   000000E2   0x68A1             LDR      R1,[R4, #+8]
   \   000000E4   0x2900             CMP      R1,#+0
   \   000000E6   0xD105             BNE.N    ??HAL_I2C_Init_12
   \   000000E8   0x6861             LDR      R1,[R4, #+4]
   \   000000EA   0x2203             MOVS     R2,#+3
   \   000000EC   0x4351             MULS     R1,R2,R1
   \   000000EE   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000F2   0xE006             B.N      ??HAL_I2C_Init_13
   \                     ??HAL_I2C_Init_12: (+1)
   \   000000F4   0x6861             LDR      R1,[R4, #+4]
   \   000000F6   0x2219             MOVS     R2,#+25
   \   000000F8   0x4351             MULS     R1,R2,R1
   \   000000FA   0xFBB6 0xF1F1      UDIV     R1,R6,R1
   \   000000FE   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \                     ??HAL_I2C_Init_13: (+1)
   \   00000102   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \                     ??HAL_I2C_Init_8: (+1)
   \   00000106   0x.... 0x....      LDR.W    R2,??DataTable7  ;; 0xffff3000
   \   0000010A   0x4010             ANDS     R0,R2,R0
   \   0000010C   0x4308             ORRS     R0,R1,R0
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x61C8             STR      R0,[R1, #+28]
    357          
    358            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    359            /* Configure I2Cx: Generalcall and NoStretch mode */
    360            MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xF07F 0x01C0      MVNS     R1,#+192
   \   0000011A   0x4008             ANDS     R0,R1,R0
   \   0000011C   0x69E1             LDR      R1,[R4, #+28]
   \   0000011E   0x4308             ORRS     R0,R1,R0
   \   00000120   0x6A21             LDR      R1,[R4, #+32]
   \   00000122   0x4308             ORRS     R0,R1,R0
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x6008             STR      R0,[R1, #+0]
    361          
    362            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    363            /* Configure I2Cx: Own Address1 and addressing mode */
    364            MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6880             LDR      R0,[R0, #+8]
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0xffff7c00
   \   00000130   0x4008             ANDS     R0,R1,R0
   \   00000132   0x6921             LDR      R1,[R4, #+16]
   \   00000134   0x4308             ORRS     R0,R1,R0
   \   00000136   0x68E1             LDR      R1,[R4, #+12]
   \   00000138   0x4308             ORRS     R0,R1,R0
   \   0000013A   0x6821             LDR      R1,[R4, #+0]
   \   0000013C   0x6088             STR      R0,[R1, #+8]
    365          
    366            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    367            /* Configure I2Cx: Dual mode and Own Address2 */
    368            MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
   \   0000013E   0x6820             LDR      R0,[R4, #+0]
   \   00000140   0x68C0             LDR      R0,[R0, #+12]
   \   00000142   0x0A00             LSRS     R0,R0,#+8
   \   00000144   0x0200             LSLS     R0,R0,#+8
   \   00000146   0x69A1             LDR      R1,[R4, #+24]
   \   00000148   0x6962             LDR      R2,[R4, #+20]
   \   0000014A   0x4311             ORRS     R1,R2,R1
   \   0000014C   0x4308             ORRS     R0,R1,R0
   \   0000014E   0x6821             LDR      R1,[R4, #+0]
   \   00000150   0x60C8             STR      R0,[R1, #+12]
    369          
    370            /* Enable the selected I2C peripheral */
    371            __HAL_I2C_ENABLE(hi2c);
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000015A   0x6821             LDR      R1,[R4, #+0]
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    372            
    373            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x63A0             STR      R0,[R4, #+56]
    374            hi2c->State = HAL_I2C_STATE_READY;
   \   00000162   0x2020             MOVS     R0,#+32
   \   00000164   0xF884 0x0035      STRB     R0,[R4, #+53]
    375            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0xF884 0x0036      STRB     R0,[R4, #+54]
    376          
    377            return HAL_OK;
   \   0000016E   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Init_1: (+1)
   \   00000170   0xBD70             POP      {R4-R6,PC}       ;; return
    378          }
    379          
    380          /**
    381            * @brief  DeInitialize the I2C peripheral. 
    382            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    383            *                the configuration information for the specified I2C.
    384            * @retval HAL status
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    387          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    388            /* Check the I2C handle allocation */
    389            if(hi2c == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    390            {
    391              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE017             B.N      ??HAL_I2C_DeInit_1
    392            }
    393            
    394            /* Check the parameters */
    395            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    396            
    397            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   0000000C   0x2024             MOVS     R0,#+36
   \   0000000E   0xF884 0x0035      STRB     R0,[R4, #+53]
    398            
    399            /* Disable the I2C Peripheral Clock */
    400            __HAL_I2C_DISABLE(hi2c);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0840             LSRS     R0,R0,#+1
   \   00000018   0x0040             LSLS     R0,R0,#+1
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    401            
    402            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    403            HAL_I2C_MspDeInit(hi2c);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_I2C_MspDeInit
    404            
    405            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x63A0             STR      R0,[R4, #+56]
    406            hi2c->State = HAL_I2C_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
    407            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0036      STRB     R0,[R4, #+54]
    408            
    409            /* Release Lock */
    410            __HAL_UNLOCK(hi2c);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
    411          
    412            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_DeInit_1: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    413          }
    414          
    415          /**
    416            * @brief Initialize the I2C MSP.
    417            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    418            *                the configuration information for the specified I2C.
    419            * @retval None
    420            */

   \                                 In section .text, align 2, keep-with-next
    421           __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    422          {
    423            /* Prevent unused argument(s) compilation warning */
    424            UNUSED(hi2c);
    425          
    426            /* NOTE : This function should not be modified, when the callback is needed,
    427                      the HAL_I2C_MspInit could be implemented in the user file
    428             */ 
    429          }
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    430          
    431          /**
    432            * @brief DeInitialize the I2C MSP.
    433            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    434            *                the configuration information for the specified I2C.
    435            * @retval None
    436            */

   \                                 In section .text, align 2, keep-with-next
    437           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    438          {
    439            /* Prevent unused argument(s) compilation warning */
    440            UNUSED(hi2c);
    441          
    442            /* NOTE : This function should not be modified, when the callback is needed,
    443                      the HAL_I2C_MspDeInit could be implemented in the user file
    444             */ 
    445          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    446          
    447          /**
    448            * @}
    449            */
    450          
    451          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions 
    452           *  @brief   Data transfers functions 
    453           *
    454          @verbatim   
    455           ===============================================================================
    456                                ##### IO operation functions #####
    457           ===============================================================================  
    458              [..]
    459              This subsection provides a set of functions allowing to manage the I2C data 
    460              transfers.
    461          
    462              (#) There are two modes of transfer:
    463                 (++) Blocking mode : The communication is performed in the polling mode. 
    464                      The status of all data processing is returned by the same function 
    465                      after finishing transfer.  
    466                 (++) No-Blocking mode : The communication is performed using Interrupts 
    467                      or DMA. These functions return the status of the transfer startup.
    468                      The end of the data processing will be indicated through the 
    469                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when 
    470                      using DMA mode.
    471          
    472              (#) Blocking mode functions are :
    473                  (++) HAL_I2C_Master_Transmit()
    474                  (++) HAL_I2C_Master_Receive()
    475                  (++) HAL_I2C_Slave_Transmit()
    476                  (++) HAL_I2C_Slave_Receive()
    477                  (++) HAL_I2C_Mem_Write()
    478                  (++) HAL_I2C_Mem_Read()
    479                  (++) HAL_I2C_IsDeviceReady()
    480                  
    481              (#) No-Blocking mode functions with Interrupt are :
    482                  (++) HAL_I2C_Master_Transmit_IT()
    483                  (++) HAL_I2C_Master_Receive_IT()
    484                  (++) HAL_I2C_Slave_Transmit_IT()
    485                  (++) HAL_I2C_Slave_Receive_IT()
    486                  (++) HAL_I2C_Mem_Write_IT()
    487                  (++) HAL_I2C_Mem_Read_IT()
    488          
    489              (#) No-Blocking mode functions with DMA are :
    490                  (++) HAL_I2C_Master_Transmit_DMA()
    491                  (++) HAL_I2C_Master_Receive_DMA()
    492                  (++) HAL_I2C_Slave_Transmit_DMA()
    493                  (++) HAL_I2C_Slave_Receive_DMA()
    494                  (++) HAL_I2C_Mem_Write_DMA()
    495                  (++) HAL_I2C_Mem_Read_DMA()
    496          
    497              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    498                  (++) HAL_I2C_MemTxCpltCallback()
    499                  (++) HAL_I2C_MemRxCpltCallback()
    500                  (++) HAL_I2C_MasterTxCpltCallback()
    501                  (++) HAL_I2C_MasterRxCpltCallback()
    502                  (++) HAL_I2C_SlaveTxCpltCallback()
    503                  (++) HAL_I2C_SlaveRxCpltCallback()
    504                  (++) HAL_I2C_ErrorCallback()
    505          
    506          @endverbatim
    507            * @{
    508            */
    509          
    510          /**
    511            * @brief  Transmits in master mode an amount of data in blocking mode.
    512            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    513            *                the configuration information for the specified I2C.
    514            * @param  DevAddress Target device address
    515            * @param  pData Pointer to data buffer
    516            * @param  Size Amount of data to be sent
    517            * @param  Timeout Timeout duration
    518            * @retval HAL status
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    521          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    522            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xF040 0x808B      BNE.W    ??HAL_I2C_Master_Transmit_0
    523            {
    524              /* Wait until BUSY flag is reset */
    525              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   0000001C   0xF242 0x7310      MOVW     R3,#+10000
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_1
    526              {
    527                return HAL_BUSY;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE07F             B.N      ??HAL_I2C_Master_Transmit_2
    528              }
    529          
    530              /* Process Locked */
    531              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   00000034   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_3
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE079             B.N      ??HAL_I2C_Master_Transmit_2
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
    532              
    533              /* Disable Pos */
    534              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6008             STR      R0,[R1, #+0]
    535          
    536              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000052   0x2021             MOVS     R0,#+33
   \   00000054   0xF884 0x0035      STRB     R0,[R4, #+53]
    537              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0xF884 0x0036      STRB     R0,[R4, #+54]
    538              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x63A0             STR      R0,[R4, #+56]
    539          
    540              /* Send Slave Address */
    541              if(I2C_MasterRequestWrite(hi2c, DevAddress, Timeout) != HAL_OK)
   \   00000062   0x4642             MOV      R2,R8
   \   00000064   0x0029             MOVS     R1,R5
   \   00000066   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_4
    542              {
    543                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0x2804             CMP      R0,#+4
   \   00000076   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_5
    544                {
    545                  /* Process Unlocked */
    546                  __HAL_UNLOCK(hi2c);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x0034      STRB     R0,[R4, #+52]
    547                  return HAL_ERROR;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE058             B.N      ??HAL_I2C_Master_Transmit_2
    548                }
    549                else
    550                {
    551                  /* Process Unlocked */
    552                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0034      STRB     R0,[R4, #+52]
    553                  return HAL_TIMEOUT;
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0xE053             B.N      ??HAL_I2C_Master_Transmit_2
    554                }
    555              }
    556          
    557              /* Clear ADDR flag */
    558              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6940             LDR      R0,[R0, #+20]
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6980             LDR      R0,[R0, #+24]
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x9800             LDR      R0,[SP, #+0]
    559          
    560              while(Size > 0)
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   0000009A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000009C   0x2F00             CMP      R7,#+0
   \   0000009E   0xD024             BEQ.N    ??HAL_I2C_Master_Transmit_7
    561              {
    562                /* Wait until TXE flag is set */
    563                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_8
    564                {
    565                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000AC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000AE   0x2804             CMP      R0,#+4
   \   000000B0   0xD107             BNE.N    ??HAL_I2C_Master_Transmit_9
    566                  {
    567                    /* Generate Stop */
    568                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    569                    return HAL_ERROR;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE038             B.N      ??HAL_I2C_Master_Transmit_2
    570                  }
    571                  else
    572                  {
    573                    return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE036             B.N      ??HAL_I2C_Master_Transmit_2
    574                  }
    575                }
    576          
    577                /* Write data to DR */
    578                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000C6   0x7830             LDRB     R0,[R6, #+0]
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6108             STR      R0,[R1, #+16]
   \   000000CC   0x1C76             ADDS     R6,R6,#+1
    579                Size--;
   \   000000CE   0x1E7F             SUBS     R7,R7,#+1
    580          
    581                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6940             LDR      R0,[R0, #+20]
   \   000000D4   0x0740             LSLS     R0,R0,#+29
   \   000000D6   0xD5E0             BPL.N    ??HAL_I2C_Master_Transmit_6
   \   000000D8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000DA   0x2F00             CMP      R7,#+0
   \   000000DC   0xD0DD             BEQ.N    ??HAL_I2C_Master_Transmit_6
    582                {
    583                  /* Write data to DR */
    584                  hi2c->Instance->DR = (*pData++);
   \   000000DE   0x7830             LDRB     R0,[R6, #+0]
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x6108             STR      R0,[R1, #+16]
   \   000000E4   0x1C76             ADDS     R6,R6,#+1
    585                  Size--;
   \   000000E6   0x1E7F             SUBS     R7,R7,#+1
   \   000000E8   0xE7D7             B.N      ??HAL_I2C_Master_Transmit_6
    586                }
    587              }
    588          
    589              /* Wait until TXE flag is set */
    590              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   000000EA   0x4641             MOV      R1,R8
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_10
    591              {
    592                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F8   0x2804             CMP      R0,#+4
   \   000000FA   0xD107             BNE.N    ??HAL_I2C_Master_Transmit_11
    593                {
    594                  /* Generate Stop */
    595                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6008             STR      R0,[R1, #+0]
    596                  return HAL_ERROR;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xE013             B.N      ??HAL_I2C_Master_Transmit_2
    597                }
    598                else
    599                {
    600                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \   0000010C   0x2003             MOVS     R0,#+3
   \   0000010E   0xE011             B.N      ??HAL_I2C_Master_Transmit_2
    601                }
    602              }
    603          
    604              /* Generate Stop */
    605              SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000118   0x6821             LDR      R1,[R4, #+0]
   \   0000011A   0x6008             STR      R0,[R1, #+0]
    606          
    607              hi2c->State = HAL_I2C_STATE_READY;
   \   0000011C   0x2020             MOVS     R0,#+32
   \   0000011E   0xF884 0x0035      STRB     R0,[R4, #+53]
    608              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x0036      STRB     R0,[R4, #+54]
    609              
    610              /* Process Unlocked */
    611              __HAL_UNLOCK(hi2c);
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x0034      STRB     R0,[R4, #+52]
    612          
    613              return HAL_OK;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xE000             B.N      ??HAL_I2C_Master_Transmit_2
    614            }
    615            else
    616            {
    617              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   00000132   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   00000134   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    618            }
    619          }
    620          
    621          /**
    622            * @brief  Receives in master mode an amount of data in blocking mode. 
    623            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    624            *                the configuration information for the specified I2C.
    625            * @param  DevAddress Target device address
    626            * @param  pData Pointer to data buffer
    627            * @param  Size Amount of data to be sent
    628            * @param  Timeout Timeout duration
    629            * @retval HAL status
    630            */

   \                                 In section .text, align 2, keep-with-next
    631          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    632          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    633            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xF040 0x811A      BNE.W    ??HAL_I2C_Master_Receive_0
    634            {
    635              /* Wait until BUSY flag is reset */
    636              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   0000001C   0xF242 0x7310      MOVW     R3,#+10000
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_1
    637              {
    638                return HAL_BUSY;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE10E             B.N      ??HAL_I2C_Master_Receive_2
    639              }
    640          
    641              /* Process Locked */
    642              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   00000034   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_I2C_Master_Receive_3
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE108             B.N      ??HAL_I2C_Master_Receive_2
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
    643          
    644              /* Disable Pos */
    645              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6008             STR      R0,[R1, #+0]
    646          
    647              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000052   0x2022             MOVS     R0,#+34
   \   00000054   0xF884 0x0035      STRB     R0,[R4, #+53]
    648              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0xF884 0x0036      STRB     R0,[R4, #+54]
    649              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x63A0             STR      R0,[R4, #+56]
    650          
    651              /* Send Slave Address */
    652              if(I2C_MasterRequestRead(hi2c, DevAddress, Timeout) != HAL_OK)
   \   00000062   0x4642             MOV      R2,R8
   \   00000064   0x0029             MOVS     R1,R5
   \   00000066   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       I2C_MasterRequestRead
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_4
    653              {
    654                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0x2804             CMP      R0,#+4
   \   00000076   0xD104             BNE.N    ??HAL_I2C_Master_Receive_5
    655                {
    656                  /* Process Unlocked */
    657                  __HAL_UNLOCK(hi2c);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x0034      STRB     R0,[R4, #+52]
    658                  return HAL_ERROR;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE0E7             B.N      ??HAL_I2C_Master_Receive_2
    659                }
    660                else
    661                {
    662                  /* Process Unlocked */
    663                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0034      STRB     R0,[R4, #+52]
    664                  return HAL_TIMEOUT;
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0xE0E2             B.N      ??HAL_I2C_Master_Receive_2
    665                }
    666              }
    667          
    668              if(Size == 0)
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD10D             BNE.N    ??HAL_I2C_Master_Receive_6
    669              {
    670                /* Clear ADDR flag */
    671                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6940             LDR      R0,[R0, #+20]
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6980             LDR      R0,[R0, #+24]
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
    672                
    673                /* Generate Stop */
    674                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x6008             STR      R0,[R1, #+0]
   \   000000AC   0xE03A             B.N      ??HAL_I2C_Master_Receive_7
    675              }
    676              else if(Size == 1)
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   000000AE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000B0   0x2F01             CMP      R7,#+1
   \   000000B2   0xD113             BNE.N    ??HAL_I2C_Master_Receive_8
    677              {
    678                /* Disable Acknowledge */
    679                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    680          
    681                /* Clear ADDR flag */
    682                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6980             LDR      R0,[R0, #+24]
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
    683          
    684                /* Generate Stop */
    685                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0xE023             B.N      ??HAL_I2C_Master_Receive_7
    686              }
    687              else if(Size == 2)
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   000000DC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000DE   0x2F02             CMP      R7,#+2
   \   000000E0   0xD113             BNE.N    ??HAL_I2C_Master_Receive_9
    688              {
    689                /* Disable Acknowledge */
    690                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    691          
    692                /* Enable Pos */
    693                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000F6   0x6821             LDR      R1,[R4, #+0]
   \   000000F8   0x6008             STR      R0,[R1, #+0]
    694          
    695                /* Clear ADDR flag */
    696                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6940             LDR      R0,[R0, #+20]
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x6980             LDR      R0,[R0, #+24]
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0xE00C             B.N      ??HAL_I2C_Master_Receive_7
    697              }
    698              else
    699              {
    700                /* Enable Acknowledge */
    701                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6008             STR      R0,[R1, #+0]
    702          
    703                /* Clear ADDR flag */
    704                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x6940             LDR      R0,[R0, #+20]
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6980             LDR      R0,[R0, #+24]
   \   00000120   0x9000             STR      R0,[SP, #+0]
   \   00000122   0x9800             LDR      R0,[SP, #+0]
    705              }
    706          
    707              while(Size > 0)
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   00000124   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000126   0x2F00             CMP      R7,#+0
   \   00000128   0xF000 0x8087      BEQ.W    ??HAL_I2C_Master_Receive_10
    708              {
    709                if(Size <= 3)
   \   0000012C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000012E   0x2F04             CMP      R7,#+4
   \   00000130   0xDA66             BGE.N    ??HAL_I2C_Master_Receive_11
    710                {
    711                  /* One byte */
    712                  if(Size == 1)
   \   00000132   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000134   0x2F01             CMP      R7,#+1
   \   00000136   0xD112             BNE.N    ??HAL_I2C_Master_Receive_12
    713                  {
    714                    /* Wait until RXNE flag is set */
    715                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \   00000138   0x4641             MOV      R1,R8
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD006             BEQ.N    ??HAL_I2C_Master_Receive_13
    716                    {
    717                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   00000144   0x6BA0             LDR      R0,[R4, #+56]
   \   00000146   0x2820             CMP      R0,#+32
   \   00000148   0xD101             BNE.N    ??HAL_I2C_Master_Receive_14
    718                      {
    719                        return HAL_TIMEOUT;
   \   0000014A   0x2003             MOVS     R0,#+3
   \   0000014C   0xE081             B.N      ??HAL_I2C_Master_Receive_2
    720                      }
    721                      else
    722                      {
    723                        return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0xE07F             B.N      ??HAL_I2C_Master_Receive_2
    724                      }
    725                    }
    726          
    727                    /* Read data from DR */
    728                    (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6900             LDR      R0,[R0, #+16]
   \   00000156   0x7030             STRB     R0,[R6, #+0]
   \   00000158   0x1C76             ADDS     R6,R6,#+1
    729                    Size--;
   \   0000015A   0x1E7F             SUBS     R7,R7,#+1
   \   0000015C   0xE7E2             B.N      ??HAL_I2C_Master_Receive_7
    730                  }
    731                  /* Two bytes */
    732                  else if(Size == 2)
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   0000015E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000160   0x2F02             CMP      R7,#+2
   \   00000162   0xD11B             BNE.N    ??HAL_I2C_Master_Receive_15
    733                  {
    734                    /* Wait until BTF flag is set */
    735                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   00000164   0x4643             MOV      R3,R8
   \   00000166   0x2200             MOVS     R2,#+0
   \   00000168   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x10004
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_16
    736                    {
    737                      return HAL_TIMEOUT;
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0xE06B             B.N      ??HAL_I2C_Master_Receive_2
    738                    }
    739          
    740                    /* Generate Stop */
    741                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000182   0x6821             LDR      R1,[R4, #+0]
   \   00000184   0x6008             STR      R0,[R1, #+0]
    742          
    743                    /* Read data from DR */
    744                    (*pData++) = hi2c->Instance->DR;
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x6900             LDR      R0,[R0, #+16]
   \   0000018A   0x7030             STRB     R0,[R6, #+0]
   \   0000018C   0x1C76             ADDS     R6,R6,#+1
    745                    Size--;
   \   0000018E   0x1E7F             SUBS     R7,R7,#+1
    746          
    747                    /* Read data from DR */
    748                    (*pData++) = hi2c->Instance->DR;
   \   00000190   0x6820             LDR      R0,[R4, #+0]
   \   00000192   0x6900             LDR      R0,[R0, #+16]
   \   00000194   0x7030             STRB     R0,[R6, #+0]
   \   00000196   0x1C76             ADDS     R6,R6,#+1
    749                    Size--;
   \   00000198   0x1E7F             SUBS     R7,R7,#+1
   \   0000019A   0xE7C3             B.N      ??HAL_I2C_Master_Receive_7
    750                  }
    751                  /* 3 Last bytes */
    752                  else
    753                  {
    754                    /* Wait until BTF flag is set */
    755                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   0000019C   0x4643             MOV      R3,R8
   \   0000019E   0x2200             MOVS     R2,#+0
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x10004
   \   000001A4   0x0020             MOVS     R0,R4
   \   000001A6   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_17
    756                    {
    757                      return HAL_TIMEOUT;
   \   000001AE   0x2003             MOVS     R0,#+3
   \   000001B0   0xE04F             B.N      ??HAL_I2C_Master_Receive_2
    758                    }
    759          
    760                    /* Disable Acknowledge */
    761                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6800             LDR      R0,[R0, #+0]
   \   000001B6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000001BA   0x6821             LDR      R1,[R4, #+0]
   \   000001BC   0x6008             STR      R0,[R1, #+0]
    762          
    763                    /* Read data from DR */
    764                    (*pData++) = hi2c->Instance->DR;
   \   000001BE   0x6820             LDR      R0,[R4, #+0]
   \   000001C0   0x6900             LDR      R0,[R0, #+16]
   \   000001C2   0x7030             STRB     R0,[R6, #+0]
   \   000001C4   0x1C76             ADDS     R6,R6,#+1
    765                    Size--;
   \   000001C6   0x1E7F             SUBS     R7,R7,#+1
    766          
    767                    /* Wait until BTF flag is set */
    768                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   000001C8   0x4643             MOV      R3,R8
   \   000001CA   0x2200             MOVS     R2,#+0
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x10004
   \   000001D0   0x0020             MOVS     R0,R4
   \   000001D2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_18
    769                    {
    770                      return HAL_TIMEOUT;
   \   000001DA   0x2003             MOVS     R0,#+3
   \   000001DC   0xE039             B.N      ??HAL_I2C_Master_Receive_2
    771                    }
    772          
    773                    /* Generate Stop */
    774                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \   000001DE   0x6820             LDR      R0,[R4, #+0]
   \   000001E0   0x6800             LDR      R0,[R0, #+0]
   \   000001E2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001E6   0x6821             LDR      R1,[R4, #+0]
   \   000001E8   0x6008             STR      R0,[R1, #+0]
    775          
    776                    /* Read data from DR */
    777                    (*pData++) = hi2c->Instance->DR;
   \   000001EA   0x6820             LDR      R0,[R4, #+0]
   \   000001EC   0x6900             LDR      R0,[R0, #+16]
   \   000001EE   0x7030             STRB     R0,[R6, #+0]
   \   000001F0   0x1C76             ADDS     R6,R6,#+1
    778                    Size--;
   \   000001F2   0x1E7F             SUBS     R7,R7,#+1
    779          
    780                    /* Read data from DR */
    781                    (*pData++) = hi2c->Instance->DR;
   \   000001F4   0x6820             LDR      R0,[R4, #+0]
   \   000001F6   0x6900             LDR      R0,[R0, #+16]
   \   000001F8   0x7030             STRB     R0,[R6, #+0]
   \   000001FA   0x1C76             ADDS     R6,R6,#+1
    782                    Size--;
   \   000001FC   0x1E7F             SUBS     R7,R7,#+1
   \   000001FE   0xE791             B.N      ??HAL_I2C_Master_Receive_7
    783                  }
    784                }
    785                else
    786                {
    787                  /* Wait until RXNE flag is set */
    788                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   00000200   0x4641             MOV      R1,R8
   \   00000202   0x0020             MOVS     R0,R4
   \   00000204   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD006             BEQ.N    ??HAL_I2C_Master_Receive_19
    789                  {
    790                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   0000020C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000020E   0x2820             CMP      R0,#+32
   \   00000210   0xD101             BNE.N    ??HAL_I2C_Master_Receive_20
    791                    {
    792                      return HAL_TIMEOUT;
   \   00000212   0x2003             MOVS     R0,#+3
   \   00000214   0xE01D             B.N      ??HAL_I2C_Master_Receive_2
    793                    }
    794                    else
    795                    {
    796                      return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_20: (+1)
   \   00000216   0x2001             MOVS     R0,#+1
   \   00000218   0xE01B             B.N      ??HAL_I2C_Master_Receive_2
    797                    }
    798                  }
    799          
    800                  /* Read data from DR */
    801                  (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_19: (+1)
   \   0000021A   0x6820             LDR      R0,[R4, #+0]
   \   0000021C   0x6900             LDR      R0,[R0, #+16]
   \   0000021E   0x7030             STRB     R0,[R6, #+0]
   \   00000220   0x1C76             ADDS     R6,R6,#+1
    802                  Size--;
   \   00000222   0x1E7F             SUBS     R7,R7,#+1
    803          
    804                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   00000224   0x6820             LDR      R0,[R4, #+0]
   \   00000226   0x6940             LDR      R0,[R0, #+20]
   \   00000228   0x0740             LSLS     R0,R0,#+29
   \   0000022A   0xF57F 0xAF7B      BPL.W    ??HAL_I2C_Master_Receive_7
    805                  {
    806                    /* Read data from DR */
    807                    (*pData++) = hi2c->Instance->DR;
   \   0000022E   0x6820             LDR      R0,[R4, #+0]
   \   00000230   0x6900             LDR      R0,[R0, #+16]
   \   00000232   0x7030             STRB     R0,[R6, #+0]
   \   00000234   0x1C76             ADDS     R6,R6,#+1
    808                    Size--;
   \   00000236   0x1E7F             SUBS     R7,R7,#+1
   \   00000238   0xE774             B.N      ??HAL_I2C_Master_Receive_7
    809                  }
    810                }
    811              }
    812          
    813              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   0000023A   0x2020             MOVS     R0,#+32
   \   0000023C   0xF884 0x0035      STRB     R0,[R4, #+53]
    814              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0xF884 0x0036      STRB     R0,[R4, #+54]
    815              
    816              /* Process Unlocked */
    817              __HAL_UNLOCK(hi2c);
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0xF884 0x0034      STRB     R0,[R4, #+52]
    818              
    819              return HAL_OK;
   \   0000024C   0x2000             MOVS     R0,#+0
   \   0000024E   0xE000             B.N      ??HAL_I2C_Master_Receive_2
    820            }
    821            else
    822            {
    823              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   00000250   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   00000252   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    824            }
    825          }
    826          
    827          /**
    828            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    829            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    830            *                the configuration information for the specified I2C.
    831            * @param  pData Pointer to data buffer
    832            * @param  Size Amount of data to be sent
    833            * @param  Timeout Timeout duration
    834            * @retval HAL status
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    837          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    838            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xF040 0x8094      BNE.W    ??HAL_I2C_Slave_Transmit_0
    839            {    
    840              if((pData == NULL) || (Size == 0))
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_I2C_Slave_Transmit_1
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_2
    841              {
    842                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE08D             B.N      ??HAL_I2C_Slave_Transmit_3
    843              }
    844          
    845              /* Process Locked */
    846              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_4
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE087             B.N      ??HAL_I2C_Slave_Transmit_3
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
    847              
    848              /* Disable Pos */
    849              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    850          
    851              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000040   0x2021             MOVS     R0,#+33
   \   00000042   0xF884 0x0035      STRB     R0,[R4, #+53]
    852              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000046   0x2020             MOVS     R0,#+32
   \   00000048   0xF884 0x0036      STRB     R0,[R4, #+54]
    853              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
    854          
    855              /* Enable Address Acknowledge */
    856              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    857          
    858              /* Wait until ADDR flag is set */
    859              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   0000005C   0x003B             MOVS     R3,R7
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_5
    860              {
    861                return HAL_TIMEOUT;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE065             B.N      ??HAL_I2C_Slave_Transmit_3
    862              }
    863              
    864              /* Clear ADDR flag */
    865              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6940             LDR      R0,[R0, #+20]
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6980             LDR      R0,[R0, #+24]
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
    866          
    867              /* If 10bit addressing mode is selected */
    868              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   00000080   0x6920             LDR      R0,[R4, #+16]
   \   00000082   0xF5B0 0x4F40      CMP      R0,#+49152
   \   00000086   0xD111             BNE.N    ??HAL_I2C_Slave_Transmit_6
    869              {
    870                /* Wait until ADDR flag is set */
    871                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   00000088   0x003B             MOVS     R3,R7
   \   0000008A   0x2200             MOVS     R2,#+0
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_7
    872                {
    873                  return HAL_TIMEOUT;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0xE04F             B.N      ??HAL_I2C_Slave_Transmit_3
    874                }
    875          
    876                /* Clear ADDR flag */
    877                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6940             LDR      R0,[R0, #+20]
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6980             LDR      R0,[R0, #+24]
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
    878              }
    879          
    880              while(Size > 0)
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   000000AC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD024             BEQ.N    ??HAL_I2C_Slave_Transmit_8
    881              {
    882                /* Wait until TXE flag is set */
    883                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000B2   0x0039             MOVS     R1,R7
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD00C             BEQ.N    ??HAL_I2C_Slave_Transmit_9
    884                {
    885                  /* Disable Address Acknowledge */
    886                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000C6   0x6821             LDR      R1,[R4, #+0]
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    887                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0x2804             CMP      R0,#+4
   \   000000CE   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_10
    888                  {
    889                    return HAL_ERROR;
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xE034             B.N      ??HAL_I2C_Slave_Transmit_3
    890                  }
    891                  else
    892                  {
    893                    return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0xE032             B.N      ??HAL_I2C_Slave_Transmit_3
    894                  }
    895                }
    896          
    897                /* Write data to DR */
    898                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   000000D8   0x7828             LDRB     R0,[R5, #+0]
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6108             STR      R0,[R1, #+16]
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
    899                Size--;
   \   000000E0   0x1E76             SUBS     R6,R6,#+1
    900          
    901                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6940             LDR      R0,[R0, #+20]
   \   000000E6   0x0740             LSLS     R0,R0,#+29
   \   000000E8   0xD5E0             BPL.N    ??HAL_I2C_Slave_Transmit_6
   \   000000EA   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EC   0x2E00             CMP      R6,#+0
   \   000000EE   0xD0DD             BEQ.N    ??HAL_I2C_Slave_Transmit_6
    902                {
    903                  /* Write data to DR */
    904                  hi2c->Instance->DR = (*pData++);
   \   000000F0   0x7828             LDRB     R0,[R5, #+0]
   \   000000F2   0x6821             LDR      R1,[R4, #+0]
   \   000000F4   0x6108             STR      R0,[R1, #+16]
   \   000000F6   0x1C6D             ADDS     R5,R5,#+1
    905                  Size--;
   \   000000F8   0x1E76             SUBS     R6,R6,#+1
   \   000000FA   0xE7D7             B.N      ??HAL_I2C_Slave_Transmit_6
    906                }
    907              }
    908          
    909              /* Wait until AF flag is set */
    910              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   000000FC   0x003B             MOVS     R3,R7
   \   000000FE   0x2200             MOVS     R2,#+0
   \   00000100   0xF45F 0x3182      MOVS     R1,#+66560
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_11
    911              {
    912                return HAL_TIMEOUT;
   \   0000010E   0x2003             MOVS     R0,#+3
   \   00000110   0xE015             B.N      ??HAL_I2C_Slave_Transmit_3
    913              }
    914          
    915              /* Clear AF flag */
    916              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \   00000112   0xF47F 0x6080      MVNS     R0,#+1024
   \   00000116   0x6821             LDR      R1,[R4, #+0]
   \   00000118   0x6148             STR      R0,[R1, #+20]
    917          
    918              /* Disable Address Acknowledge */
    919              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0x6008             STR      R0,[R1, #+0]
    920          
    921              hi2c->State = HAL_I2C_STATE_READY;
   \   00000126   0x2020             MOVS     R0,#+32
   \   00000128   0xF884 0x0035      STRB     R0,[R4, #+53]
    922              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF884 0x0036      STRB     R0,[R4, #+54]
    923          
    924              /* Process Unlocked */
    925              __HAL_UNLOCK(hi2c);
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xF884 0x0034      STRB     R0,[R4, #+52]
    926              
    927              return HAL_OK;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE000             B.N      ??HAL_I2C_Slave_Transmit_3
    928            }
    929            else
    930            {
    931              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   0000013C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   0000013E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    932            }
    933          }
    934          
    935          /**
    936            * @brief  Receive in slave mode an amount of data in blocking mode 
    937            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    938            *                the configuration information for the specified I2C.
    939            * @param  pData Pointer to data buffer
    940            * @param  Size Amount of data to be sent
    941            * @param  Timeout Timeout duration
    942            * @retval HAL status
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    945          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001D             MOVS     R5,R3
    946            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xF040 0x808C      BNE.W    ??HAL_I2C_Slave_Receive_0
    947            {  
    948              if((pData == NULL) || (Size == 0))
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_I2C_Slave_Receive_1
   \   00000018   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_2
    949              {
    950                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE085             B.N      ??HAL_I2C_Slave_Receive_3
    951              }
    952          
    953              /* Process Locked */
    954              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_4
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE07F             B.N      ??HAL_I2C_Slave_Receive_3
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
    955              
    956              /* Disable Pos */
    957              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    958          
    959              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000040   0x2022             MOVS     R0,#+34
   \   00000042   0xF884 0x0035      STRB     R0,[R4, #+53]
    960              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000046   0x2020             MOVS     R0,#+32
   \   00000048   0xF884 0x0036      STRB     R0,[R4, #+54]
    961              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
    962          
    963              /* Enable Address Acknowledge */
    964              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    965          
    966              /* Wait until ADDR flag is set */
    967              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   0000005C   0x002B             MOVS     R3,R5
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_5
    968              {
    969                return HAL_TIMEOUT;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE05D             B.N      ??HAL_I2C_Slave_Receive_3
    970              }
    971          
    972              /* Clear ADDR flag */
    973              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6940             LDR      R0,[R0, #+20]
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6980             LDR      R0,[R0, #+24]
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
    974          
    975              while(Size > 0)
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   00000080   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xD024             BEQ.N    ??HAL_I2C_Slave_Receive_7
    976              {
    977                /* Wait until RXNE flag is set */
    978                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00C             BEQ.N    ??HAL_I2C_Slave_Receive_8
    979                {
    980                  /* Disable Address Acknowledge */
    981                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    982                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   0000009E   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A0   0x2820             CMP      R0,#+32
   \   000000A2   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_9
    983                  {
    984                    return HAL_TIMEOUT;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0xE042             B.N      ??HAL_I2C_Slave_Receive_3
    985                  }
    986                  else
    987                  {
    988                    return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE040             B.N      ??HAL_I2C_Slave_Receive_3
    989                  }
    990                }
    991          
    992                /* Read data from DR */
    993                (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6900             LDR      R0,[R0, #+16]
   \   000000B0   0x7030             STRB     R0,[R6, #+0]
   \   000000B2   0x1C76             ADDS     R6,R6,#+1
    994                Size--;
   \   000000B4   0x1E7F             SUBS     R7,R7,#+1
    995          
    996                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6940             LDR      R0,[R0, #+20]
   \   000000BA   0x0740             LSLS     R0,R0,#+29
   \   000000BC   0xD5E0             BPL.N    ??HAL_I2C_Slave_Receive_6
   \   000000BE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C0   0x2F00             CMP      R7,#+0
   \   000000C2   0xD0DD             BEQ.N    ??HAL_I2C_Slave_Receive_6
    997                {
    998                  /* Read data from DR */
    999                  (*pData++) = hi2c->Instance->DR;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6900             LDR      R0,[R0, #+16]
   \   000000C8   0x7030             STRB     R0,[R6, #+0]
   \   000000CA   0x1C76             ADDS     R6,R6,#+1
   1000                  Size--;
   \   000000CC   0x1E7F             SUBS     R7,R7,#+1
   \   000000CE   0xE7D7             B.N      ??HAL_I2C_Slave_Receive_6
   1001                }
   1002              }
   1003          
   1004              /* Wait until STOP flag is set */
   1005              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   000000D0   0x2123             MOVS     R1,#+35
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD00C             BEQ.N    ??HAL_I2C_Slave_Receive_10
   1006              {
   1007                /* Disable Address Acknowledge */
   1008                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000E4   0x6821             LDR      R1,[R4, #+0]
   \   000000E6   0x6008             STR      R0,[R1, #+0]
   1009          
   1010                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000E8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EA   0x2804             CMP      R0,#+4
   \   000000EC   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_11
   1011                {
   1012                  return HAL_ERROR;
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0xE01D             B.N      ??HAL_I2C_Slave_Receive_3
   1013                }
   1014                else
   1015                {
   1016                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Receive_11: (+1)
   \   000000F2   0x2003             MOVS     R0,#+3
   \   000000F4   0xE01B             B.N      ??HAL_I2C_Slave_Receive_3
   1017                }
   1018              }
   1019          
   1020              /* Clear STOP flag */
   1021              __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6940             LDR      R0,[R0, #+20]
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6008             STR      R0,[R1, #+0]
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   1022          
   1023              /* Disable Address Acknowledge */
   1024              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6008             STR      R0,[R1, #+0]
   1025          
   1026              hi2c->State = HAL_I2C_STATE_READY;
   \   00000116   0x2020             MOVS     R0,#+32
   \   00000118   0xF884 0x0035      STRB     R0,[R4, #+53]
   1027              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF884 0x0036      STRB     R0,[R4, #+54]
   1028          
   1029              /* Process Unlocked */
   1030              __HAL_UNLOCK(hi2c);
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x0034      STRB     R0,[R4, #+52]
   1031              
   1032              return HAL_OK;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xE000             B.N      ??HAL_I2C_Slave_Receive_3
   1033            }
   1034            else
   1035            {
   1036              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   0000012C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   0000012E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1037            } 
   1038          }
   1039          
   1040          /**
   1041            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1042            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1043            *                the configuration information for the specified I2C.
   1044            * @param  DevAddress Target device address
   1045            * @param  pData Pointer to data buffer
   1046            * @param  Size Amount of data to be sent
   1047            * @retval HAL status
   1048            */

   \                                 In section .text, align 2, keep-with-next
   1049          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1050          {   
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1051            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD167             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1052            {
   1053              /* Wait until BUSY flag is reset */
   1054              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   00000012   0xF242 0x7310      MOVW     R3,#+10000
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_IT_1
   1055              {
   1056                return HAL_BUSY;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE05C             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1057              }
   1058          
   1059              /* Process Locked */
   1060              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   0000002A   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_IT_3
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE056             B.N      ??HAL_I2C_Master_Transmit_IT_2
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   1061              
   1062              /* Disable Pos */
   1063              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
   1064          
   1065              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000048   0x2021             MOVS     R0,#+33
   \   0000004A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1066              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0xF884 0x0036      STRB     R0,[R4, #+54]
   1067              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   1068          
   1069              hi2c->pBuffPtr = pData;
   \   00000058   0x6266             STR      R6,[R4, #+36]
   1070              hi2c->XferSize = Size;
   \   0000005A   0x8527             STRH     R7,[R4, #+40]
   1071              hi2c->XferCount = Size;
   \   0000005C   0x8567             STRH     R7,[R4, #+42]
   1072          
   1073              /* Send Slave Address */
   1074              if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000005E   0x2223             MOVS     R2,#+35
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_IT_4
   1075              {
   1076                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_IT_5
   1077                {
   1078                  /* Process Unlocked */
   1079                  __HAL_UNLOCK(hi2c);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF884 0x0034      STRB     R0,[R4, #+52]
   1080                  return HAL_ERROR;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xE032             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1081                }
   1082                else
   1083                {
   1084                  /* Process Unlocked */
   1085                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_IT_5: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF884 0x0034      STRB     R0,[R4, #+52]
   1086                  return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE02D             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1087                }
   1088              }
   1089          
   1090              /* Clear ADDR flag */
   1091              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_IT_4: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6940             LDR      R0,[R0, #+20]
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6980             LDR      R0,[R0, #+24]
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   1092          
   1093              if(hi2c->XferSize > 0)
   \   00000096   0x8D20             LDRH     R0,[R4, #+40]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD009             BEQ.N    ??HAL_I2C_Master_Transmit_IT_6
   1094              {
   1095                /* Process Unlocked */
   1096                __HAL_UNLOCK(hi2c);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1097          
   1098                /* Note : The I2C interrupts must be enabled after unlocking current process 
   1099                          to avoid the risk of I2C interrupt handle execution before current
   1100                          process unlock */
   1101          
   1102                /* Enable EVT, BUF and ERR interrupt */
   1103                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6840             LDR      R0,[R0, #+4]
   \   000000A6   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6048             STR      R0,[R1, #+4]
   \   000000AE   0xE016             B.N      ??HAL_I2C_Master_Transmit_IT_7
   1104              }
   1105              else
   1106              {
   1107                /* Wait until TXE flag is set */
   1108                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_IT_6: (+1)
   \   000000B0   0x2323             MOVS     R3,#+35
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x10080
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_IT_8
   1109                {
   1110                  return HAL_TIMEOUT;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE00E             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1111                }
   1112          
   1113                /* Generate Stop */
   1114                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Master_Transmit_IT_8: (+1)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   1115          
   1116                hi2c->State = HAL_I2C_STATE_READY;
   \   000000D2   0x2020             MOVS     R0,#+32
   \   000000D4   0xF884 0x0035      STRB     R0,[R4, #+53]
   1117                
   1118                /* Process Unlocked */
   1119                __HAL_UNLOCK(hi2c);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1120              }
   1121          
   1122              return HAL_OK;
   \                     ??HAL_I2C_Master_Transmit_IT_7: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE000             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1123            }
   1124            else
   1125            {
   1126              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   000000E4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1127            } 
   1128          }
   1129          
   1130          /**
   1131            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1132            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1133            *                the configuration information for the specified I2C.
   1134            * @param  DevAddress Target device address
   1135            * @param  pData Pointer to data buffer
   1136            * @param  Size Amount of data to be received
   1137            * @retval HAL status
   1138            */

   \                                 In section .text, align 2, keep-with-next
   1139          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1140          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1141            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xF040 0x809B      BNE.W    ??HAL_I2C_Master_Receive_IT_0
   1142            {
   1143              /* Wait until BUSY flag is reset */
   1144              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   00000014   0xF242 0x7310      MOVW     R3,#+10000
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_IT_1
   1145              {
   1146                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE08F             B.N      ??HAL_I2C_Master_Receive_IT_2
   1147              }
   1148          
   1149              /* Process Locked */
   1150              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   0000002C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE.N    ??HAL_I2C_Master_Receive_IT_3
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE089             B.N      ??HAL_I2C_Master_Receive_IT_2
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1151              
   1152              /* Disable Pos */
   1153              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   1154          
   1155              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   0000004A   0x2022             MOVS     R0,#+34
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1156              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1157              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1158          
   1159              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1160              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1161              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1162          
   1163              /* Send Slave Address */
   1164              if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000060   0x2223             MOVS     R2,#+35
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       I2C_MasterRequestRead
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_IT_4
   1165              {
   1166                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000070   0x6BA0             LDR      R0,[R4, #+56]
   \   00000072   0x2804             CMP      R0,#+4
   \   00000074   0xD104             BNE.N    ??HAL_I2C_Master_Receive_IT_5
   1167                {
   1168                  /* Process Unlocked */
   1169                  __HAL_UNLOCK(hi2c);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x0034      STRB     R0,[R4, #+52]
   1170                  return HAL_ERROR;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE065             B.N      ??HAL_I2C_Master_Receive_IT_2
   1171                }
   1172                else
   1173                {
   1174                  /* Process Unlocked */
   1175                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_IT_5: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   1176                  return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE060             B.N      ??HAL_I2C_Master_Receive_IT_2
   1177                }
   1178              }
   1179          
   1180              if(hi2c->XferCount == 0)
   \                     ??HAL_I2C_Master_Receive_IT_4: (+1)
   \   0000008A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD10D             BNE.N    ??HAL_I2C_Master_Receive_IT_6
   1181              {
   1182                /* Clear ADDR flag */
   1183                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   1184                
   1185                /* Generate Stop */
   1186                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE03A             B.N      ??HAL_I2C_Master_Receive_IT_7
   1187              }
   1188              else if(hi2c->XferCount == 1)
   \                     ??HAL_I2C_Master_Receive_IT_6: (+1)
   \   000000AC   0x8D60             LDRH     R0,[R4, #+42]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD113             BNE.N    ??HAL_I2C_Master_Receive_IT_8
   1189              {
   1190                /* Disable Acknowledge */
   1191                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6008             STR      R0,[R1, #+0]
   1192          
   1193                /* Clear ADDR flag */
   1194                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   1195          
   1196                /* Generate Stop */
   1197                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x6008             STR      R0,[R1, #+0]
   \   000000D8   0xE023             B.N      ??HAL_I2C_Master_Receive_IT_7
   1198              }
   1199              else if(hi2c->XferCount == 2)
   \                     ??HAL_I2C_Master_Receive_IT_8: (+1)
   \   000000DA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000DC   0x2802             CMP      R0,#+2
   \   000000DE   0xD113             BNE.N    ??HAL_I2C_Master_Receive_IT_9
   1200              {
   1201                /* Disable Acknowledge */
   1202                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000E8   0x6821             LDR      R1,[R4, #+0]
   \   000000EA   0x6008             STR      R0,[R1, #+0]
   1203          
   1204                /* Enable Pos */
   1205                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   1206          
   1207                /* Clear ADDR flag */
   1208                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6940             LDR      R0,[R0, #+20]
   \   000000FC   0x9000             STR      R0,[SP, #+0]
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6980             LDR      R0,[R0, #+24]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0xE00C             B.N      ??HAL_I2C_Master_Receive_IT_7
   1209              }
   1210              else
   1211              {
   1212                /* Enable Acknowledge */
   1213                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_IT_9: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6008             STR      R0,[R1, #+0]
   1214          
   1215                /* Clear ADDR flag */
   1216                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6940             LDR      R0,[R0, #+20]
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6980             LDR      R0,[R0, #+24]
   \   0000011E   0x9000             STR      R0,[SP, #+0]
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   1217              }
   1218          
   1219              if(hi2c->XferCount == 0)
   \                     ??HAL_I2C_Master_Receive_IT_7: (+1)
   \   00000122   0x8D60             LDRH     R0,[R4, #+42]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD102             BNE.N    ??HAL_I2C_Master_Receive_IT_10
   1220              {
   1221                hi2c->State = HAL_I2C_STATE_READY;
   \   00000128   0x2020             MOVS     R0,#+32
   \   0000012A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1222              }
   1223          
   1224              /* Process Unlocked */
   1225              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_IT_10: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x0034      STRB     R0,[R4, #+52]
   1226          
   1227              if(hi2c->XferCount > 0)
   \   00000134   0x8D60             LDRH     R0,[R4, #+42]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD005             BEQ.N    ??HAL_I2C_Master_Receive_IT_11
   1228              {
   1229                /* Note : The I2C interrupts must be enabled after unlocking current process
   1230                          to avoid the risk of I2C interrupt handle execution before current
   1231                          process unlock */
   1232          
   1233                /* Enable EVT, BUF and ERR interrupt */
   1234                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000013A   0x6820             LDR      R0,[R4, #+0]
   \   0000013C   0x6840             LDR      R0,[R0, #+4]
   \   0000013E   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   00000142   0x6821             LDR      R1,[R4, #+0]
   \   00000144   0x6048             STR      R0,[R1, #+4]
   1235              }
   1236              return HAL_OK;
   \                     ??HAL_I2C_Master_Receive_IT_11: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xE000             B.N      ??HAL_I2C_Master_Receive_IT_2
   1237            }
   1238            else
   1239            {
   1240              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   0000014A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   0000014C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1241            }
   1242          }
   1243          
   1244          /**
   1245            * @brief  Transmit in slave mode an amount of data in no-blocking mode with Interrupt
   1246            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
   1247            *         the configuration information for I2C module
   1248            * @param  pData: Pointer to data buffer
   1249            * @param  Size: Amount of data to be sent
   1250            * @retval HAL status
   1251            */

   \                                 In section .text, align 2, keep-with-next
   1252          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1253          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
   1254            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF893 0x0035      LDRB     R0,[R3, #+53]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD131             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1255            {
   1256              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_2
   1257              {
   1258                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE02B             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1259              }
   1260          
   1261              /* Process Locked */
   1262              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_2: (+1)
   \   0000001A   0xF893 0x0034      LDRB     R0,[R3, #+52]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_4
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE025             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   \                     ??HAL_I2C_Slave_Transmit_IT_4: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF883 0x0034      STRB     R0,[R3, #+52]
   1263          
   1264              /* Disable Pos */
   1265              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000002C   0x6818             LDR      R0,[R3, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000034   0x681C             LDR      R4,[R3, #+0]
   \   00000036   0x6020             STR      R0,[R4, #+0]
   1266          
   1267              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000038   0x2021             MOVS     R0,#+33
   \   0000003A   0xF883 0x0035      STRB     R0,[R3, #+53]
   1268              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF883 0x0036      STRB     R0,[R3, #+54]
   1269              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6398             STR      R0,[R3, #+56]
   1270          
   1271              hi2c->pBuffPtr = pData;
   \   00000048   0x6259             STR      R1,[R3, #+36]
   1272              hi2c->XferSize = Size;
   \   0000004A   0x851A             STRH     R2,[R3, #+40]
   1273              hi2c->XferCount = Size;
   \   0000004C   0x855A             STRH     R2,[R3, #+42]
   1274          
   1275              /* Enable Address Acknowledge */
   1276              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000004E   0x6818             LDR      R0,[R3, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000056   0x681C             LDR      R4,[R3, #+0]
   \   00000058   0x6020             STR      R0,[R4, #+0]
   1277          
   1278              /* Process Unlocked */
   1279              __HAL_UNLOCK(hi2c);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF883 0x0034      STRB     R0,[R3, #+52]
   1280          
   1281              /* Note : The I2C interrupts must be enabled after unlocking current process
   1282                        to avoid the risk of I2C interrupt handle execution before current
   1283                        process unlock */
   1284          
   1285              /* Enable EVT, BUF and ERR interrupt */
   1286              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000060   0x6818             LDR      R0,[R3, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   00000068   0x681C             LDR      R4,[R3, #+0]
   \   0000006A   0x6060             STR      R0,[R4, #+4]
   1287              
   1288              return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE000             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1289            }
   1290            else
   1291            {
   1292              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   00000070   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_IT_3: (+1)
   \   00000072   0xBC10             POP      {R4}
   \   00000074   0x4770             BX       LR               ;; return
   1293            } 
   1294          }
   1295          
   1296          /**
   1297            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt 
   1298            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1299            *                the configuration information for the specified I2C.
   1300            * @param  pData Pointer to data buffer
   1301            * @param  Size Amount of data to be sent
   1302            * @retval HAL status
   1303            */

   \                                 In section .text, align 2, keep-with-next
   1304          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1305          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
   1306            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF893 0x0035      LDRB     R0,[R3, #+53]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD131             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1307            {
   1308              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_I2C_Slave_Receive_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_2
   1309              {
   1310                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE02B             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1311              }
   1312          
   1313              /* Process Locked */
   1314              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_2: (+1)
   \   0000001A   0xF893 0x0034      LDRB     R0,[R3, #+52]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_4
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE025             B.N      ??HAL_I2C_Slave_Receive_IT_3
   \                     ??HAL_I2C_Slave_Receive_IT_4: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF883 0x0034      STRB     R0,[R3, #+52]
   1315          
   1316              /* Disable Pos */
   1317              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000002C   0x6818             LDR      R0,[R3, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000034   0x681C             LDR      R4,[R3, #+0]
   \   00000036   0x6020             STR      R0,[R4, #+0]
   1318          
   1319              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000038   0x2022             MOVS     R0,#+34
   \   0000003A   0xF883 0x0035      STRB     R0,[R3, #+53]
   1320              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF883 0x0036      STRB     R0,[R3, #+54]
   1321              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6398             STR      R0,[R3, #+56]
   1322          
   1323              hi2c->pBuffPtr = pData;
   \   00000048   0x6259             STR      R1,[R3, #+36]
   1324              hi2c->XferSize = Size;
   \   0000004A   0x851A             STRH     R2,[R3, #+40]
   1325              hi2c->XferCount = Size;
   \   0000004C   0x855A             STRH     R2,[R3, #+42]
   1326          
   1327              /* Enable Address Acknowledge */
   1328              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000004E   0x6818             LDR      R0,[R3, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000056   0x681C             LDR      R4,[R3, #+0]
   \   00000058   0x6020             STR      R0,[R4, #+0]
   1329          
   1330              /* Process Unlocked */
   1331              __HAL_UNLOCK(hi2c);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF883 0x0034      STRB     R0,[R3, #+52]
   1332          
   1333              /* Note : The I2C interrupts must be enabled after unlocking current process
   1334                        to avoid the risk of I2C interrupt handle execution before current
   1335                        process unlock */
   1336          
   1337              /* Enable EVT, BUF and ERR interrupt */
   1338              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000060   0x6818             LDR      R0,[R3, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   00000068   0x681C             LDR      R4,[R3, #+0]
   \   0000006A   0x6060             STR      R0,[R4, #+4]
   1339          
   1340              return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE000             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1341            }
   1342            else
   1343            {
   1344              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   00000070   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_IT_3: (+1)
   \   00000072   0xBC10             POP      {R4}
   \   00000074   0x4770             BX       LR               ;; return
   1345            }
   1346          }
   1347          
   1348          /**
   1349            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1350            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1351            *                the configuration information for the specified I2C.
   1352            * @param  DevAddress Target device address
   1353            * @param  pData Pointer to data buffer
   1354            * @param  Size Amount of data to be sent
   1355            * @retval HAL status
   1356            */

   \                                 In section .text, align 2, keep-with-next
   1357          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1358          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1359            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xF040 0x8092      BNE.W    ??HAL_I2C_Master_Transmit_DMA_0
   1360            {
   1361              /* Wait until BUSY flag is reset */
   1362              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   00000014   0xF242 0x7310      MOVW     R3,#+10000
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   1363              {
   1364                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE086             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1365              }
   1366          
   1367              /* Process Locked */
   1368              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   0000002C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_DMA_3
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE080             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1369          
   1370              /* Disable Pos */
   1371              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   1372          
   1373              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   0000004A   0x2021             MOVS     R0,#+33
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1374              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1375              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1376          
   1377              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1378              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1379              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1380          
   1381              if(hi2c->XferSize > 0)
   \   00000060   0x8D20             LDRH     R0,[R4, #+40]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD033             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_4
   1382              {
   1383                /* Set the I2C DMA transfer complete callback */
   1384                hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000006A   0x6AE1             LDR      R1,[R4, #+44]
   \   0000006C   0x6288             STR      R0,[R1, #+40]
   1385          
   1386                /* Set the DMA error callback */
   1387                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000072   0x6AE1             LDR      R1,[R4, #+44]
   \   00000074   0x6308             STR      R0,[R1, #+48]
   1388          
   1389                /* Enable the DMA Channel */
   1390                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   00000076   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000078   0x003B             MOVS     R3,R7
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0xF110 0x0210      ADDS     R2,R0,#+16
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0x6AE0             LDR      R0,[R4, #+44]
   \   00000084   0x.... 0x....      BL       HAL_DMA_Start_IT
   1391          
   1392                /* Send Slave Address */
   1393                if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000088   0x2223             MOVS     R2,#+35
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_5
   1394                {
   1395                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000098   0x6BA0             LDR      R0,[R4, #+56]
   \   0000009A   0x2804             CMP      R0,#+4
   \   0000009C   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_DMA_6
   1396                  {
   1397                    /* Process Unlocked */
   1398                    __HAL_UNLOCK(hi2c);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1399                    return HAL_ERROR;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE048             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1400                  }
   1401                  else
   1402                  {
   1403                    /* Process Unlocked */
   1404                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1405                    return HAL_TIMEOUT;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE043             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1406                  }
   1407                }
   1408          
   1409                /* Enable DMA Request */
   1410                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   1411          
   1412              /* Clear ADDR flag */
   1413              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0xE02F             B.N      ??HAL_I2C_Master_Transmit_DMA_7
   1414              }
   1415              else
   1416              {
   1417                /* Send Slave Address */
   1418                if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   000000CE   0x2223             MOVS     R2,#+35
   \   000000D0   0x0029             MOVS     R1,R5
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_8
   1419                {
   1420                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000DE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_DMA_9
   1421                  {
   1422                    /* Process Unlocked */
   1423                    __HAL_UNLOCK(hi2c);
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1424                    return HAL_ERROR;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE025             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1425                  }
   1426                  else
   1427                  {
   1428                    /* Process Unlocked */
   1429                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_9: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1430                    return HAL_TIMEOUT;
   \   000000F4   0x2003             MOVS     R0,#+3
   \   000000F6   0xE020             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1431                  }
   1432                }
   1433          
   1434                /* Clear ADDR flag */
   1435                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_8: (+1)
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6940             LDR      R0,[R0, #+20]
   \   000000FC   0x9000             STR      R0,[SP, #+0]
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6980             LDR      R0,[R0, #+24]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   1436          
   1437                /* Wait until TXE flag is set */
   1438                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000106   0x2323             MOVS     R3,#+35
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x10080
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_10
   1439                {
   1440                  return HAL_TIMEOUT;
   \   00000118   0x2003             MOVS     R0,#+3
   \   0000011A   0xE00E             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1441                }
   1442          
   1443                /* Generate Stop */
   1444                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Transmit_DMA_10: (+1)
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x6008             STR      R0,[R1, #+0]
   1445          
   1446                hi2c->State = HAL_I2C_STATE_READY;
   \   00000128   0x2020             MOVS     R0,#+32
   \   0000012A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1447              }
   1448          
   1449              /* Process Unlocked */
   1450              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_7: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x0034      STRB     R0,[R4, #+52]
   1451              
   1452              return HAL_OK;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0xE000             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1453            }
   1454            else
   1455            {
   1456              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   00000138   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000013A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1457            }
   1458          }
   1459          
   1460          /**
   1461            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA 
   1462            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1463            *                the configuration information for the specified I2C.
   1464            * @param  DevAddress Target device address
   1465            * @param  pData Pointer to data buffer
   1466            * @param  Size Amount of data to be sent
   1467            * @retval HAL status
   1468            */

   \                                 In section .text, align 2, keep-with-next
   1469          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1470          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1471            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xF040 0x8097      BNE.W    ??HAL_I2C_Master_Receive_DMA_0
   1472            {
   1473              /* Wait until BUSY flag is reset */
   1474              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   00000014   0xF242 0x7310      MOVW     R3,#+10000
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_DMA_1
   1475              {
   1476                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE08B             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1477              }
   1478          
   1479              /* Process Locked */
   1480              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   0000002C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE.N    ??HAL_I2C_Master_Receive_DMA_3
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE085             B.N      ??HAL_I2C_Master_Receive_DMA_2
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1481          
   1482              /* Disable Pos */
   1483              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   1484          
   1485              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   0000004A   0x2022             MOVS     R0,#+34
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1486              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1487              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1488          
   1489              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1490              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1491              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1492          
   1493              if(hi2c->XferSize > 0)
   \   00000060   0x8D20             LDRH     R0,[R4, #+40]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD043             BEQ.N    ??HAL_I2C_Master_Receive_DMA_4
   1494              {
   1495                /* Set the I2C DMA transfer complete callback */
   1496                hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000006A   0x6B21             LDR      R1,[R4, #+48]
   \   0000006C   0x6288             STR      R0,[R1, #+40]
   1497          
   1498                /* Set the DMA error callback */
   1499                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000072   0x6B21             LDR      R1,[R4, #+48]
   \   00000074   0x6308             STR      R0,[R1, #+48]
   1500          
   1501                /* Enable the DMA Channel */
   1502                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   00000076   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000078   0x003B             MOVS     R3,R7
   \   0000007A   0x0032             MOVS     R2,R6
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0xF110 0x0110      ADDS     R1,R0,#+16
   \   00000082   0x6B20             LDR      R0,[R4, #+48]
   \   00000084   0x.... 0x....      BL       HAL_DMA_Start_IT
   1503          
   1504                /* Send Slave Address */
   1505                if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000088   0x2223             MOVS     R2,#+35
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       I2C_MasterRequestRead
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_DMA_5
   1506                {
   1507                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000098   0x6BA0             LDR      R0,[R4, #+56]
   \   0000009A   0x2804             CMP      R0,#+4
   \   0000009C   0xD104             BNE.N    ??HAL_I2C_Master_Receive_DMA_6
   1508                  {
   1509                    /* Process Unlocked */
   1510                    __HAL_UNLOCK(hi2c);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1511                    return HAL_ERROR;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE04D             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1512                  }
   1513                  else
   1514                  {
   1515                    /* Process Unlocked */
   1516                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1517                    return HAL_TIMEOUT;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE048             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1518                  }
   1519                }
   1520          
   1521                if(Size == 1)
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \   000000B2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000B4   0x2F01             CMP      R7,#+1
   \   000000B6   0xD106             BNE.N    ??HAL_I2C_Master_Receive_DMA_7
   1522                {
   1523                  /* Disable Acknowledge */
   1524                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE005             B.N      ??HAL_I2C_Master_Receive_DMA_8
   1525                }
   1526                else
   1527                {
   1528                  /* Enable Last DMA bit */
   1529                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Master_Receive_DMA_7: (+1)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6840             LDR      R0,[R0, #+4]
   \   000000CA   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6048             STR      R0,[R1, #+4]
   1530                }
   1531          
   1532                /* Enable DMA Request */
   1533                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Receive_DMA_8: (+1)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6840             LDR      R0,[R0, #+4]
   \   000000D6   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6048             STR      R0,[R1, #+4]
   1534          
   1535                /* Clear ADDR flag */
   1536                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6940             LDR      R0,[R0, #+20]
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6980             LDR      R0,[R0, #+24]
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0xE024             B.N      ??HAL_I2C_Master_Receive_DMA_9
   1537              }
   1538              else
   1539              {
   1540                /* Send Slave Address */
   1541                if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   000000EE   0x2223             MOVS     R2,#+35
   \   000000F0   0x0029             MOVS     R1,R5
   \   000000F2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       I2C_MasterRequestRead
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_DMA_10
   1542                {
   1543                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000100   0x2804             CMP      R0,#+4
   \   00000102   0xD104             BNE.N    ??HAL_I2C_Master_Receive_DMA_11
   1544                  {
   1545                    /* Process Unlocked */
   1546                    __HAL_UNLOCK(hi2c);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0034      STRB     R0,[R4, #+52]
   1547                    return HAL_ERROR;
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE01A             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1548                  }
   1549                  else
   1550                  {
   1551                    /* Process Unlocked */
   1552                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_11: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF884 0x0034      STRB     R0,[R4, #+52]
   1553                    return HAL_TIMEOUT;
   \   00000114   0x2003             MOVS     R0,#+3
   \   00000116   0xE015             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1554                  }
   1555                }
   1556          
   1557                /* Clear ADDR flag */
   1558                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_10: (+1)
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x6940             LDR      R0,[R0, #+20]
   \   0000011C   0x9000             STR      R0,[SP, #+0]
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6980             LDR      R0,[R0, #+24]
   \   00000122   0x9000             STR      R0,[SP, #+0]
   \   00000124   0x9800             LDR      R0,[SP, #+0]
   1559          
   1560                /* Generate Stop */
   1561                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0x6008             STR      R0,[R1, #+0]
   1562          
   1563                hi2c->State = HAL_I2C_STATE_READY;
   \   00000132   0x2020             MOVS     R0,#+32
   \   00000134   0xF884 0x0035      STRB     R0,[R4, #+53]
   1564              }
   1565          
   1566              /* Process Unlocked */
   1567              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_9: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1568              
   1569              return HAL_OK;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xE000             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1570            }
   1571            else
   1572            {
   1573              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   00000142   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   00000144   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1574            }
   1575          }
   1576          
   1577          /**
   1578            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA 
   1579            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1580            *                the configuration information for the specified I2C.
   1581            * @param  pData Pointer to data buffer
   1582            * @param  Size Amount of data to be sent
   1583            * @retval HAL status
   1584            */

   \                                 In section .text, align 2, keep-with-next
   1585          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1586          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1587            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD174             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1588            {
   1589              if((pData == NULL) || (Size == 0))
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   1590              {
   1591                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE06E             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   1592              }
   1593          
   1594              /* Process Locked */
   1595              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   00000020   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_4
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE068             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1596          
   1597              /* Disable Pos */
   1598              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1599          
   1600              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   0000003E   0x2021             MOVS     R0,#+33
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   1601              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF884 0x0036      STRB     R0,[R4, #+54]
   1602              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x63A0             STR      R0,[R4, #+56]
   1603          
   1604              hi2c->pBuffPtr = pData;
   \   0000004E   0x6265             STR      R5,[R4, #+36]
   1605              hi2c->XferSize = Size;
   \   00000050   0x8526             STRH     R6,[R4, #+40]
   1606              hi2c->XferCount = Size;
   \   00000052   0x8566             STRH     R6,[R4, #+42]
   1607          
   1608              /* Set the I2C DMA transfer complete callback */
   1609              hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000058   0x6AE1             LDR      R1,[R4, #+44]
   \   0000005A   0x6288             STR      R0,[R1, #+40]
   1610          
   1611              /* Set the DMA error callback */
   1612              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000060   0x6AE1             LDR      R1,[R4, #+44]
   \   00000062   0x6308             STR      R0,[R1, #+48]
   1613          
   1614              /* Enable the DMA Channel */
   1615              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   00000064   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   0x0033             MOVS     R3,R6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xF110 0x0210      ADDS     R2,R0,#+16
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x6AE0             LDR      R0,[R4, #+44]
   \   00000072   0x.... 0x....      BL       HAL_DMA_Start_IT
   1616          
   1617              /* Enable DMA Request */
   1618              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6048             STR      R0,[R1, #+4]
   1619          
   1620              /* Enable Address Acknowledge */
   1621              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1622          
   1623              /* Wait until ADDR flag is set */
   1624              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   0000008E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_5
   1625              {
   1626                return HAL_TIMEOUT;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xE02B             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   1627              }
   1628          
   1629              /* If 7bit addressing mode is selected */
   1630              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   000000A6   0x6920             LDR      R0,[R4, #+16]
   \   000000A8   0xF5B0 0x4F80      CMP      R0,#+16384
   \   000000AC   0xD107             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_6
   1631              {
   1632                /* Clear ADDR flag */
   1633                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6940             LDR      R0,[R0, #+20]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6980             LDR      R0,[R0, #+24]
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0xE019             B.N      ??HAL_I2C_Slave_Transmit_DMA_7
   1634              }
   1635              else
   1636              {
   1637                /* Clear ADDR flag */
   1638                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_6: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   1639          
   1640                /* Wait until ADDR flag is set */
   1641                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   000000CC   0xF242 0x7310      MOVW     R3,#+10000
   \   000000D0   0x2200             MOVS     R2,#+0
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_8
   1642                {
   1643                  return HAL_TIMEOUT;
   \   000000E0   0x2003             MOVS     R0,#+3
   \   000000E2   0xE00C             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   1644                }
   1645          
   1646                /* Clear ADDR flag */
   1647                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_8: (+1)
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6940             LDR      R0,[R0, #+20]
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6980             LDR      R0,[R0, #+24]
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0x9800             LDR      R0,[SP, #+0]
   1648              }
   1649          
   1650              /* Process Unlocked */
   1651              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_7: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x0034      STRB     R0,[R4, #+52]
   1652              
   1653              return HAL_OK;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xE000             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   1654            }
   1655            else
   1656            {
   1657              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   000000FE   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1658            }
   1659          }
   1660          
   1661          /**
   1662            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA 
   1663            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1664            *                the configuration information for the specified I2C.
   1665            * @param  pData Pointer to data buffer
   1666            * @param  Size Amount of data to be sent
   1667            * @retval HAL status
   1668            */

   \                                 In section .text, align 2, keep-with-next
   1669          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1670          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1671            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD155             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1672            {
   1673              if((pData == NULL) || (Size == 0))
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   1674              {
   1675                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE04F             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   1676              }
   1677          
   1678              /* Process Locked */
   1679              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   00000020   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_4
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE049             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1680          
   1681              /* Disable Pos */
   1682              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1683          
   1684              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   0000003E   0x2022             MOVS     R0,#+34
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   1685              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF884 0x0036      STRB     R0,[R4, #+54]
   1686              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x63A0             STR      R0,[R4, #+56]
   1687          
   1688              hi2c->pBuffPtr = pData;
   \   0000004E   0x6265             STR      R5,[R4, #+36]
   1689              hi2c->XferSize = Size;
   \   00000050   0x8526             STRH     R6,[R4, #+40]
   1690              hi2c->XferCount = Size;
   \   00000052   0x8566             STRH     R6,[R4, #+42]
   1691              
   1692              /* Set the I2C DMA transfer complete callback */
   1693              hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000058   0x6B21             LDR      R1,[R4, #+48]
   \   0000005A   0x6288             STR      R0,[R1, #+40]
   1694              
   1695              /* Set the DMA error callback */
   1696              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000060   0x6B21             LDR      R1,[R4, #+48]
   \   00000062   0x6308             STR      R0,[R1, #+48]
   1697          
   1698              /* Enable the DMA Channel */
   1699              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   00000064   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   0x0033             MOVS     R3,R6
   \   00000068   0x002A             MOVS     R2,R5
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0xF110 0x0110      ADDS     R1,R0,#+16
   \   00000070   0x6B20             LDR      R0,[R4, #+48]
   \   00000072   0x.... 0x....      BL       HAL_DMA_Start_IT
   1700          
   1701              /* Enable DMA Request */
   1702              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6048             STR      R0,[R1, #+4]
   1703          
   1704              /* Enable Address Acknowledge */
   1705              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1706          
   1707              /* Wait until ADDR flag is set */
   1708              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   0000008E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x10002
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_5
   1709              {
   1710                return HAL_TIMEOUT;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xE00C             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   1711              }
   1712          
   1713              /* Clear ADDR flag */
   1714              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6940             LDR      R0,[R0, #+20]
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6980             LDR      R0,[R0, #+24]
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   1715          
   1716              /* Process Unlocked */
   1717              __HAL_UNLOCK(hi2c);
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1718              
   1719              return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   1720            }
   1721            else
   1722            {
   1723              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   000000C0   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1724            }
   1725          }
   1726          /**
   1727            * @brief  Write an amount of data in blocking mode to a specific memory address
   1728            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1729            *                the configuration information for the specified I2C.
   1730            * @param  DevAddress Target device address
   1731            * @param  MemAddress Internal memory address
   1732            * @param  MemAddSize Size of internal memory address
   1733            * @param  pData Pointer to data buffer
   1734            * @param  Size Amount of data to be sent
   1735            * @param  Timeout Timeout duration
   1736            * @retval HAL status
   1737            */

   \                                 In section .text, align 2, keep-with-next
   1738          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1739          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000012   0x9C0B             LDR      R4,[SP, #+44]
   \   00000014   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   1740            /* Check the parameters */
   1741            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1742          
   1743            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000018   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xF040 0x8095      BNE.W    ??HAL_I2C_Mem_Write_0
   1744            {
   1745              if((pData == NULL) || (Size == 0))
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_1
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD101             BNE.N    ??HAL_I2C_Mem_Write_2
   1746              {
   1747                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE08D             B.N      ??HAL_I2C_Mem_Write_3
   1748              }
   1749          
   1750              /* Wait until BUSY flag is reset */
   1751              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   00000032   0xF242 0x7310      MOVW     R3,#+10000
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD001             BEQ.N    ??HAL_I2C_Mem_Write_4
   1752              {
   1753                return HAL_BUSY;
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE081             B.N      ??HAL_I2C_Mem_Write_3
   1754              }
   1755          
   1756              /* Process Locked */
   1757              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   0000004A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD101             BNE.N    ??HAL_I2C_Mem_Write_5
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xE07B             B.N      ??HAL_I2C_Mem_Write_3
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xF885 0x0034      STRB     R0,[R5, #+52]
   1758          
   1759              /* Disable Pos */
   1760              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1761          
   1762              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000068   0x2021             MOVS     R0,#+33
   \   0000006A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1763              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000006E   0x2040             MOVS     R0,#+64
   \   00000070   0xF885 0x0036      STRB     R0,[R5, #+54]
   1764              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x63A8             STR      R0,[R5, #+56]
   1765          
   1766              /* Send Slave Address and Memory Address */
   1767              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   00000078   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000007C   0x4643             MOV      R3,R8
   \   0000007E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000080   0x003A             MOVS     R2,R7
   \   00000082   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000084   0x0031             MOVS     R1,R6
   \   00000086   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_6
   1768              {
   1769                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000092   0x6BA8             LDR      R0,[R5, #+56]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD104             BNE.N    ??HAL_I2C_Mem_Write_7
   1770                {
   1771                  /* Process Unlocked */
   1772                  __HAL_UNLOCK(hi2c);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF885 0x0034      STRB     R0,[R5, #+52]
   1773                  return HAL_ERROR;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE055             B.N      ??HAL_I2C_Mem_Write_3
   1774                }
   1775                else
   1776                {
   1777                  /* Process Unlocked */
   1778                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF885 0x0034      STRB     R0,[R5, #+52]
   1779                  return HAL_TIMEOUT;
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0xE050             B.N      ??HAL_I2C_Mem_Write_3
   1780                }
   1781              }
   1782          
   1783              while(Size > 0)
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   000000AC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AE   0x2C00             CMP      R4,#+0
   \   000000B0   0xD028             BEQ.N    ??HAL_I2C_Mem_Write_8
   1784              {
   1785                /* Wait until TXE flag is set */
   1786                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000B2   0x4651             MOV      R1,R10
   \   000000B4   0x0028             MOVS     R0,R5
   \   000000B6   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_9
   1787                {
   1788                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000BE   0x6BA8             LDR      R0,[R5, #+56]
   \   000000C0   0x2804             CMP      R0,#+4
   \   000000C2   0xD107             BNE.N    ??HAL_I2C_Mem_Write_10
   1789                  {
   1790                    /* Generate Stop */
   1791                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000C4   0x6828             LDR      R0,[R5, #+0]
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000CC   0x6829             LDR      R1,[R5, #+0]
   \   000000CE   0x6008             STR      R0,[R1, #+0]
   1792                    return HAL_ERROR;
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xE03C             B.N      ??HAL_I2C_Mem_Write_3
   1793                  }
   1794                  else
   1795                  {
   1796                    return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0xE03A             B.N      ??HAL_I2C_Mem_Write_3
   1797                  }
   1798                }
   1799               
   1800                /* Write data to DR */
   1801                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   000000D8   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000DC   0x6829             LDR      R1,[R5, #+0]
   \   000000DE   0x6108             STR      R0,[R1, #+16]
   \   000000E0   0xF119 0x0901      ADDS     R9,R9,#+1
   1802                Size--;
   \   000000E4   0x1E64             SUBS     R4,R4,#+1
   1803          
   1804                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0x6940             LDR      R0,[R0, #+20]
   \   000000EA   0x0740             LSLS     R0,R0,#+29
   \   000000EC   0xD5DE             BPL.N    ??HAL_I2C_Mem_Write_6
   \   000000EE   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000F0   0x2C00             CMP      R4,#+0
   \   000000F2   0xD0DB             BEQ.N    ??HAL_I2C_Mem_Write_6
   1805                {
   1806                  /* Write data to DR */
   1807                  hi2c->Instance->DR = (*pData++);
   \   000000F4   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000F8   0x6829             LDR      R1,[R5, #+0]
   \   000000FA   0x6108             STR      R0,[R1, #+16]
   \   000000FC   0xF119 0x0901      ADDS     R9,R9,#+1
   1808                  Size--;
   \   00000100   0x1E64             SUBS     R4,R4,#+1
   \   00000102   0xE7D3             B.N      ??HAL_I2C_Mem_Write_6
   1809                }
   1810              }
   1811          
   1812              /* Wait until TXE flag is set */
   1813              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   00000104   0x4651             MOV      R1,R10
   \   00000106   0x0028             MOVS     R0,R5
   \   00000108   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_11
   1814              {
   1815                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000110   0x6BA8             LDR      R0,[R5, #+56]
   \   00000112   0x2804             CMP      R0,#+4
   \   00000114   0xD107             BNE.N    ??HAL_I2C_Mem_Write_12
   1816                {
   1817                  /* Generate Stop */
   1818                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000116   0x6828             LDR      R0,[R5, #+0]
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000011E   0x6829             LDR      R1,[R5, #+0]
   \   00000120   0x6008             STR      R0,[R1, #+0]
   1819                  return HAL_ERROR;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE013             B.N      ??HAL_I2C_Mem_Write_3
   1820                }
   1821                else
   1822                {
   1823                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_12: (+1)
   \   00000126   0x2003             MOVS     R0,#+3
   \   00000128   0xE011             B.N      ??HAL_I2C_Mem_Write_3
   1824                }
   1825              }
   1826          
   1827              /* Generate Stop */
   1828              SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Write_11: (+1)
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000132   0x6829             LDR      R1,[R5, #+0]
   \   00000134   0x6008             STR      R0,[R1, #+0]
   1829          
   1830              hi2c->State = HAL_I2C_STATE_READY;
   \   00000136   0x2020             MOVS     R0,#+32
   \   00000138   0xF885 0x0035      STRB     R0,[R5, #+53]
   1831              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0xF885 0x0036      STRB     R0,[R5, #+54]
   1832          
   1833              /* Process Unlocked */
   1834              __HAL_UNLOCK(hi2c);
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF885 0x0034      STRB     R0,[R5, #+52]
   1835              
   1836              return HAL_OK;
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0xE000             B.N      ??HAL_I2C_Mem_Write_3
   1837            }
   1838            else
   1839            {
   1840              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   0000014C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   0000014E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1841            }
   1842          }
   1843          
   1844          /**
   1845            * @brief  Read an amount of data in blocking mode from a specific memory address
   1846            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1847            *                the configuration information for the specified I2C.
   1848            * @param  DevAddress Target device address
   1849            * @param  MemAddress Internal memory address
   1850            * @param  MemAddSize Size of internal memory address
   1851            * @param  pData Pointer to data buffer
   1852            * @param  Size Amount of data to be sent
   1853            * @param  Timeout Timeout duration
   1854            * @retval HAL status
   1855            */

   \                                 In section .text, align 2, keep-with-next
   1856          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1857          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000012   0x9C0B             LDR      R4,[SP, #+44]
   \   00000014   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   1858            /* Check the parameters */
   1859            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1860          
   1861            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000018   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xF040 0x8120      BNE.W    ??HAL_I2C_Mem_Read_0
   1862            {
   1863              if((pData == NULL) || (Size == 0))
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_1
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD101             BNE.N    ??HAL_I2C_Mem_Read_2
   1864              {
   1865                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE118             B.N      ??HAL_I2C_Mem_Read_3
   1866              }
   1867          
   1868              /* Wait until BUSY flag is reset */
   1869              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   00000032   0xF242 0x7310      MOVW     R3,#+10000
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_4
   1870              {
   1871                return HAL_BUSY;
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE10C             B.N      ??HAL_I2C_Mem_Read_3
   1872              }
   1873          
   1874              /* Process Locked */
   1875              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   0000004A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD101             BNE.N    ??HAL_I2C_Mem_Read_5
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xE106             B.N      ??HAL_I2C_Mem_Read_3
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xF885 0x0034      STRB     R0,[R5, #+52]
   1876              
   1877              /* Disable Pos */
   1878              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1879          
   1880              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000068   0x2022             MOVS     R0,#+34
   \   0000006A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1881              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000006E   0x2040             MOVS     R0,#+64
   \   00000070   0xF885 0x0036      STRB     R0,[R5, #+54]
   1882              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x63A8             STR      R0,[R5, #+56]
   1883              
   1884              /* Send Slave Address and Memory Address */
   1885              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   00000078   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000007C   0x4643             MOV      R3,R8
   \   0000007E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000080   0x003A             MOVS     R2,R7
   \   00000082   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000084   0x0031             MOVS     R1,R6
   \   00000086   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_6
   1886              {
   1887                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000092   0x6BA8             LDR      R0,[R5, #+56]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD104             BNE.N    ??HAL_I2C_Mem_Read_7
   1888                {
   1889                  /* Process Unlocked */
   1890                  __HAL_UNLOCK(hi2c);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF885 0x0034      STRB     R0,[R5, #+52]
   1891                  return HAL_ERROR;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE0E0             B.N      ??HAL_I2C_Mem_Read_3
   1892                }
   1893                else
   1894                {
   1895                  /* Process Unlocked */
   1896                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF885 0x0034      STRB     R0,[R5, #+52]
   1897                  return HAL_TIMEOUT;
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0xE0DB             B.N      ??HAL_I2C_Mem_Read_3
   1898                }
   1899              }
   1900          
   1901              if(Size == 1)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   000000AC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AE   0x2C01             CMP      R4,#+1
   \   000000B0   0xD113             BNE.N    ??HAL_I2C_Mem_Read_8
   1902              {
   1903                /* Disable Acknowledge */
   1904                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x6008             STR      R0,[R1, #+0]
   1905          
   1906                /* Clear ADDR flag */
   1907                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x6828             LDR      R0,[R5, #+0]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   1908          
   1909                /* Generate Stop */
   1910                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000D4   0x6829             LDR      R1,[R5, #+0]
   \   000000D6   0x6008             STR      R0,[R1, #+0]
   \   000000D8   0xE01D             B.N      ??HAL_I2C_Mem_Read_9
   1911              }
   1912              else if(Size == 2)
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   000000DA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000DC   0x2C02             CMP      R4,#+2
   \   000000DE   0xD113             BNE.N    ??HAL_I2C_Mem_Read_10
   1913              {
   1914                /* Disable Acknowledge */
   1915                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000E0   0x6828             LDR      R0,[R5, #+0]
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000E8   0x6829             LDR      R1,[R5, #+0]
   \   000000EA   0x6008             STR      R0,[R1, #+0]
   1916          
   1917                /* Enable Pos */
   1918                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   1919          
   1920                /* Clear ADDR flag */
   1921                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000F8   0x6828             LDR      R0,[R5, #+0]
   \   000000FA   0x6940             LDR      R0,[R0, #+20]
   \   000000FC   0x9000             STR      R0,[SP, #+0]
   \   000000FE   0x6828             LDR      R0,[R5, #+0]
   \   00000100   0x6980             LDR      R0,[R0, #+24]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0xE006             B.N      ??HAL_I2C_Mem_Read_9
   1922              }
   1923              else
   1924              {
   1925                /* Clear ADDR flag */
   1926                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   00000108   0x6828             LDR      R0,[R5, #+0]
   \   0000010A   0x6940             LDR      R0,[R0, #+20]
   \   0000010C   0x9000             STR      R0,[SP, #+0]
   \   0000010E   0x6828             LDR      R0,[R5, #+0]
   \   00000110   0x6980             LDR      R0,[R0, #+24]
   \   00000112   0x9000             STR      R0,[SP, #+0]
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   1927              }
   1928          
   1929              while(Size > 0)
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   00000116   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000118   0x2C00             CMP      R4,#+0
   \   0000011A   0xF000 0x8097      BEQ.W    ??HAL_I2C_Mem_Read_11
   1930              {
   1931                if(Size <= 3)
   \   0000011E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000120   0x2C04             CMP      R4,#+4
   \   00000122   0xDA72             BGE.N    ??HAL_I2C_Mem_Read_12
   1932                {
   1933                  /* One byte */
   1934                  if(Size== 1)
   \   00000124   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000126   0x2C01             CMP      R4,#+1
   \   00000128   0xD114             BNE.N    ??HAL_I2C_Mem_Read_13
   1935                  {
   1936                    /* Wait until RXNE flag is set */
   1937                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \   0000012A   0x4651             MOV      R1,R10
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD006             BEQ.N    ??HAL_I2C_Mem_Read_14
   1938                    {
   1939                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   00000136   0x6BA8             LDR      R0,[R5, #+56]
   \   00000138   0x2820             CMP      R0,#+32
   \   0000013A   0xD101             BNE.N    ??HAL_I2C_Mem_Read_15
   1940                      {
   1941                        return HAL_TIMEOUT;
   \   0000013C   0x2003             MOVS     R0,#+3
   \   0000013E   0xE091             B.N      ??HAL_I2C_Mem_Read_3
   1942                      }
   1943                      else
   1944                      {
   1945                        return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0xE08F             B.N      ??HAL_I2C_Mem_Read_3
   1946                      }
   1947                    }
   1948          
   1949                    /* Read data from DR */
   1950                    (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   00000144   0x6828             LDR      R0,[R5, #+0]
   \   00000146   0x6900             LDR      R0,[R0, #+16]
   \   00000148   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000014C   0xF119 0x0901      ADDS     R9,R9,#+1
   1951                    Size--;
   \   00000150   0x1E64             SUBS     R4,R4,#+1
   \   00000152   0xE7E0             B.N      ??HAL_I2C_Mem_Read_9
   1952                  }
   1953                  /* Two bytes */
   1954                  else if(Size == 2)
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   00000154   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000156   0x2C02             CMP      R4,#+2
   \   00000158   0xD11F             BNE.N    ??HAL_I2C_Mem_Read_16
   1955                  {
   1956                    /* Wait until BTF flag is set */
   1957                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   0000015A   0x4653             MOV      R3,R10
   \   0000015C   0x2200             MOVS     R2,#+0
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x10004
   \   00000162   0x0028             MOVS     R0,R5
   \   00000164   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_17
   1958                    {
   1959                      return HAL_TIMEOUT;
   \   0000016C   0x2003             MOVS     R0,#+3
   \   0000016E   0xE079             B.N      ??HAL_I2C_Mem_Read_3
   1960                    }
   1961          
   1962                    /* Generate Stop */
   1963                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   00000170   0x6828             LDR      R0,[R5, #+0]
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000178   0x6829             LDR      R1,[R5, #+0]
   \   0000017A   0x6008             STR      R0,[R1, #+0]
   1964          
   1965                    /* Read data from DR */
   1966                    (*pData++) = hi2c->Instance->DR;
   \   0000017C   0x6828             LDR      R0,[R5, #+0]
   \   0000017E   0x6900             LDR      R0,[R0, #+16]
   \   00000180   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000184   0xF119 0x0901      ADDS     R9,R9,#+1
   1967                    Size--;
   \   00000188   0x1E64             SUBS     R4,R4,#+1
   1968          
   1969                    /* Read data from DR */
   1970                    (*pData++) = hi2c->Instance->DR;
   \   0000018A   0x6828             LDR      R0,[R5, #+0]
   \   0000018C   0x6900             LDR      R0,[R0, #+16]
   \   0000018E   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000192   0xF119 0x0901      ADDS     R9,R9,#+1
   1971                    Size--;
   \   00000196   0x1E64             SUBS     R4,R4,#+1
   \   00000198   0xE7BD             B.N      ??HAL_I2C_Mem_Read_9
   1972                  }
   1973                  /* 3 Last bytes */
   1974                  else
   1975                  {
   1976                    /* Wait until BTF flag is set */
   1977                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   0000019A   0x4653             MOV      R3,R10
   \   0000019C   0x2200             MOVS     R2,#+0
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x10004
   \   000001A2   0x0028             MOVS     R0,R5
   \   000001A4   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_18
   1978                    {
   1979                      return HAL_TIMEOUT;
   \   000001AC   0x2003             MOVS     R0,#+3
   \   000001AE   0xE059             B.N      ??HAL_I2C_Mem_Read_3
   1980                    }
   1981          
   1982                    /* Disable Acknowledge */
   1983                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   000001B0   0x6828             LDR      R0,[R5, #+0]
   \   000001B2   0x6800             LDR      R0,[R0, #+0]
   \   000001B4   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000001B8   0x6829             LDR      R1,[R5, #+0]
   \   000001BA   0x6008             STR      R0,[R1, #+0]
   1984          
   1985                    /* Read data from DR */
   1986                    (*pData++) = hi2c->Instance->DR;
   \   000001BC   0x6828             LDR      R0,[R5, #+0]
   \   000001BE   0x6900             LDR      R0,[R0, #+16]
   \   000001C0   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000001C4   0xF119 0x0901      ADDS     R9,R9,#+1
   1987                    Size--;
   \   000001C8   0x1E64             SUBS     R4,R4,#+1
   1988          
   1989                    /* Wait until BTF flag is set */
   1990                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   000001CA   0x4653             MOV      R3,R10
   \   000001CC   0x2200             MOVS     R2,#+0
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x10004
   \   000001D2   0x0028             MOVS     R0,R5
   \   000001D4   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001D8   0x2800             CMP      R0,#+0
   \   000001DA   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_19
   1991                    {
   1992                      return HAL_TIMEOUT;
   \   000001DC   0x2003             MOVS     R0,#+3
   \   000001DE   0xE041             B.N      ??HAL_I2C_Mem_Read_3
   1993                    }
   1994          
   1995                    /* Generate Stop */
   1996                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   000001E0   0x6828             LDR      R0,[R5, #+0]
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001E8   0x6829             LDR      R1,[R5, #+0]
   \   000001EA   0x6008             STR      R0,[R1, #+0]
   1997          
   1998                    /* Read data from DR */
   1999                    (*pData++) = hi2c->Instance->DR;
   \   000001EC   0x6828             LDR      R0,[R5, #+0]
   \   000001EE   0x6900             LDR      R0,[R0, #+16]
   \   000001F0   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000001F4   0xF119 0x0901      ADDS     R9,R9,#+1
   2000                    Size--;
   \   000001F8   0x1E64             SUBS     R4,R4,#+1
   2001          
   2002                    /* Read data from DR */
   2003                    (*pData++) = hi2c->Instance->DR;
   \   000001FA   0x6828             LDR      R0,[R5, #+0]
   \   000001FC   0x6900             LDR      R0,[R0, #+16]
   \   000001FE   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000202   0xF119 0x0901      ADDS     R9,R9,#+1
   2004                    Size--;
   \   00000206   0x1E64             SUBS     R4,R4,#+1
   \   00000208   0xE785             B.N      ??HAL_I2C_Mem_Read_9
   2005                  }
   2006                }
   2007                else
   2008                {
   2009                  /* Wait until RXNE flag is set */
   2010                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   0000020A   0x4651             MOV      R1,R10
   \   0000020C   0x0028             MOVS     R0,R5
   \   0000020E   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000212   0x2800             CMP      R0,#+0
   \   00000214   0xD006             BEQ.N    ??HAL_I2C_Mem_Read_20
   2011                  {
   2012                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   00000216   0x6BA8             LDR      R0,[R5, #+56]
   \   00000218   0x2820             CMP      R0,#+32
   \   0000021A   0xD101             BNE.N    ??HAL_I2C_Mem_Read_21
   2013                    {
   2014                      return HAL_TIMEOUT;
   \   0000021C   0x2003             MOVS     R0,#+3
   \   0000021E   0xE021             B.N      ??HAL_I2C_Mem_Read_3
   2015                    }
   2016                    else
   2017                    {
   2018                      return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_21: (+1)
   \   00000220   0x2001             MOVS     R0,#+1
   \   00000222   0xE01F             B.N      ??HAL_I2C_Mem_Read_3
   2019                    }
   2020                  }
   2021          
   2022                  /* Read data from DR */
   2023                  (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_20: (+1)
   \   00000224   0x6828             LDR      R0,[R5, #+0]
   \   00000226   0x6900             LDR      R0,[R0, #+16]
   \   00000228   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000022C   0xF119 0x0901      ADDS     R9,R9,#+1
   2024                  Size--;
   \   00000230   0x1E64             SUBS     R4,R4,#+1
   2025          
   2026                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   00000232   0x6828             LDR      R0,[R5, #+0]
   \   00000234   0x6940             LDR      R0,[R0, #+20]
   \   00000236   0x0740             LSLS     R0,R0,#+29
   \   00000238   0xF57F 0xAF6D      BPL.W    ??HAL_I2C_Mem_Read_9
   2027                  {
   2028                    /* Read data from DR */
   2029                    (*pData++) = hi2c->Instance->DR;
   \   0000023C   0x6828             LDR      R0,[R5, #+0]
   \   0000023E   0x6900             LDR      R0,[R0, #+16]
   \   00000240   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000244   0xF119 0x0901      ADDS     R9,R9,#+1
   2030                    Size--;
   \   00000248   0x1E64             SUBS     R4,R4,#+1
   \   0000024A   0xE764             B.N      ??HAL_I2C_Mem_Read_9
   2031                  }
   2032                }
   2033              }
   2034          
   2035              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   0000024C   0x2020             MOVS     R0,#+32
   \   0000024E   0xF885 0x0035      STRB     R0,[R5, #+53]
   2036              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0xF885 0x0036      STRB     R0,[R5, #+54]
   2037              
   2038              /* Process Unlocked */
   2039              __HAL_UNLOCK(hi2c);
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0xF885 0x0034      STRB     R0,[R5, #+52]
   2040              
   2041              return HAL_OK;
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0xE000             B.N      ??HAL_I2C_Mem_Read_3
   2042            }
   2043            else
   2044            {
   2045              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   00000262   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   00000264   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2046            }
   2047          }
   2048          /**
   2049            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2050            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2051            *                the configuration information for the specified I2C.
   2052            * @param  DevAddress Target device address
   2053            * @param  MemAddress Internal memory address
   2054            * @param  MemAddSize Size of internal memory address
   2055            * @param  pData Pointer to data buffer
   2056            * @param  Size Amount of data to be sent
   2057            * @retval HAL status
   2058            */

   \                                 In section .text, align 2, keep-with-next
   2059          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2060          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \   00000010   0x9C09             LDR      R4,[SP, #+36]
   2061            /* Check the parameters */
   2062            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2063            
   2064            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xD153             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   2065            {
   2066              if((pData == NULL) || (Size == 0))
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD101             BNE.N    ??HAL_I2C_Mem_Write_IT_2
   2067              {
   2068                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE04C             B.N      ??HAL_I2C_Mem_Write_IT_3
   2069              }
   2070          
   2071              /* Wait until BUSY flag is reset */
   2072              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   0000002A   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??HAL_I2C_Mem_Write_IT_4
   2073              {
   2074                return HAL_BUSY;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xE040             B.N      ??HAL_I2C_Mem_Write_IT_3
   2075              }
   2076          
   2077              /* Process Locked */
   2078              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   00000042   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_I2C_Mem_Write_IT_5
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE03A             B.N      ??HAL_I2C_Mem_Write_IT_3
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF885 0x0034      STRB     R0,[R5, #+52]
   2079              
   2080              /* Disable Pos */
   2081              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000005C   0x6829             LDR      R1,[R5, #+0]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   2082          
   2083              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000060   0x2021             MOVS     R0,#+33
   \   00000062   0xF885 0x0035      STRB     R0,[R5, #+53]
   2084              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   00000066   0x2040             MOVS     R0,#+64
   \   00000068   0xF885 0x0036      STRB     R0,[R5, #+54]
   2085              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x63A8             STR      R0,[R5, #+56]
   2086              
   2087              hi2c->pBuffPtr = pData;
   \   00000070   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2088              hi2c->XferSize = Size;
   \   00000074   0x852C             STRH     R4,[R5, #+40]
   2089              hi2c->XferCount = Size;
   \   00000076   0x856C             STRH     R4,[R5, #+42]
   2090              
   2091              /* Send Slave Address and Memory Address */
   2092              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000078   0x2023             MOVS     R0,#+35
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x4643             MOV      R3,R8
   \   0000007E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000080   0x003A             MOVS     R2,R7
   \   00000082   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000084   0x0031             MOVS     R1,R6
   \   00000086   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_IT_6
   2093              {
   2094                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000092   0x6BA8             LDR      R0,[R5, #+56]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD104             BNE.N    ??HAL_I2C_Mem_Write_IT_7
   2095                {
   2096                  /* Process Unlocked */
   2097                  __HAL_UNLOCK(hi2c);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF885 0x0034      STRB     R0,[R5, #+52]
   2098                  return HAL_ERROR;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE010             B.N      ??HAL_I2C_Mem_Write_IT_3
   2099                }
   2100                else
   2101                {
   2102                  /* Process Unlocked */
   2103                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_IT_7: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF885 0x0034      STRB     R0,[R5, #+52]
   2104                  return HAL_TIMEOUT;
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0xE00B             B.N      ??HAL_I2C_Mem_Write_IT_3
   2105                }
   2106              }
   2107          
   2108              /* Process Unlocked */
   2109              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_IT_6: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF885 0x0034      STRB     R0,[R5, #+52]
   2110          
   2111              /* Note : The I2C interrupts must be enabled after unlocking current process
   2112                        to avoid the risk of I2C interrupt handle execution before current
   2113                        process unlock */
   2114          
   2115              /* Enable EVT, BUF and ERR interrupt */
   2116              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   2117          
   2118              return HAL_OK;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_3
   2119            }
   2120            else
   2121            {
   2122              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   000000C2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   000000C4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2123            }
   2124          }
   2125          
   2126          /**
   2127            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2128            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2129            *                the configuration information for the specified I2C.
   2130            * @param  DevAddress Target device address
   2131            * @param  MemAddress Internal memory address
   2132            * @param  MemAddSize Size of internal memory address
   2133            * @param  pData Pointer to data buffer
   2134            * @param  Size Amount of data to be sent
   2135            * @retval HAL status
   2136            */

   \                                 In section .text, align 2, keep-with-next
   2137          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2138          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \   00000010   0x9C09             LDR      R4,[SP, #+36]
   2139            /* Check the parameters */
   2140            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2141            
   2142            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xF040 0x808F      BNE.W    ??HAL_I2C_Mem_Read_IT_0
   2143            {
   2144              if((pData == NULL) || (Size == 0))
   \   0000001C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   \   00000022   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD101             BNE.N    ??HAL_I2C_Mem_Read_IT_2
   2145              {
   2146                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE087             B.N      ??HAL_I2C_Mem_Read_IT_3
   2147              }
   2148          
   2149              /* Wait until BUSY flag is reset */
   2150              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   0000002C   0xF242 0x7310      MOVW     R3,#+10000
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_IT_4
   2151              {
   2152                return HAL_BUSY;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0xE07B             B.N      ??HAL_I2C_Mem_Read_IT_3
   2153              }
   2154          
   2155              /* Process Locked */
   2156              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   00000044   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD101             BNE.N    ??HAL_I2C_Mem_Read_IT_5
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0xE075             B.N      ??HAL_I2C_Mem_Read_IT_3
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF885 0x0034      STRB     R0,[R5, #+52]
   2157              
   2158              /* Disable Pos */
   2159              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000005E   0x6829             LDR      R1,[R5, #+0]
   \   00000060   0x6008             STR      R0,[R1, #+0]
   2160              
   2161              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000062   0x2022             MOVS     R0,#+34
   \   00000064   0xF885 0x0035      STRB     R0,[R5, #+53]
   2162              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   00000068   0x2040             MOVS     R0,#+64
   \   0000006A   0xF885 0x0036      STRB     R0,[R5, #+54]
   2163              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x63A8             STR      R0,[R5, #+56]
   2164          
   2165              hi2c->pBuffPtr = pData;
   \   00000072   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2166              hi2c->XferSize = Size;
   \   00000076   0x852C             STRH     R4,[R5, #+40]
   2167              hi2c->XferCount = Size;
   \   00000078   0x856C             STRH     R4,[R5, #+42]
   2168              
   2169              /* Send Slave Address and Memory Address */
   2170              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000007A   0x2023             MOVS     R0,#+35
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x4643             MOV      R3,R8
   \   00000080   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000082   0x003A             MOVS     R2,R7
   \   00000084   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000086   0x0031             MOVS     R1,R6
   \   00000088   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_IT_6
   2171              {
   2172                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000094   0x6BA8             LDR      R0,[R5, #+56]
   \   00000096   0x2804             CMP      R0,#+4
   \   00000098   0xD104             BNE.N    ??HAL_I2C_Mem_Read_IT_7
   2173                {
   2174                  /* Process Unlocked */
   2175                  __HAL_UNLOCK(hi2c);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF885 0x0034      STRB     R0,[R5, #+52]
   2176                  return HAL_ERROR;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE04B             B.N      ??HAL_I2C_Mem_Read_IT_3
   2177                }
   2178                else
   2179                {
   2180                  /* Process Unlocked */
   2181                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_7: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF885 0x0034      STRB     R0,[R5, #+52]
   2182                  return HAL_TIMEOUT;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0xE046             B.N      ??HAL_I2C_Mem_Read_IT_3
   2183                }
   2184              }
   2185          
   2186              if(hi2c->XferCount == 1)
   \                     ??HAL_I2C_Mem_Read_IT_6: (+1)
   \   000000AE   0x8D68             LDRH     R0,[R5, #+42]
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD113             BNE.N    ??HAL_I2C_Mem_Read_IT_8
   2187              {
   2188                /* Disable Acknowledge */
   2189                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000B4   0x6828             LDR      R0,[R5, #+0]
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000BC   0x6829             LDR      R1,[R5, #+0]
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   2190          
   2191                /* Clear ADDR flag */
   2192                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000C0   0x6828             LDR      R0,[R5, #+0]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x6828             LDR      R0,[R5, #+0]
   \   000000C8   0x6980             LDR      R0,[R0, #+24]
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   2193          
   2194                /* Generate Stop */
   2195                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000D6   0x6829             LDR      R1,[R5, #+0]
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0xE023             B.N      ??HAL_I2C_Mem_Read_IT_9
   2196              }
   2197              else if(hi2c->XferCount == 2)
   \                     ??HAL_I2C_Mem_Read_IT_8: (+1)
   \   000000DC   0x8D68             LDRH     R0,[R5, #+42]
   \   000000DE   0x2802             CMP      R0,#+2
   \   000000E0   0xD113             BNE.N    ??HAL_I2C_Mem_Read_IT_10
   2198              {
   2199                /* Disable Acknowledge */
   2200                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000EA   0x6829             LDR      R1,[R5, #+0]
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   2201          
   2202                /* Enable Pos */
   2203                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000F6   0x6829             LDR      R1,[R5, #+0]
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   2204          
   2205                /* Clear ADDR flag */
   2206                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000FA   0x6828             LDR      R0,[R5, #+0]
   \   000000FC   0x6940             LDR      R0,[R0, #+20]
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x6828             LDR      R0,[R5, #+0]
   \   00000102   0x6980             LDR      R0,[R0, #+24]
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0xE00C             B.N      ??HAL_I2C_Mem_Read_IT_9
   2207              }
   2208              else
   2209              {
   2210                /* Enable Acknowledge */
   2211                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_IT_10: (+1)
   \   0000010A   0x6828             LDR      R0,[R5, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000112   0x6829             LDR      R1,[R5, #+0]
   \   00000114   0x6008             STR      R0,[R1, #+0]
   2212          
   2213                /* Clear ADDR flag */
   2214                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000116   0x6828             LDR      R0,[R5, #+0]
   \   00000118   0x6940             LDR      R0,[R0, #+20]
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x6828             LDR      R0,[R5, #+0]
   \   0000011E   0x6980             LDR      R0,[R0, #+24]
   \   00000120   0x9000             STR      R0,[SP, #+0]
   \   00000122   0x9800             LDR      R0,[SP, #+0]
   2215              }
   2216          
   2217              /* Process Unlocked */
   2218              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_9: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF885 0x0034      STRB     R0,[R5, #+52]
   2219          
   2220              /* Note : The I2C interrupts must be enabled after unlocking current process 
   2221                        to avoid the risk of I2C interrupt handle execution before current
   2222                        process unlock */
   2223          
   2224              /* Enable EVT, BUF and ERR interrupt */
   2225              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0x6840             LDR      R0,[R0, #+4]
   \   0000012E   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \   00000132   0x6829             LDR      R1,[R5, #+0]
   \   00000134   0x6048             STR      R0,[R1, #+4]
   2226          
   2227              return HAL_OK;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_3
   2228            }
   2229            else
   2230            {
   2231              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   0000013A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   0000013C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2232            }
   2233          }
   2234          /**
   2235            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2236            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2237            *                the configuration information for the specified I2C.
   2238            * @param  DevAddress Target device address
   2239            * @param  MemAddress Internal memory address
   2240            * @param  MemAddSize Size of internal memory address
   2241            * @param  pData Pointer to data buffer
   2242            * @param  Size Amount of data to be sent
   2243            * @retval HAL status
   2244            */

   \                                 In section .text, align 2, keep-with-next
   2245          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2246          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \   00000010   0x9C09             LDR      R4,[SP, #+36]
   2247            /* Check the parameters */
   2248            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2249            
   2250            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xD163             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   2251            {
   2252              if((pData == NULL) || (Size == 0))
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_DMA_1
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD101             BNE.N    ??HAL_I2C_Mem_Write_DMA_2
   2253              {
   2254                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE05C             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2255              }
   2256          
   2257              /* Wait until BUSY flag is reset */
   2258              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   0000002A   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??HAL_I2C_Mem_Write_DMA_4
   2259              {
   2260                return HAL_BUSY;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xE050             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2261              }
   2262          
   2263              /* Process Locked */
   2264              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   00000042   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_I2C_Mem_Write_DMA_5
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE04A             B.N      ??HAL_I2C_Mem_Write_DMA_3
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF885 0x0034      STRB     R0,[R5, #+52]
   2265              
   2266              /* Disable Pos */
   2267              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000005C   0x6829             LDR      R1,[R5, #+0]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   2268          
   2269              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000060   0x2021             MOVS     R0,#+33
   \   00000062   0xF885 0x0035      STRB     R0,[R5, #+53]
   2270              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   00000066   0x2040             MOVS     R0,#+64
   \   00000068   0xF885 0x0036      STRB     R0,[R5, #+54]
   2271              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x63A8             STR      R0,[R5, #+56]
   2272              
   2273              hi2c->pBuffPtr = pData;
   \   00000070   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2274              hi2c->XferSize = Size;
   \   00000074   0x852C             STRH     R4,[R5, #+40]
   2275              hi2c->XferCount = Size;
   \   00000076   0x856C             STRH     R4,[R5, #+42]
   2276          
   2277              /* Set the I2C DMA transfer complete callback */
   2278              hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
   \   00000078   0x.... 0x....      ADR.W    R0,I2C_DMAMemTransmitCplt
   \   0000007C   0x6AE9             LDR      R1,[R5, #+44]
   \   0000007E   0x6288             STR      R0,[R1, #+40]
   2279          
   2280              /* Set the DMA error callback */
   2281              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000080   0x....             LDR.N    R0,??DataTable10_2
   \   00000082   0x6AE9             LDR      R1,[R5, #+44]
   \   00000084   0x6308             STR      R0,[R1, #+48]
   2282          
   2283              /* Enable the DMA Channel */
   2284              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   00000086   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000088   0x0023             MOVS     R3,R4
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0xF110 0x0210      ADDS     R2,R0,#+16
   \   00000090   0x4649             MOV      R1,R9
   \   00000092   0x6AE8             LDR      R0,[R5, #+44]
   \   00000094   0x.... 0x....      BL       HAL_DMA_Start_IT
   2285          
   2286              /* Send Slave Address and Memory Address */
   2287              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000098   0x2023             MOVS     R0,#+35
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x4643             MOV      R3,R8
   \   0000009E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A0   0x003A             MOVS     R2,R7
   \   000000A2   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A4   0x0031             MOVS     R1,R6
   \   000000A6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_DMA_6
   2288              {
   2289                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000B2   0x6BA8             LDR      R0,[R5, #+56]
   \   000000B4   0x2804             CMP      R0,#+4
   \   000000B6   0xD104             BNE.N    ??HAL_I2C_Mem_Write_DMA_7
   2290                {
   2291                  /* Process Unlocked */
   2292                  __HAL_UNLOCK(hi2c);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF885 0x0034      STRB     R0,[R5, #+52]
   2293                  return HAL_ERROR;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE010             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2294                }
   2295                else
   2296                {
   2297                  /* Process Unlocked */
   2298                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF885 0x0034      STRB     R0,[R5, #+52]
   2299                  return HAL_TIMEOUT;
   \   000000C8   0x2003             MOVS     R0,#+3
   \   000000CA   0xE00B             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2300                }
   2301              }
   2302          
   2303              /* Enable DMA Request */
   2304              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x6840             LDR      R0,[R0, #+4]
   \   000000D0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D4   0x6829             LDR      R1,[R5, #+0]
   \   000000D6   0x6048             STR      R0,[R1, #+4]
   2305          
   2306              /* Process Unlocked */
   2307              __HAL_UNLOCK(hi2c);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF885 0x0034      STRB     R0,[R5, #+52]
   2308          
   2309              return HAL_OK;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2310            }
   2311            else
   2312            {
   2313              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   000000E4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2314            }
   2315          }
   2316          
   2317          /**
   2318            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   2319            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2320            *                the configuration information for the specified I2C.
   2321            * @param  DevAddress Target device address
   2322            * @param  MemAddress Internal memory address
   2323            * @param  MemAddSize Size of internal memory address
   2324            * @param  pData Pointer to data buffer
   2325            * @param  Size Amount of data to be read
   2326            * @retval HAL status
   2327            */

   \                                 In section .text, align 2, keep-with-next
   2328          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2329          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \   00000010   0x9C09             LDR      R4,[SP, #+36]
   2330            /* Check the parameters */
   2331            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2332            
   2333            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xD17B             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   2334            {
   2335              if((pData == NULL) || (Size == 0))
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_DMA_1
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD101             BNE.N    ??HAL_I2C_Mem_Read_DMA_2
   2336              {
   2337                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE074             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2338              }
   2339          
   2340              /* Wait until BUSY flag is reset */
   2341              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   0000002A   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_DMA_4
   2342              {
   2343                return HAL_BUSY;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xE068             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2344              }
   2345          
   2346              /* Process Locked */
   2347              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   00000042   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_I2C_Mem_Read_DMA_5
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE062             B.N      ??HAL_I2C_Mem_Read_DMA_3
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF885 0x0034      STRB     R0,[R5, #+52]
   2348          
   2349              /* Disable Pos */
   2350              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000005C   0x6829             LDR      R1,[R5, #+0]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   2351              
   2352              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000060   0x2022             MOVS     R0,#+34
   \   00000062   0xF885 0x0035      STRB     R0,[R5, #+53]
   2353              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   00000066   0x2040             MOVS     R0,#+64
   \   00000068   0xF885 0x0036      STRB     R0,[R5, #+54]
   2354              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x63A8             STR      R0,[R5, #+56]
   2355          
   2356              hi2c->pBuffPtr = pData;
   \   00000070   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2357              hi2c->XferSize = Size;
   \   00000074   0x852C             STRH     R4,[R5, #+40]
   2358              hi2c->XferCount = Size;
   \   00000076   0x856C             STRH     R4,[R5, #+42]
   2359          
   2360              /* Set the I2C DMA transfer complete callback */
   2361              hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
   \   00000078   0x.... 0x....      ADR.W    R0,I2C_DMAMemReceiveCplt
   \   0000007C   0x6B29             LDR      R1,[R5, #+48]
   \   0000007E   0x6288             STR      R0,[R1, #+40]
   2362          
   2363              /* Set the DMA error callback */
   2364              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   00000080   0x.... 0x....      ADR.W    R0,I2C_DMAError
   \   00000084   0x6B29             LDR      R1,[R5, #+48]
   \   00000086   0x6308             STR      R0,[R1, #+48]
   2365          
   2366              /* Enable the DMA Channel */
   2367              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   00000088   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008A   0x0023             MOVS     R3,R4
   \   0000008C   0x464A             MOV      R2,R9
   \   0000008E   0x6828             LDR      R0,[R5, #+0]
   \   00000090   0xF110 0x0110      ADDS     R1,R0,#+16
   \   00000094   0x6B28             LDR      R0,[R5, #+48]
   \   00000096   0x.... 0x....      BL       HAL_DMA_Start_IT
   2368          
   2369              /* Send Slave Address and Memory Address */
   2370              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000009A   0x2023             MOVS     R0,#+35
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x4643             MOV      R3,R8
   \   000000A0   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A2   0x003A             MOVS     R2,R7
   \   000000A4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   0x0031             MOVS     R1,R6
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_DMA_6
   2371              {
   2372                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000B4   0x6BA8             LDR      R0,[R5, #+56]
   \   000000B6   0x2804             CMP      R0,#+4
   \   000000B8   0xD104             BNE.N    ??HAL_I2C_Mem_Read_DMA_7
   2373                {
   2374                  /* Process Unlocked */
   2375                  __HAL_UNLOCK(hi2c);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF885 0x0034      STRB     R0,[R5, #+52]
   2376                  return HAL_ERROR;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xE027             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2377                }
   2378                else
   2379                {
   2380                  /* Process Unlocked */
   2381                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF885 0x0034      STRB     R0,[R5, #+52]
   2382                  return HAL_TIMEOUT;
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xE022             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2383                }
   2384              }
   2385          
   2386              if(Size == 1)
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   000000CE   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000D0   0x2C01             CMP      R4,#+1
   \   000000D2   0xD106             BNE.N    ??HAL_I2C_Mem_Read_DMA_8
   2387              {
   2388                /* Disable Acknowledge */
   2389                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000D4   0x6828             LDR      R0,[R5, #+0]
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000DC   0x6829             LDR      R1,[R5, #+0]
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   \   000000E0   0xE005             B.N      ??HAL_I2C_Mem_Read_DMA_9
   2390              }
   2391              else
   2392              {
   2393                /* Enable Last DMA bit */
   2394                SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0x6840             LDR      R0,[R0, #+4]
   \   000000E6   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000EA   0x6829             LDR      R1,[R5, #+0]
   \   000000EC   0x6048             STR      R0,[R1, #+4]
   2395              }
   2396          
   2397              /* Enable DMA Request */
   2398              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0x6840             LDR      R0,[R0, #+4]
   \   000000F2   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000F6   0x6829             LDR      R1,[R5, #+0]
   \   000000F8   0x6048             STR      R0,[R1, #+4]
   2399          
   2400              /* Clear ADDR flag */
   2401              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000FA   0x6828             LDR      R0,[R5, #+0]
   \   000000FC   0x6940             LDR      R0,[R0, #+20]
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x6828             LDR      R0,[R5, #+0]
   \   00000102   0x6980             LDR      R0,[R0, #+24]
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   2402          
   2403              /* Process Unlocked */
   2404              __HAL_UNLOCK(hi2c);
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xF885 0x0034      STRB     R0,[R5, #+52]
   2405              
   2406              return HAL_OK;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2407            }
   2408            else
   2409            {
   2410              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   00000112   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   00000114   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2411            }
   2412          }
   2413          
   2414          /**
   2415            * @brief  Checks if target device is ready for communication. 
   2416            * @note   This function is used with Memory devices
   2417            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2418            *                the configuration information for the specified I2C.
   2419            * @param  DevAddress Target device address
   2420            * @param  Trials Number of trials
   2421            * @param  Timeout Timeout duration
   2422            * @retval HAL status
   2423            */

   \                                 In section .text, align 2, keep-with-next
   2424          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   2425          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2426            uint32_t tickstart = 0, I2C_Trials = 1;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0901      MOVS     R9,#+1
   2427          
   2428            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x809E      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2429            {
   2430              /* Wait until BUSY flag is reset */
   2431              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   0000001E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_1
   2432              {
   2433                return HAL_BUSY;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE092             B.N      ??HAL_I2C_IsDeviceReady_2
   2434              }
   2435          
   2436              /* Process Locked */
   2437              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   00000036   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD101             BNE.N    ??HAL_I2C_IsDeviceReady_3
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xE08C             B.N      ??HAL_I2C_IsDeviceReady_2
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF884 0x0034      STRB     R0,[R4, #+52]
   2438              
   2439              /* Disable Pos */
   2440              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
   2441          
   2442              hi2c->State = HAL_I2C_STATE_BUSY;
   \   00000054   0x2024             MOVS     R0,#+36
   \   00000056   0xF884 0x0035      STRB     R0,[R4, #+53]
   2443              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x63A0             STR      R0,[R4, #+56]
   2444          
   2445              do
   2446              {
   2447                /* Generate Start */
   2448                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
   2449          
   2450                /* Wait until SB flag is set */
   2451                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   0000006A   0x003B             MOVS     R3,R7
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0xF05F 0x1101      MOVS     R1,#+65537
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_5
   2452                {
   2453                  return HAL_TIMEOUT;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0xE06D             B.N      ??HAL_I2C_IsDeviceReady_2
   2454                }
   2455          
   2456                /* Send slave address */
   2457                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   00000080   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6108             STR      R0,[R1, #+16]
   2458          
   2459                /* Wait until ADDR or AF flag are set */
   2460                /* Get tick */
   2461                tickstart = HAL_GetTick();
   \   00000088   0x.... 0x....      BL       HAL_GetTick
   \   0000008C   0x4680             MOV      R8,R0
   2462          
   2463                while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == RESET) && \
   2464                      (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && \
   2465                      (hi2c->State != HAL_I2C_STATE_TIMEOUT))
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6940             LDR      R0,[R0, #+20]
   \   00000092   0x0780             LSLS     R0,R0,#+30
   \   00000094   0xD416             BMI.N    ??HAL_I2C_IsDeviceReady_7
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6940             LDR      R0,[R0, #+20]
   \   0000009A   0x0540             LSLS     R0,R0,#+21
   \   0000009C   0xD412             BMI.N    ??HAL_I2C_IsDeviceReady_7
   \   0000009E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000A2   0x28A0             CMP      R0,#+160
   \   000000A4   0xD00E             BEQ.N    ??HAL_I2C_IsDeviceReady_7
   2466                {
   2467                  if(Timeout != HAL_MAX_DELAY)
   \   000000A6   0xF5B7 0x4F00      CMP      R7,#+32768
   \   000000AA   0xD0F0             BEQ.N    ??HAL_I2C_IsDeviceReady_6
   2468                  {
   2469                    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000AC   0x2F00             CMP      R7,#+0
   \   000000AE   0xD005             BEQ.N    ??HAL_I2C_IsDeviceReady_8
   \   000000B0   0x.... 0x....      BL       HAL_GetTick
   \   000000B4   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000B8   0x4287             CMP      R7,R0
   \   000000BA   0xD2E8             BCS.N    ??HAL_I2C_IsDeviceReady_6
   2470                    {
   2471                      hi2c->State = HAL_I2C_STATE_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000BC   0x20A0             MOVS     R0,#+160
   \   000000BE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C2   0xE7E4             B.N      ??HAL_I2C_IsDeviceReady_6
   2472                    }
   2473                  }
   2474                }
   2475          
   2476                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000C4   0x2020             MOVS     R0,#+32
   \   000000C6   0xF884 0x0035      STRB     R0,[R4, #+53]
   2477          
   2478                /* Check if the ADDR flag has been set */
   2479                if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6940             LDR      R0,[R0, #+20]
   \   000000CE   0x0780             LSLS     R0,R0,#+30
   \   000000D0   0xD520             BPL.N    ??HAL_I2C_IsDeviceReady_9
   2480                {
   2481                  /* Generate Stop */
   2482                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6008             STR      R0,[R1, #+0]
   2483          
   2484                  /* Clear ADDR Flag */
   2485                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6940             LDR      R0,[R0, #+20]
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6980             LDR      R0,[R0, #+24]
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   2486          
   2487                  /* Wait until BUSY flag is reset */
   2488                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   000000EC   0xF242 0x7310      MOVW     R3,#+10000
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0xF05F 0x1102      MOVS     R1,#+131074
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_10
   2489                  {
   2490                    return HAL_TIMEOUT;
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0xE02B             B.N      ??HAL_I2C_IsDeviceReady_2
   2491                  }
   2492          
   2493                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   00000104   0x2020             MOVS     R0,#+32
   \   00000106   0xF884 0x0035      STRB     R0,[R4, #+53]
   2494          
   2495                  /* Process Unlocked */
   2496                  __HAL_UNLOCK(hi2c);
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF884 0x0034      STRB     R0,[R4, #+52]
   2497          
   2498                  return HAL_OK;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xE023             B.N      ??HAL_I2C_IsDeviceReady_2
   2499                }
   2500                else
   2501                {
   2502                  /* Generate Stop */
   2503                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000011C   0x6821             LDR      R1,[R4, #+0]
   \   0000011E   0x6008             STR      R0,[R1, #+0]
   2504          
   2505                  /* Clear AF Flag */
   2506                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000120   0xF47F 0x6080      MVNS     R0,#+1024
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x6148             STR      R0,[R1, #+20]
   2507          
   2508                  /* Wait until BUSY flag is reset */
   2509                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   00000128   0xF242 0x7310      MOVW     R3,#+10000
   \   0000012C   0x2201             MOVS     R2,#+1
   \   0000012E   0xF05F 0x1102      MOVS     R1,#+131074
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_11
   2510                  {
   2511                    return HAL_TIMEOUT;
   \   0000013C   0x2003             MOVS     R0,#+3
   \   0000013E   0xE00D             B.N      ??HAL_I2C_IsDeviceReady_2
   2512                  }
   2513                }
   2514              }while(I2C_Trials++ < Trials);
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   00000140   0x4648             MOV      R0,R9
   \   00000142   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000146   0x42B0             CMP      R0,R6
   \   00000148   0xD389             BCC.N    ??HAL_I2C_IsDeviceReady_4
   2515          
   2516              hi2c->State = HAL_I2C_STATE_READY;
   \   0000014A   0x2020             MOVS     R0,#+32
   \   0000014C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2517          
   2518              /* Process Unlocked */
   2519              __HAL_UNLOCK(hi2c);
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xF884 0x0034      STRB     R0,[R4, #+52]
   2520          
   2521              return HAL_ERROR;
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE000             B.N      ??HAL_I2C_IsDeviceReady_2
   2522            }
   2523            else
   2524            {
   2525              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   0000015A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   0000015C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2526            }
   2527          }
   2528          
   2529          /**
   2530            * @brief  This function handles I2C event interrupt request.
   2531            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2532            *                the configuration information for the specified I2C.
   2533            * @retval None
   2534            */

   \                                 In section .text, align 2, keep-with-next
   2535          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   2536          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2537            /* Master or Memory mode selected */
   2538            if((hi2c->Mode == HAL_I2C_MODE_MASTER) || \
   2539               (hi2c->Mode == HAL_I2C_MODE_MEM))
   \   00000004   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000008   0x2810             CMP      R0,#+16
   \   0000000A   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000000C   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000010   0x2840             CMP      R0,#+64
   \   00000012   0xD13B             BNE.N    ??HAL_I2C_EV_IRQHandler_1
   2540            {
   2541              /* I2C in mode Transmitter -----------------------------------------------*/
   2542              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == SET)
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x0740             LSLS     R0,R0,#+29
   \   0000001A   0xD51B             BPL.N    ??HAL_I2C_EV_IRQHandler_2
   2543              {
   2544                /* TXE set and BTF reset -----------------------------------------------*/
   2545                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == SET) && \
   2546                   (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF) == SET) && \
   2547                   (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD50B             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x0540             LSLS     R0,R0,#+21
   \   0000002A   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6940             LDR      R0,[R0, #+20]
   \   00000030   0x0740             LSLS     R0,R0,#+29
   \   00000032   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_3
   2548                {
   2549                  I2C_MasterTransmit_TXE(hi2c);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       I2C_MasterTransmit_TXE
   \   0000003A   0xE07A             B.N      ??HAL_I2C_EV_IRQHandler_4
   2550                }
   2551                /* BTF set -------------------------------------------------------------*/
   2552                else if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && \
   2553                        (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6940             LDR      R0,[R0, #+20]
   \   00000040   0x0740             LSLS     R0,R0,#+29
   \   00000042   0xD576             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6840             LDR      R0,[R0, #+4]
   \   00000048   0x0580             LSLS     R0,R0,#+22
   \   0000004A   0xD572             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   2554                {
   2555                  I2C_MasterTransmit_BTF(hi2c);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       I2C_MasterTransmit_BTF
   \   00000052   0xE06E             B.N      ??HAL_I2C_EV_IRQHandler_4
   2556                }
   2557              }
   2558              /* I2C in mode Receiver --------------------------------------------------*/
   2559              else
   2560              {
   2561                /* RXNE set and BTF reset -----------------------------------------------*/
   2562                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && \
   2563                   (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF) == SET) && \
   2564                   (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6940             LDR      R0,[R0, #+20]
   \   00000058   0x0640             LSLS     R0,R0,#+25
   \   0000005A   0xD50B             BPL.N    ??HAL_I2C_EV_IRQHandler_5
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x0540             LSLS     R0,R0,#+21
   \   00000062   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6940             LDR      R0,[R0, #+20]
   \   00000068   0x0740             LSLS     R0,R0,#+29
   \   0000006A   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_5
   2565                {
   2566                  I2C_MasterReceive_RXNE(hi2c);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       I2C_MasterReceive_RXNE
   \   00000072   0xE05E             B.N      ??HAL_I2C_EV_IRQHandler_4
   2567                }
   2568                /* BTF set -------------------------------------------------------------*/
   2569                else if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6940             LDR      R0,[R0, #+20]
   \   00000078   0x0740             LSLS     R0,R0,#+29
   \   0000007A   0xD55A             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6840             LDR      R0,[R0, #+4]
   \   00000080   0x0580             LSLS     R0,R0,#+22
   \   00000082   0xD556             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   2570                {
   2571                  I2C_MasterReceive_BTF(hi2c);
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       I2C_MasterReceive_BTF
   \   0000008A   0xE052             B.N      ??HAL_I2C_EV_IRQHandler_4
   2572                }
   2573              }
   2574            }
   2575            /* Slave mode selected */
   2576            else
   2577            {
   2578              /* ADDR set --------------------------------------------------------------*/
   2579              if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET) && \
   2580                 (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_EVT)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6940             LDR      R0,[R0, #+20]
   \   00000090   0x0780             LSLS     R0,R0,#+30
   \   00000092   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_6
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6840             LDR      R0,[R0, #+4]
   \   00000098   0x0580             LSLS     R0,R0,#+22
   \   0000009A   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_6
   2581              {
   2582                I2C_Slave_ADDR(hi2c);
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       I2C_Slave_ADDR
   \   000000A2   0xE046             B.N      ??HAL_I2C_EV_IRQHandler_4
   2583              }
   2584              /* STOPF set --------------------------------------------------------------*/
   2585              else if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) && \
   2586                      (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_EVT)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6940             LDR      R0,[R0, #+20]
   \   000000A8   0x06C0             LSLS     R0,R0,#+27
   \   000000AA   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6840             LDR      R0,[R0, #+4]
   \   000000B0   0x0580             LSLS     R0,R0,#+22
   \   000000B2   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   2587              {
   2588                I2C_Slave_STOPF(hi2c);
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       I2C_Slave_STOPF
   \   000000BA   0xE03A             B.N      ??HAL_I2C_EV_IRQHandler_4
   2589              }
   2590              /* I2C in mode Transmitter -----------------------------------------------*/
   2591              else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == SET)
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6980             LDR      R0,[R0, #+24]
   \   000000C0   0x0740             LSLS     R0,R0,#+29
   \   000000C2   0xD51B             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   2592              {
   2593                /* TXE set and BTF reset -----------------------------------------------*/
   2594                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == SET) && \
   2595                   (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF) == SET) && \
   2596                   (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6940             LDR      R0,[R0, #+20]
   \   000000C8   0x0600             LSLS     R0,R0,#+24
   \   000000CA   0xD50B             BPL.N    ??HAL_I2C_EV_IRQHandler_9
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x6840             LDR      R0,[R0, #+4]
   \   000000D0   0x0540             LSLS     R0,R0,#+21
   \   000000D2   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_9
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6940             LDR      R0,[R0, #+20]
   \   000000D8   0x0740             LSLS     R0,R0,#+29
   \   000000DA   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_9
   2597                {
   2598                  I2C_SlaveTransmit_TXE(hi2c);
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       I2C_SlaveTransmit_TXE
   \   000000E2   0xE026             B.N      ??HAL_I2C_EV_IRQHandler_4
   2599                }
   2600                /* BTF set -------------------------------------------------------------*/
   2601                else if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && \
   2602                        (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_9: (+1)
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6940             LDR      R0,[R0, #+20]
   \   000000E8   0x0740             LSLS     R0,R0,#+29
   \   000000EA   0xD522             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6840             LDR      R0,[R0, #+4]
   \   000000F0   0x0580             LSLS     R0,R0,#+22
   \   000000F2   0xD51E             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   2603                {
   2604                  I2C_SlaveTransmit_BTF(hi2c);
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       I2C_SlaveTransmit_BTF
   \   000000FA   0xE01A             B.N      ??HAL_I2C_EV_IRQHandler_4
   2605                }
   2606              }
   2607              /* I2C in mode Receiver --------------------------------------------------*/
   2608              else
   2609              {
   2610                /* RXNE set and BTF reset ----------------------------------------------*/
   2611                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && \
   2612                   (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF) == SET) && \
   2613                   (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_8: (+1)
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6940             LDR      R0,[R0, #+20]
   \   00000100   0x0640             LSLS     R0,R0,#+25
   \   00000102   0xD50B             BPL.N    ??HAL_I2C_EV_IRQHandler_10
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6840             LDR      R0,[R0, #+4]
   \   00000108   0x0540             LSLS     R0,R0,#+21
   \   0000010A   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_10
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6940             LDR      R0,[R0, #+20]
   \   00000110   0x0740             LSLS     R0,R0,#+29
   \   00000112   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_10
   2614                {
   2615                  I2C_SlaveReceive_RXNE(hi2c);
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       I2C_SlaveReceive_RXNE
   \   0000011A   0xE00A             B.N      ??HAL_I2C_EV_IRQHandler_4
   2616                }
   2617                /* BTF set -------------------------------------------------------------*/
   2618                else if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_10: (+1)
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6940             LDR      R0,[R0, #+20]
   \   00000120   0x0740             LSLS     R0,R0,#+29
   \   00000122   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0x6840             LDR      R0,[R0, #+4]
   \   00000128   0x0580             LSLS     R0,R0,#+22
   \   0000012A   0xD502             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   2619                {
   2620                  I2C_SlaveReceive_BTF(hi2c);
   \   0000012C   0x0020             MOVS     R0,R4
   \   0000012E   0x.... 0x....      BL       I2C_SlaveReceive_BTF
   2621                }
   2622              }
   2623            }
   2624          }
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   00000132   0xBD10             POP      {R4,PC}          ;; return
   2625           
   2626          /**
   2627            * @brief  This function handles I2C error interrupt request.
   2628            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2629            *                the configuration information for the specified I2C.
   2630            * @retval None
   2631            */

   \                                 In section .text, align 2, keep-with-next
   2632          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   2633          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2634          
   2635            /* I2C Bus error interrupt occurred ----------------------------------------*/
   2636            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && \
   2637               (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR) == SET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD50B             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x05C0             LSLS     R0,R0,#+23
   \   00000012   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   2638            {
   2639              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   00000014   0x6BA0             LDR      R0,[R4, #+56]
   \   00000016   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001A   0x63A0             STR      R0,[R4, #+56]
   2640          
   2641              /* Clear BERR flag */
   2642              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   0000001C   0xF47F 0x7080      MVNS     R0,#+256
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6148             STR      R0,[R1, #+20]
   2643            }
   2644          
   2645            /* I2C Arbitration Loss error interrupt occurred ---------------------------*/
   2646            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && \
   2647               (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6940             LDR      R0,[R0, #+20]
   \   00000028   0x0580             LSLS     R0,R0,#+22
   \   0000002A   0xD50B             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0x05C0             LSLS     R0,R0,#+23
   \   00000032   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   2648            {
   2649              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   00000034   0x6BA0             LDR      R0,[R4, #+56]
   \   00000036   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
   2650          
   2651              /* Clear ARLO flag */
   2652              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   0000003C   0xF47F 0x7000      MVNS     R0,#+512
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
   2653            }
   2654          
   2655            /* I2C Acknowledge failure error interrupt occurred ------------------------*/
   2656            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) && \
   2657               (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0x0540             LSLS     R0,R0,#+21
   \   0000004A   0xD51A             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0x05C0             LSLS     R0,R0,#+23
   \   00000052   0xD516             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   2658            {
   2659              if((hi2c->Mode == HAL_I2C_MODE_SLAVE) && \
   2660                 (hi2c->XferCount == 0) && \
   2661                 (hi2c->State == HAL_I2C_STATE_BUSY_TX))
   \   00000054   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000058   0x2820             CMP      R0,#+32
   \   0000005A   0xD10A             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   0000005C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD107             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   00000062   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000066   0x2821             CMP      R0,#+33
   \   00000068   0xD103             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   2662              {
   2663                I2C_Slave_AF(hi2c);
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       I2C_Slave_AF
   \   00000070   0xE007             B.N      ??HAL_I2C_ER_IRQHandler_2
   2664              }
   2665              else
   2666              {
   2667                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   2668                /* Clear AF flag */
   2669                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000007A   0xF47F 0x6080      MVNS     R0,#+1024
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6148             STR      R0,[R1, #+20]
   2670              }
   2671            }
   2672          
   2673            /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
   2674            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && \
   2675               (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6940             LDR      R0,[R0, #+20]
   \   00000086   0x0500             LSLS     R0,R0,#+20
   \   00000088   0xD50B             BPL.N    ??HAL_I2C_ER_IRQHandler_4
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x05C0             LSLS     R0,R0,#+23
   \   00000090   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_4
   2676            {
   2677              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   00000092   0x6BA0             LDR      R0,[R4, #+56]
   \   00000094   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000098   0x63A0             STR      R0,[R4, #+56]
   2678              /* Clear OVR flag */
   2679              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   0000009A   0xF47F 0x6000      MVNS     R0,#+2048
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6148             STR      R0,[R1, #+20]
   2680            }
   2681          
   2682            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_4: (+1)
   \   000000A2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD011             BEQ.N    ??HAL_I2C_ER_IRQHandler_5
   2683            {
   2684              hi2c->State = HAL_I2C_STATE_READY;
   \   000000A8   0x2020             MOVS     R0,#+32
   \   000000AA   0xF884 0x0035      STRB     R0,[R4, #+53]
   2685              
   2686              /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
   2687              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF430 0x6000      BICS     R0,R0,#0x800
   \   000000B6   0x6821             LDR      R1,[R4, #+0]
   \   000000B8   0x6008             STR      R0,[R1, #+0]
   2688          
   2689              /* Disable EVT, BUF and ERR interrupts */
   2690              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6840             LDR      R0,[R0, #+4]
   \   000000BE   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6048             STR      R0,[R1, #+4]
   2691          
   2692              HAL_I2C_ErrorCallback(hi2c);
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2693            }
   2694          }
   \                     ??HAL_I2C_ER_IRQHandler_5: (+1)
   \   000000CC   0xBD10             POP      {R4,PC}          ;; return
   2695          
   2696          /**
   2697            * @brief  Master Tx Transfer completed callback.
   2698            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2699            *                the configuration information for the specified I2C.
   2700            * @retval None
   2701            */

   \                                 In section .text, align 2, keep-with-next
   2702           __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2703          {
   2704            /* Prevent unused argument(s) compilation warning */
   2705            UNUSED(hi2c);
   2706          
   2707            /* NOTE : This function should not be modified, when the callback is needed,
   2708                      the HAL_I2C_MasterTxCpltCallback can be implemented in the user file
   2709             */
   2710          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2711          
   2712          /**
   2713            * @brief  Master Rx Transfer completed callback.
   2714            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2715            *                the configuration information for the specified I2C.
   2716            * @retval None
   2717            */

   \                                 In section .text, align 2, keep-with-next
   2718          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2719          {
   2720            /* Prevent unused argument(s) compilation warning */
   2721            UNUSED(hi2c);
   2722          
   2723            /* NOTE : This function should not be modified, when the callback is needed,
   2724                      the HAL_I2C_MasterRxCpltCallback can be implemented in the user file
   2725             */
   2726          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2727          
   2728          /** @brief  Slave Tx Transfer completed callback.
   2729            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2730            *                the configuration information for the specified I2C.
   2731            * @retval None
   2732            */

   \                                 In section .text, align 2, keep-with-next
   2733           __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2734          {
   2735            /* Prevent unused argument(s) compilation warning */
   2736            UNUSED(hi2c);
   2737          
   2738            /* NOTE : This function should not be modified, when the callback is needed,
   2739                      the HAL_I2C_SlaveTxCpltCallback can be implemented in the user file
   2740             */
   2741          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2742          
   2743          /**
   2744            * @brief  Slave Rx Transfer completed callback.
   2745            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2746            *                the configuration information for the specified I2C.
   2747            * @retval None
   2748            */

   \                                 In section .text, align 2, keep-with-next
   2749          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2750          {
   2751            /* Prevent unused argument(s) compilation warning */
   2752            UNUSED(hi2c);
   2753          
   2754            /* NOTE : This function should not be modified, when the callback is needed,
   2755                      the HAL_I2C_SlaveRxCpltCallback can be implemented in the user file
   2756             */
   2757          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2758          
   2759          /**
   2760            * @brief  Memory Tx Transfer completed callback.
   2761            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2762            *                the configuration information for the specified I2C.
   2763            * @retval None
   2764            */

   \                                 In section .text, align 2, keep-with-next
   2765           __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2766          {
   2767            /* Prevent unused argument(s) compilation warning */
   2768            UNUSED(hi2c);
   2769          
   2770            /* NOTE : This function should not be modified, when the callback is needed,
   2771                      the HAL_I2C_MemTxCpltCallback can be implemented in the user file
   2772             */
   2773          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2774          
   2775          /**
   2776            * @brief  Memory Rx Transfer completed callback.
   2777            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2778            *                the configuration information for the specified I2C.
   2779            * @retval None
   2780            */

   \                                 In section .text, align 2, keep-with-next
   2781          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2782          {
   2783            /* Prevent unused argument(s) compilation warning */
   2784            UNUSED(hi2c);
   2785          
   2786            /* NOTE : This function should not be modified, when the callback is needed,
   2787                      the HAL_I2C_MemRxCpltCallback can be implemented in the user file
   2788             */
   2789          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2790          
   2791          /**
   2792            * @brief  I2C error callback.
   2793            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2794            *                the configuration information for the specified I2C.
   2795            * @retval None
   2796            */

   \                                 In section .text, align 2, keep-with-next
   2797           __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   2798          {
   2799            /* Prevent unused argument(s) compilation warning */
   2800            UNUSED(hi2c);
   2801          
   2802            /* NOTE : This function should not be modified, when the callback is needed,
   2803                      the HAL_I2C_ErrorCallback can be implemented in the user file
   2804             */
   2805          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2806          
   2807          /**
   2808            * @}
   2809            */
   2810          
   2811          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State and Errors functions
   2812           *  @brief   Peripheral State and Errors functions
   2813           *
   2814          @verbatim   
   2815           ===============================================================================
   2816                      ##### Peripheral State, Mode and Error functions #####
   2817           ===============================================================================  
   2818              [..]
   2819              This subsection permits to get in run-time the status of the peripheral 
   2820              and the data flow.
   2821          
   2822          @endverbatim
   2823            * @{
   2824            */
   2825          
   2826          /**
   2827            * @brief  Return the I2C handle state.
   2828            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2829            *                the configuration information for the specified I2C.
   2830            * @retval HAL state
   2831            */

   \                                 In section .text, align 2, keep-with-next
   2832          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   2833          {
   2834            /* Return I2C handle state */
   2835            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   2836          }
   2837          
   2838          /**
   2839            * @brief  Returns the I2C Master, Slave, Memory or no mode.
   2840            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2841            *         the configuration information for I2C module
   2842            * @retval HAL mode
   2843            */

   \                                 In section .text, align 2, keep-with-next
   2844          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   2845          {
   2846            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \   00000000   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000004   0x4770             BX       LR               ;; return
   2847          }
   2848          
   2849          /**
   2850          * @brief  Return the I2C error code.
   2851            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2852            *              the configuration information for the specified I2C.
   2853            * @retval I2C Error Code
   2854          */

   \                                 In section .text, align 2, keep-with-next
   2855          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   2856          {
   2857            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2858          }
   2859          
   2860          /**
   2861            * @}
   2862            */
   2863          
   2864          /**
   2865            * @}
   2866            */   
   2867          
   2868          
   2869          /** @addtogroup I2C_Private_Functions
   2870            * @{
   2871            */
   2872          
   2873          
   2874          /**
   2875            * @brief  Handle TXE flag for Master
   2876            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   2877            *         the configuration information for I2C module
   2878            * @retval HAL status
   2879            */

   \                                 In section .text, align 2, keep-with-next
   2880          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
   2881          {
   \                     I2C_MasterTransmit_TXE: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2882            if(hi2c->XferCount == 0)
   \   00000002   0x8D48             LDRH     R0,[R1, #+42]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD106             BNE.N    ??I2C_MasterTransmit_TXE_0
   2883            {
   2884              /* Disable BUF interrupt */
   2885              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x6050             STR      R0,[R2, #+4]
   \   00000014   0xE008             B.N      ??I2C_MasterTransmit_TXE_1
   2886            }
   2887            else
   2888            {
   2889              /* Write data to DR */
   2890              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??I2C_MasterTransmit_TXE_0: (+1)
   \   00000016   0x6A48             LDR      R0,[R1, #+36]
   \   00000018   0x1C42             ADDS     R2,R0,#+1
   \   0000001A   0x624A             STR      R2,[R1, #+36]
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x6110             STR      R0,[R2, #+16]
   2891              hi2c->XferCount--;
   \   00000022   0x8D48             LDRH     R0,[R1, #+42]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x8548             STRH     R0,[R1, #+42]
   2892            }
   2893          
   2894            return HAL_OK;
   \                     ??I2C_MasterTransmit_TXE_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   2895          }
   2896          
   2897          /**
   2898            * @brief  Handle BTF flag for Master transmitter
   2899            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   2900            *         the configuration information for I2C module
   2901            * @retval HAL status
   2902            */

   \                                 In section .text, align 2, keep-with-next
   2903          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
   2904          {
   \                     I2C_MasterTransmit_BTF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2905            if(hi2c->XferCount != 0)
   \   00000004   0x8D60             LDRH     R0,[R4, #+42]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD009             BEQ.N    ??I2C_MasterTransmit_BTF_0
   2906            {
   2907              /* Write data to DR */
   2908              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   0000000A   0x6A60             LDR      R0,[R4, #+36]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
   \   0000000E   0x6261             STR      R1,[R4, #+36]
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6108             STR      R0,[R1, #+16]
   2909              hi2c->XferCount--;
   \   00000016   0x8D60             LDRH     R0,[R4, #+42]
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x8560             STRH     R0,[R4, #+42]
   \   0000001C   0xE01C             B.N      ??I2C_MasterTransmit_BTF_1
   2910            }
   2911            else
   2912            {
   2913              /* Disable EVT, BUF and ERR interrupt */
   2914              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_BTF_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
   2915          
   2916              /* Generate Stop */
   2917              SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2918          
   2919              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000036   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000003A   0x2840             CMP      R0,#+64
   \   0000003C   0xD106             BNE.N    ??I2C_MasterTransmit_BTF_2
   2920              {
   2921                hi2c->State = HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   2922          
   2923                HAL_I2C_MemTxCpltCallback(hi2c);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   0000004A   0xE005             B.N      ??I2C_MasterTransmit_BTF_1
   2924              }
   2925              else
   2926              {
   2927                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterTransmit_BTF_2: (+1)
   \   0000004C   0x2020             MOVS     R0,#+32
   \   0000004E   0xF884 0x0035      STRB     R0,[R4, #+53]
   2928          
   2929                HAL_I2C_MasterTxCpltCallback(hi2c);
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   2930              }
   2931            }
   2932            return HAL_OK;
   \                     ??I2C_MasterTransmit_BTF_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   2933          }
   2934          
   2935          /**
   2936            * @brief  Handle RXNE flag for Master
   2937            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   2938            *         the configuration information for I2C module
   2939            * @retval HAL status
   2940            */

   \                                 In section .text, align 2, keep-with-next
   2941          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
   2942          {
   \                     I2C_MasterReceive_RXNE: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2943            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   2944          
   2945            tmp = hi2c->XferCount;
   \   00000006   0x8D60             LDRH     R0,[R4, #+42]
   \   00000008   0x0005             MOVS     R5,R0
   2946            if(tmp > 3)
   \   0000000A   0x2D04             CMP      R5,#+4
   \   0000000C   0xD309             BCC.N    ??I2C_MasterReceive_RXNE_0
   2947            {
   2948              /* Read data from DR */
   2949              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000000E   0x6A60             LDR      R0,[R4, #+36]
   \   00000010   0x1C41             ADDS     R1,R0,#+1
   \   00000012   0x6261             STR      R1,[R4, #+36]
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6909             LDR      R1,[R1, #+16]
   \   00000018   0x7001             STRB     R1,[R0, #+0]
   2950              hi2c->XferCount--;
   \   0000001A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x8560             STRH     R0,[R4, #+42]
   \   00000020   0xE02A             B.N      ??I2C_MasterReceive_RXNE_1
   2951            }
   2952            else if((tmp == 2) || (tmp == 3))
   \                     ??I2C_MasterReceive_RXNE_0: (+1)
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD001             BEQ.N    ??I2C_MasterReceive_RXNE_2
   \   00000026   0x2D03             CMP      R5,#+3
   \   00000028   0xD106             BNE.N    ??I2C_MasterReceive_RXNE_3
   2953            {
   2954              /* Disable BUF interrupt */
   2955              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \                     ??I2C_MasterReceive_RXNE_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   \   00000036   0xE01F             B.N      ??I2C_MasterReceive_RXNE_1
   2956            }
   2957            else
   2958            {
   2959              /* Disable EVT, BUF and ERR interrupt */
   2960              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterReceive_RXNE_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6048             STR      R0,[R1, #+4]
   2961          
   2962              /* Read data from DR */
   2963              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x1C41             ADDS     R1,R0,#+1
   \   00000048   0x6261             STR      R1,[R4, #+36]
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6909             LDR      R1,[R1, #+16]
   \   0000004E   0x7001             STRB     R1,[R0, #+0]
   2964              hi2c->XferCount--;
   \   00000050   0x8D60             LDRH     R0,[R4, #+42]
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0x8560             STRH     R0,[R4, #+42]
   2965          
   2966              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000056   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000005A   0x2840             CMP      R0,#+64
   \   0000005C   0xD106             BNE.N    ??I2C_MasterReceive_RXNE_4
   2967              {
   2968                hi2c->State = HAL_I2C_STATE_READY;
   \   0000005E   0x2020             MOVS     R0,#+32
   \   00000060   0xF884 0x0035      STRB     R0,[R4, #+53]
   2969          
   2970                HAL_I2C_MemRxCpltCallback(hi2c);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   0000006A   0xE005             B.N      ??I2C_MasterReceive_RXNE_1
   2971              }
   2972              else
   2973              {
   2974                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_RXNE_4: (+1)
   \   0000006C   0x2020             MOVS     R0,#+32
   \   0000006E   0xF884 0x0035      STRB     R0,[R4, #+53]
   2975          
   2976                HAL_I2C_MasterRxCpltCallback(hi2c);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   2977              }
   2978            }
   2979            return HAL_OK;
   \                     ??I2C_MasterReceive_RXNE_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2980          }
   2981          
   2982          /**
   2983            * @brief  Handle BTF flag for Master receiver
   2984            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   2985            *         the configuration information for I2C module
   2986            * @retval HAL status
   2987            */

   \                                 In section .text, align 2, keep-with-next
   2988          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
   2989          {
   \                     I2C_MasterReceive_BTF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2990            if(hi2c->XferCount == 3)
   \   00000004   0x8D60             LDRH     R0,[R4, #+42]
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD10F             BNE.N    ??I2C_MasterReceive_BTF_0
   2991            {
   2992              /* Disable Acknowledge */
   2993              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
   2994          
   2995              /* Read data from DR */
   2996              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000016   0x6A60             LDR      R0,[R4, #+36]
   \   00000018   0x1C41             ADDS     R1,R0,#+1
   \   0000001A   0x6261             STR      R1,[R4, #+36]
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6909             LDR      R1,[R1, #+16]
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   2997              hi2c->XferCount--;
   \   00000022   0x8D60             LDRH     R0,[R4, #+42]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x8560             STRH     R0,[R4, #+42]
   \   00000028   0xE03B             B.N      ??I2C_MasterReceive_BTF_1
   2998            }
   2999            else if(hi2c->XferCount == 2)
   \                     ??I2C_MasterReceive_BTF_0: (+1)
   \   0000002A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD12F             BNE.N    ??I2C_MasterReceive_BTF_2
   3000            {
   3001              /* Generate Stop */
   3002              SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   3003          
   3004              /* Read data from DR */
   3005              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0x1C41             ADDS     R1,R0,#+1
   \   00000040   0x6261             STR      R1,[R4, #+36]
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6909             LDR      R1,[R1, #+16]
   \   00000046   0x7001             STRB     R1,[R0, #+0]
   3006              hi2c->XferCount--;
   \   00000048   0x8D60             LDRH     R0,[R4, #+42]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x8560             STRH     R0,[R4, #+42]
   3007          
   3008              /* Read data from DR */
   3009              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000004E   0x6A60             LDR      R0,[R4, #+36]
   \   00000050   0x1C41             ADDS     R1,R0,#+1
   \   00000052   0x6261             STR      R1,[R4, #+36]
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6909             LDR      R1,[R1, #+16]
   \   00000058   0x7001             STRB     R1,[R0, #+0]
   3010              hi2c->XferCount--;
   \   0000005A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x8560             STRH     R0,[R4, #+42]
   3011          
   3012              /* Disable EVT and ERR interrupt */
   3013              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6048             STR      R0,[R1, #+4]
   3014          
   3015              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   0000006C   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000070   0x2840             CMP      R0,#+64
   \   00000072   0xD106             BNE.N    ??I2C_MasterReceive_BTF_3
   3016              {
   3017                hi2c->State = HAL_I2C_STATE_READY;
   \   00000074   0x2020             MOVS     R0,#+32
   \   00000076   0xF884 0x0035      STRB     R0,[R4, #+53]
   3018          
   3019                HAL_I2C_MemRxCpltCallback(hi2c);
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000080   0xE00F             B.N      ??I2C_MasterReceive_BTF_1
   3020              }
   3021              else
   3022              {
   3023                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_BTF_3: (+1)
   \   00000082   0x2020             MOVS     R0,#+32
   \   00000084   0xF884 0x0035      STRB     R0,[R4, #+53]
   3024          
   3025                HAL_I2C_MasterRxCpltCallback(hi2c);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   0000008E   0xE008             B.N      ??I2C_MasterReceive_BTF_1
   3026              }
   3027            }
   3028            else
   3029            {
   3030              /* Read data from DR */
   3031              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_2: (+1)
   \   00000090   0x6A60             LDR      R0,[R4, #+36]
   \   00000092   0x1C41             ADDS     R1,R0,#+1
   \   00000094   0x6261             STR      R1,[R4, #+36]
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6909             LDR      R1,[R1, #+16]
   \   0000009A   0x7001             STRB     R1,[R0, #+0]
   3032              hi2c->XferCount--;
   \   0000009C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0x8560             STRH     R0,[R4, #+42]
   3033            }
   3034            return HAL_OK;
   \                     ??I2C_MasterReceive_BTF_1: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
   3035          }
   3036          
   3037          /**
   3038            * @brief  Handle TXE flag for Slave
   3039            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3040            *         the configuration information for I2C module
   3041            * @retval HAL status
   3042            */

   \                                 In section .text, align 2, keep-with-next
   3043          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
   3044          {
   \                     I2C_SlaveTransmit_TXE: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   3045            if(hi2c->XferCount != 0)
   \   00000002   0x8D48             LDRH     R0,[R1, #+42]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??I2C_SlaveTransmit_TXE_0
   3046            {
   3047              /* Write data to DR */
   3048              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000008   0x6A48             LDR      R0,[R1, #+36]
   \   0000000A   0x1C42             ADDS     R2,R0,#+1
   \   0000000C   0x624A             STR      R2,[R1, #+36]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x6110             STR      R0,[R2, #+16]
   3049              hi2c->XferCount--;
   \   00000014   0x8D48             LDRH     R0,[R1, #+42]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x8548             STRH     R0,[R1, #+42]
   3050            }
   3051            return HAL_OK;
   \                     ??I2C_SlaveTransmit_TXE_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   3052          }
   3053          
   3054          /**
   3055            * @brief  Handle BTF flag for Slave transmitter
   3056            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3057            *         the configuration information for I2C module
   3058            * @retval HAL status
   3059            */

   \                                 In section .text, align 2, keep-with-next
   3060          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
   3061          {
   \                     I2C_SlaveTransmit_BTF: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   3062            if(hi2c->XferCount != 0)
   \   00000002   0x8D48             LDRH     R0,[R1, #+42]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??I2C_SlaveTransmit_BTF_0
   3063            {
   3064              /* Write data to DR */
   3065              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000008   0x6A48             LDR      R0,[R1, #+36]
   \   0000000A   0x1C42             ADDS     R2,R0,#+1
   \   0000000C   0x624A             STR      R2,[R1, #+36]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x6110             STR      R0,[R2, #+16]
   3066              hi2c->XferCount--;
   \   00000014   0x8D48             LDRH     R0,[R1, #+42]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x8548             STRH     R0,[R1, #+42]
   3067            }
   3068            return HAL_OK;
   \                     ??I2C_SlaveTransmit_BTF_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   3069          }
   3070          
   3071          /**
   3072            * @brief  Handle RXNE flag for Slave
   3073            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3074            *         the configuration information for I2C module
   3075            * @retval HAL status
   3076            */

   \                                 In section .text, align 2, keep-with-next
   3077          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
   3078          {
   \                     I2C_SlaveReceive_RXNE: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   3079            if(hi2c->XferCount != 0)
   \   00000002   0x8D48             LDRH     R0,[R1, #+42]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??I2C_SlaveReceive_RXNE_0
   3080            {
   3081              /* Read data from DR */
   3082              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000008   0x6A48             LDR      R0,[R1, #+36]
   \   0000000A   0x1C42             ADDS     R2,R0,#+1
   \   0000000C   0x624A             STR      R2,[R1, #+36]
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x6912             LDR      R2,[R2, #+16]
   \   00000012   0x7002             STRB     R2,[R0, #+0]
   3083              hi2c->XferCount--;
   \   00000014   0x8D48             LDRH     R0,[R1, #+42]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x8548             STRH     R0,[R1, #+42]
   3084            }
   3085            return HAL_OK;
   \                     ??I2C_SlaveReceive_RXNE_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   3086          }
   3087          
   3088          /**
   3089            * @brief  Handle BTF flag for Slave receiver
   3090            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3091            *         the configuration information for I2C module
   3092            * @retval HAL status
   3093            */

   \                                 In section .text, align 2, keep-with-next
   3094          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
   3095          {
   \                     I2C_SlaveReceive_BTF: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   3096            if(hi2c->XferCount != 0)
   \   00000002   0x8D48             LDRH     R0,[R1, #+42]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??I2C_SlaveReceive_BTF_0
   3097            {
   3098              /* Read data from DR */
   3099              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000008   0x6A48             LDR      R0,[R1, #+36]
   \   0000000A   0x1C42             ADDS     R2,R0,#+1
   \   0000000C   0x624A             STR      R2,[R1, #+36]
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x6912             LDR      R2,[R2, #+16]
   \   00000012   0x7002             STRB     R2,[R0, #+0]
   3100              hi2c->XferCount--;
   \   00000014   0x8D48             LDRH     R0,[R1, #+42]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x8548             STRH     R0,[R1, #+42]
   3101            }
   3102            return HAL_OK;
   \                     ??I2C_SlaveReceive_BTF_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   3103          }
   3104          
   3105          /**
   3106            * @brief  Handle ADD flag for Slave
   3107            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3108            *         the configuration information for I2C module
   3109            * @retval HAL status
   3110            */

   \                                 In section .text, align 2, keep-with-next
   3111          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)
   3112          {
   \                     I2C_Slave_ADDR: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
   3113            /* Clear ADDR flag */
   3114            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x6808             LDR      R0,[R1, #+0]
   \   0000000C   0x6980             LDR      R0,[R0, #+24]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   3115          
   3116            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0x4770             BX       LR               ;; return
   3117          }
   3118          
   3119          /**
   3120            * @brief  Handle STOPF flag for Slave
   3121            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3122            *         the configuration information for I2C module
   3123            * @retval HAL status
   3124            */

   \                                 In section .text, align 2, keep-with-next
   3125          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
   3126          {
   \                     I2C_Slave_STOPF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   3127            /* Disable EVT, BUF and ERR interrupt */
   3128            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x6048             STR      R0,[R1, #+4]
   3129          
   3130            /* Clear STOPF flag */
   3131            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   3132          
   3133            /* Disable Acknowledge */
   3134            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6008             STR      R0,[R1, #+0]
   3135          
   3136            hi2c->State = HAL_I2C_STATE_READY;
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
   3137          
   3138            HAL_I2C_SlaveRxCpltCallback(hi2c);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3139          
   3140            return HAL_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   3141          }
   3142          
   3143          /**
   3144            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3145            *         the configuration information for I2C module
   3146            * @retval HAL status
   3147            */

   \                                 In section .text, align 2, keep-with-next
   3148          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
   3149          {
   \                     I2C_Slave_AF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3150            /* Disable EVT, BUF and ERR interrupt */
   3151            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6048             STR      R0,[R1, #+4]
   3152          
   3153            /* Clear AF flag */
   3154            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000010   0xF47F 0x6080      MVNS     R0,#+1024
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6148             STR      R0,[R1, #+20]
   3155          
   3156            /* Disable Acknowledge */
   3157            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
   3158          
   3159            hi2c->State = HAL_I2C_STATE_READY;
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0xF884 0x0035      STRB     R0,[R4, #+53]
   3160          
   3161            HAL_I2C_SlaveTxCpltCallback(hi2c);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   3162          
   3163            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   3164          }
   3165          
   3166          /**
   3167            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3168            *         the configuration information for I2C module
   3169            * @param  DevAddress Target device address
   3170            * @param  Timeout Timeout duration
   3171            * @retval HAL status
   3172            */

   \                                 In section .text, align 2, keep-with-next
   3173          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
   3174          {
   \                     I2C_MasterRequestWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3175            /* Generate Start */
   3176            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x6008             STR      R0,[R1, #+0]
   3177          
   3178            /* Wait until SB flag is set */
   3179            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000014   0x0033             MOVS     R3,R6
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xF05F 0x1101      MOVS     R1,#+65537
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??I2C_MasterRequestWrite_0
   3180            {
   3181              return HAL_TIMEOUT;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE034             B.N      ??I2C_MasterRequestWrite_1
   3182            }
   3183          
   3184            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestWrite_0: (+1)
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD104             BNE.N    ??I2C_MasterRequestWrite_2
   3185            {
   3186              /* Send slave address */
   3187              hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \   00000032   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6108             STR      R0,[R1, #+16]
   \   0000003A   0xE01B             B.N      ??I2C_MasterRequestWrite_3
   3188            }
   3189            else
   3190            {
   3191              /* Send header of slave address */
   3192              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestWrite_2: (+1)
   \   0000003C   0xF415 0x7040      ANDS     R0,R5,#0x300
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x09C0             LSRS     R0,R0,#+7
   \   00000044   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6108             STR      R0,[R1, #+16]
   3193          
   3194              /* Wait until ADD10 flag is set */
   3195              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
   \   0000004E   0x0032             MOVS     R2,R6
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x10008
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD006             BEQ.N    ??I2C_MasterRequestWrite_4
   3196              {
   3197                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000005E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0xD101             BNE.N    ??I2C_MasterRequestWrite_5
   3198                {
   3199                  return HAL_ERROR;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE015             B.N      ??I2C_MasterRequestWrite_1
   3200                }
   3201                else
   3202                {
   3203                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_5: (+1)
   \   00000068   0x2003             MOVS     R0,#+3
   \   0000006A   0xE013             B.N      ??I2C_MasterRequestWrite_1
   3204                }
   3205              }
   3206          
   3207              /* Send slave address */
   3208              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestWrite_4: (+1)
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6108             STR      R0,[R1, #+16]
   3209            }
   3210          
   3211            /* Wait until ADDR flag is set */
   3212            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_3: (+1)
   \   00000074   0x0032             MOVS     R2,R6
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x10002
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD006             BEQ.N    ??I2C_MasterRequestWrite_6
   3213            {
   3214              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000084   0x6BA0             LDR      R0,[R4, #+56]
   \   00000086   0x2804             CMP      R0,#+4
   \   00000088   0xD101             BNE.N    ??I2C_MasterRequestWrite_7
   3215              {
   3216                return HAL_ERROR;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE002             B.N      ??I2C_MasterRequestWrite_1
   3217              }
   3218              else
   3219              {
   3220                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_7: (+1)
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xE000             B.N      ??I2C_MasterRequestWrite_1
   3221              }
   3222            }
   3223          
   3224            return HAL_OK;
   \                     ??I2C_MasterRequestWrite_6: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRequestWrite_1: (+1)
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return
   3225          }
   3226          
   3227          /**
   3228            * @brief  Master sends target device address for read request.
   3229            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3230            *         the configuration information for I2C module
   3231            * @param  DevAddress Target device address
   3232            * @param  Timeout Timeout duration
   3233            * @retval HAL status
   3234            */

   \                                 In section .text, align 2, keep-with-next
   3235          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
   3236          {
   \                     I2C_MasterRequestRead: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   3237            /* Enable Acknowledge */
   3238            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
   3239          
   3240            /* Generate Start */
   3241            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   3242          
   3243            /* Wait until SB flag is set */
   3244            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000022   0x0033             MOVS     R3,R6
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0xF05F 0x1101      MOVS     R1,#+65537
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ.N    ??I2C_MasterRequestRead_0
   3245            {
   3246              return HAL_TIMEOUT;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xE065             B.N      ??I2C_MasterRequestRead_1
   3247            }
   3248          
   3249            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestRead_0: (+1)
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000003E   0xD105             BNE.N    ??I2C_MasterRequestRead_2
   3250            {
   3251              /* Send slave address */
   3252              hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \   00000040   0xF055 0x0001      ORRS     R0,R5,#0x1
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6108             STR      R0,[R1, #+16]
   \   0000004A   0xE04B             B.N      ??I2C_MasterRequestRead_3
   3253            }
   3254            else
   3255            {
   3256              /* Send header of slave address */
   3257              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestRead_2: (+1)
   \   0000004C   0xF415 0x7040      ANDS     R0,R5,#0x300
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0x09C0             LSRS     R0,R0,#+7
   \   00000054   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6108             STR      R0,[R1, #+16]
   3258          
   3259              /* Wait until ADD10 flag is set */
   3260              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
   \   0000005E   0x0032             MOVS     R2,R6
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x10008
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD006             BEQ.N    ??I2C_MasterRequestRead_4
   3261              {
   3262                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD101             BNE.N    ??I2C_MasterRequestRead_5
   3263                {
   3264                  return HAL_ERROR;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE045             B.N      ??I2C_MasterRequestRead_1
   3265                }
   3266                else
   3267                {
   3268                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_5: (+1)
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xE043             B.N      ??I2C_MasterRequestRead_1
   3269                }
   3270              }
   3271          
   3272              /* Send slave address */
   3273              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestRead_4: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6108             STR      R0,[R1, #+16]
   3274          
   3275              /* Wait until ADDR flag is set */
   3276              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000084   0x0032             MOVS     R2,R6
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x10002
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD006             BEQ.N    ??I2C_MasterRequestRead_6
   3277              {
   3278                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000094   0x6BA0             LDR      R0,[R4, #+56]
   \   00000096   0x2804             CMP      R0,#+4
   \   00000098   0xD101             BNE.N    ??I2C_MasterRequestRead_7
   3279                {
   3280                  return HAL_ERROR;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE032             B.N      ??I2C_MasterRequestRead_1
   3281                }
   3282                else
   3283                {
   3284                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_7: (+1)
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0xE030             B.N      ??I2C_MasterRequestRead_1
   3285                }
   3286              }
   3287          
   3288              /* Clear ADDR flag */
   3289              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_MasterRequestRead_6: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6940             LDR      R0,[R0, #+20]
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6980             LDR      R0,[R0, #+24]
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   3290          
   3291              /* Generate Restart */
   3292              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   3293          
   3294              /* Wait until SB flag is set */
   3295              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   000000BC   0x0033             MOVS     R3,R6
   \   000000BE   0x2200             MOVS     R2,#+0
   \   000000C0   0xF05F 0x1101      MOVS     R1,#+65537
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD001             BEQ.N    ??I2C_MasterRequestRead_8
   3296              {
   3297                return HAL_TIMEOUT;
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0xE018             B.N      ??I2C_MasterRequestRead_1
   3298              }
   3299          
   3300              /* Send header of slave address */
   3301              hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
   \                     ??I2C_MasterRequestRead_8: (+1)
   \   000000D2   0xF415 0x7040      ANDS     R0,R5,#0x300
   \   000000D6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D8   0x09C0             LSRS     R0,R0,#+7
   \   000000DA   0xF050 0x00F1      ORRS     R0,R0,#0xF1
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x6108             STR      R0,[R1, #+16]
   3302            }
   3303          
   3304            /* Wait until ADDR flag is set */
   3305            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \                     ??I2C_MasterRequestRead_3: (+1)
   \   000000E4   0x0032             MOVS     R2,R6
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x10002
   \   000000EA   0x0020             MOVS     R0,R4
   \   000000EC   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD006             BEQ.N    ??I2C_MasterRequestRead_9
   3306            {
   3307              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F6   0x2804             CMP      R0,#+4
   \   000000F8   0xD101             BNE.N    ??I2C_MasterRequestRead_10
   3308              {
   3309                return HAL_ERROR;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xE002             B.N      ??I2C_MasterRequestRead_1
   3310              }
   3311              else
   3312              {
   3313                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_10: (+1)
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xE000             B.N      ??I2C_MasterRequestRead_1
   3314              }
   3315            }
   3316          
   3317            return HAL_OK;
   \                     ??I2C_MasterRequestRead_9: (+1)
   \   00000102   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRequestRead_1: (+1)
   \   00000104   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   3318          }
   3319          
   3320          /**
   3321            * @brief  Master sends target device address followed by internal memory address for write request.
   3322            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3323            *         the configuration information for I2C module
   3324            * @param  DevAddress Target device address
   3325            * @param  MemAddress Internal memory address
   3326            * @param  MemAddSize Size of internal memory address
   3327            * @param  Timeout Timeout duration
   3328            * @retval HAL status
   3329            */

   \                                 In section .text, align 2, keep-with-next
   3330          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3331          {
   \                     I2C_RequestMemoryWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   3332            /* Generate Start */
   3333            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   3334          
   3335            /* Wait until SB flag is set */
   3336            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   0000001E   0x4643             MOV      R3,R8
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xF05F 0x1101      MOVS     R1,#+65537
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??I2C_RequestMemoryWrite_0
   3337            {
   3338              return HAL_TIMEOUT;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0xE052             B.N      ??I2C_RequestMemoryWrite_1
   3339            }
   3340          
   3341            /* Send slave address */
   3342            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \   00000034   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6108             STR      R0,[R1, #+16]
   3343          
   3344            /* Wait until ADDR flag is set */
   3345            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   0000003C   0x4642             MOV      R2,R8
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x10002
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD006             BEQ.N    ??I2C_RequestMemoryWrite_2
   3346            {
   3347              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xD101             BNE.N    ??I2C_RequestMemoryWrite_3
   3348              {
   3349                return HAL_ERROR;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE041             B.N      ??I2C_RequestMemoryWrite_1
   3350              }
   3351              else
   3352              {
   3353                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xE03F             B.N      ??I2C_RequestMemoryWrite_1
   3354              }
   3355            }
   3356          
   3357            /* Clear ADDR flag */
   3358            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6940             LDR      R0,[R0, #+20]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6980             LDR      R0,[R0, #+24]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   3359          
   3360            /* Wait until TXE flag is set */
   3361            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000068   0x4641             MOV      R1,R8
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00C             BEQ.N    ??I2C_RequestMemoryWrite_4
   3362            {
   3363              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000074   0x6BA0             LDR      R0,[R4, #+56]
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD107             BNE.N    ??I2C_RequestMemoryWrite_5
   3364              {
   3365                /* Generate Stop */
   3366                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6008             STR      R0,[R1, #+0]
   3367                return HAL_ERROR;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xE027             B.N      ??I2C_RequestMemoryWrite_1
   3368              }
   3369              else
   3370              {
   3371                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_5: (+1)
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0xE025             B.N      ??I2C_RequestMemoryWrite_1
   3372              }
   3373            }
   3374          
   3375            /* If Memory address size is 8Bit */
   3376            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryWrite_4: (+1)
   \   0000008E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD104             BNE.N    ??I2C_RequestMemoryWrite_6
   3377            {
   3378              /* Send Memory Address */
   3379              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6108             STR      R0,[R1, #+16]
   \   0000009C   0xE01C             B.N      ??I2C_RequestMemoryWrite_7
   3380            }
   3381            /* If Memory address size is 16Bit */
   3382            else
   3383            {
   3384              /* Send MSB of Memory Address */
   3385              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_6: (+1)
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A2   0x0A00             LSRS     R0,R0,#+8
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6108             STR      R0,[R1, #+16]
   3386          
   3387              /* Wait until TXE flag is set */
   3388              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000AA   0x4641             MOV      R1,R8
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD00C             BEQ.N    ??I2C_RequestMemoryWrite_8
   3389              {
   3390                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000B6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B8   0x2804             CMP      R0,#+4
   \   000000BA   0xD107             BNE.N    ??I2C_RequestMemoryWrite_9
   3391                {
   3392                  /* Generate Stop */
   3393                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6008             STR      R0,[R1, #+0]
   3394                  return HAL_ERROR;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xE006             B.N      ??I2C_RequestMemoryWrite_1
   3395                }
   3396                else
   3397                {
   3398                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_9: (+1)
   \   000000CC   0x2003             MOVS     R0,#+3
   \   000000CE   0xE004             B.N      ??I2C_RequestMemoryWrite_1
   3399                }
   3400              }
   3401          
   3402              /* Send LSB of Memory Address */
   3403              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_8: (+1)
   \   000000D0   0x0030             MOVS     R0,R6
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x6108             STR      R0,[R1, #+16]
   3404            }
   3405          
   3406            return HAL_OK;
   \                     ??I2C_RequestMemoryWrite_7: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \   000000DA   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3407          }
   3408          
   3409          /**
   3410            * @brief  Master sends target device address followed by internal memory address for read request.
   3411            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3412            *         the configuration information for I2C module
   3413            * @param  DevAddress Target device address
   3414            * @param  MemAddress Internal memory address
   3415            * @param  MemAddSize Size of internal memory address
   3416            * @param  Timeout Timeout duration
   3417            * @retval HAL status
   3418            */

   \                                 In section .text, align 2, keep-with-next
   3419          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3420          {
   \                     I2C_RequestMemoryRead: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   3421            /* Enable Acknowledge */
   3422            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   3423          
   3424            /* Generate Start */
   3425            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
   3426          
   3427            /* Wait until SB flag is set */
   3428            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   0000002A   0x4643             MOV      R3,R8
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0xF05F 0x1101      MOVS     R1,#+65537
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??I2C_RequestMemoryRead_0
   3429            {
   3430              return HAL_TIMEOUT;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xE088             B.N      ??I2C_RequestMemoryRead_1
   3431            }
   3432          
   3433            /* Send slave address */
   3434            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \   00000040   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6108             STR      R0,[R1, #+16]
   3435          
   3436            /* Wait until ADDR flag is set */
   3437            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000048   0x4642             MOV      R2,R8
   \   0000004A   0x....             LDR.N    R1,??DataTable16_1  ;; 0x10002
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD006             BEQ.N    ??I2C_RequestMemoryRead_2
   3438            {
   3439              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000056   0x6BA0             LDR      R0,[R4, #+56]
   \   00000058   0x2804             CMP      R0,#+4
   \   0000005A   0xD101             BNE.N    ??I2C_RequestMemoryRead_3
   3440              {
   3441                return HAL_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE078             B.N      ??I2C_RequestMemoryRead_1
   3442              }
   3443              else
   3444              {
   3445                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xE076             B.N      ??I2C_RequestMemoryRead_1
   3446              }
   3447            }
   3448          
   3449            /* Clear ADDR flag */
   3450            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6940             LDR      R0,[R0, #+20]
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6980             LDR      R0,[R0, #+24]
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   3451          
   3452            /* Wait until TXE flag is set */
   3453            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000072   0x4641             MOV      R1,R8
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD00C             BEQ.N    ??I2C_RequestMemoryRead_4
   3454            {
   3455              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000080   0x2804             CMP      R0,#+4
   \   00000082   0xD107             BNE.N    ??I2C_RequestMemoryRead_5
   3456              {
   3457                /* Generate Stop */
   3458                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   3459                return HAL_ERROR;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE05E             B.N      ??I2C_RequestMemoryRead_1
   3460              }
   3461              else
   3462              {
   3463                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_5: (+1)
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xE05C             B.N      ??I2C_RequestMemoryRead_1
   3464              }
   3465            }
   3466          
   3467            /* If Memory address size is 8Bit */
   3468            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \   00000098   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000009A   0x2F01             CMP      R7,#+1
   \   0000009C   0xD104             BNE.N    ??I2C_RequestMemoryRead_6
   3469            {
   3470              /* Send Memory Address */
   3471              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x6108             STR      R0,[R1, #+16]
   \   000000A6   0xE01C             B.N      ??I2C_RequestMemoryRead_7
   3472            }
   3473            /* If Memory address size is 16Bit */
   3474            else
   3475            {
   3476              /* Send MSB of Memory Address */
   3477              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_6: (+1)
   \   000000A8   0x0030             MOVS     R0,R6
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x0A00             LSRS     R0,R0,#+8
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6108             STR      R0,[R1, #+16]
   3478          
   3479              /* Wait until TXE flag is set */
   3480              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD00C             BEQ.N    ??I2C_RequestMemoryRead_8
   3481              {
   3482                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000C0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000C2   0x2804             CMP      R0,#+4
   \   000000C4   0xD107             BNE.N    ??I2C_RequestMemoryRead_9
   3483                {
   3484                  /* Generate Stop */
   3485                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   3486                  return HAL_ERROR;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xE03D             B.N      ??I2C_RequestMemoryRead_1
   3487                }
   3488                else
   3489                {
   3490                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_9: (+1)
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xE03B             B.N      ??I2C_RequestMemoryRead_1
   3491                }
   3492              }
   3493          
   3494              /* Send LSB of Memory Address */
   3495              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_8: (+1)
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0x6108             STR      R0,[R1, #+16]
   3496            }
   3497          
   3498            /* Wait until TXE flag is set */
   3499            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??I2C_RequestMemoryRead_7: (+1)
   \   000000E2   0x4641             MOV      R1,R8
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD00C             BEQ.N    ??I2C_RequestMemoryRead_10
   3500            {
   3501              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F0   0x2804             CMP      R0,#+4
   \   000000F2   0xD107             BNE.N    ??I2C_RequestMemoryRead_11
   3502              {
   3503                /* Generate Stop */
   3504                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000FC   0x6821             LDR      R1,[R4, #+0]
   \   000000FE   0x6008             STR      R0,[R1, #+0]
   3505                return HAL_ERROR;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xE026             B.N      ??I2C_RequestMemoryRead_1
   3506              }
   3507              else
   3508              {
   3509                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_11: (+1)
   \   00000104   0x2003             MOVS     R0,#+3
   \   00000106   0xE024             B.N      ??I2C_RequestMemoryRead_1
   3510              }
   3511            }
   3512          
   3513            /* Generate Restart */
   3514            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_RequestMemoryRead_10: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6008             STR      R0,[R1, #+0]
   3515          
   3516            /* Wait until SB flag is set */
   3517            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000114   0x4643             MOV      R3,R8
   \   00000116   0x2200             MOVS     R2,#+0
   \   00000118   0xF05F 0x1101      MOVS     R1,#+65537
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD001             BEQ.N    ??I2C_RequestMemoryRead_12
   3518            {
   3519              return HAL_TIMEOUT;
   \   00000126   0x2003             MOVS     R0,#+3
   \   00000128   0xE013             B.N      ??I2C_RequestMemoryRead_1
   3520            }
   3521          
   3522            /* Send slave address */
   3523            hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \                     ??I2C_RequestMemoryRead_12: (+1)
   \   0000012A   0xF055 0x0001      ORRS     R0,R5,#0x1
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0x6821             LDR      R1,[R4, #+0]
   \   00000132   0x6108             STR      R0,[R1, #+16]
   3524          
   3525            /* Wait until ADDR flag is set */
   3526            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000134   0x4642             MOV      R2,R8
   \   00000136   0x....             LDR.N    R1,??DataTable16_1  ;; 0x10002
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD006             BEQ.N    ??I2C_RequestMemoryRead_13
   3527            {
   3528              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000142   0x6BA0             LDR      R0,[R4, #+56]
   \   00000144   0x2804             CMP      R0,#+4
   \   00000146   0xD101             BNE.N    ??I2C_RequestMemoryRead_14
   3529              {
   3530                return HAL_ERROR;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xE002             B.N      ??I2C_RequestMemoryRead_1
   3531              }
   3532              else
   3533              {
   3534                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_14: (+1)
   \   0000014C   0x2003             MOVS     R0,#+3
   \   0000014E   0xE000             B.N      ??I2C_RequestMemoryRead_1
   3535              }
   3536            }
   3537          
   3538            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_13: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \   00000152   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3539          }
   3540          
   3541          /**
   3542            * @brief  DMA I2C master transmit process complete callback.
   3543            * @param  hdma DMA handle
   3544            * @retval None
   3545            */

   \                                 In section .text, align 2, keep-with-next
   3546          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
   3547          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3548            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3549          
   3550            /* Wait until BTF flag is reset */
   3551            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000006   0x2323             MOVS     R3,#+35
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable16_2  ;; 0x10004
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??I2C_DMAMasterTransmitCplt_0
   3552            {
   3553              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000016   0x6BA8             LDR      R0,[R5, #+56]
   \   00000018   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001C   0x63A8             STR      R0,[R5, #+56]
   3554            }
   3555          
   3556            /* Generate Stop */
   3557            SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
   3558          
   3559            /* Disable DMA Request */
   3560            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   3561          
   3562            hi2c->XferCount = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8568             STRH     R0,[R5, #+42]
   3563          
   3564            hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF885 0x0035      STRB     R0,[R5, #+53]
   3565            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF885 0x0036      STRB     R0,[R5, #+54]
   3566          
   3567            /* Check if Errors has been detected during transfer */
   3568            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000046   0x6BA8             LDR      R0,[R5, #+56]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD003             BEQ.N    ??I2C_DMAMasterTransmitCplt_1
   3569            {
   3570              HAL_I2C_ErrorCallback(hi2c);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000052   0xE002             B.N      ??I2C_DMAMasterTransmitCplt_2
   3571            }
   3572            else
   3573            {
   3574              HAL_I2C_MasterTxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterTransmitCplt_1: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   3575            }
   3576          }
   \                     ??I2C_DMAMasterTransmitCplt_2: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3577          
   3578          /**
   3579            * @brief  DMA I2C slave transmit process complete callback.
   3580            * @param  hdma DMA handle
   3581            * @retval None
   3582            */

   \                                 In section .text, align 2, keep-with-next
   3583          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
   3584          {
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3585            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3586          
   3587            /* Wait until AF flag is reset */
   3588            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000006   0x2323             MOVS     R3,#+35
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF45F 0x3182      MOVS     R1,#+66560
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??I2C_DMASlaveTransmitCplt_0
   3589            {
   3590              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000018   0x6BA8             LDR      R0,[R5, #+56]
   \   0000001A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001E   0x63A8             STR      R0,[R5, #+56]
   3591            }
   3592          
   3593            /* Clear AF flag */
   3594            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \   00000020   0xF47F 0x6080      MVNS     R0,#+1024
   \   00000024   0x6829             LDR      R1,[R5, #+0]
   \   00000026   0x6148             STR      R0,[R1, #+20]
   3595          
   3596            /* Disable Address Acknowledge */
   3597            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6829             LDR      R1,[R5, #+0]
   \   00000032   0x6008             STR      R0,[R1, #+0]
   3598          
   3599            /* Disable DMA Request */
   3600            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6829             LDR      R1,[R5, #+0]
   \   0000003E   0x6048             STR      R0,[R1, #+4]
   3601          
   3602            hi2c->XferCount = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x8568             STRH     R0,[R5, #+42]
   3603          
   3604            hi2c->State = HAL_I2C_STATE_READY;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF885 0x0035      STRB     R0,[R5, #+53]
   3605            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF885 0x0036      STRB     R0,[R5, #+54]
   3606          
   3607            /* Check if Errors has been detected during transfer */
   3608            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000050   0x6BA8             LDR      R0,[R5, #+56]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD003             BEQ.N    ??I2C_DMASlaveTransmitCplt_1
   3609            {
   3610              HAL_I2C_ErrorCallback(hi2c);
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000005C   0xE002             B.N      ??I2C_DMASlaveTransmitCplt_2
   3611            }
   3612            else
   3613            {
   3614              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveTransmitCplt_1: (+1)
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   3615            }
   3616          }
   \                     ??I2C_DMASlaveTransmitCplt_2: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3617          
   3618          /**
   3619            * @brief  DMA I2C master receive process complete callback
   3620            * @param  hdma DMA handle
   3621            * @retval None
   3622            */

   \                                 In section .text, align 2, keep-with-next
   3623          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
   3624          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3625            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3626          
   3627            /* Generate Stop */
   3628            SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000000E   0x6829             LDR      R1,[R5, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   3629          
   3630            /* Disable Last DMA */
   3631            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6048             STR      R0,[R1, #+4]
   3632          
   3633            /* Disable Acknowledge */
   3634            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
   3635          
   3636            /* Disable DMA Request */
   3637            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   3638          
   3639            hi2c->XferCount = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8568             STRH     R0,[R5, #+42]
   3640          
   3641            hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF885 0x0035      STRB     R0,[R5, #+53]
   3642            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF885 0x0036      STRB     R0,[R5, #+54]
   3643          
   3644            /* Check if Errors has been detected during transfer */
   3645            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000046   0x6BA8             LDR      R0,[R5, #+56]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD003             BEQ.N    ??I2C_DMAMasterReceiveCplt_0
   3646            {
   3647              HAL_I2C_ErrorCallback(hi2c);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000052   0xE002             B.N      ??I2C_DMAMasterReceiveCplt_1
   3648            }
   3649            else
   3650            {
   3651              HAL_I2C_MasterRxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   3652            }
   3653          }
   \                     ??I2C_DMAMasterReceiveCplt_1: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3654          
   3655          /**
   3656            * @brief  DMA I2C slave receive process complete callback.
   3657            * @param  hdma DMA handle
   3658            * @retval None
   3659            */

   \                                 In section .text, align 2, keep-with-next
   3660          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
   3661          {
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3662            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3663          
   3664            /* Wait until STOPF flag is reset */
   3665            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000006   0x2123             MOVS     R1,#+35
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00B             BEQ.N    ??I2C_DMASlaveReceiveCplt_0
   3666            {
   3667              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000012   0x6BA8             LDR      R0,[R5, #+56]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD104             BNE.N    ??I2C_DMASlaveReceiveCplt_1
   3668              {
   3669                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000018   0x6BA8             LDR      R0,[R5, #+56]
   \   0000001A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001E   0x63A8             STR      R0,[R5, #+56]
   \   00000020   0xE003             B.N      ??I2C_DMASlaveReceiveCplt_0
   3670              }
   3671              else
   3672              {
   3673                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_DMASlaveReceiveCplt_1: (+1)
   \   00000022   0x6BA8             LDR      R0,[R5, #+56]
   \   00000024   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000028   0x63A8             STR      R0,[R5, #+56]
   3674              }
   3675            }
   3676          
   3677            /* Clear STOPF flag */
   3678            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6940             LDR      R0,[R0, #+20]
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000038   0x6829             LDR      R1,[R5, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   3679          
   3680            /* Disable Address Acknowledge */
   3681            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000046   0x6829             LDR      R1,[R5, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   3682          
   3683            /* Disable DMA Request */
   3684            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000052   0x6829             LDR      R1,[R5, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
   3685          
   3686            hi2c->XferCount = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8568             STRH     R0,[R5, #+42]
   3687          
   3688            hi2c->State = HAL_I2C_STATE_READY;
   \   0000005A   0x2020             MOVS     R0,#+32
   \   0000005C   0xF885 0x0035      STRB     R0,[R5, #+53]
   3689            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF885 0x0036      STRB     R0,[R5, #+54]
   3690          
   3691            /* Check if Errors has been detected during transfer */
   3692            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000066   0x6BA8             LDR      R0,[R5, #+56]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD003             BEQ.N    ??I2C_DMASlaveReceiveCplt_2
   3693            {
   3694              HAL_I2C_ErrorCallback(hi2c);
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000072   0xE002             B.N      ??I2C_DMASlaveReceiveCplt_3
   3695            }
   3696            else
   3697            {
   3698              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveReceiveCplt_2: (+1)
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3699            }
   3700          }
   \                     ??I2C_DMASlaveReceiveCplt_3: (+1)
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3701          
   3702          /**
   3703            * @brief  DMA I2C Memory Write process complete callback
   3704            * @param  hdma DMA handle
   3705            * @retval None
   3706            */

   \                                 In section .text, align 4, keep-with-next
   3707          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)
   3708          {
   \                     I2C_DMAMemTransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3709            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3710          
   3711            /* Wait until BTF flag is reset */
   3712            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000006   0x2323             MOVS     R3,#+35
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable16_2  ;; 0x10004
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??I2C_DMAMemTransmitCplt_0
   3713            {
   3714              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000016   0x6BA8             LDR      R0,[R5, #+56]
   \   00000018   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001C   0x63A8             STR      R0,[R5, #+56]
   3715            }
   3716          
   3717            /* Generate Stop */
   3718            SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \                     ??I2C_DMAMemTransmitCplt_0: (+1)
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
   3719          
   3720            /* Disable DMA Request */
   3721            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   3722          
   3723            hi2c->XferCount = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8568             STRH     R0,[R5, #+42]
   3724          
   3725            hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF885 0x0035      STRB     R0,[R5, #+53]
   3726            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF885 0x0036      STRB     R0,[R5, #+54]
   3727          
   3728            /* Check if Errors has been detected during transfer */
   3729            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000046   0x6BA8             LDR      R0,[R5, #+56]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD003             BEQ.N    ??I2C_DMAMemTransmitCplt_1
   3730            {
   3731              HAL_I2C_ErrorCallback(hi2c);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000052   0xE002             B.N      ??I2C_DMAMemTransmitCplt_2
   3732            }
   3733            else
   3734            {
   3735              HAL_I2C_MemTxCpltCallback(hi2c);
   \                     ??I2C_DMAMemTransmitCplt_1: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   3736            }
   3737          }
   \                     ??I2C_DMAMemTransmitCplt_2: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3738          
   3739          /**
   3740            * @brief  DMA I2C Memory Read process complete callback
   3741            * @param  hdma DMA handle
   3742            * @retval None
   3743            */

   \                                 In section .text, align 4, keep-with-next
   3744          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)
   3745          {
   \                     I2C_DMAMemReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3746            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3747          
   3748            /* Disable Acknowledge */
   3749            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000000E   0x6829             LDR      R1,[R5, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   3750          
   3751            /* Generate Stop */
   3752            SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   3753          
   3754            /* Disable Last DMA */
   3755            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
   3756          
   3757            /* Disable DMA Request */
   3758            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   3759          
   3760            hi2c->XferCount = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8568             STRH     R0,[R5, #+42]
   3761          
   3762            hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF885 0x0035      STRB     R0,[R5, #+53]
   3763            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF885 0x0036      STRB     R0,[R5, #+54]
   3764          
   3765            /* Check if Errors has been detected during transfer */
   3766            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000046   0x6BA8             LDR      R0,[R5, #+56]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD003             BEQ.N    ??I2C_DMAMemReceiveCplt_0
   3767            {
   3768              HAL_I2C_ErrorCallback(hi2c);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000052   0xE002             B.N      ??I2C_DMAMemReceiveCplt_1
   3769            }
   3770            else
   3771            {
   3772              HAL_I2C_MemRxCpltCallback(hi2c);
   \                     ??I2C_DMAMemReceiveCplt_0: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   3773            }
   3774          }
   \                     ??I2C_DMAMemReceiveCplt_1: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3775          
   3776          /**
   3777            * @brief  DMA I2C communication error callback.
   3778            * @param  hdma DMA handle
   3779            * @retval None
   3780            */

   \                                 In section .text, align 4, keep-with-next
   3781          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   3782          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3783            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   3784          
   3785            /* Disable Acknowledge */
   3786            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000000E   0x6829             LDR      R1,[R5, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   3787          
   3788            hi2c->XferCount = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8568             STRH     R0,[R5, #+42]
   3789          
   3790            hi2c->State = HAL_I2C_STATE_READY;
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF885 0x0035      STRB     R0,[R5, #+53]
   3791            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF885 0x0036      STRB     R0,[R5, #+54]
   3792          
   3793            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   00000022   0x6BA8             LDR      R0,[R5, #+56]
   \   00000024   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000028   0x63A8             STR      R0,[R5, #+56]
   3794          
   3795            HAL_I2C_ErrorCallback(hi2c);
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3796          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3797          
   3798          /**
   3799            * @brief  This function handles I2C Communication Timeout.
   3800            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3801            *         the configuration information for I2C module
   3802            * @param  Flag specifies the I2C flag to check.
   3803            * @param  Status The new Flag status (SET or RESET).
   3804            * @param  Timeout Timeout duration
   3805            * @retval HAL status
   3806            */

   \                                 In section .text, align 2, keep-with-next
   3807          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   3808          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   3809            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   3810          
   3811            /* Get tick */
   3812            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   3813          
   3814            /* Wait until flag is set */
   3815            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD12D             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   3816            {
   3817              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x0C28             LSRS     R0,R5,#+16
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10A             BNE.N    ??I2C_WaitOnFlagUntilTimeout_2
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6940             LDR      R0,[R0, #+20]
   \   00000028   0x4028             ANDS     R0,R5,R0
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE00B             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE009             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x4028             ANDS     R0,R5,R0
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_5
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_5: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_4: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD140             BNE.N    ??I2C_WaitOnFlagUntilTimeout_6
   3818              {
   3819                /* Check for the Timeout */
   3820                if(Timeout != HAL_MAX_DELAY)
   \   00000052   0xF5B7 0x4F00      CMP      R7,#+32768
   \   00000056   0xD0E1             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_1
   3821                {
   3822                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD005             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_7
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000064   0x4287             CMP      R7,R0
   \   00000066   0xD2D9             BCS.N    ??I2C_WaitOnFlagUntilTimeout_1
   3823                  {
   3824                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnFlagUntilTimeout_7: (+1)
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0xF884 0x0035      STRB     R0,[R4, #+53]
   3825          
   3826                    /* Process Unlocked */
   3827                    __HAL_UNLOCK(hi2c);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF884 0x0034      STRB     R0,[R4, #+52]
   3828          
   3829                    return HAL_TIMEOUT;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE02E             B.N      ??I2C_WaitOnFlagUntilTimeout_8
   3830                  }
   3831                }
   3832              }
   3833            }
   3834            else
   3835            {
   3836              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \   00000078   0x0C28             LSRS     R0,R5,#+16
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD10A             BNE.N    ??I2C_WaitOnFlagUntilTimeout_9
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6940             LDR      R0,[R0, #+20]
   \   00000084   0x4028             ANDS     R0,R5,R0
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_10
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE00B             B.N      ??I2C_WaitOnFlagUntilTimeout_11
   \                     ??I2C_WaitOnFlagUntilTimeout_10: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE009             B.N      ??I2C_WaitOnFlagUntilTimeout_11
   \                     ??I2C_WaitOnFlagUntilTimeout_9: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0x4028             ANDS     R0,R5,R0
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_12
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_11
   \                     ??I2C_WaitOnFlagUntilTimeout_12: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_11: (+1)
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD012             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_6
   3837              {
   3838                /* Check for the Timeout */
   3839                if(Timeout != HAL_MAX_DELAY)
   \   000000AE   0xF5B7 0x4F00      CMP      R7,#+32768
   \   000000B2   0xD0E1             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   3840                {
   3841                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD005             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_13
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000C0   0x4287             CMP      R7,R0
   \   000000C2   0xD2D9             BCS.N    ??I2C_WaitOnFlagUntilTimeout_0
   3842                  {
   3843                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnFlagUntilTimeout_13: (+1)
   \   000000C4   0x2020             MOVS     R0,#+32
   \   000000C6   0xF884 0x0035      STRB     R0,[R4, #+53]
   3844          
   3845                    /* Process Unlocked */
   3846                    __HAL_UNLOCK(hi2c);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0034      STRB     R0,[R4, #+52]
   3847          
   3848                    return HAL_TIMEOUT;
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_8
   3849                  }
   3850                }
   3851              }
   3852            }
   3853            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_6: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_8: (+1)
   \   000000D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3854          }
   3855          
   3856          /**
   3857            * @brief  This function handles I2C Communication Timeout for Master addressing phase.
   3858            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
   3859            *         the configuration information for I2C module
   3860            * @param  Flag specifies the I2C flag to check.
   3861            * @param  Timeout Timeout duration
   3862            * @retval HAL status
   3863            */

   \                                 In section .text, align 2, keep-with-next
   3864          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout)
   3865          {
   \                     I2C_WaitOnMasterAddressFlagUntilTimeout: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3866            uint32_t tickstart = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   3867          
   3868            /* Get tick */
   3869            tickstart = HAL_GetTick();
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x0007             MOVS     R7,R0
   3870          
   3871            while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_0: (+1)
   \   00000010   0x0C28             LSRS     R0,R5,#+16
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD10A             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_1
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6940             LDR      R0,[R0, #+20]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_2
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE00B             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE009             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_1: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0x4028             ANDS     R0,R5,R0
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_4
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_3: (+1)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD129             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_5
   3872            {
   3873              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0x0540             LSLS     R0,R0,#+21
   \   0000004C   0xD513             BPL.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_6
   3874              {
   3875                /* Generate Stop */
   3876                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6008             STR      R0,[R1, #+0]
   3877          
   3878                /* Clear AF Flag */
   3879                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000005A   0xF47F 0x6080      MVNS     R0,#+1024
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6148             STR      R0,[R1, #+20]
   3880          
   3881                hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x63A0             STR      R0,[R4, #+56]
   3882                hi2c->State= HAL_I2C_STATE_READY;
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0xF884 0x0035      STRB     R0,[R4, #+53]
   3883          
   3884                /* Process Unlocked */
   3885                __HAL_UNLOCK(hi2c);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
   3886          
   3887                return HAL_ERROR;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE012             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   3888              }
   3889          
   3890              /* Check for the Timeout */
   3891              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_6: (+1)
   \   00000076   0xF5B6 0x4F00      CMP      R6,#+32768
   \   0000007A   0xD0C9             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   3892              {
   3893                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD004             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_8
   \   00000080   0x.... 0x....      BL       HAL_GetTick
   \   00000084   0x1BC0             SUBS     R0,R0,R7
   \   00000086   0x4286             CMP      R6,R0
   \   00000088   0xD2C2             BCS.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   3894                {
   3895                  hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_8: (+1)
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0xF884 0x0035      STRB     R0,[R4, #+53]
   3896          
   3897                  /* Process Unlocked */
   3898                  __HAL_UNLOCK(hi2c);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF884 0x0034      STRB     R0,[R4, #+52]
   3899          
   3900                  return HAL_TIMEOUT;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   3901                }
   3902              }
   3903            }
   3904            return HAL_OK;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_7: (+1)
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3905          }
   3906          
   3907          /**
   3908            * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
   3909            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3910            *                the configuration information for the specified I2C.
   3911            * @param  Timeout Timeout duration
   3912            * @retval HAL status
   3913            */

   \                                 In section .text, align 2, keep-with-next
   3914          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   3915          {  
   \                     I2C_WaitOnTXEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3916            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x0006             MOVS     R6,R0
   3917            
   3918            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0xD41C             BMI.N    ??I2C_WaitOnTXEFlagUntilTimeout_1
   3919            {
   3920              /* Check if a NACK is detected */
   3921              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_2
   3922              {
   3923                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE016             B.N      ??I2C_WaitOnTXEFlagUntilTimeout_3
   3924              }
   3925          		
   3926              /* Check for the Timeout */
   3927              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_2: (+1)
   \   00000022   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000026   0xD0F1             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   3928              {
   3929                if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD004             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_4
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0x1B80             SUBS     R0,R0,R6
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD2EA             BCS.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   3930                {
   3931                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_4: (+1)
   \   00000036   0x6BA0             LDR      R0,[R4, #+56]
   \   00000038   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003C   0x63A0             STR      R0,[R4, #+56]
   3932                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   3933          
   3934                  /* Process Unlocked */
   3935                  __HAL_UNLOCK(hi2c);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
   3936          
   3937                  return HAL_TIMEOUT;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xE000             B.N      ??I2C_WaitOnTXEFlagUntilTimeout_3
   3938                }
   3939              }
   3940            }
   3941            return HAL_OK;      
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_3: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   3942          }
   3943          
   3944          /**
   3945            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   3946            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3947            *                the configuration information for the specified I2C.
   3948            * @param  Timeout Timeout duration
   3949            * @retval HAL status
   3950            */

   \                                 In section .text, align 2, keep-with-next
   3951          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   3952          {  
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3953            uint32_t tickstart = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
   3954            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x0006             MOVS     R6,R0
   3955            
   3956            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6940             LDR      R0,[R0, #+20]
   \   00000012   0x06C0             LSLS     R0,R0,#+27
   \   00000014   0xD419             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   3957            {
   3958              /* Check if a NACK is detected */
   3959              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   3960              {
   3961                return HAL_ERROR;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE013             B.N      ??I2C_WaitOnSTOPFlagUntilTimeout_3
   3962              }
   3963          		
   3964              /* Check for the Timeout */
   3965              if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD004             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_4
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B80             SUBS     R0,R0,R6
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD2ED             BCS.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   3966              {
   3967                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_4: (+1)
   \   00000032   0x6BA0             LDR      R0,[R4, #+56]
   \   00000034   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000038   0x63A0             STR      R0,[R4, #+56]
   3968                hi2c->State= HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF884 0x0035      STRB     R0,[R4, #+53]
   3969          
   3970                /* Process Unlocked */
   3971                __HAL_UNLOCK(hi2c);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   3972          
   3973                return HAL_TIMEOUT;
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xE000             B.N      ??I2C_WaitOnSTOPFlagUntilTimeout_3
   3974              }
   3975            }
   3976            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_3: (+1)
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
   3977          }
   3978          
   3979          /**
   3980            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   3981            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3982            *                the configuration information for the specified I2C.
   3983            * @param  Timeout Timeout duration
   3984            * @retval HAL status
   3985            */

   \                                 In section .text, align 2, keep-with-next
   3986          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   3987          {  
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3988            uint32_t tickstart = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
   3989            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x0006             MOVS     R6,R0
   3990            
   3991            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6940             LDR      R0,[R0, #+20]
   \   00000012   0x0640             LSLS     R0,R0,#+25
   \   00000014   0xD424             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   3992            {
   3993              /* Check if a STOPF is detected */
   3994              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6940             LDR      R0,[R0, #+20]
   \   0000001A   0x06C0             LSLS     R0,R0,#+27
   \   0000001C   0xD50D             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_2
   3995              {
   3996                /* Clear STOP Flag */
   3997                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   0000001E   0xF07F 0x0010      MVNS     R0,#+16
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6148             STR      R0,[R1, #+20]
   3998          
   3999                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x63A0             STR      R0,[R4, #+56]
   4000                hi2c->State= HAL_I2C_STATE_READY;
   \   0000002A   0x2020             MOVS     R0,#+32
   \   0000002C   0xF884 0x0035      STRB     R0,[R4, #+53]
   4001          
   4002                /* Process Unlocked */
   4003                __HAL_UNLOCK(hi2c);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF884 0x0034      STRB     R0,[R4, #+52]
   4004          
   4005                return HAL_ERROR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE013             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_3
   4006              }
   4007          		
   4008              /* Check for the Timeout */
   4009              if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??I2C_WaitOnRXNEFlagUntilTimeout_4
   \   0000003E   0x.... 0x....      BL       HAL_GetTick
   \   00000042   0x1B80             SUBS     R0,R0,R6
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xD2E2             BCS.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   4010              {
   4011                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_4: (+1)
   \   00000048   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
   4012                hi2c->State= HAL_I2C_STATE_READY;
   \   00000050   0x2020             MOVS     R0,#+32
   \   00000052   0xF884 0x0035      STRB     R0,[R4, #+53]
   4013          
   4014                /* Process Unlocked */
   4015                __HAL_UNLOCK(hi2c);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x0034      STRB     R0,[R4, #+52]
   4016          
   4017                return HAL_TIMEOUT;
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xE000             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_3
   4018              }
   4019            }
   4020            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
   4021          }
   4022          
   4023          /**
   4024            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   4025            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4026            *                the configuration information for the specified I2C.
   4027            * @retval HAL status
   4028            */

   \                                 In section .text, align 2, keep-with-next
   4029          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
   4030          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   4031            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6940             LDR      R0,[R0, #+20]
   \   00000006   0x0540             LSLS     R0,R0,#+21
   \   00000008   0xD50D             BPL.N    ??I2C_IsAcknowledgeFailed_0
   4032            {
   4033              /* Clear NACKF Flag */
   4034              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000000A   0xF47F 0x6080      MVNS     R0,#+1024
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x6150             STR      R0,[R2, #+20]
   4035          
   4036              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x6388             STR      R0,[R1, #+56]
   4037              hi2c->State= HAL_I2C_STATE_READY;
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF881 0x0035      STRB     R0,[R1, #+53]
   4038          
   4039              /* Process Unlocked */
   4040              __HAL_UNLOCK(hi2c);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF881 0x0034      STRB     R0,[R1, #+52]
   4041          
   4042              return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??I2C_IsAcknowledgeFailed_1
   4043            }
   4044            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   4045          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xFFFF3000         DC32     0xffff3000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xFFFF7C00         DC32     0xffff7c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x00010080         DC32     0x10080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x00010008         DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x00010004         DC32     0x10004
   4046          /**
   4047            * @}
   4048            */
   4049          
   4050          #endif /* HAL_I2C_MODULE_ENABLED */
   4051          
   4052          /**
   4053            * @}
   4054            */
   4055          
   4056          /**
   4057            * @}
   4058            */
   4059          
   4060          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       8   HAL_I2C_ER_IRQHandler
         8   -> HAL_I2C_ErrorCallback
         8   -> I2C_Slave_AF
       8   HAL_I2C_EV_IRQHandler
         8   -> I2C_MasterReceive_BTF
         8   -> I2C_MasterReceive_RXNE
         8   -> I2C_MasterTransmit_BTF
         8   -> I2C_MasterTransmit_TXE
         8   -> I2C_SlaveReceive_BTF
         8   -> I2C_SlaveReceive_RXNE
         8   -> I2C_SlaveTransmit_BTF
         8   -> I2C_SlaveTransmit_TXE
         8   -> I2C_Slave_ADDR
         8   -> I2C_Slave_STOPF
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
      16   HAL_I2C_Init
        16   -> HAL_I2C_MspInit
        16   -> HAL_RCC_GetPCLK1Freq
      32   HAL_I2C_IsDeviceReady
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      32   HAL_I2C_Master_Receive
        32   -> I2C_MasterRequestRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
      24   HAL_I2C_Master_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
      24   HAL_I2C_Master_Receive_IT
        24   -> I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Master_Transmit
        32   -> I2C_MasterRequestWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      24   HAL_I2C_Master_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_MasterRequestWrite
        24   -> I2C_WaitOnFlagUntilTimeout
      24   HAL_I2C_Master_Transmit_IT
        24   -> I2C_MasterRequestWrite
        24   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      32   HAL_I2C_Mem_Read_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Mem_Read_IT
        32   -> I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
      40   HAL_I2C_Mem_Write
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Mem_Write_IT
        32   -> I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      24   HAL_I2C_Slave_Receive
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnRXNEFlagUntilTimeout
        24   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Slave_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_WaitOnFlagUntilTimeout
       4   HAL_I2C_Slave_Receive_IT
      24   HAL_I2C_Slave_Transmit
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnTXEFlagUntilTimeout
      24   HAL_I2C_Slave_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_WaitOnFlagUntilTimeout
       4   HAL_I2C_Slave_Transmit_IT
      16   I2C_DMAError
        16   -> HAL_I2C_ErrorCallback
      16   I2C_DMAMasterReceiveCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
      16   I2C_DMAMasterTransmitCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> I2C_WaitOnFlagUntilTimeout
      16   I2C_DMAMemReceiveCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemRxCpltCallback
      16   I2C_DMAMemTransmitCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemTxCpltCallback
        16   -> I2C_WaitOnFlagUntilTimeout
      16   I2C_DMASlaveReceiveCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   I2C_DMASlaveTransmitCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_WaitOnFlagUntilTimeout
       0   I2C_IsAcknowledgeFailed
       8   I2C_MasterReceive_BTF
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
      16   I2C_MasterReceive_RXNE
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
      24   I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnMasterAddressFlagUntilTimeout
      16   I2C_MasterRequestWrite
        16   -> I2C_WaitOnFlagUntilTimeout
        16   -> I2C_WaitOnMasterAddressFlagUntilTimeout
       8   I2C_MasterTransmit_BTF
         8   -> HAL_I2C_MasterTxCpltCallback
         8   -> HAL_I2C_MemTxCpltCallback
       0   I2C_MasterTransmit_TXE
      32   I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
       0   I2C_SlaveReceive_BTF
       0   I2C_SlaveReceive_RXNE
       0   I2C_SlaveTransmit_BTF
       0   I2C_SlaveTransmit_TXE
       4   I2C_Slave_ADDR
       8   I2C_Slave_AF
         8   -> HAL_I2C_SlaveTxCpltCallback
      16   I2C_Slave_STOPF
        16   -> HAL_I2C_SlaveRxCpltCallback
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      24   I2C_WaitOnMasterAddressFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable12
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable8
       4  ??DataTable9
      62  HAL_I2C_DeInit
     206  HAL_I2C_ER_IRQHandler
     308  HAL_I2C_EV_IRQHandler
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     370  HAL_I2C_Init
     352  HAL_I2C_IsDeviceReady
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     598  HAL_I2C_Master_Receive
     326  HAL_I2C_Master_Receive_DMA
     334  HAL_I2C_Master_Receive_IT
     312  HAL_I2C_Master_Transmit
     316  HAL_I2C_Master_Transmit_DMA
     230  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     616  HAL_I2C_Mem_Read
     280  HAL_I2C_Mem_Read_DMA
     320  HAL_I2C_Mem_Read_IT
     338  HAL_I2C_Mem_Write
     232  HAL_I2C_Mem_Write_DMA
     200  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     304  HAL_I2C_Slave_Receive
     194  HAL_I2C_Slave_Receive_DMA
     118  HAL_I2C_Slave_Receive_IT
     320  HAL_I2C_Slave_Transmit
     256  HAL_I2C_Slave_Transmit_DMA
     118  HAL_I2C_Slave_Transmit_IT
      50  I2C_DMAError
      92  I2C_DMAMasterReceiveCplt
      92  I2C_DMAMasterTransmitCplt
      92  I2C_DMAMemReceiveCplt
      92  I2C_DMAMemTransmitCplt
     124  I2C_DMASlaveReceiveCplt
     102  I2C_DMASlaveTransmitCplt
      42  I2C_IsAcknowledgeFailed
     166  I2C_MasterReceive_BTF
     124  I2C_MasterReceive_RXNE
     262  I2C_MasterRequestRead
     150  I2C_MasterRequestWrite
      92  I2C_MasterTransmit_BTF
      44  I2C_MasterTransmit_TXE
     342  I2C_RequestMemoryRead
     222  I2C_RequestMemoryWrite
      30  I2C_SlaveReceive_BTF
      30  I2C_SlaveReceive_RXNE
      30  I2C_SlaveTransmit_BTF
      30  I2C_SlaveTransmit_TXE
      24  I2C_Slave_ADDR
      52  I2C_Slave_AF
      66  I2C_Slave_STOPF
     218  I2C_WaitOnFlagUntilTimeout
     158  I2C_WaitOnMasterAddressFlagUntilTimeout
     100  I2C_WaitOnRXNEFlagUntilTimeout
      78  I2C_WaitOnSTOPFlagUntilTimeout
      82  I2C_WaitOnTXEFlagUntilTimeout

 
 9 798 bytes in section .text
 
 9 798 bytes of CODE memory

Errors: none
Warnings: none
