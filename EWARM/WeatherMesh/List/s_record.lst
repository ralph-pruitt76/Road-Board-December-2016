###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       30/Jan/2018  13:45:46
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\s_record.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\s_record.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -D WM -lCN
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List
#        -o
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.4\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List\s_record.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj\s_record.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\s_record.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : s_record.c
      4            * Description        : This file provides code for the parsing of S-Record data.
      5            * error buffer.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2017 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "s_record.h"
     37          #include "usart.h"
     38          #include "gpio.h"
     39          #include "i2c.h"
     40          #include <stdio.h>
     41          #include <string.h>
     42          
     43          
     44          /**
     45            * @brief  This function Parses the passed s-record file.
     46            * @param  char *tempBffr      Pointer to passed Chars to be translated
     47            * @param  SrecElmentPtr SrecPtr    Pointer to Structure to receive results of Translation
     48            * @retval HAL_StatusTypeDef:     HAL_OK:       No Errors
     49            *                                HAL_ERROR:    Error Found during initialization.
     50            */

   \                                 In section .text, align 2, keep-with-next
     51          HAL_StatusTypeDef Parse_srecord( char *tempBffr, SrecElmentPtr SrecPtr )
     52          {
   \                     Parse_srecord: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     53            uint8_t ByteBffr[BYTE_BFFR_SIZE];     // Bffr to Convert Bytes.
     54            uint8_t Calc_Checksum;                // Used to Verify Checksum;
     55            int x;
     56            
     57            // Set Passed SRec Error Code to null....
     58            SrecPtr->Srec_Err = NO_ERROR;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7068             STRB     R0,[R5, #+1]
     59            SrecPtr->Address = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x60A8             STR      R0,[R5, #+8]
     60            
     61            // Clear Out Passed Buffer before populating.
     62            for (x=0; x<SREC_SIZE; x++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0007             MOVS     R7,R0
   \                     ??Parse_srecord_0: (+1)
   \   00000014   0x2F46             CMP      R7,#+70
   \   00000016   0xDA05             BGE.N    ??Parse_srecord_1
     63              SrecPtr->Data[x] = 0x00;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xEB05 0x0107      ADD      R1,R5,R7
   \   0000001E   0x7348             STRB     R0,[R1, #+13]
   \   00000020   0x1C7F             ADDS     R7,R7,#+1
   \   00000022   0xE7F7             B.N      ??Parse_srecord_0
     64            // Validate if this is an S-Record.
     65            if (tempBffr[0] != 'S')
   \                     ??Parse_srecord_1: (+1)
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2853             CMP      R0,#+83
   \   00000028   0xD003             BEQ.N    ??Parse_srecord_2
     66            {
     67              SrecPtr->Srec_Err = ILLEGAL_SREC;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7068             STRB     R0,[R5, #+1]
     68              return HAL_ERROR;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE0F3             B.N      ??Parse_srecord_3
     69            }
     70            
     71            // Get Byte Count.
     72            if (Get_Bytes( 1, &tempBffr[2], ByteBffr ) != HAL_OK)
   \                     ??Parse_srecord_2: (+1)
   \   00000032   0x466A             MOV      R2,SP
   \   00000034   0x1CA1             ADDS     R1,R4,#+2
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       Get_Bytes
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??Parse_srecord_4
     73            {
     74              // Illegal Byte Count Value.
     75              SrecPtr->Srec_Err = ILLEGAL_BYTE_CNT;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0x7068             STRB     R0,[R5, #+1]
     76              return HAL_ERROR;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE0E8             B.N      ??Parse_srecord_3
     77            }
     78            // Now Save Byte Count.
     79            SrecPtr->ByteCount = *ByteBffr;
   \                     ??Parse_srecord_4: (+1)
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x6068             STR      R0,[R5, #+4]
     80            // Now get all remaining bytes in Record.
     81            if (Get_Bytes( SrecPtr->ByteCount+1, &tempBffr[2], ByteBffr ) != HAL_OK)
   \   0000004E   0x466A             MOV      R2,SP
   \   00000050   0x1CA1             ADDS     R1,R4,#+2
   \   00000052   0x6868             LDR      R0,[R5, #+4]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       Get_Bytes
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD003             BEQ.N    ??Parse_srecord_5
     82            {
     83              // Illegal Byte Count Value.
     84              SrecPtr->Srec_Err = ILLEGAL_BYTE_DATA;
   \   00000060   0x2005             MOVS     R0,#+5
   \   00000062   0x7068             STRB     R0,[R5, #+1]
     85              return HAL_ERROR;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE0D8             B.N      ??Parse_srecord_3
     86            }
     87            // Place ChkSum into Structure.
     88            SrecPtr->Checksum = ByteBffr[SrecPtr->ByteCount];
   \                     ??Parse_srecord_5: (+1)
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x6869             LDR      R1,[R5, #+4]
   \   0000006C   0x5C40             LDRB     R0,[R0, R1]
   \   0000006E   0x7328             STRB     R0,[R5, #+12]
     89            // Now Calculate CheckSum.
     90            Calc_Checksum = Calc_ChkSum( (SrecPtr->ByteCount), ByteBffr );
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x6868             LDR      R0,[R5, #+4]
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x.... 0x....      BL       Calc_ChkSum
   \   0000007A   0x0006             MOVS     R6,R0
     91            if (Calc_Checksum != SrecPtr->Checksum)
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x7B29             LDRB     R1,[R5, #+12]
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD003             BEQ.N    ??Parse_srecord_6
     92            {
     93              // Illegal Byte Count Value.
     94              SrecPtr->Srec_Err = BAD_CHECKSUM;
   \   00000086   0x2006             MOVS     R0,#+6
   \   00000088   0x7068             STRB     R0,[R5, #+1]
     95              return HAL_ERROR;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE0C5             B.N      ??Parse_srecord_3
     96            }
     97            
     98            // OK...Now Determine what Kind of S-Record and process it.
     99            switch (tempBffr[1])
   \                     ??Parse_srecord_6: (+1)
   \   0000008E   0x7860             LDRB     R0,[R4, #+1]
   \   00000090   0x2830             CMP      R0,#+48
   \   00000092   0xD013             BEQ.N    ??Parse_srecord_7
   \   00000094   0xF0C0 0x80BC      BCC.W    ??Parse_srecord_8
   \   00000098   0x2832             CMP      R0,#+50
   \   0000009A   0xD03B             BEQ.N    ??Parse_srecord_9
   \   0000009C   0xD324             BCC.N    ??Parse_srecord_10
   \   0000009E   0x2834             CMP      R0,#+52
   \   000000A0   0xD070             BEQ.N    ??Parse_srecord_11
   \   000000A2   0xD351             BCC.N    ??Parse_srecord_12
   \   000000A4   0x2836             CMP      R0,#+54
   \   000000A6   0xD07B             BEQ.N    ??Parse_srecord_13
   \   000000A8   0xD370             BCC.N    ??Parse_srecord_14
   \   000000AA   0x2838             CMP      R0,#+56
   \   000000AC   0xF000 0x8098      BEQ.W    ??Parse_srecord_15
   \   000000B0   0xF0C0 0x8084      BCC.W    ??Parse_srecord_16
   \   000000B4   0x2839             CMP      R0,#+57
   \   000000B6   0xF000 0x80A1      BEQ.W    ??Parse_srecord_17
   \   000000BA   0xE0A9             B.N      ??Parse_srecord_8
    100            {
    101              case '0':
    102                // S0: Header: vendor specific ASCII text represented as a series of hex digit pairs
    103                SrecPtr->RecordType = S0_HEADER;
   \                     ??Parse_srecord_7: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
    104                // Now Get Address Field...
    105                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<8) + ByteBffr[2];
   \   000000C0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000C4   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000000C8   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   000000CC   0x60A8             STR      R0,[R5, #+8]
    106                // Populate Data Field
    107                for (x=3; x<SrecPtr->ByteCount; x++)
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0x0007             MOVS     R7,R0
   \                     ??Parse_srecord_18: (+1)
   \   000000D2   0x6868             LDR      R0,[R5, #+4]
   \   000000D4   0x4287             CMP      R7,R0
   \   000000D6   0xD206             BCS.N    ??Parse_srecord_19
    108                  SrecPtr->Data[x-3] = ByteBffr[x];
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x5DC0             LDRB     R0,[R0, R7]
   \   000000DC   0xEB05 0x0107      ADD      R1,R5,R7
   \   000000E0   0x7288             STRB     R0,[R1, #+10]
   \   000000E2   0x1C7F             ADDS     R7,R7,#+1
   \   000000E4   0xE7F5             B.N      ??Parse_srecord_18
    109                break;
   \                     ??Parse_srecord_19: (+1)
   \   000000E6   0xE097             B.N      ??Parse_srecord_20
    110              case '1':
    111                // S1: Data: data that starts at the 16-bit address field.
    112                SrecPtr->RecordType = S1_DATA;
   \                     ??Parse_srecord_10: (+1)
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x7028             STRB     R0,[R5, #+0]
    113                // Now Get Address Field...
    114                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<8) + ByteBffr[2];
   \   000000EC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000F0   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000000F4   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   000000F8   0x60A8             STR      R0,[R5, #+8]
    115                // Populate Data Field
    116                for (x=3; x<SrecPtr->ByteCount; x++)
   \   000000FA   0x2003             MOVS     R0,#+3
   \   000000FC   0x0007             MOVS     R7,R0
   \                     ??Parse_srecord_21: (+1)
   \   000000FE   0x6868             LDR      R0,[R5, #+4]
   \   00000100   0x4287             CMP      R7,R0
   \   00000102   0xD206             BCS.N    ??Parse_srecord_22
    117                  SrecPtr->Data[x-3] = ByteBffr[x];
   \   00000104   0x4668             MOV      R0,SP
   \   00000106   0x5DC0             LDRB     R0,[R0, R7]
   \   00000108   0xEB05 0x0107      ADD      R1,R5,R7
   \   0000010C   0x7288             STRB     R0,[R1, #+10]
   \   0000010E   0x1C7F             ADDS     R7,R7,#+1
   \   00000110   0xE7F5             B.N      ??Parse_srecord_21
    118                break;
   \                     ??Parse_srecord_22: (+1)
   \   00000112   0xE081             B.N      ??Parse_srecord_20
    119              case '2':
    120                // S2: Data: data that starts at a 24-bit address.
    121                SrecPtr->RecordType = S2_DATA;
   \                     ??Parse_srecord_9: (+1)
   \   00000114   0x2002             MOVS     R0,#+2
   \   00000116   0x7028             STRB     R0,[R5, #+0]
    122                // Now Get Address Field...
    123                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<16) + (uint32_t)(ByteBffr[2]<<8) + ByteBffr[3];
   \   00000118   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000011C   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000120   0x0209             LSLS     R1,R1,#+8
   \   00000122   0xEB11 0x4000      ADDS     R0,R1,R0, LSL #+16
   \   00000126   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   0000012A   0x1808             ADDS     R0,R1,R0
   \   0000012C   0x60A8             STR      R0,[R5, #+8]
    124                // Populate Data Field
    125                for (x=4; x<SrecPtr->ByteCount; x++)
   \   0000012E   0x2004             MOVS     R0,#+4
   \   00000130   0x0007             MOVS     R7,R0
   \                     ??Parse_srecord_23: (+1)
   \   00000132   0x6868             LDR      R0,[R5, #+4]
   \   00000134   0x4287             CMP      R7,R0
   \   00000136   0xD206             BCS.N    ??Parse_srecord_24
    126                  SrecPtr->Data[x-4] = ByteBffr[x];
   \   00000138   0x4668             MOV      R0,SP
   \   0000013A   0x5DC0             LDRB     R0,[R0, R7]
   \   0000013C   0xEB05 0x0107      ADD      R1,R5,R7
   \   00000140   0x7248             STRB     R0,[R1, #+9]
   \   00000142   0x1C7F             ADDS     R7,R7,#+1
   \   00000144   0xE7F5             B.N      ??Parse_srecord_23
    127                break;
   \                     ??Parse_srecord_24: (+1)
   \   00000146   0xE067             B.N      ??Parse_srecord_20
    128              case '3':
    129                // S3: Data: data that starts at a 32-bit address.
    130                SrecPtr->RecordType = S3_DATA;
   \                     ??Parse_srecord_12: (+1)
   \   00000148   0x2003             MOVS     R0,#+3
   \   0000014A   0x7028             STRB     R0,[R5, #+0]
    131                // Now Get Address Field...
    132                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<24) + (uint32_t)(ByteBffr[2]<<16) + (uint32_t)(ByteBffr[3]<<8) + ByteBffr[4];
   \   0000014C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000150   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000154   0x0409             LSLS     R1,R1,#+16
   \   00000156   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   0000015A   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   0000015E   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000162   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000166   0x1808             ADDS     R0,R1,R0
   \   00000168   0x60A8             STR      R0,[R5, #+8]
    133                // Populate Data Field
    134                for (x=5; x<SrecPtr->ByteCount; x++)
   \   0000016A   0x2005             MOVS     R0,#+5
   \   0000016C   0x0007             MOVS     R7,R0
   \                     ??Parse_srecord_25: (+1)
   \   0000016E   0x6868             LDR      R0,[R5, #+4]
   \   00000170   0x4287             CMP      R7,R0
   \   00000172   0xD206             BCS.N    ??Parse_srecord_26
    135                  SrecPtr->Data[x-5] = ByteBffr[x];
   \   00000174   0x4668             MOV      R0,SP
   \   00000176   0x5DC0             LDRB     R0,[R0, R7]
   \   00000178   0xEB05 0x0107      ADD      R1,R5,R7
   \   0000017C   0x7208             STRB     R0,[R1, #+8]
   \   0000017E   0x1C7F             ADDS     R7,R7,#+1
   \   00000180   0xE7F5             B.N      ??Parse_srecord_25
    136                break;
   \                     ??Parse_srecord_26: (+1)
   \   00000182   0xE049             B.N      ??Parse_srecord_20
    137              case '4':
    138                // S4: Reserved: ERROR.
    139                SrecPtr->Srec_Err = RESERVED_RECORD;
   \                     ??Parse_srecord_11: (+1)
   \   00000184   0x2003             MOVS     R0,#+3
   \   00000186   0x7068             STRB     R0,[R5, #+1]
    140                return HAL_ERROR;
   \   00000188   0x2001             MOVS     R0,#+1
   \   0000018A   0xE046             B.N      ??Parse_srecord_3
    141                break;
    142              case '5':
    143                // S5: Count: 16-bit count of S1 / S2 / S3 records.
    144                SrecPtr->RecordType = S5_COUNT;
   \                     ??Parse_srecord_14: (+1)
   \   0000018C   0x2005             MOVS     R0,#+5
   \   0000018E   0x7028             STRB     R0,[R5, #+0]
    145                // Now Get 16-Bit Count Field...
    146                SrecPtr->ByteCount = (uint32_t)(ByteBffr[1]<<8) + ByteBffr[2];
   \   00000190   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000194   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000198   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000019C   0x6068             STR      R0,[R5, #+4]
    147                break;
   \   0000019E   0xE03B             B.N      ??Parse_srecord_20
    148              case '6':
    149                // S6: Count: 24-bit count of S1 / S2 / S3 records.
    150                SrecPtr->RecordType = S6_COUNT;
   \                     ??Parse_srecord_13: (+1)
   \   000001A0   0x2006             MOVS     R0,#+6
   \   000001A2   0x7028             STRB     R0,[R5, #+0]
    151                // Now Get 24-Bit Count Field...
    152                SrecPtr->ByteCount = (uint32_t)(ByteBffr[1]<<16) + (uint32_t)(ByteBffr[2]<<8) + ByteBffr[3];
   \   000001A4   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001A8   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000001AC   0x0209             LSLS     R1,R1,#+8
   \   000001AE   0xEB11 0x4000      ADDS     R0,R1,R0, LSL #+16
   \   000001B2   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000001B6   0x1808             ADDS     R0,R1,R0
   \   000001B8   0x6068             STR      R0,[R5, #+4]
    153                break;
   \   000001BA   0xE02D             B.N      ??Parse_srecord_20
    154              case '7':
    155                // S7: Start Address: starting execution location at a 32-bit address.
    156                SrecPtr->RecordType = S7_START;
   \                     ??Parse_srecord_16: (+1)
   \   000001BC   0x2007             MOVS     R0,#+7
   \   000001BE   0x7028             STRB     R0,[R5, #+0]
    157                // Now Get Address Field...
    158                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<24) + (uint32_t)(ByteBffr[2]<<16) + (uint32_t)(ByteBffr[3]<<8) + ByteBffr[4];
   \   000001C0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001C4   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000001C8   0x0409             LSLS     R1,R1,#+16
   \   000001CA   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   000001CE   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000001D2   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   000001D6   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000001DA   0x1808             ADDS     R0,R1,R0
   \   000001DC   0x60A8             STR      R0,[R5, #+8]
    159                break;
   \   000001DE   0xE01B             B.N      ??Parse_srecord_20
    160              case '8':
    161                // S8: Start Address: starting execution location at a 24-bit address.
    162                SrecPtr->RecordType = S8_START;
   \                     ??Parse_srecord_15: (+1)
   \   000001E0   0x2008             MOVS     R0,#+8
   \   000001E2   0x7028             STRB     R0,[R5, #+0]
    163                // Now Get Address Field...
    164                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<16) + (uint32_t)(ByteBffr[2]<<8) + ByteBffr[3];
   \   000001E4   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001E8   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000001EC   0x0209             LSLS     R1,R1,#+8
   \   000001EE   0xEB11 0x4000      ADDS     R0,R1,R0, LSL #+16
   \   000001F2   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000001F6   0x1808             ADDS     R0,R1,R0
   \   000001F8   0x60A8             STR      R0,[R5, #+8]
    165                break;
   \   000001FA   0xE00D             B.N      ??Parse_srecord_20
    166              case '9':
    167                // S9: Start Address: starting execution location at a 16-bit address.
    168                SrecPtr->RecordType = S9_START;
   \                     ??Parse_srecord_17: (+1)
   \   000001FC   0x2009             MOVS     R0,#+9
   \   000001FE   0x7028             STRB     R0,[R5, #+0]
    169                // Now Get Address Field...
    170                SrecPtr->Address = (uint32_t)(ByteBffr[1]<<8) + ByteBffr[2];
   \   00000200   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000204   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000208   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000020C   0x60A8             STR      R0,[R5, #+8]
    171                break;
   \   0000020E   0xE003             B.N      ??Parse_srecord_20
    172              default:
    173                // ERROR
    174                SrecPtr->Srec_Err = ILLEGAL_RECORD;
   \                     ??Parse_srecord_8: (+1)
   \   00000210   0x2002             MOVS     R0,#+2
   \   00000212   0x7068             STRB     R0,[R5, #+1]
    175                return HAL_ERROR;
   \   00000214   0x2001             MOVS     R0,#+1
   \   00000216   0xE000             B.N      ??Parse_srecord_3
    176                break;
    177            } //EndSwitch (tempBffr[1])
    178          
    179            // Done Return HAL_OK.
    180            return HAL_OK;
   \                     ??Parse_srecord_20: (+1)
   \   00000218   0x2000             MOVS     R0,#+0
   \                     ??Parse_srecord_3: (+1)
   \   0000021A   0xB00D             ADD      SP,SP,#+52
   \   0000021C   0xBDF0             POP      {R4-R7,PC}       ;; return
    181          }
    182          
    183          /**
    184            * @brief  This function converts the passed bffr to Bytes.
    185            * @param  uint8_t size        Number of Bytes to translate
    186            * @param  char *tempBffr      Pointer to passed Chars to be translated
    187            * @param  uint8_t *bytePtr    Resulting bytes converted from Characters passed.
    188            * @retval HAL_StatusTypeDef:     HAL_OK:       No Errors
    189            *                                HAL_ERROR:    Error Found during initialization.
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          HAL_StatusTypeDef Get_Bytes( uint8_t size, char *tempBffr, uint8_t *bytePtr )
    192          {
   \                     Get_Bytes: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    193            uint8_t temp_Size;
    194            uint8_t temp_Value;
    195            uint8_t temp_Value2;
    196            
    197            for (temp_Size=0; temp_Size<size; temp_Size++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   \                     ??Get_Bytes_0: (+1)
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x0039             MOVS     R1,R7
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD224             BCS.N    ??Get_Bytes_1
    198            {
    199              // Get First Char in pointed and verify if Number 0-9 or a-f or A-F.
    200              if (Get_Nibble( tempBffr, &temp_Value ) != HAL_OK)
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       Get_Nibble
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??Get_Bytes_2
    201                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE01D             B.N      ??Get_Bytes_3
    202              tempBffr++;
   \                     ??Get_Bytes_2: (+1)
   \   00000028   0x1C64             ADDS     R4,R4,#+1
    203              
    204              // OK. We Now Have a good value. Convert to MSB Value.
    205              temp_Value = temp_Value << 4;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0x0100             LSLS     R0,R0,#+4
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    206              // Get Next Nibble
    207              if (Get_Nibble( tempBffr, &temp_Value2 ) != HAL_OK)
   \   00000034   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       Get_Nibble
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD001             BEQ.N    ??Get_Bytes_4
    208                return HAL_ERROR;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE00E             B.N      ??Get_Bytes_3
    209              tempBffr++;
   \                     ??Get_Bytes_4: (+1)
   \   00000046   0x1C64             ADDS     R4,R4,#+1
    210          
    211              // Now Add the new Value into result
    212              temp_Value += temp_Value2;
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000050   0x1808             ADDS     R0,R1,R0
   \   00000052   0xF88D 0x0000      STRB     R0,[SP, #+0]
    213              // Store Result.
    214              *bytePtr = temp_Value;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0x7028             STRB     R0,[R5, #+0]
    215              bytePtr++;
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
    216            } //Enfor (temp_Size=0; temp_Size<size; temp_Size++)
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7D4             B.N      ??Get_Bytes_0
    217            
    218            // Done. Return HAL_OK.
    219            return HAL_OK;
   \                     ??Get_Bytes_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??Get_Bytes_3: (+1)
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    220          }
    221          
    222          /**
    223            * @brief  This function converts the passed Char to Byte.
    224            * @param  char *tempBffr      Pointer to passed Char to be translated
    225            * @param  uint8_t *Result     Resulting byte converted from Character passed.
    226            * @retval HAL_StatusTypeDef:     HAL_OK:       No Errors
    227            *                                HAL_ERROR:    Error Found during initialization.
    228            */

   \                                 In section .text, align 2, keep-with-next
    229          HAL_StatusTypeDef Get_Nibble( char *tempBffr, uint8_t *Result )
    230          {
   \                     Get_Nibble: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    231            // Get Char in pointed and verify if Number 0-9 or a-f or A-F.
    232            if ( (*tempBffr>= '0') && (*tempBffr<= '9') )
   \   00000002   0x7810             LDRB     R0,[R2, #+0]
   \   00000004   0x2830             CMP      R0,#+48
   \   00000006   0xDB06             BLT.N    ??Get_Nibble_0
   \   00000008   0x7810             LDRB     R0,[R2, #+0]
   \   0000000A   0x283A             CMP      R0,#+58
   \   0000000C   0xDA03             BGE.N    ??Get_Nibble_0
    233            {
    234              *Result = (uint8_t)(*tempBffr) - (uint8_t)('0');
   \   0000000E   0x7810             LDRB     R0,[R2, #+0]
   \   00000010   0x3830             SUBS     R0,R0,#+48
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   \   00000014   0xE015             B.N      ??Get_Nibble_1
    235            }
    236            else if ( (*tempBffr>= 'a') && (*tempBffr<= 'f') )
   \                     ??Get_Nibble_0: (+1)
   \   00000016   0x7810             LDRB     R0,[R2, #+0]
   \   00000018   0x2861             CMP      R0,#+97
   \   0000001A   0xDB06             BLT.N    ??Get_Nibble_2
   \   0000001C   0x7810             LDRB     R0,[R2, #+0]
   \   0000001E   0x2867             CMP      R0,#+103
   \   00000020   0xDA03             BGE.N    ??Get_Nibble_2
    237            {
    238              *Result = ((uint8_t)(*tempBffr) - (uint8_t)('a')) + 10;
   \   00000022   0x7810             LDRB     R0,[R2, #+0]
   \   00000024   0x3857             SUBS     R0,R0,#+87
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   \   00000028   0xE00B             B.N      ??Get_Nibble_1
    239            }
    240            else if ( (*tempBffr>= 'A') && (*tempBffr<= 'F') )
   \                     ??Get_Nibble_2: (+1)
   \   0000002A   0x7810             LDRB     R0,[R2, #+0]
   \   0000002C   0x2841             CMP      R0,#+65
   \   0000002E   0xDB06             BLT.N    ??Get_Nibble_3
   \   00000030   0x7810             LDRB     R0,[R2, #+0]
   \   00000032   0x2847             CMP      R0,#+71
   \   00000034   0xDA03             BGE.N    ??Get_Nibble_3
    241            {
    242              *Result = ((uint8_t)(*tempBffr) - (uint8_t)('A')) + 10;
   \   00000036   0x7810             LDRB     R0,[R2, #+0]
   \   00000038   0x3837             SUBS     R0,R0,#+55
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   \   0000003C   0xE001             B.N      ??Get_Nibble_1
    243            }
    244            else
    245              return HAL_ERROR;
   \                     ??Get_Nibble_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE000             B.N      ??Get_Nibble_4
    246            return HAL_OK;
   \                     ??Get_Nibble_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??Get_Nibble_4: (+1)
   \   00000044   0x4770             BX       LR               ;; return
    247          }
    248          
    249          /**
    250            * @brief  This function calculates the Checksum of the passed data.
    251            * @param  uint8_t size        Number of Bytes to translate
    252            * @param  uint8_t *bytePtr    Bffr of Bytes to Calculate Checksum.
    253            * @retval uint8_t:     Calculated Checksum
    254            */

   \                                 In section .text, align 2, keep-with-next
    255          uint8_t Calc_ChkSum( uint8_t size, uint8_t *bytePtr )
    256          {
   \                     Calc_ChkSum: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    257            uint16_t temp_value;
    258            uint8_t final_value;
    259            int x;
    260            
    261            // Clear temp_value
    262            temp_value = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x002B             MOVS     R3,R5
    263            
    264            // Now Calculate Checksum.
    265            for (x=0; x<size; x++)
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x002C             MOVS     R4,R5
   \                     ??Calc_ChkSum_0: (+1)
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x4294             CMP      R4,R2
   \   00000010   0xDA04             BGE.N    ??Calc_ChkSum_1
    266            {
    267              temp_value += *bytePtr++;
   \   00000012   0x780D             LDRB     R5,[R1, #+0]
   \   00000014   0x18EB             ADDS     R3,R5,R3
   \   00000016   0x1C49             ADDS     R1,R1,#+1
    268            }
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \   0000001A   0xE7F7             B.N      ??Calc_ChkSum_0
    269            
    270            // Now Convert to final_value
    271            final_value = (uint8_t)(temp_value & 0xff);
   \                     ??Calc_ChkSum_1: (+1)
   \   0000001C   0x001D             MOVS     R5,R3
   \   0000001E   0x0028             MOVS     R0,R5
    272            
    273            // Get ones compliment
    274            final_value ^=0xff;
   \   00000020   0xF090 0x00FF      EORS     R0,R0,#0xFF
    275          
    276            return final_value;
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
    277          }
    278          
    279          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Calc_ChkSum
      24   Get_Bytes
        24   -> Get_Nibble
       0   Get_Nibble
      72   Parse_srecord
        72   -> Calc_ChkSum
        72   -> Get_Bytes


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      42  Calc_ChkSum
     102  Get_Bytes
      70  Get_Nibble
     542  Parse_srecord

 
 756 bytes in section .text
 
 756 bytes of CODE memory

Errors: none
Warnings: none
