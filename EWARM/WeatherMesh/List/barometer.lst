###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       31/Jan/2018  11:51:07
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\barometer.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\barometer.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -D WM -lCN
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List
#        -o
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.4\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\List\barometer.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\WeatherMesh\Obj\barometer.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\barometer.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : barometer.c
      4            * Description        : This file provides code for the control of the baromoeter
      5            *                      hardware based on the LPS22HB chip.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "barometer.h"
     37          #include "Calibration.h"
     38          
     39          /* barometer init function */
     40          /**
     41            * @brief  RoadBrd_Init_Barometer( void )
     42            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
     43            *                                HAL_ERROR:    Error found in Tasking or data passed.
     44            *                                HAL_BUSY:     UART is busy.
     45            *                                HAL_TIMEOUT:  UART timed out.
     46            */

   \                                 In section .text, align 2, keep-with-next
     47          HAL_StatusTypeDef RoadBrd_Init_Barometer( void )
     48          {
   \                     RoadBrd_Init_Barometer: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
     49          //  uint8_t tempBuffer[2];
     50          //  HAL_StatusTypeDef Status;
     51            PRESSURE_StatusTypeDef Status2;
     52          
     53            PRESSURE_InitTypeDef LPS25HB_InitStructure;
     54            
     55            /* Set up the pressure/temperature sensor init structure */
     56            LPS25HB_InitStructure.OutputDataRate = LPS25HB_ODR_7Hz;               /*!< Output Data Rate: P - 7Hz, T - 7Hz */
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
     57            LPS25HB_InitStructure.PressureResolution = LPS25HB_P_RES_AVG_32;      // LPS25HB_Pressure_Resolution_Selection 32Bit
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
     58            LPS25HB_InitStructure.TemperatureResolution = LPS25HB_T_RES_AVG_32;   // LPS25HB_Temperature_Resolution_Selection 32Bit
   \   0000000E   0x2008             MOVS     R0,#+8
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
     59            LPS25HB_InitStructure.DiffEnable = LPS25HB_DIFF_DISABLE;              /*!< interrupt circuit enabled */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
     60            LPS25HB_InitStructure.BlockDataUpdate = LPS25HB_BDU_CONT;             /*!< continuous update */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
     61            LPS25HB_InitStructure.SPIMode = LPS25HB_SPI_SIM_4W;                   /*!< 4-wire interface */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0005      STRB     R0,[SP, #+5]
     62            
     63            /* Initialize the pressure/temperature sensor */
     64            Status2 = LPS25HB_Init(&LPS25HB_InitStructure);
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       LPS25HB_Init
   \   0000002C   0x0004             MOVS     R4,R0
     65            switch(Status2)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD005             BEQ.N    ??RoadBrd_Init_Barometer_0
   \   00000034   0x2C02             CMP      R4,#+2
   \   00000036   0xD007             BEQ.N    ??RoadBrd_Init_Barometer_1
   \   00000038   0xD304             BCC.N    ??RoadBrd_Init_Barometer_2
   \   0000003A   0x2C03             CMP      R4,#+3
   \   0000003C   0xD006             BEQ.N    ??RoadBrd_Init_Barometer_3
   \   0000003E   0xE007             B.N      ??RoadBrd_Init_Barometer_4
     66            {
     67              case PRESSURE_OK:
     68                return HAL_OK;
   \                     ??RoadBrd_Init_Barometer_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE006             B.N      ??RoadBrd_Init_Barometer_5
     69              case PRESSURE_ERROR:
     70                return HAL_ERROR;
   \                     ??RoadBrd_Init_Barometer_2: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE004             B.N      ??RoadBrd_Init_Barometer_5
     71              case PRESSURE_TIMEOUT:
     72                return HAL_TIMEOUT;
   \                     ??RoadBrd_Init_Barometer_1: (+1)
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0xE002             B.N      ??RoadBrd_Init_Barometer_5
     73              case PRESSURE_NOT_IMPLEMENTED:
     74                return HAL_ERROR;
   \                     ??RoadBrd_Init_Barometer_3: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE000             B.N      ??RoadBrd_Init_Barometer_5
     75              default:
     76                return HAL_ERROR;
   \                     ??RoadBrd_Init_Barometer_4: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Init_Barometer_5: (+1)
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     77            }
     78          }
     79          /* Misc barometer functions */
     80          /**
     81            * @brief  RoadBrd_Enable_Barometer( void )
     82            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
     83            *                                HAL_ERROR:    Error found in Tasking or data passed.
     84            *                                HAL_BUSY:     UART is busy.
     85            *                                HAL_TIMEOUT:  UART timed out.
     86            */

   \                                 In section .text, align 2, keep-with-next
     87          HAL_StatusTypeDef RoadBrd_Enable_Barometer( void )
     88          {
   \                     RoadBrd_Enable_Barometer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     89            uint8_t tempBuffer[2];
     90            HAL_StatusTypeDef Status;
     91          
     92            // CTRL_REG1 =	1000.0100 > 0x86
     93            tempBuffer[0] = 0x80;
   \   00000004   0x2080             MOVS     R0,#+128
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
     94            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
     95          #ifdef REV_L
     96            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG1, tempBuffer, (uint16_t)1);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0x20BA             MOVS     R0,#+186
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0004             MOVS     R4,R0
     97            // 2. If Status was good, Time to get response.
     98            if (Status == HAL_OK)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD109             BNE.N    ??RoadBrd_Enable_Barometer_0
     99            {
    100              // Now wait for completion of XMIT.
    101              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0004             MOVS     R4,R0
    102              if (Status != HAL_OK)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_Enable_Barometer_0
    103                return Status;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE001             B.N      ??RoadBrd_Enable_Barometer_1
    104            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    105            return Status;
   \                     ??RoadBrd_Enable_Barometer_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_Enable_Barometer_1: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    106          #else
    107            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG1, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
    108            return Status;
    109          #endif
    110          }
    111          
    112          /**
    113            * @brief  RoadBrd_Disable_Barometer( void )
    114            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    115            *                                HAL_ERROR:    Error found in Tasking or data passed.
    116            *                                HAL_BUSY:     UART is busy.
    117            *                                HAL_TIMEOUT:  UART timed out.
    118            */

   \                                 In section .text, align 2, keep-with-next
    119          HAL_StatusTypeDef RoadBrd_Disable_Barometer( void )
    120          {
   \                     RoadBrd_Disable_Barometer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    121            uint8_t tempBuffer[2];
    122            HAL_StatusTypeDef Status;
    123          
    124            // CTRL_REG1 =	1000.0100 > 0x06
    125            tempBuffer[0] = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    126            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    127          #ifdef REV_L
    128            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG1, tempBuffer, (uint16_t)1);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0x20BA             MOVS     R0,#+186
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0004             MOVS     R4,R0
    129            // 2. If Status was good, Time to get response.
    130            if (Status == HAL_OK)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD109             BNE.N    ??RoadBrd_Disable_Barometer_0
    131            {
    132              // Now wait for completion of XMIT.
    133              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0004             MOVS     R4,R0
    134              if (Status != HAL_OK)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_Disable_Barometer_0
    135                return Status;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE001             B.N      ??RoadBrd_Disable_Barometer_1
    136            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    137            return Status;
   \                     ??RoadBrd_Disable_Barometer_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_Disable_Barometer_1: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    138          #else
    139            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG1, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
    140            return Status;
    141          #endif
    142          }
    143          
    144          /**
    145            * @brief  RoadBrd_StartSample_Barometer( void )
    146            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    147            *                                HAL_ERROR:    Error found in Tasking or data passed.
    148            *                                HAL_BUSY:     UART is busy.
    149            *                                HAL_TIMEOUT:  UART timed out.
    150            */

   \                                 In section .text, align 2, keep-with-next
    151          HAL_StatusTypeDef RoadBrd_StartSample_Barometer( void )
    152          {
   \                     RoadBrd_StartSample_Barometer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    153            uint8_t tempBuffer[2];
    154            HAL_StatusTypeDef Status;
    155          
    156            // CTRL_REG2 =	0001.0010 > 0x12
    157            tempBuffer[0] = 0x01;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    158            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    159          #ifdef REV_L
    160            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG2, tempBuffer, (uint16_t)1);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2121             MOVS     R1,#+33
   \   00000016   0x20BA             MOVS     R0,#+186
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0004             MOVS     R4,R0
    161            // 2. If Status was good, Time to get response.
    162            if (Status == HAL_OK)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD109             BNE.N    ??RoadBrd_StartSample_Barometer_0
    163            {
    164              // Now wait for completion of XMIT.
    165              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0004             MOVS     R4,R0
    166              if (Status != HAL_OK)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_StartSample_Barometer_0
    167                return Status;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE001             B.N      ??RoadBrd_StartSample_Barometer_1
    168            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    169            return Status;
   \                     ??RoadBrd_StartSample_Barometer_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_StartSample_Barometer_1: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    170          #else
    171            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG2, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
    172            return Status;
    173          #endif
    174          }
    175          
    176          /**
    177            * @brief  RoadBrd_StartSample_BarometerWait( void )
    178            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    179            *                                HAL_ERROR:    Error found in Tasking or data passed.
    180            *                                HAL_BUSY:     UART is busy.
    181            *                                HAL_TIMEOUT:  UART timed out.
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          HAL_StatusTypeDef RoadBrd_StartSample_BarometerWait( void )
    184          {
   \                     RoadBrd_StartSample_BarometerWait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    185            uint8_t tempBuffer[2];
    186            HAL_StatusTypeDef Status;
    187          
    188            // CTRL_REG2 =	0001.0010 > 0x12
    189            tempBuffer[0] = 0x01;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    190            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    191          #ifdef REV_L
    192            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG2, tempBuffer, (uint16_t)1);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2121             MOVS     R1,#+33
   \   00000016   0x20BA             MOVS     R0,#+186
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0004             MOVS     R4,R0
    193            // 2. If Status was good, Time to get response.
    194            if (Status == HAL_OK)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD115             BNE.N    ??RoadBrd_StartSample_BarometerWait_0
    195            {
    196              // Now wait for completion of XMIT.
    197              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0004             MOVS     R4,R0
    198              if (Status != HAL_OK)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_StartSample_BarometerWait_1
    199                return Status;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE00D             B.N      ??RoadBrd_StartSample_BarometerWait_2
    200            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    201            else
    202              return Status;
    203          #else
    204            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)CTRL_REG2, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
    205            if (Status != HAL_OK)                 // If Error, return Status     
    206              return Status;
    207          #endif
    208            //  =Let's wait a little time to allow cmd to complete and clear.
    209            RoadBrd_Delay(WAIT_PRESSEVNT);
   \                     ??RoadBrd_StartSample_BarometerWait_1: (+1)
   \   00000038   0xF44F 0x7096      MOV      R0,#+300
   \   0000003C   0x.... 0x....      BL       RoadBrd_Delay
    210          
    211            // OK...NOW Wait for Data to be ready. Will set timeout at five seconds.
    212            Status = RoadBrd_WaitForPressure( (uint16_t)FIVE_SECOND_DELAY );
   \   00000040   0xF44F 0x707A      MOV      R0,#+1000
   \   00000044   0x.... 0x....      BL       RoadBrd_WaitForPressure
   \   00000048   0x0004             MOVS     R4,R0
    213            
    214            return Status;
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xE001             B.N      ??RoadBrd_StartSample_BarometerWait_2
   \                     ??RoadBrd_StartSample_BarometerWait_0: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_StartSample_BarometerWait_2: (+1)
   \   00000054   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    215          }
    216          
    217          /**
    218            * @brief  RoadBrd_Barometer_Status( uint8_t *pStatus )
    219            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    220            *                                HAL_ERROR:    Error found in Tasking or data passed.
    221            *                                HAL_BUSY:     UART is busy.
    222            *                                HAL_TIMEOUT:  UART timed out.
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef RoadBrd_Barometer_Status( PRStatPtr SPtr )
    225          {
   \                     RoadBrd_Barometer_Status: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            uint8_t tempBuffer[2];
    227            HAL_StatusTypeDef Status;
    228          
    229           // Test STATUS as follows:
    230            //    Bit 0: T_DA			0: new data for temperature is not yet available
    231            //    				1: new data for temperature is available
    232            //    Bit 1: P_DA			0: new data for pressure is not yet available
    233            //    				1: new data for pressure is available
    234            //    Bit 4: T_OR			0: no overrun has occurred    
    235            //    				1: a new data for temperature has overwritten the previous one
    236            //    Bit 5: P_OR			0: no overrun has occurred
    237            //    				1: new data for pressure has overwritten the previous one
    238            // Setup to Read WHOAMI Status from device.
    239            tempBuffer[0] = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    240            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    241          
    242          #ifdef REV_L
    243            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)STATUS, tempBuffer, (uint16_t)NULL_SIZE);
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2127             MOVS     R1,#+39
   \   00000016   0x20BA             MOVS     R0,#+186
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0005             MOVS     R5,R0
    244            // 2. If Status was good, Time to get response.
    245            if (Status == HAL_OK)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD12B             BNE.N    ??RoadBrd_Barometer_Status_0
    246            {
    247              // Now wait for completion of XMIT.
    248              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0005             MOVS     R5,R0
    249              if (Status != HAL_OK)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_Barometer_Status_1
    250                return Status;
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE023             B.N      ??RoadBrd_Barometer_Status_2
    251              else
    252              {
    253                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)BARO_ADDR, tempBuffer, (uint16_t)1);
   \                     ??RoadBrd_Barometer_Status_1: (+1)
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x20BA             MOVS     R0,#+186
   \   0000003E   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000042   0x0005             MOVS     R5,R0
    254                if (Status == HAL_OK)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD115             BNE.N    ??RoadBrd_Barometer_Status_3
    255                {
    256                  // Now wait for completion of Receive.
    257                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   0000004A   0x2064             MOVS     R0,#+100
   \   0000004C   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000050   0x0005             MOVS     R5,R0
    258                  if (Status != HAL_OK)
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??RoadBrd_Barometer_Status_4
    259                    return Status;
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xE010             B.N      ??RoadBrd_Barometer_Status_2
    260                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    261                else
    262                  return Status;
    263              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    264            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    265            else
    266              return Status;
    267          #else
    268            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)STATUS, tempBuffer, (uint16_t)NULL_SIZE, I2C_TIMEOUT);
    269            // If Status was good, Time to get response.
    270            if (Status == HAL_OK)
    271            {
    272              Status =  RoadBrd_I2C_Master_Receive((uint16_t)BARO_ADDR, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
    273            }
    274            else
    275              return Status;
    276          #endif
    277            // Build Status NOW
    278            // Build Raw Response
    279            sprintf( (char *)SPtr->Raw, "%02x", tempBuffer[0]);
   \                     ??RoadBrd_Barometer_Status_4: (+1)
   \   0000005E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000062   0x....             LDR.N    R1,??DataTable3
   \   00000064   0x1C60             ADDS     R0,R4,#+1
   \   00000066   0x.... 0x....      BL       sprintf
    280            //strcat( (char *)SPtr->Raw, "Rw" );
    281            
    282            // Pass Status Response.
    283            SPtr->Status = tempBuffer[0];
   \   0000006A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
    284          
    285            return Status;
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE004             B.N      ??RoadBrd_Barometer_Status_2
   \                     ??RoadBrd_Barometer_Status_3: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE001             B.N      ??RoadBrd_Barometer_Status_2
   \                     ??RoadBrd_Barometer_Status_0: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_Barometer_Status_2: (+1)
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    286          }
    287          
    288          /**
    289            * @brief  HAL_I2C_StateTypeDef RoadBrd_WaitForPressure( uint16_t WaitCnt ): Wait for state to change
    290            * @param  uint16_t WaitCnt: Count of 5msec ticks to wait before timing out.
    291            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    292            *                                HAL_ERROR:    Error found in Tasking or data passed.
    293            *                                HAL_BUSY:     UART is busy.
    294            *                                HAL_TIMEOUT:  UART timed out.
    295            */

   \                                 In section .text, align 2, keep-with-next
    296          HAL_StatusTypeDef RoadBrd_WaitForPressure( uint16_t WaitCnt )
    297          {
   \                     RoadBrd_WaitForPressure: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    298            HAL_StatusTypeDef Status;
    299            uint16_t x;
    300            PRStatus PRMeasure;
    301            
    302            // Now wait for transaction to complete.
    303            for( x=0; x<=WaitCnt; x++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??RoadBrd_WaitForPressure_0: (+1)
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD31A             BCC.N    ??RoadBrd_WaitForPressure_1
    304            {
    305              // Get new Status from Pressure Transducer.
    306              Status = RoadBrd_Barometer_Status(&PRMeasure);
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       RoadBrd_Barometer_Status
   \   0000001A   0x0006             MOVS     R6,R0
    307              if(Status != HAL_OK)
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD002             BEQ.N    ??RoadBrd_WaitForPressure_2
    308                return Status;
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xE027             B.N      ??RoadBrd_WaitForPressure_3
    309              
    310              // Test to see if event finished.
    311              if (((PRMeasure.Status&TDA_TEST) > 0) &&
    312                  ((PRMeasure.Status&PDA_TEST) > 0))
   \                     ??RoadBrd_WaitForPressure_2: (+1)
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xDB05             BLT.N    ??RoadBrd_WaitForPressure_4
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xDA04             BGE.N    ??RoadBrd_WaitForPressure_1
    313                break;
    314              // Wait 5msec.
    315              RoadBrd_Delay(WAIT_PRESSURE);
   \                     ??RoadBrd_WaitForPressure_4: (+1)
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0x.... 0x....      BL       RoadBrd_Delay
    316            }
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \   00000048   0xE7DE             B.N      ??RoadBrd_WaitForPressure_0
    317            // Test for timeout.
    318            if( x == WaitCnt)
   \                     ??RoadBrd_WaitForPressure_1: (+1)
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x0021             MOVS     R1,R4
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD101             BNE.N    ??RoadBrd_WaitForPressure_5
    319              return HAL_TIMEOUT;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xE00E             B.N      ??RoadBrd_WaitForPressure_3
    320            // Test for Over run on Sensors.
    321            if (((PRMeasure.Status&TOR_TEST) > 0) ||
    322                ((PRMeasure.Status&POR_TEST) > 0))
   \                     ??RoadBrd_WaitForPressure_5: (+1)
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xDA05             BGE.N    ??RoadBrd_WaitForPressure_6
   \   00000066   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006A   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xDB01             BLT.N    ??RoadBrd_WaitForPressure_7
    323              return HAL_ERROR;
   \                     ??RoadBrd_WaitForPressure_6: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE000             B.N      ??RoadBrd_WaitForPressure_3
    324            else
    325              return HAL_OK;
   \                     ??RoadBrd_WaitForPressure_7: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??RoadBrd_WaitForPressure_3: (+1)
   \   00000078   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    326          }
    327          
    328          /**
    329            * @brief  This routine reads the Pressure and returns scaled values into passed Structure.
    330            * @param  PRPrsPtr PRPtr: Pointer to structure receiving results.
    331            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          HAL_StatusTypeDef RoadBrd_Baro_ReadPressure_Scaled( PRPrsPtr PRPtr )
    334          //HAL_StatusTypeDef RoadBrd_Baro_ReadPressure( uint8_t *pData )
    335          {
   \                     RoadBrd_Baro_ReadPressure_Scaled: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    336            HAL_StatusTypeDef Status;
    337            int32_t legacyValue;
    338            float PressureResult, value, fracvalue;
    339            double temp2;
    340            int temp3;
    341            
    342            Status = HAL_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4680             MOV      R8,R0
    343            
    344            if (LPS25HB_GetPressure(&value) == PRESSURE_OK)
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       LPS25HB_GetPressure
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD13A             BNE.N    ??RoadBrd_Baro_ReadPressure_Scaled_0
    345            {
    346              PressureResult = value;
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x0006             MOVS     R6,R0
    347              PressureResult = RoadBrd_CAL_ScaleValue( CAL_PRESSURE, PressureResult);
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0x.... 0x....      BL       RoadBrd_CAL_ScaleValue
   \   00000020   0x0006             MOVS     R6,R0
    348          
    349              // Now Build Legacy Format.
    350              legacyValue = (uint32_t)(value * 2.5);
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x.... 0x....      BL       __aeabi_f2d
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x....             LDR.N    R3,??DataTable3_1  ;; 0x40040000
   \   0000002C   0x.... 0x....      BL       __aeabi_dmul
   \   00000030   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000034   0x0005             MOVS     R5,R0
    351              legacyValue = (legacyValue << 8);
   \   00000036   0x022D             LSLS     R5,R5,#+8
    352              fracvalue = modf(value, &temp2);
   \   00000038   0xAA02             ADD      R2,SP,#+8
   \   0000003A   0x4692             MOV      R10,R2
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x4652             MOV      R2,R10
   \   00000044   0x.... 0x....      BL       modf
   \   00000048   0x.... 0x....      BL       __aeabi_d2f
   \   0000004C   0x4681             MOV      R9,R0
    353              temp3 = (int)(fracvalue * 256);
   \   0000004E   0xF05F 0x4087      MOVS     R0,#+1132462080
   \   00000052   0x4649             MOV      R1,R9
   \   00000054   0x.... 0x....      BL       __aeabi_fmul
   \   00000058   0x.... 0x....      BL       __aeabi_f2iz
   \   0000005C   0x0007             MOVS     R7,R0
    354              temp3 = temp3 & 0xF0;
   \   0000005E   0xF017 0x07F0      ANDS     R7,R7,#0xF0
    355              legacyValue = legacyValue + temp3;
   \   00000062   0x197D             ADDS     R5,R7,R5
    356            }
    357            else
    358              return HAL_ERROR;
    359          
    360            // NOW Build Result
    361            // Build Raw Result.
    362            sprintf( (char *)PRPtr->Raw, "%08x", legacyValue);
   \   00000064   0x002A             MOVS     R2,R5
   \   00000066   0x....             LDR.N    R1,??DataTable3_2
   \   00000068   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000006C   0x.... 0x....      BL       sprintf
    363            PRPtr->RawC = legacyValue;
   \   00000070   0x61A5             STR      R5,[R4, #+24]
    364            // Build Clean Result.
    365            sprintf( (char *)PRPtr->Pressure,"%06.3f",PressureResult);
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       __aeabi_f2d
   \   00000078   0x0002             MOVS     R2,R0
   \   0000007A   0x000B             MOVS     R3,R1
   \   0000007C   0x....             LDR.N    R1,??DataTable3_3
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       sprintf
    366          
    367            return Status;
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xE000             B.N      ??RoadBrd_Baro_ReadPressure_Scaled_1
   \                     ??RoadBrd_Baro_ReadPressure_Scaled_0: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Baro_ReadPressure_Scaled_1: (+1)
   \   0000008C   0xB004             ADD      SP,SP,#+16
   \   0000008E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    368          }
    369          
    370          /**
    371            * @brief  This routine reads the Pressure and returns values into passed Structure.
    372            * @param  PRPrsPtr PRPtr: Pointer to structure receiving results.
    373            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          HAL_StatusTypeDef RoadBrd_Baro_ReadPressure( PRPrsPtr PRPtr )
    376          //HAL_StatusTypeDef RoadBrd_Baro_ReadPressure( uint8_t *pData )
    377          {
   \                     RoadBrd_Baro_ReadPressure: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    378            HAL_StatusTypeDef Status;
    379            int32_t legacyValue;
    380            float PressureResult, value, fracvalue;
    381            double temp2;
    382            int temp3;
    383            
    384            Status = HAL_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0005             MOVS     R5,R0
    385            
    386            if (LPS25HB_GetPressure(&value) == PRESSURE_OK)
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       LPS25HB_GetPressure
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD135             BNE.N    ??RoadBrd_Baro_ReadPressure_0
    387            {
    388              PressureResult = value;
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x4681             MOV      R9,R0
    389          
    390              // Now Build Legacy Format.
    391              legacyValue = (uint32_t)(value * 2.5);
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x....             LDR.N    R3,??DataTable3_1  ;; 0x40040000
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000002A   0x0006             MOVS     R6,R0
    392              legacyValue = (legacyValue << 8);
   \   0000002C   0x0236             LSLS     R6,R6,#+8
    393              fracvalue = modf(value, &temp2);
   \   0000002E   0xAA02             ADD      R2,SP,#+8
   \   00000030   0x4692             MOV      R10,R2
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4652             MOV      R2,R10
   \   0000003A   0x.... 0x....      BL       modf
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x4680             MOV      R8,R0
    394              temp3 = (int)(fracvalue * 256);
   \   00000044   0xF05F 0x4087      MOVS     R0,#+1132462080
   \   00000048   0x4641             MOV      R1,R8
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000052   0x0007             MOVS     R7,R0
    395              temp3 = temp3 & 0xF0;
   \   00000054   0xF017 0x07F0      ANDS     R7,R7,#0xF0
    396              legacyValue = legacyValue + temp3;
   \   00000058   0x19BE             ADDS     R6,R7,R6
    397            }
    398            else
    399              return HAL_ERROR;
    400          
    401            // NOW Build Result
    402            // Build Raw Result.
    403            sprintf( (char *)PRPtr->Raw, "%08x", legacyValue);
   \   0000005A   0x0032             MOVS     R2,R6
   \   0000005C   0x....             LDR.N    R1,??DataTable3_2
   \   0000005E   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000062   0x.... 0x....      BL       sprintf
    404            PRPtr->RawC = legacyValue;
   \   00000066   0x61A6             STR      R6,[R4, #+24]
    405            // Build Clean Result.
    406            sprintf( (char *)PRPtr->Pressure,"%06.3f",PressureResult);
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0x.... 0x....      BL       __aeabi_f2d
   \   0000006E   0x0002             MOVS     R2,R0
   \   00000070   0x000B             MOVS     R3,R1
   \   00000072   0x....             LDR.N    R1,??DataTable3_3
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       sprintf
    407          
    408            return Status;
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xE000             B.N      ??RoadBrd_Baro_ReadPressure_1
   \                     ??RoadBrd_Baro_ReadPressure_0: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Baro_ReadPressure_1: (+1)
   \   00000082   0xB004             ADD      SP,SP,#+16
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    409          }
    410          
    411          /**
    412            * @brief  RoadBrd_Baro_ReadPressureAscii( uint8_t *pData  )
    413            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    414            *                                HAL_ERROR:    Error found in Tasking or data passed.
    415            *                                HAL_BUSY:     UART is busy.
    416            *                                HAL_TIMEOUT:  UART timed out.
    417            */
    418          
    419          /**
    420            * @brief  RoadBrd_Baro_ReadTemp( uint8_t *pData  ) TEMP_OUT_L...TEMP_OUT_H
    421            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    422            *                                HAL_ERROR:    Error found in Tasking or data passed.
    423            *                                HAL_BUSY:     UART is busy.
    424            *                                HAL_TIMEOUT:  UART timed out.
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          HAL_StatusTypeDef RoadBrd_Baro_ReadTemp( TempPtr TmpPtr )
    427          {
   \                     RoadBrd_Baro_ReadTemp: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    428            int16_t calcValue;
    429            float Temp_C, Temp_F;
    430            char tempBffr2[5];
    431          
    432          #if 0
    433            // 1. Read Read TEMP_OUT_L
    434            uint8_t tempBuffer[4];
    435            tempBuffer[0] = 0x00;
    436            tempBuffer[1] = 0x00;
    437          #ifdef REV_L
    438            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)TEMP_OUT_L, tempBuffer, (uint16_t)NULL_SIZE);
    439            // 2. If Status was good, Time to get response.
    440            if (Status == HAL_OK)
    441            {
    442              // Now wait for completion of XMIT.
    443              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
    444              if (Status != HAL_OK)
    445                return Status;
    446              else
    447              {
    448                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)BARO_ADDR, &pData[0], (uint16_t)1);
    449                if (Status == HAL_OK)
    450                {
    451                  // Now wait for completion of Receive.
    452                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
    453                  if (Status != HAL_OK)
    454                    return Status;
    455                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    456                else
    457                  return Status;
    458              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    459            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    460            else
    461              return Status;
    462          #else
    463            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)TEMP_OUT_L, tempBuffer, (uint16_t)NULL_SIZE, I2C_TIMEOUT);
    464            // If Status was good, Time to get response.
    465            if (Status == HAL_OK)
    466            {
    467              Status =  RoadBrd_I2C_Master_Receive((uint16_t)BARO_ADDR, &pData[0], (uint16_t)1, I2C_TIMEOUT);
    468              if(Status != HAL_OK)
    469                return Status;
    470            }
    471            else
    472              return Status;
    473          #endif
    474            // 2. Read Read TEMP_OUT_H
    475            tempBuffer[0] = 0x00;
    476            tempBuffer[1] = 0x00;
    477          #ifdef REV_L
    478            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)BARO_ADDR, (uint8_t)TEMP_OUT_H, tempBuffer, (uint16_t)NULL_SIZE);
    479            // 2. If Status was good, Time to get response.
    480            if (Status == HAL_OK)
    481            {
    482              // Now wait for completion of XMIT.
    483              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
    484              if (Status != HAL_OK)
    485                return Status;
    486              else
    487              {
    488                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)BARO_ADDR, &pData[1], (uint16_t)1);
    489                if (Status == HAL_OK)
    490                {
    491                  // Now wait for completion of Receive.
    492                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
    493                  if (Status != HAL_OK)
    494                    return Status;
    495                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    496                else
    497                  return Status;
    498              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    499            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    500            return Status;
    501          #else
    502            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)TEMP_OUT_H, tempBuffer, (uint16_t)NULL_SIZE, I2C_TIMEOUT);
    503            // If Status was good, Time to get response.
    504            if (Status == HAL_OK)
    505            {
    506              Status =  RoadBrd_I2C_Master_Receive((uint16_t)BARO_ADDR, &pData[1], (uint16_t)1, I2C_TIMEOUT);
    507            }
    508            return Status;
    509          #endif
    510          #endif
    511            if (LPS25HB_I2C_GetRawTemperature(&calcValue) != PRESSURE_OK)
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       LPS25HB_I2C_GetRawTemperature
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??RoadBrd_Baro_ReadTemp_0
    512              return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE041             B.N      ??RoadBrd_Baro_ReadTemp_1
    513            
    514            if (LPS25HB_GetTemperature(&Temp_C) == PRESSURE_OK)
   \                     ??RoadBrd_Baro_ReadTemp_0: (+1)
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       LPS25HB_GetTemperature
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD13B             BNE.N    ??RoadBrd_Baro_ReadTemp_2
    515            {
    516              // TIme to build all needed outputs.
    517              Temp_F = (Temp_C * 1.8) + 32;
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x....             LDR.N    R2,??DataTable3_4  ;; 0xcccccccd
   \   00000026   0x....             LDR.N    R3,??DataTable3_5  ;; 0x3ffccccc
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x....             LDR.N    R3,??DataTable3_6  ;; 0x40400000
   \   00000030   0x.... 0x....      BL       __aeabi_dadd
   \   00000034   0x.... 0x....      BL       __aeabi_d2f
   \   00000038   0x0005             MOVS     R5,R0
    518              TmpPtr->RawC = calcValue;
   \   0000003A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000003E   0x82E0             STRH     R0,[R4, #+22]
    519              sprintf( (char *)TmpPtr->TempC, "%3.1f", Temp_C );
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x0002             MOVS     R2,R0
   \   00000048   0x000B             MOVS     R3,R1
   \   0000004A   0x....             LDR.N    R1,??DataTable3_7
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       sprintf
    520              sprintf( (char *)TmpPtr->TempF, "%3.1f", Temp_F );
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       __aeabi_f2d
   \   00000058   0x0002             MOVS     R2,R0
   \   0000005A   0x000B             MOVS     R3,R1
   \   0000005C   0x....             LDR.N    R1,??DataTable3_7
   \   0000005E   0x1DE0             ADDS     R0,R4,#+7
   \   00000060   0x.... 0x....      BL       sprintf
    521              // NOW, Build Raw Data String..
    522              sprintf( (char *)TmpPtr->Raw, "%02x", ((calcValue & 0xff00)>>8));
   \   00000064   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000068   0xF3C0 0x2207      UBFX     R2,R0,#+8,#+8
   \   0000006C   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000006E   0x....             LDR.N    R1,??DataTable3
   \   00000070   0xF114 0x000E      ADDS     R0,R4,#+14
   \   00000074   0x.... 0x....      BL       sprintf
    523              sprintf( (char *)tempBffr2, "%02x", (calcValue & 0x00ff));
   \   00000078   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000007C   0xF000 0x02FF      AND      R2,R0,#0xFF
   \   00000080   0x....             LDR.N    R1,??DataTable3
   \   00000082   0xA802             ADD      R0,SP,#+8
   \   00000084   0x.... 0x....      BL       sprintf
    524              strcat( (char *)TmpPtr->Raw, (char *)tempBffr2 );
   \   00000088   0xA902             ADD      R1,SP,#+8
   \   0000008A   0xF114 0x000E      ADDS     R0,R4,#+14
   \   0000008E   0x.... 0x....      BL       strcat
    525              //strcat( (char *)TmpPtr->Raw, "Rw" );
    526          
    527            }
    528            else
    529              return HAL_ERROR;
    530          
    531            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE000             B.N      ??RoadBrd_Baro_ReadTemp_1
   \                     ??RoadBrd_Baro_ReadTemp_2: (+1)
   \   00000096   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Baro_ReadTemp_1: (+1)
   \   00000098   0xB005             ADD      SP,SP,#+20
   \   0000009A   0xBD30             POP      {R4,R5,PC}       ;; return
    532          }
    533          
    534          /**
    535            * @brief  RoadBrd_TestandRead_Barometer( void )
    536            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    537            *                                HAL_ERROR:    Error found in Tasking or data passed.
    538            *                                HAL_BUSY:     UART is busy.
    539            *                                HAL_TIMEOUT:  UART timed out.
    540            */

   \                                 In section .text, align 2, keep-with-next
    541          HAL_StatusTypeDef RoadBrd_TestandRead_Barometer( void )
    542          {
   \                     RoadBrd_TestandRead_Barometer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB0A2             SUB      SP,SP,#+136
    543            uint8_t tempBuffer[TXBUFFERSIZE];
    544            
    545            HAL_StatusTypeDef Status;
    546            
    547            // Setup to Read WHOAMI Status from device.
    548            tempBuffer[0] = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
    549            tempBuffer[1] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    550            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)BARO_ADDR, (uint8_t)WHO_AM_I, tempBuffer, (uint16_t)NULL_SIZE, I2C_TIMEOUT);
   \   00000010   0xF44F 0x70FA      MOV      R0,#+500
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xAA01             ADD      R2,SP,#+4
   \   0000001A   0x210F             MOVS     R1,#+15
   \   0000001C   0x20BA             MOVS     R0,#+186
   \   0000001E   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   00000022   0x0004             MOVS     R4,R0
    551            // If Status was good, Time to get response.
    552            if (Status == HAL_OK)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD107             BNE.N    ??RoadBrd_TestandRead_Barometer_0
    553            {
    554              Status =  RoadBrd_I2C_Master_Receive((uint16_t)BARO_ADDR, tempBuffer, (uint16_t)1, I2C_TIMEOUT);
   \   0000002A   0xF44F 0x73FA      MOV      R3,#+500
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0x20BA             MOVS     R0,#+186
   \   00000034   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive
   \   00000038   0x0004             MOVS     R4,R0
    555            }
    556            
    557            // Now test result and see if it compares.
    558            if(tempBuffer[0] == (uint8_t)WHOAMI_RSLT)
   \                     ??RoadBrd_TestandRead_Barometer_0: (+1)
   \   0000003A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000003E   0x28BD             CMP      R0,#+189
   \   00000040   0xD101             BNE.N    ??RoadBrd_TestandRead_Barometer_1
    559              return HAL_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE000             B.N      ??RoadBrd_TestandRead_Barometer_2
    560            else
    561              return HAL_ERROR;
   \                     ??RoadBrd_TestandRead_Barometer_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_TestandRead_Barometer_2: (+1)
   \   00000048   0xB022             ADD      SP,SP,#+136
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    562          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0xCCCCCCCD         DC32     0xcccccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x3FFCCCCC         DC32     0x3ffccccc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x25 0x30          DC8 "%02x"
   \              0x32 0x78    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x25 0x30          DC8 "%08x"
   \              0x38 0x78    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x25 0x30          DC8 "%06.3f"
   \              0x36 0x2E    
   \              0x33 0x66    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x25 0x33          DC8 "%3.1f"
   \              0x2E 0x31    
   \              0x66 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
    563          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   RoadBrd_Baro_ReadPressure
        48   -> LPS25HB_GetPressure
        48   -> __aeabi_d2f
        48   -> __aeabi_d2uiz
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_f2iz
        48   -> __aeabi_fmul
        48   -> modf
        48   -> sprintf
      48   RoadBrd_Baro_ReadPressure_Scaled
        48   -> LPS25HB_GetPressure
        48   -> RoadBrd_CAL_ScaleValue
        48   -> __aeabi_d2f
        48   -> __aeabi_d2uiz
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_f2iz
        48   -> __aeabi_fmul
        48   -> modf
        48   -> sprintf
      32   RoadBrd_Baro_ReadTemp
        32   -> LPS25HB_GetTemperature
        32   -> LPS25HB_I2C_GetRawTemperature
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> sprintf
        32   -> strcat
      16   RoadBrd_Barometer_Status
        16   -> RoadBrd_I2C_Master_Receive_IT
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState
        16   -> sprintf
      16   RoadBrd_Disable_Barometer
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState
      16   RoadBrd_Enable_Barometer
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState
      16   RoadBrd_Init_Barometer
        16   -> LPS25HB_Init
      16   RoadBrd_StartSample_Barometer
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState
      16   RoadBrd_StartSample_BarometerWait
        16   -> RoadBrd_Delay
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForPressure
        16   -> RoadBrd_WaitForState
     144   RoadBrd_TestandRead_Barometer
       144   -> RoadBrd_I2C_Master_Receive
       144   -> RoadBrd_I2C_Master_Transmit_CMDData
      24   RoadBrd_WaitForPressure
        24   -> RoadBrd_Barometer_Status
        24   -> RoadBrd_Delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
     136  RoadBrd_Baro_ReadPressure
     146  RoadBrd_Baro_ReadPressure_Scaled
     156  RoadBrd_Baro_ReadTemp
     130  RoadBrd_Barometer_Status
      62  RoadBrd_Disable_Barometer
      62  RoadBrd_Enable_Barometer
      84  RoadBrd_Init_Barometer
      62  RoadBrd_StartSample_Barometer
      86  RoadBrd_StartSample_BarometerWait
      76  RoadBrd_TestandRead_Barometer
     122  RoadBrd_WaitForPressure

 
    32 bytes in section .rodata
 1 154 bytes in section .text
 
 1 154 bytes of CODE  memory
    32 bytes of CONST memory

Errors: none
Warnings: none
