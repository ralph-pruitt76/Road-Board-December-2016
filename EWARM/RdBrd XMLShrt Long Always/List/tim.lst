###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       16/Oct/2017  08:52:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\tim.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\tim.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\tim.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\tim.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\tim.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : TIM.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the TIM instances.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "tim.h"
     37          #include "wwdg.h"
     38          
     39          /* USER CODE BEGIN 0 */

   \                                 In section .bss, align 1
     40          __IO ITStatus Timr2Ready = RESET;
   \                     Timr2Ready:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     41          __IO ITStatus Timr3Ready = RESET;
   \                     Timr3Ready:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
     42          static uint32_t SnsrTickCnt = PROCESS_SNSR_TIME;
   \                     SnsrTickCnt:
   \   00000000   0x00000064         DC32 100

   \                                 In section .data, align 4
     43          static uint32_t RdSndTickCnt = PROCESS_RD_SND_TIME;
   \                     RdSndTickCnt:
   \   00000000   0x0000007B         DC32 123

   \                                 In section .data, align 4
     44          static uint32_t ledOffCnt = PROCESS_LEDOFF_TIME;
   \                     ledOffCnt:
   \   00000000   0x00000001         DC32 1
     45          
     46          /* USER CODE END 0 */
     47          

   \                                 In section .bss, align 4
     48          TIM_HandleTypeDef htim2;
   \                     htim2:
   \   00000000                      DS8 56

   \                                 In section .bss, align 4
     49          TIM_HandleTypeDef htim3;
   \                     htim3:
   \   00000000                      DS8 56
     50          
     51          /* TIM2 init function */

   \                                 In section .text, align 2, keep-with-next
     52          void MX_TIM2_Init(void)
     53          {
   \                     MX_TIM2_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     54            TIM_ClockConfigTypeDef sClockSourceConfig;
     55            TIM_MasterConfigTypeDef sMasterConfig;
     56          
     57            htim2.Instance = TIM2;
   \   00000004   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000008   0x....             LDR.N    R1,??DataTable14
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     58            htim2.Init.Prescaler = 16000;
   \   0000000C   0xF44F 0x507A      MOV      R0,#+16000
   \   00000010   0x....             LDR.N    R1,??DataTable14
   \   00000012   0x6048             STR      R0,[R1, #+4]
     59            htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable14
   \   00000018   0x6088             STR      R0,[R1, #+8]
     60            htim2.Init.Period = 200;
   \   0000001A   0x20C8             MOVS     R0,#+200
   \   0000001C   0x....             LDR.N    R1,??DataTable14
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
     61            htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable14
   \   00000024   0x6108             STR      R0,[R1, #+16]
     62            if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
   \   00000026   0x....             LDR.N    R0,??DataTable14
   \   00000028   0x.... 0x....      BL       HAL_TIM_Base_Init
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??MX_TIM2_Init_0
     63            {
     64              Error_Handler();
   \   00000030   0x.... 0x....      BL       Error_Handler
     65            }
     66          
     67            sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   \                     ??MX_TIM2_Init_0: (+1)
   \   00000034   0xF44F 0x5080      MOV      R0,#+4096
   \   00000038   0x9002             STR      R0,[SP, #+8]
     68            if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0x....             LDR.N    R0,??DataTable14
   \   0000003E   0x.... 0x....      BL       HAL_TIM_ConfigClockSource
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD001             BEQ.N    ??MX_TIM2_Init_1
     69            {
     70              Error_Handler();
   \   00000046   0x.... 0x....      BL       Error_Handler
     71            }
     72          
     73            sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   \                     ??MX_TIM2_Init_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9000             STR      R0,[SP, #+0]
     74            sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x9001             STR      R0,[SP, #+4]
     75            if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x....             LDR.N    R0,??DataTable14
   \   00000056   0x.... 0x....      BL       HAL_TIMEx_MasterConfigSynchronization
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??MX_TIM2_Init_2
     76            {
     77              Error_Handler();
   \   0000005E   0x.... 0x....      BL       Error_Handler
     78            }
     79          
     80          }
   \                     ??MX_TIM2_Init_2: (+1)
   \   00000062   0xB007             ADD      SP,SP,#+28
   \   00000064   0xBD00             POP      {PC}             ;; return
     81          /* TIM3 init function */

   \                                 In section .text, align 2, keep-with-next
     82          void MX_TIM3_Init(void)
     83          {
   \                     MX_TIM3_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     84            TIM_ClockConfigTypeDef sClockSourceConfig;
     85            TIM_MasterConfigTypeDef sMasterConfig;
     86          
     87            htim3.Instance = TIM3;
   \   00000004   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40000400
   \   00000006   0x....             LDR.N    R1,??DataTable14_2
   \   00000008   0x6008             STR      R0,[R1, #+0]
     88            htim3.Init.Prescaler = 16000;
   \   0000000A   0xF44F 0x507A      MOV      R0,#+16000
   \   0000000E   0x....             LDR.N    R1,??DataTable14_2
   \   00000010   0x6048             STR      R0,[R1, #+4]
     89            htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable14_2
   \   00000016   0x6088             STR      R0,[R1, #+8]
     90            htim3.Init.Period = 20;
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x....             LDR.N    R1,??DataTable14_2
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
     91            htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable14_2
   \   00000022   0x6108             STR      R0,[R1, #+16]
     92            if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
   \   00000024   0x....             LDR.N    R0,??DataTable14_2
   \   00000026   0x.... 0x....      BL       HAL_TIM_Base_Init
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??MX_TIM3_Init_0
     93            {
     94              Error_Handler();
   \   0000002E   0x.... 0x....      BL       Error_Handler
     95            }
     96          
     97            sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   \                     ??MX_TIM3_Init_0: (+1)
   \   00000032   0xF44F 0x5080      MOV      R0,#+4096
   \   00000036   0x9002             STR      R0,[SP, #+8]
     98            if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
   \   00000038   0xA902             ADD      R1,SP,#+8
   \   0000003A   0x....             LDR.N    R0,??DataTable14_2
   \   0000003C   0x.... 0x....      BL       HAL_TIM_ConfigClockSource
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD001             BEQ.N    ??MX_TIM3_Init_1
     99            {
    100              Error_Handler();
   \   00000044   0x.... 0x....      BL       Error_Handler
    101            }
    102          
    103            sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   \                     ??MX_TIM3_Init_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    104            sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
    105            if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x....             LDR.N    R0,??DataTable14_2
   \   00000054   0x.... 0x....      BL       HAL_TIMEx_MasterConfigSynchronization
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??MX_TIM3_Init_2
    106            {
    107              Error_Handler();
   \   0000005C   0x.... 0x....      BL       Error_Handler
    108            }
    109          
    110          }
   \                     ??MX_TIM3_Init_2: (+1)
   \   00000060   0xB007             ADD      SP,SP,#+28
   \   00000062   0xBD00             POP      {PC}             ;; return
    111          

   \                                 In section .text, align 2, keep-with-next
    112          void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
    113          {
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    114          
    115            if(tim_baseHandle->Instance==TIM2)
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF1B1 0x4F80      CMP      R1,#+1073741824
   \   00000008   0xD10C             BNE.N    ??HAL_TIM_Base_MspInit_0
    116            {
    117            /* USER CODE BEGIN TIM2_MspInit 0 */
    118          
    119            /* USER CODE END TIM2_MspInit 0 */
    120              /* Peripheral clock enable */
    121              __HAL_RCC_TIM2_CLK_ENABLE();
   \   0000000A   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000012   0x....             LDR.N    R2,??DataTable14_3  ;; 0x40023824
   \   00000014   0x6011             STR      R1,[R2, #+0]
   \   00000016   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0xE00F             B.N      ??HAL_TIM_Base_MspInit_1
    122            /* USER CODE BEGIN TIM2_MspInit 1 */
    123          
    124            /* USER CODE END TIM2_MspInit 1 */
    125            }
    126            else if(tim_baseHandle->Instance==TIM3)
   \                     ??HAL_TIM_Base_MspInit_0: (+1)
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40000400
   \   00000028   0x4291             CMP      R1,R2
   \   0000002A   0xD10B             BNE.N    ??HAL_TIM_Base_MspInit_1
    127            {
    128            /* USER CODE BEGIN TIM3_MspInit 0 */
    129          
    130            /* USER CODE END TIM3_MspInit 0 */
    131              /* Peripheral clock enable */
    132              __HAL_RCC_TIM3_CLK_ENABLE();
   \   0000002C   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000034   0x....             LDR.N    R2,??DataTable14_3  ;; 0x40023824
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \   00000038   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0xF011 0x0102      ANDS     R1,R1,#0x2
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x9900             LDR      R1,[SP, #+0]
    133            /* USER CODE BEGIN TIM3_MspInit 1 */
    134          
    135            /* USER CODE END TIM3_MspInit 1 */
    136            }
    137          }
   \                     ??HAL_TIM_Base_MspInit_1: (+1)
   \   00000044   0xB001             ADD      SP,SP,#+4
   \   00000046   0x4770             BX       LR               ;; return
    138          

   \                                 In section .text, align 2, keep-with-next
    139          void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle)
    140          {
    141          
    142            if(tim_baseHandle->Instance==TIM2)
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF1B1 0x4F80      CMP      R1,#+1073741824
   \   00000006   0xD106             BNE.N    ??HAL_TIM_Base_MspDeInit_0
    143            {
    144            /* USER CODE BEGIN TIM2_MspDeInit 0 */
    145          
    146            /* USER CODE END TIM2_MspDeInit 0 */
    147              /* Peripheral clock disable */
    148              __HAL_RCC_TIM2_CLK_DISABLE();
   \   00000008   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x0849             LSRS     R1,R1,#+1
   \   0000000E   0x0049             LSLS     R1,R1,#+1
   \   00000010   0x....             LDR.N    R2,??DataTable14_3  ;; 0x40023824
   \   00000012   0x6011             STR      R1,[R2, #+0]
   \   00000014   0xE00A             B.N      ??HAL_TIM_Base_MspDeInit_1
    149            /* USER CODE BEGIN TIM2_MspDeInit 1 */
    150          
    151            /* USER CODE END TIM2_MspDeInit 1 */
    152            }
    153            else if(tim_baseHandle->Instance==TIM3)
   \                     ??HAL_TIM_Base_MspDeInit_0: (+1)
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40000400
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD106             BNE.N    ??HAL_TIM_Base_MspDeInit_1
    154            {
    155            /* USER CODE BEGIN TIM3_MspDeInit 0 */
    156          
    157            /* USER CODE END TIM3_MspDeInit 0 */
    158              /* Peripheral clock disable */
    159              __HAL_RCC_TIM3_CLK_DISABLE();
   \   0000001E   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40023824
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF07F 0x0202      MVNS     R2,#+2
   \   00000026   0x4011             ANDS     R1,R2,R1
   \   00000028   0x....             LDR.N    R2,??DataTable14_3  ;; 0x40023824
   \   0000002A   0x6011             STR      R1,[R2, #+0]
    160            /* USER CODE BEGIN TIM3_MspDeInit 1 */
    161          
    162            /* USER CODE END TIM3_MspDeInit 1 */
    163            }
    164          } 
   \                     ??HAL_TIM_Base_MspDeInit_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    165          
    166          /* USER CODE BEGIN 1 */
    167          /**
    168            * @brief  Timer Period Elipsed callback
    169            * @param  UartHandle: UART handle
    170            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    171            *         you can add your own implementation.
    172            * @retval None
    173            */

   \                                 In section .text, align 2, keep-with-next
    174          void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
    175          {
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    176            /* Handle appropriate TIMER by setting the key flag.*/
    177             if(htim->Instance==TIM2)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000000A   0xD103             BNE.N    ??HAL_TIM_PeriodElapsedCallback_0
    178            {
    179          	Timr2Ready = SET;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable14_4
   \   00000010   0x7008             STRB     R0,[R1, #+0]
   \   00000012   0xE01F             B.N      ??HAL_TIM_PeriodElapsedCallback_1
    180            }
    181            else if(htim->Instance==TIM3)
   \                     ??HAL_TIM_PeriodElapsedCallback_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40000400
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD115             BNE.N    ??HAL_TIM_PeriodElapsedCallback_2
    182            {
    183              // Handle LED Off Count;
    184              ledOffCnt--;
   \   0000001C   0x....             LDR.N    R0,??DataTable14_5
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0x....             LDR.N    R1,??DataTable14_5
   \   00000024   0x6008             STR      R0,[R1, #+0]
    185               if ( ledOffCnt == 0 )
   \   00000026   0x....             LDR.N    R0,??DataTable14_5
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD108             BNE.N    ??HAL_TIM_PeriodElapsedCallback_3
    186              {
    187                // Reset Timer;
    188                ledOffCnt = PROCESS_LEDOFF_TIME;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable14_5
   \   00000032   0x6008             STR      R0,[R1, #+0]
    189                RoadBrd_gpio_Off( STATUS_LED );
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0x.... 0x....      BL       RoadBrd_gpio_Off
    190                RoadBrd_gpio_Off( BGM_LED );
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       RoadBrd_gpio_Off
    191              }
    192              Timr3Ready = SET;
   \                     ??HAL_TIM_PeriodElapsedCallback_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable14_6
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   \   00000046   0xE005             B.N      ??HAL_TIM_PeriodElapsedCallback_1
    193            }
    194            else if(htim->Instance==TIM4)
   \                     ??HAL_TIM_PeriodElapsedCallback_2: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x....             LDR.N    R1,??DataTable14_7  ;; 0x40000800
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD101             BNE.N    ??HAL_TIM_PeriodElapsedCallback_1
    195            {
    196          	HAL_IncTick();
   \   00000050   0x.... 0x....      BL       HAL_IncTick
    197            }
    198          }
   \                     ??HAL_TIM_PeriodElapsedCallback_1: (+1)
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    199          
    200          /**
    201            * @brief  Clear Timer 2 Flag
    202            * @param  None
    203            * @retval None
    204            */

   \                                 In section .text, align 2, keep-with-next
    205          void Clear_Timer2_Flg( void )
    206          {
    207            Timr2Ready = RESET;
   \                     Clear_Timer2_Flg: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable14_4
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    208          }
   \   00000006   0x4770             BX       LR               ;; return
    209          
    210          /**
    211            * @brief  Clear Timer 3 Flag
    212            * @param  None
    213            * @retval None
    214            */

   \                                 In section .text, align 2, keep-with-next
    215          void Clear_Timer3_Flg( void )
    216          {
    217            Timr3Ready = RESET;
   \                     Clear_Timer3_Flg: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable14_6
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    218          }
   \   00000006   0x4770             BX       LR               ;; return
    219          
    220          /**
    221            * @brief  Test Timer 2 Flag
    222            * @param  None
    223            * @retval bool: true(1)       Timr2Ready SET
    224            *               false(0)      TImr2Ready RESET
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          bool Test_Timer2( void )
    227          {
    228            if (Timr2Ready == SET)
   \                     Test_Timer2: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_4
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??Test_Timer2_0
    229              return true;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??Test_Timer2_1
    230            else
    231              return false;
   \                     ??Test_Timer2_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??Test_Timer2_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    232          }
    233          
    234          /**
    235            * @brief  Test Timer 3 Flag
    236            * @param  None
    237            * @retval bool: true(1)       Timr3Ready SET
    238            *               false(0)      TImr3Ready RESET
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          bool Test_Timer3( void )
    241          {
    242            if (Timr3Ready == SET)
   \                     Test_Timer3: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_6
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??Test_Timer3_0
    243              return true;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??Test_Timer3_1
    244            else
    245              return false;
   \                     ??Test_Timer3_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??Test_Timer3_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    246          }
    247          
    248          /**
    249            * @brief  Processes Timer Flag status and performs requested operations.
    250            * @param  None
    251            * @note   This code is the heart beat for handling all sensor stimulus and updating 
    252            *         the BLE data according to the stimulus
    253            * @retval None
    254            */

   \                                 In section .text, align 2, keep-with-next
    255          HAL_StatusTypeDef Proc_Timer2( void )
    256          {
   \                     Proc_Timer2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    257            HAL_StatusTypeDef Status;
    258            
    259            Status = HAL_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0004             MOVS     R4,R0
    260            if ( Test_Timer2() )
   \   00000006   0x.... 0x....      BL       Test_Timer2
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD021             BEQ.N    ??Proc_Timer2_0
    261            {
    262              // Clear Timer 2 flag for next interupt.
    263              Clear_Timer2_Flg();
   \   0000000E   0x.... 0x....      BL       Clear_Timer2_Flg
    264              // Handle Road Board Stimulus.
    265              RdSndTickCnt--;
   \   00000012   0x....             LDR.N    R0,??DataTable14_8
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable14_8
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    266              if ( RdSndTickCnt == 0 )
   \   0000001C   0x....             LDR.N    R0,??DataTable14_8
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD107             BNE.N    ??Proc_Timer2_1
    267              {
    268                // Reset Timer;
    269                //RdSndTickCnt = PROCESS_RD_SND_TIME;
    270                RdSndTickCnt = RoadBrd_Get_RdSndTickCnt();
   \   00000024   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   00000028   0x....             LDR.N    R1,??DataTable14_8
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    271                // TBD...Processing code for Road Sound goes here.
    272                // This will be a tasks start here in the future. For now, Will execute the FFT here(Set Time window at least 300msec out of sync to 1 sec timer and at least 5 Seconds.
    273                Process_RdSound();
   \   0000002C   0x.... 0x....      BL       Process_RdSound
    274                // This code checks to determine if we have an active connection.
    275                Test_Connection();
   \   00000030   0x.... 0x....      BL       Test_Connection
    276              }
    277              // Handle Sensor Stimulus Count;
    278              SnsrTickCnt--;
   \                     ??Proc_Timer2_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable14_9
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable14_9
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    279              if ( SnsrTickCnt == 0 )
   \   0000003E   0x....             LDR.N    R0,??DataTable14_9
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD105             BNE.N    ??Proc_Timer2_0
    280              {
    281                // Reset Timer;
    282                //SnsrTickCnt = PROCESS_SNSR_TIME;
    283                SnsrTickCnt = RoadBrd_Get_SnsrTickCnt();
   \   00000046   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   0000004A   0x....             LDR.N    R1,??DataTable14_9
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    284                // Enable processing sensors here....
    285                SetDataReady();
   \   0000004E   0x.... 0x....      BL       SetDataReady
    286              }
    287            }
    288            return Status;
   \                     ??Proc_Timer2_0: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    289          }
    290          
    291          /**
    292            * @brief  Start Timer 2 in Interrupt mode.
    293            * @param  UartHandle: UART handle
    294            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    295            *         you can add your own implementation.
    296            * @retval None
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          void HAL_TIM_StartTimer2( void )
    299          {
   \                     HAL_TIM_StartTimer2: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    300            SnsrTickCnt = RoadBrd_Get_SnsrTickCnt();
   \   00000002   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   00000006   0x....             LDR.N    R1,??DataTable14_9
   \   00000008   0x6008             STR      R0,[R1, #+0]
    301            RdSndTickCnt = RoadBrd_Get_RdSndTickCnt();
   \   0000000A   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   0000000E   0x....             LDR.N    R1,??DataTable14_8
   \   00000010   0x6008             STR      R0,[R1, #+0]
    302            if (HAL_TIM_Base_Start_IT( &htim2 ) != HAL_OK)
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??HAL_TIM_StartTimer2_0
    303            {
    304              Error_Handler();
   \   0000001C   0x.... 0x....      BL       Error_Handler
    305            }
    306          }
   \                     ??HAL_TIM_StartTimer2_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    307          
    308          /**
    309            * @brief  Start Timer 3 in Interrupt mode.
    310            * @param  UartHandle: UART handle
    311            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    312            *         you can add your own implementation.
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void HAL_TIM_StartTimer3( void )
    316          {
   \                     HAL_TIM_StartTimer3: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    317            if (HAL_TIM_Base_Start_IT( &htim3 ) != HAL_OK)
   \   00000002   0x....             LDR.N    R0,??DataTable14_2
   \   00000004   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??HAL_TIM_StartTimer3_0
    318            {
    319              Error_Handler();
   \   0000000C   0x.... 0x....      BL       Error_Handler
    320            }
    321          }
   \                     ??HAL_TIM_StartTimer3_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    322          
    323          /**
    324            * @brief  Update Key Tick Counts.
    325            * @param  uint32_t PassedRdSndTickCnt
    326            * @param  uint32_t PassedSnsrTickCnt
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void Set_TickCounts( uint32_t PassedRdSndTickCnt, uint32_t PassedSnsrTickCnt )
    330          {
    331            RdSndTickCnt = PassedRdSndTickCnt;
   \                     Set_TickCounts: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_8
   \   00000002   0x6010             STR      R0,[R2, #+0]
    332            SnsrTickCnt = PassedSnsrTickCnt;
   \   00000004   0x....             LDR.N    R2,??DataTable14_9
   \   00000006   0x6011             STR      R1,[R2, #+0]
    333          }
   \   00000008   0x4770             BX       LR               ;; return
    334          
    335          /**
    336            * @brief  Update RdSndTickCnt.
    337            * @param  uint32_t PassedRdSndTickCnt
    338            * @retval None
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          void Set_RdSndTickCnt( uint32_t PassedRdSndTickCnt )
    341          {
    342            RdSndTickCnt = PassedRdSndTickCnt;
   \                     Set_RdSndTickCnt: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_8
   \   00000002   0x6008             STR      R0,[R1, #+0]
    343          }
   \   00000004   0x4770             BX       LR               ;; return
    344          
    345          /**
    346            * @brief  Update SnsrTickCnt.
    347            * @param  uint32_t PassedSnsrTickCnt
    348            * @retval None
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          void Set_SnsrTickCnt( uint32_t PassedSnsrTickCnt )
    351          {
    352            SnsrTickCnt = PassedSnsrTickCnt;
   \                     Set_SnsrTickCnt: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_9
   \   00000002   0x6008             STR      R0,[R1, #+0]
    353          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     htim3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     Timr2Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     ledOffCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     Timr3Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     RdSndTickCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     SnsrTickCnt
    354          
    355          /* USER CODE END 1 */
    356          
    357          /**
    358            * @}
    359            */
    360          
    361          /**
    362            * @}
    363            */
    364          
    365          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Clear_Timer2_Flg
       0   Clear_Timer3_Flg
       0   HAL_TIM_Base_MspDeInit
       4   HAL_TIM_Base_MspInit
       8   HAL_TIM_PeriodElapsedCallback
         8   -> HAL_IncTick
         8   -> RoadBrd_gpio_Off
       8   HAL_TIM_StartTimer2
         8   -> Error_Handler
         8   -> HAL_TIM_Base_Start_IT
         8   -> RoadBrd_Get_RdSndTickCnt
         8   -> RoadBrd_Get_SnsrTickCnt
       8   HAL_TIM_StartTimer3
         8   -> Error_Handler
         8   -> HAL_TIM_Base_Start_IT
      32   MX_TIM2_Init
        32   -> Error_Handler
        32   -> HAL_TIMEx_MasterConfigSynchronization
        32   -> HAL_TIM_Base_Init
        32   -> HAL_TIM_ConfigClockSource
      32   MX_TIM3_Init
        32   -> Error_Handler
        32   -> HAL_TIMEx_MasterConfigSynchronization
        32   -> HAL_TIM_Base_Init
        32   -> HAL_TIM_ConfigClockSource
       8   Proc_Timer2
         8   -> Clear_Timer2_Flg
         8   -> Process_RdSound
         8   -> RoadBrd_Get_RdSndTickCnt
         8   -> RoadBrd_Get_SnsrTickCnt
         8   -> SetDataReady
         8   -> Test_Connection
         8   -> Test_Timer2
       0   Set_RdSndTickCnt
       0   Set_SnsrTickCnt
       0   Set_TickCounts
       0   Test_Timer2
       0   Test_Timer3


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       8  Clear_Timer2_Flg
       8  Clear_Timer3_Flg
      46  HAL_TIM_Base_MspDeInit
      72  HAL_TIM_Base_MspInit
      86  HAL_TIM_PeriodElapsedCallback
      34  HAL_TIM_StartTimer2
      18  HAL_TIM_StartTimer3
     102  MX_TIM2_Init
     100  MX_TIM3_Init
      88  Proc_Timer2
       4  RdSndTickCnt
       6  Set_RdSndTickCnt
       6  Set_SnsrTickCnt
      10  Set_TickCounts
       4  SnsrTickCnt
      16  Test_Timer2
      16  Test_Timer3
       1  Timr2Ready
       1  Timr3Ready
      56  htim2
      56  htim3
       4  ledOffCnt

 
 114 bytes in section .bss
  12 bytes in section .data
 656 bytes in section .text
 
 656 bytes of CODE memory
 126 bytes of DATA memory

Errors: none
Warnings: none
