###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       13/Oct/2017  13:57:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_rcc_ex.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_rcc_ex.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   Extended RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities RCC extension peripheral:
     10            *           + Extended Peripheral Control functions
     11            *  
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************  
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32l1xx_hal.h"
     44          
     45          /** @addtogroup STM32L1xx_HAL_Driver
     46            * @{
     47            */
     48          
     49          #ifdef HAL_RCC_MODULE_ENABLED
     50          
     51          
     52          /** @defgroup RCCEx RCCEx
     53            * @brief RCC Extension HAL module driver
     54            * @{
     55            */
     56          
     57          /* Private typedef -----------------------------------------------------------*/
     58          /* Private define ------------------------------------------------------------*/
     59          /** @defgroup RCCEx_Private_Constants RCCEx Private Constants
     60            * @{
     61            */
     62          /**
     63            * @}
     64            */
     65            
     66          /* Private macro -------------------------------------------------------------*/
     67          /** @defgroup RCCEx_Private_Macros RCCEx Private Macros
     68            * @{
     69            */
     70          /**
     71            * @}
     72            */
     73          
     74          /* Private variables ---------------------------------------------------------*/
     75          /* Private function prototypes -----------------------------------------------*/
     76          /* Private functions ---------------------------------------------------------*/
     77          
     78          /** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
     79            * @{
     80            */
     81          
     82          /** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions 
     83           *  @brief  Extended Peripheral Control functions  
     84           *
     85          @verbatim   
     86           ===============================================================================
     87                          ##### Extended Peripheral Control functions  #####
     88           ===============================================================================  
     89              [..]
     90              This subsection provides a set of functions allowing to control the RCC Clocks 
     91              frequencies.
     92              [..] 
     93              (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
     94                  select the RTC clock source; in this case the Backup domain will be reset in  
     95                  order to modify the RTC Clock source, as consequence RTC registers (including 
     96                  the backup registers) are set to their reset values.
     97                
     98          @endverbatim
     99            * @{
    100            */
    101          
    102          /**
    103            * @brief  Initializes the RCC extended peripherals clocks according to the specified
    104            *         parameters in the RCC_PeriphCLKInitTypeDef.
    105            * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that
    106            *         contains the configuration information for the Extended Peripherals clocks(RTC/LCD clock).
    107            * @retval HAL status
    108            * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
    109            *         to possibly update HSE divider.
    110            */

   \                                 In section .text, align 2, keep-with-next
    111          HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    112          {
   \                     HAL_RCCEx_PeriphCLKConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    113            uint32_t tickstart = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    114            uint32_t temp_reg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    115            
    116            /* Check the parameters */
    117            assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
    118            
    119            /*------------------------------- RTC/LCD Configuration ------------------------*/ 
    120            if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
    121          #if defined(LCD)
    122             || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
    123          #endif /* LCD */
    124               )
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0xF010 0x0F03      TST      R0,#0x3
   \   00000010   0xF000 0x80A4      BEQ.W    ??HAL_RCCEx_PeriphCLKConfig_0
    125            {
    126              /* check for RTC Parameters used to output RTCCLK */
    127              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
    128              {
    129                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    130              }
    131          
    132          #if defined(LCD)
    133              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
   \                     ??HAL_RCCEx_PeriphCLKConfig_1: (+1)
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
    134              {
    135                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    136              }
    137          #endif /* LCD */
    138          
    139              /* As soon as function is called to change RTC clock source, activation of the 
    140                 power domain is done. */
    141              /* Enable Power Clock*/
    142              __HAL_RCC_PWR_CLK_ENABLE();
   \                     ??HAL_RCCEx_PeriphCLKConfig_2: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000024   0x....             LDR.N    R1,??DataTable6  ;; 0x40023824
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
    143              
    144              /* Enable write access to Backup domain */
    145              SET_BIT(PWR->CR, PWR_CR_DBP);
   \   00000034   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40007000
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000003C   0x....             LDR.N    R1,??DataTable6_1  ;; 0x40007000
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    146              
    147              /* Wait for Backup domain Write protection disable */
    148              tickstart = HAL_GetTick();
   \   00000040   0x.... 0x....      BL       HAL_GetTick
   \   00000044   0x0005             MOVS     R5,R0
    149              
    150              while((PWR->CR & PWR_CR_DBP) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40007000
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x05C0             LSLS     R0,R0,#+23
   \   0000004C   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_4
    151              {
    152                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0x1B40             SUBS     R0,R0,R5
   \   00000054   0x2865             CMP      R0,#+101
   \   00000056   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_3
    153                {
    154                  return HAL_TIMEOUT;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xE080             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    155                }
    156              }
    157              
    158              /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */ 
    159              temp_reg = (RCC->CR & RCC_CR_RTCPRE);
   \                     ??HAL_RCCEx_PeriphCLKConfig_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   00000064   0x0006             MOVS     R6,R0
    160              if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
    161          #if defined (LCD)
    162               || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
    163          #endif /* LCD */
    164                 )
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   0000006C   0x4286             CMP      R6,R0
   \   0000006E   0xD104             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_6
   \   00000070   0x68A0             LDR      R0,[R4, #+8]
   \   00000072   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   00000076   0x4286             CMP      R6,R0
   \   00000078   0xD00B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_7
    165              { /* Check HSE State */
    166                if (((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE) && HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
   \                     ??HAL_RCCEx_PeriphCLKConfig_6: (+1)
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   00000080   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000084   0xD105             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_7
   \   00000086   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x0380             LSLS     R0,R0,#+14
   \   0000008C   0xD501             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_7
    167                {
    168                  /* To update HSE divider, first switch-OFF HSE clock oscillator*/
    169                  return HAL_ERROR; 
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE065             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    170                }
    171              }
    172              
    173              /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    174              temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
   \                     ??HAL_RCCEx_PeriphCLKConfig_7: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   0000009A   0x0006             MOVS     R6,R0
    175              
    176              if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
    177                && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
    178          #if defined(LCD)
    179                || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
    180                 && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
    181          #endif /* LCD */
    182               ))
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD045             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_8
   \   000000A0   0x6860             LDR      R0,[R4, #+4]
   \   000000A2   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   000000A6   0x4286             CMP      R6,R0
   \   000000A8   0xD002             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_9
   \   000000AA   0x7820             LDRB     R0,[R4, #+0]
   \   000000AC   0x07C0             LSLS     R0,R0,#+31
   \   000000AE   0xD407             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_10
   \                     ??HAL_RCCEx_PeriphCLKConfig_9: (+1)
   \   000000B0   0x68A0             LDR      R0,[R4, #+8]
   \   000000B2   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   000000B6   0x4286             CMP      R6,R0
   \   000000B8   0xD038             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_8
   \   000000BA   0x7820             LDRB     R0,[R4, #+0]
   \   000000BC   0x0780             LSLS     R0,R0,#+30
   \   000000BE   0xD535             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_8
    183              {
    184                /* Store the content of CSR register before the reset of Backup Domain */
    185                temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
   \                     ??HAL_RCCEx_PeriphCLKConfig_10: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   000000C8   0x0006             MOVS     R6,R0
    186                
    187                /* RTC Clock selection can be changed only if the Backup Domain is reset */
    188                __HAL_RCC_BACKUPRESET_FORCE();
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF44F 0x7180      MOV      R1,#+256
   \   000000D0   0xFAB1 0xF181      CLZ      R1,R1
   \   000000D4   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   000000D6   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    189                __HAL_RCC_BACKUPRESET_RELEASE();
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF44F 0x7180      MOV      R1,#+256
   \   000000E2   0xFAB1 0xF181      CLZ      R1,R1
   \   000000E6   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   000000E8   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    190                
    191                /* Restore the Content of CSR register */
    192                RCC->CSR = temp_reg;
   \   000000EE   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   000000F0   0x6006             STR      R6,[R0, #+0]
    193                
    194                 /* Wait for LSERDY if LSE was enabled */
    195                if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY))
   \   000000F2   0x05B0             LSLS     R0,R6,#+22
   \   000000F4   0xD51A             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_8
    196                {
    197                  /* Get Start Tick */
    198                  tickstart = HAL_GetTick();
   \   000000F6   0x.... 0x....      BL       HAL_GetTick
   \   000000FA   0x0005             MOVS     R5,R0
    199                  
    200                  /* Wait till LSE is ready */  
    201                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_11: (+1)
   \   000000FC   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000100   0xFAB0 0xF080      CLZ      R0,R0
   \   00000104   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000010C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000110   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000114   0x40C8             LSRS     R0,R0,R1
   \   00000116   0x07C0             LSLS     R0,R0,#+31
   \   00000118   0xD408             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_8
    202                  {
    203                    if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   0000011A   0x.... 0x....      BL       HAL_GetTick
   \   0000011E   0x1B40             SUBS     R0,R0,R5
   \   00000120   0xF241 0x3189      MOVW     R1,#+5001
   \   00000124   0x4288             CMP      R0,R1
   \   00000126   0xD3E9             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_11
    204                    {
    205                      return HAL_TIMEOUT;
   \   00000128   0x2003             MOVS     R0,#+3
   \   0000012A   0xE018             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    206                    }
    207                  }
    208                }
    209                
    210              }
    211              __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
   \                     ??HAL_RCCEx_PeriphCLKConfig_8: (+1)
   \   0000012C   0x6860             LDR      R0,[R4, #+4]
   \   0000012E   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   00000132   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000136   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_12
   \   00000138   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0xF030 0x40C0      BICS     R0,R0,#0x60000000
   \   00000140   0x6861             LDR      R1,[R4, #+4]
   \   00000142   0xF011 0x41C0      ANDS     R1,R1,#0x60000000
   \   00000146   0x4308             ORRS     R0,R1,R0
   \   00000148   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40023800
   \   0000014A   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCCEx_PeriphCLKConfig_12: (+1)
   \   0000014C   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0x6861             LDR      R1,[R4, #+4]
   \   00000152   0xF411 0x3140      ANDS     R1,R1,#0x30000
   \   00000156   0x4308             ORRS     R0,R1,R0
   \   00000158   0x....             LDR.N    R1,??DataTable6_3  ;; 0x40023834
   \   0000015A   0x6008             STR      R0,[R1, #+0]
    212            }
    213            
    214            return HAL_OK;
   \                     ??HAL_RCCEx_PeriphCLKConfig_0: (+1)
   \   0000015C   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCCEx_PeriphCLKConfig_5: (+1)
   \   0000015E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    215          }
    216          
    217          /**
    218            * @brief  Get the PeriphClkInit according to the internal
    219            * RCC configuration registers.
    220            * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that 
    221            *         returns the configuration information for the Extended Peripherals clocks(RTC/LCD clocks).
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    225          {
    226            uint32_t srcclk = 0;
   \                     HAL_RCCEx_GetPeriphCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    227            
    228            /* Set all possible values for the extended clock type parameter------------*/
    229            PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x6002             STR      R2,[R0, #+0]
    230          #if defined(LCD)
    231            PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LCD;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    232          #endif /* LCD */
    233          
    234            /* Get the RTC/LCD configuration -----------------------------------------------*/
    235            srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   0000000E   0x....             LDR.N    R2,??DataTable6_3  ;; 0x40023834
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF412 0x3240      ANDS     R2,R2,#0x30000
   \   00000016   0x0011             MOVS     R1,R2
    236            if (srcclk != RCC_RTCCLKSOURCE_HSE_DIV2)
   \   00000018   0xF5B1 0x3F40      CMP      R1,#+196608
   \   0000001C   0xD001             BEQ.N    ??HAL_RCCEx_GetPeriphCLKConfig_0
    237            {
    238              /* Source clock is LSE or LSI*/
    239              PeriphClkInit->RTCClockSelection = srcclk;
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   \   00000020   0xE005             B.N      ??HAL_RCCEx_GetPeriphCLKConfig_1
    240            }
    241            else
    242            {
    243              /* Source clock is HSE. Need to get the prescaler value*/
    244              PeriphClkInit->RTCClockSelection = srcclk | (READ_BIT(RCC->CR, RCC_CR_RTCPRE));
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_0: (+1)
   \   00000022   0x....             LDR.N    R2,??DataTable6_2  ;; 0x40023800
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0xF012 0x42C0      ANDS     R2,R2,#0x60000000
   \   0000002A   0x430A             ORRS     R2,R2,R1
   \   0000002C   0x6042             STR      R2,[R0, #+4]
    245            }
    246          #if defined(LCD)
    247            PeriphClkInit->LCDClockSelection = PeriphClkInit->RTCClockSelection;
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_1: (+1)
   \   0000002E   0x6842             LDR      R2,[R0, #+4]
   \   00000030   0x6082             STR      R2,[R0, #+8]
    248          #endif /* LCD */
    249          }
   \   00000032   0x4770             BX       LR               ;; return
    250          
    251          /**
    252            * @brief  Returns the peripheral clock frequency
    253            * @note   Returns 0 if peripheral clock is unknown
    254            * @param  PeriphClk Peripheral clock identifier
    255            *         This parameter can be one of the following values:
    256            *            @arg @ref RCC_PERIPHCLK_RTC  RTC peripheral clock
    257            *            @arg @ref RCC_PERIPHCLK_LCD  LCD peripheral clock (depends on devices)
    258            * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
    261          {
   \                     HAL_RCCEx_GetPeriphCLKFreq: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0001             MOVS     R1,R0
    262            uint32_t temp_reg = 0, clkprediv = 0, frequency = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2000             MOVS     R0,#+0
    263            uint32_t srcclk = 0;
   \   0000000A   0x2400             MOVS     R4,#+0
    264          
    265            /* Check the parameters */
    266            assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
    267            
    268            switch (PeriphClk)
   \   0000000C   0x000D             MOVS     R5,R1
   \   0000000E   0x1E6D             SUBS     R5,R5,#+1
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD83E             BHI.N    ??HAL_RCCEx_GetPeriphCLKFreq_0
    269            {
    270            case RCC_PERIPHCLK_RTC:
    271          #if defined(LCD)
    272            case RCC_PERIPHCLK_LCD:
    273          #endif /* LCD */
    274              {
    275                /* Get RCC CSR configuration ------------------------------------------------------*/
    276                temp_reg = RCC->CSR;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_1: (+1)
   \   00000014   0x....             LDR.N    R5,??DataTable6_3  ;; 0x40023834
   \   00000016   0x682D             LDR      R5,[R5, #+0]
   \   00000018   0x002A             MOVS     R2,R5
    277          
    278                /* Get the current RTC source */
    279                srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   0000001A   0x....             LDR.N    R5,??DataTable6_3  ;; 0x40023834
   \   0000001C   0x682D             LDR      R5,[R5, #+0]
   \   0000001E   0xF415 0x3540      ANDS     R5,R5,#0x30000
   \   00000022   0x002C             MOVS     R4,R5
    280          
    281                /* Check if LSE is ready if RTC clock selection is LSE */
    282                if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
   \   00000024   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000028   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_2
   \   0000002A   0x0595             LSLS     R5,R2,#+22
   \   0000002C   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_2
    283                {
    284                  frequency = LSE_VALUE;
   \   0000002E   0xF44F 0x4500      MOV      R5,#+32768
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xE02C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    285                }
    286                /* Check if LSI is ready if RTC clock selection is LSI */
    287                else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_2: (+1)
   \   00000036   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000003A   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_4
   \   0000003C   0x0795             LSLS     R5,R2,#+30
   \   0000003E   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_4
    288                {
    289                  frequency = LSI_VALUE;
   \   00000040   0xF249 0x0588      MOVW     R5,#+37000
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0xE023             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    290                }
    291                /* Check if HSE is ready and if RTC clock selection is HSE */
    292                else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIVX) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_4: (+1)
   \   00000048   0xF5B4 0x3F40      CMP      R4,#+196608
   \   0000004C   0xD11E             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
   \   0000004E   0x....             LDR.N    R5,??DataTable6_2  ;; 0x40023800
   \   00000050   0x682D             LDR      R5,[R5, #+0]
   \   00000052   0x03AD             LSLS     R5,R5,#+14
   \   00000054   0xD51A             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
    293                {
    294                  /* Get the current HSE clock divider */
    295                  clkprediv = __HAL_RCC_GET_RTC_HSE_PRESCALER();
   \   00000056   0x....             LDR.N    R5,??DataTable6_2  ;; 0x40023800
   \   00000058   0x682D             LDR      R5,[R5, #+0]
   \   0000005A   0xF015 0x45C0      ANDS     R5,R5,#0x60000000
   \   0000005E   0x002B             MOVS     R3,R5
    296          
    297                  switch (clkprediv)
   \   00000060   0x001D             MOVS     R5,R3
   \   00000062   0xF1B5 0x5F00      CMP      R5,#+536870912
   \   00000066   0xD00B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
   \   00000068   0xF1B5 0x4F80      CMP      R5,#+1073741824
   \   0000006C   0xD005             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_7
   \   0000006E   0xF1B5 0x4FC0      CMP      R5,#+1610612736
   \   00000072   0xD108             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_8
    298                  {
    299                    case RCC_RTC_HSE_DIV_16:  /* HSE DIV16 has been selected */
    300                    {
    301                      frequency = HSE_VALUE / 16;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_9: (+1)
   \   00000074   0x....             LDR.N    R5,??DataTable6_5  ;; 0x7a120
   \   00000076   0x0028             MOVS     R0,R5
    302                      break;
   \   00000078   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    303                    }
    304                    case RCC_RTC_HSE_DIV_8:   /* HSE DIV8 has been selected  */
    305                    {
    306                      frequency = HSE_VALUE / 8;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_7: (+1)
   \   0000007A   0x....             LDR.N    R5,??DataTable6_6  ;; 0xf4240
   \   0000007C   0x0028             MOVS     R0,R5
    307                      break;
   \   0000007E   0xE007             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    308                    }
    309                    case RCC_RTC_HSE_DIV_4:   /* HSE DIV4 has been selected  */
    310                    {
    311                      frequency = HSE_VALUE / 4;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_6: (+1)
   \   00000080   0x....             LDR.N    R5,??DataTable6_7  ;; 0x1e8480
   \   00000082   0x0028             MOVS     R0,R5
    312                      break;
   \   00000084   0xE004             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    313                    }
    314                    default:                  /* HSE DIV2 has been selected  */
    315                    {
    316                      frequency = HSE_VALUE / 2;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_8: (+1)
   \   00000086   0x....             LDR.N    R5,??DataTable6_8  ;; 0x3d0900
   \   00000088   0x0028             MOVS     R0,R5
    317                      break;
   \   0000008A   0xE001             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_3
    318                    }
    319                  }
    320                }
    321                /* Clock not enabled for RTC */
    322                else
    323                {
    324                  frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_5: (+1)
   \   0000008C   0x2500             MOVS     R5,#+0
   \   0000008E   0x0028             MOVS     R0,R5
    325                }
    326                break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_3: (+1)
   \   00000090   0xE7FF             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_10
    327              }
    328            default: 
    329              {
    330                break;
    331              }
    332            }
    333            return(frequency);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_0: (+1)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_10: (+1)
   \   00000092   0xBC70             POP      {R4-R6}
   \   00000094   0x4770             BX       LR               ;; return
    334          }
    335          
    336          #if defined(RCC_CSR_LSECSSON)
    337          /**
    338            * @brief  Enables the LSE Clock Security System.
    339            * @note   If a failure is detected on the external 32 kHz oscillator, the LSE clock is no longer supplied
    340            *         to the RTC but no hardware action is made to the registers.
    341            *         In Standby mode a wakeup is generated. In other modes an interrupt can be sent to wakeup
    342            *         the software (see Section 5.3.4: Clock interrupt register (RCC_CIR) on page 104).
    343            *         The software MUST then disable the LSECSSON bit, stop the defective 32 kHz oscillator
    344            *         (disabling LSEON), and can change the RTC clock source (no clock or LSI or HSE, with
    345            *         RTCSEL), or take any required action to secure the application.  
    346            * @note   LSE CSS available only for high density and medium+ devices
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void HAL_RCCEx_EnableLSECSS(void)
    350          {
    351            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCCEx_EnableLSECSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    352          }
   \   00000012   0x4770             BX       LR               ;; return
    353          
    354          /**
    355            * @brief  Disables the LSE Clock Security System.
    356            * @note   Once enabled this bit cannot be disabled, except after an LSE failure detection 
    357            *         (LSECSSD=1). In that case the software MUST disable the LSECSSON bit.
    358            *         Reset by power on reset and RTC software reset (RTCRST bit).
    359            * @note   LSE CSS available only for high density and medium+ devices
    360            * @retval None
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          void HAL_RCCEx_DisableLSECSS(void)
    363          {
    364            /* Disable LSE CSS */
    365            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCCEx_DisableLSECSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    366          
    367            /* Disable LSE CSS IT */
    368            __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
   \   00000012   0x....             LDR.N    R0,??DataTable6_9  ;; 0x4002380d
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000001A   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4002380d
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    369          }
   \   0000001E   0x4770             BX       LR               ;; return
    370          
    371          /**
    372            * @brief  Enable the LSE Clock Security System IT & corresponding EXTI line.
    373            * @note   LSE Clock Security System IT is mapped on RTC EXTI line 19
    374            * @retval None
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          void HAL_RCCEx_EnableLSECSS_IT(void)
    377          {
    378            /* Enable LSE CSS */
    379            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCCEx_EnableLSECSS_IT: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    380          
    381            /* Enable LSE CSS IT */
    382            __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
   \   00000012   0x....             LDR.N    R0,??DataTable6_9  ;; 0x4002380d
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000001A   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4002380d
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    383            
    384            /* Enable IT on EXTI Line 19 */
    385            __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
   \   0000001E   0x....             LDR.N    R0,??DataTable6_10  ;; 0x40010400
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000026   0x....             LDR.N    R1,??DataTable6_10  ;; 0x40010400
   \   00000028   0x6008             STR      R0,[R1, #+0]
    386            __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
   \   0000002A   0x....             LDR.N    R0,??DataTable6_11  ;; 0x40010408
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000032   0x....             LDR.N    R1,??DataTable6_11  ;; 0x40010408
   \   00000034   0x6008             STR      R0,[R1, #+0]
    387          }
   \   00000036   0x4770             BX       LR               ;; return
    388          
    389          /**
    390            * @brief Handle the RCC LSE Clock Security System interrupt request.
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          void HAL_RCCEx_LSECSS_IRQHandler(void)
    394          {
   \                     HAL_RCCEx_LSECSS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    395            /* Check RCC LSE CSSF flag  */
    396            if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
   \   00000002   0x....             LDR.N    R0,??DataTable6_12  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0640             LSLS     R0,R0,#+25
   \   00000008   0xD504             BPL.N    ??HAL_RCCEx_LSECSS_IRQHandler_0
    397            {
    398              /* RCC LSE Clock Security System interrupt user callback */
    399              HAL_RCCEx_LSECSS_Callback();
   \   0000000A   0x.... 0x....      BL       HAL_RCCEx_LSECSS_Callback
    400          
    401              /* Clear RCC LSE CSS pending bit */
    402              __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x....             LDR.N    R1,??DataTable6_13  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    403            }
    404          }                                                                            
   \                     ??HAL_RCCEx_LSECSS_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    405          
    406          /**
    407            * @brief  RCCEx LSE Clock Security System interrupt callback.
    408            * @retval none
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          __weak void HAL_RCCEx_LSECSS_Callback(void)
    411          {
    412            /* NOTE : This function should not be modified, when the callback is needed,
    413                      the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
    414             */
    415          }
   \                     HAL_RCCEx_LSECSS_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x40010408         DC32     0x40010408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x4002380E         DC32     0x4002380e
    416          #endif /* RCC_CSR_LSECSSON */
    417            
    418          /**
    419            * @}
    420            */
    421          
    422          /**
    423            * @}
    424            */
    425          
    426          /**
    427            * @}
    428            */
    429          
    430          #endif /* HAL_RCC_MODULE_ENABLED */
    431          /**
    432            * @}
    433            */
    434          
    435          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCCEx_DisableLSECSS
       0   HAL_RCCEx_EnableLSECSS
       0   HAL_RCCEx_EnableLSECSS_IT
       0   HAL_RCCEx_GetPeriphCLKConfig
      12   HAL_RCCEx_GetPeriphCLKFreq
       0   HAL_RCCEx_LSECSS_Callback
       8   HAL_RCCEx_LSECSS_IRQHandler
         8   -> HAL_RCCEx_LSECSS_Callback
      24   HAL_RCCEx_PeriphCLKConfig
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      32  HAL_RCCEx_DisableLSECSS
      20  HAL_RCCEx_EnableLSECSS
      56  HAL_RCCEx_EnableLSECSS_IT
      52  HAL_RCCEx_GetPeriphCLKConfig
     150  HAL_RCCEx_GetPeriphCLKFreq
       2  HAL_RCCEx_LSECSS_Callback
      22  HAL_RCCEx_LSECSS_IRQHandler
     352  HAL_RCCEx_PeriphCLKConfig

 
 742 bytes in section .text
 
 742 bytes of CODE memory

Errors: none
Warnings: none
