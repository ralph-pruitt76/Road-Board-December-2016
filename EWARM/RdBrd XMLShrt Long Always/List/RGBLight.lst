###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       08/Dec/2017  07:22:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\RGBLight.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\RGBLight.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\RGBLight.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\RGBLight.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\RGBLight.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : RGBLight.c
      4            * Description        : This file provides code for the control of the RGB Light
      5            *                      sensor hardware based on the ISL91250 chip.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "RGBLight.h"
     37          #include "Calibration.h"
     38          
     39            /**
     40            * @brief  This function initializes the RGB sensor Hardware. This is the 
     41            *         default init. Assume Default Parms and write them.
     42            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
     43            *                                HAL_ERROR:    Error found in Tasking or data passed.
     44            *                                HAL_BUSY:     UART is busy.
     45            *                                HAL_TIMEOUT:  UART timed out.
     46            */

   \                                 In section .text, align 2, keep-with-next
     47          HAL_StatusTypeDef RoadBrd_RGBInit( void )
     48          {
   \                     RoadBrd_RGBInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     49            HAL_StatusTypeDef Status;
     50            int num_bytes;
     51            uint8_t i2cData[4];  
     52          
     53            // This is the default init. Assume Default Parms and write them.
     54            // Load Config Register with Config Settings
     55            num_bytes = 3;    // No Data to Pass.
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x0005             MOVS     R5,R0
     56            i2cData[0] = (uint8_t)RGB_CNFG1_DEFAULT;
   \   00000006   0x201D             MOVS     R0,#+29
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
     57            i2cData[1] = (uint8_t)RGB_CNFG2_DEFAULT;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
     58            i2cData[2] = (uint8_t)RGB_CNFG3_DEFAULT;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
     59          #ifdef REV_L
     60            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_CNFG1, i2cData, (uint16_t)num_bytes);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0003             MOVS     R3,R0
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2088             MOVS     R0,#+136
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000028   0x0004             MOVS     R4,R0
     61            // 2. If Status was good, Time to get response.
     62            if (Status == HAL_OK)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD10C             BNE.N    ??RoadBrd_RGBInit_0
     63            {
     64              // Now wait for completion of XMIT.
     65              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000036   0x0004             MOVS     R4,R0
     66              if (Status != HAL_OK)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD002             BEQ.N    ??RoadBrd_RGBInit_1
     67                return Status;
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xE004             B.N      ??RoadBrd_RGBInit_2
     68            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
     69            else
     70              return Status;
     71          #else
     72            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_CNFG1, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
     73          #endif
     74            return Status;
   \                     ??RoadBrd_RGBInit_1: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xE001             B.N      ??RoadBrd_RGBInit_2
   \                     ??RoadBrd_RGBInit_0: (+1)
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBInit_2: (+1)
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     75          }
     76          
     77            /**
     78            * @brief  This function initializes the RGB sensor Hardware. This is the 
     79            *         Full  init. Assume Default Parms and write them.
     80            * @param  RGBInitPtr LPtr: Ptr to structure of initialization parameters.
     81            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
     82            *                                HAL_ERROR:    Error found in Tasking or data passed.
     83            *                                HAL_BUSY:     UART is busy.
     84            *                                HAL_TIMEOUT:  UART timed out.
     85            */

   \                                 In section .text, align 2, keep-with-next
     86          HAL_StatusTypeDef RoadBrd_RGBFullInit( RGBInitPtr LPtr )
     87          {
   \                     RoadBrd_RGBFullInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     88            HAL_StatusTypeDef Status;
     89            int num_bytes;
     90            uint8_t i2cData[4];  
     91          
     92            // This is the default init. Assume Default Parms and write them.
     93            // Load Config Register with Config Settings
     94            num_bytes = 3;    // No Data to Pass.
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0x0006             MOVS     R6,R0
     95            i2cData[0] = LPtr->config1;
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     96            i2cData[1] = LPtr->config2;
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
     97            i2cData[2] = LPtr->config3;
   \   00000016   0x78A0             LDRB     R0,[R4, #+2]
   \   00000018   0xF88D 0x0002      STRB     R0,[SP, #+2]
     98          #ifdef REV_L
     99            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_CNFG1, i2cData, (uint16_t)num_bytes);
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x0003             MOVS     R3,R0
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x466A             MOV      R2,SP
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2088             MOVS     R0,#+136
   \   00000028   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000002C   0x0005             MOVS     R5,R0
    100            // 2. If Status was good, Time to get response.
    101            if (Status == HAL_OK)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD10C             BNE.N    ??RoadBrd_RGBFullInit_0
    102            {
    103              // Now wait for completion of XMIT.
    104              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000034   0x2064             MOVS     R0,#+100
   \   00000036   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000003A   0x0005             MOVS     R5,R0
    105              if (Status != HAL_OK)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD002             BEQ.N    ??RoadBrd_RGBFullInit_1
    106                return Status;
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE004             B.N      ??RoadBrd_RGBFullInit_2
    107            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    108            else
    109              return Status;
    110          #else
    111            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_CNFG1, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    112          #endif
    113            return Status;
   \                     ??RoadBrd_RGBFullInit_1: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xE001             B.N      ??RoadBrd_RGBFullInit_2
   \                     ??RoadBrd_RGBFullInit_0: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBFullInit_2: (+1)
   \   00000052   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    114          }
    115          
    116            /**
    117            * @brief  This function resets the RGB sensor Hardware. 
    118            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    119            *                                HAL_ERROR:    Error found in Tasking or data passed.
    120            *                                HAL_BUSY:     UART is busy.
    121            *                                HAL_TIMEOUT:  UART timed out.
    122            */

   \                                 In section .text, align 2, keep-with-next
    123          HAL_StatusTypeDef RoadBrd_RGBReset( void )
    124          {
   \                     RoadBrd_RGBReset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    125            HAL_StatusTypeDef Status;
    126            int num_bytes;
    127            uint8_t i2cData[4];  
    128          
    129            // 1. Time to send Command and collect status.
    130            num_bytes = 1;    // No Data to Pass.
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x0005             MOVS     R5,R0
    131            i2cData[0] = (uint8_t)RGB_RESET_CODE;
   \   00000006   0x2046             MOVS     R0,#+70
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    132          #ifdef REV_L
    133            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_IDRST, i2cData, (uint16_t)num_bytes);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x0003             MOVS     R3,R0
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2088             MOVS     R0,#+136
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   0000001C   0x0004             MOVS     R4,R0
    134            // 2. If Status was good, Time to get response.
    135            if (Status == HAL_OK)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD10C             BNE.N    ??RoadBrd_RGBReset_0
    136            {
    137              // Now wait for completion of XMIT.
    138              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002A   0x0004             MOVS     R4,R0
    139              if (Status != HAL_OK)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??RoadBrd_RGBReset_1
    140                return Status;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE004             B.N      ??RoadBrd_RGBReset_2
    141            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    142            else
    143              return Status;
    144          #else
    145            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_IDRST, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    146          #endif
    147          
    148            return Status;
   \                     ??RoadBrd_RGBReset_1: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xE001             B.N      ??RoadBrd_RGBReset_2
   \                     ??RoadBrd_RGBReset_0: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBReset_2: (+1)
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    149          }
    150          
    151          /**
    152            * @brief  This function reads the Part ID.
    153            * @param  RGBIdentPtr id: Ptr to structure to receive the final values of the Part ID.
    154            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    155            *                                HAL_ERROR:    Error found in Tasking or data passed.
    156            *                                HAL_BUSY:     UART is busy.
    157            *                                HAL_TIMEOUT:  UART timed out.
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef RoadBrd_RGBReadID( RGBIdentPtr id )
    160          {
   \                     RoadBrd_RGBReadID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    161            HAL_StatusTypeDef Status;
    162            int num_bytes;
    163            uint8_t i2cData[4];  
    164          
    165            // 1. Time to send Command and collect status.
    166            num_bytes = 0;    // No Data to Pass.
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0006             MOVS     R6,R0
    167            i2cData[0] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    168          #ifdef REV_L
    169            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_IDRST, i2cData, (uint16_t)num_bytes);
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x0003             MOVS     R3,R0
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2088             MOVS     R0,#+136
   \   0000001C   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000020   0x0005             MOVS     R5,R0
    170            // 2. If Status was good, Time to get response.
    171            if (Status == HAL_OK)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD123             BNE.N    ??RoadBrd_RGBReadID_0
    172            {
    173              // Now wait for completion of XMIT.
    174              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000028   0x2064             MOVS     R0,#+100
   \   0000002A   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002E   0x0005             MOVS     R5,R0
    175              if (Status != HAL_OK)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD002             BEQ.N    ??RoadBrd_RGBReadID_1
    176                return Status;
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE027             B.N      ??RoadBrd_RGBReadID_2
    177              else
    178              {
    179                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)RGB_SNSR, i2cData, (uint16_t)1);
   \                     ??RoadBrd_RGBReadID_1: (+1)
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x2088             MOVS     R0,#+136
   \   00000042   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000046   0x0005             MOVS     R5,R0
    180                if (Status == HAL_OK)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD10D             BNE.N    ??RoadBrd_RGBReadID_3
    181                {
    182                  // Now wait for completion of Receive.
    183                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   0000004E   0x2064             MOVS     R0,#+100
   \   00000050   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000054   0x0005             MOVS     R5,R0
    184                  if (Status != HAL_OK)
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD002             BEQ.N    ??RoadBrd_RGBReadID_4
    185                    return Status;
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xE014             B.N      ??RoadBrd_RGBReadID_2
    186                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    187                else
    188                  return Status;
    189              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    190            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    191            else
    192              return Status;
    193          #else
    194            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_IDRST, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    195            // 2. If Status was good, Time to get response.
    196            if (Status == HAL_OK)
    197            {
    198              Status =  RoadBrd_I2C_Master_Receive((uint16_t)RGB_SNSR, i2cData, (uint16_t)1, I2C_TIMEOUT);
    199            }
    200            else
    201              return Status;
    202          #endif
    203            if (Status == HAL_OK)
   \                     ??RoadBrd_RGBReadID_4: (+1)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD10F             BNE.N    ??RoadBrd_RGBReadID_5
   \   00000068   0xE005             B.N      ??RoadBrd_RGBReadID_6
   \                     ??RoadBrd_RGBReadID_3: (+1)
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE00D             B.N      ??RoadBrd_RGBReadID_2
   \                     ??RoadBrd_RGBReadID_0: (+1)
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE00A             B.N      ??RoadBrd_RGBReadID_2
    204            {
    205              // Build Status
    206              id->id = i2cData[0];
   \                     ??RoadBrd_RGBReadID_6: (+1)
   \   00000076   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007A   0x7020             STRB     R0,[R4, #+0]
    207              sprintf( (char *)id->Raw, "%02x", i2cData[0]);
   \   0000007C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable2_1
   \   00000082   0x1C60             ADDS     R0,R4,#+1
   \   00000084   0x.... 0x....      BL       sprintf
    208              //strcat( (char *)id->Raw, "Rw" );
    209            }
    210            return Status;
   \                     ??RoadBrd_RGBReadID_5: (+1)
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBReadID_2: (+1)
   \   0000008C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    211          }
    212          
    213          /**
    214            * @brief  This function reads the Part Status.
    215            * @param  RGBIdentPtr id: Ptr to structure to receive the final values of the Part Status.
    216            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    217            *                                HAL_ERROR:    Error found in Tasking or data passed.
    218            *                                HAL_BUSY:     UART is busy.
    219            *                                HAL_TIMEOUT:  UART timed out.
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          HAL_StatusTypeDef RoadBrd_RGBReadStatus( RGBStatusPtr Stat )
    222          {
   \                     RoadBrd_RGBReadStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    223            HAL_StatusTypeDef Status;
    224            int num_bytes;
    225            uint8_t i2cData[4];  
    226          
    227            // 1. Time to send Command and collect status.
    228            num_bytes = 0;    // No Data to Pass.
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0006             MOVS     R6,R0
    229            i2cData[0] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    230          #ifdef REV_L
    231            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_STATUS, i2cData, (uint16_t)num_bytes);
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x0003             MOVS     R3,R0
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x2108             MOVS     R1,#+8
   \   0000001A   0x2088             MOVS     R0,#+136
   \   0000001C   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000020   0x0005             MOVS     R5,R0
    232            // 2. If Status was good, Time to get response.
    233            if (Status == HAL_OK)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD123             BNE.N    ??RoadBrd_RGBReadStatus_0
    234            {
    235              // Now wait for completion of XMIT.
    236              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000028   0x2064             MOVS     R0,#+100
   \   0000002A   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002E   0x0005             MOVS     R5,R0
    237              if (Status != HAL_OK)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD002             BEQ.N    ??RoadBrd_RGBReadStatus_1
    238                return Status;
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE027             B.N      ??RoadBrd_RGBReadStatus_2
    239              else
    240              {
    241                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)RGB_SNSR, i2cData, (uint16_t)1);
   \                     ??RoadBrd_RGBReadStatus_1: (+1)
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x2088             MOVS     R0,#+136
   \   00000042   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000046   0x0005             MOVS     R5,R0
    242                if (Status == HAL_OK)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD10D             BNE.N    ??RoadBrd_RGBReadStatus_3
    243                {
    244                  // Now wait for completion of Receive.
    245                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   0000004E   0x2064             MOVS     R0,#+100
   \   00000050   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000054   0x0005             MOVS     R5,R0
    246                  if (Status != HAL_OK)
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD002             BEQ.N    ??RoadBrd_RGBReadStatus_4
    247                    return Status;
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xE014             B.N      ??RoadBrd_RGBReadStatus_2
    248                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    249                else
    250                  return Status;
    251              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    252            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    253            else
    254              return Status;
    255          #else
    256            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_IDRST, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    257            // 2. If Status was good, Time to get response.
    258            if (Status == HAL_OK)
    259            {
    260              Status =  RoadBrd_I2C_Master_Receive((uint16_t)RGB_SNSR, i2cData, (uint16_t)1, I2C_TIMEOUT);
    261            }
    262            else
    263              return Status;
    264          #endif
    265            if (Status == HAL_OK)
   \                     ??RoadBrd_RGBReadStatus_4: (+1)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD10F             BNE.N    ??RoadBrd_RGBReadStatus_5
   \   00000068   0xE005             B.N      ??RoadBrd_RGBReadStatus_6
   \                     ??RoadBrd_RGBReadStatus_3: (+1)
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE00D             B.N      ??RoadBrd_RGBReadStatus_2
   \                     ??RoadBrd_RGBReadStatus_0: (+1)
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE00A             B.N      ??RoadBrd_RGBReadStatus_2
    266            {
    267              // Build Status
    268              Stat->status = i2cData[0];
   \                     ??RoadBrd_RGBReadStatus_6: (+1)
   \   00000076   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007A   0x7020             STRB     R0,[R4, #+0]
    269              sprintf( (char *)Stat->Raw, "%02x", i2cData[0]);
   \   0000007C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable2_1
   \   00000082   0x1C60             ADDS     R0,R4,#+1
   \   00000084   0x.... 0x....      BL       sprintf
    270              //strcat( (char *)Stat->Raw, "Rw" );
    271            }
    272            return Status;
   \                     ??RoadBrd_RGBReadStatus_5: (+1)
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBReadStatus_2: (+1)
   \   0000008C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    273          }
    274          
    275          /**
    276            * @brief  This function reads the Light Values to the passed Light Structure.
    277            * @param  RGBLghtPtr LPtr: Ptr to structure to receive the final values of the Light Values.
    278            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    279            *                                HAL_ERROR:    Error found in Tasking or data passed.
    280            *                                HAL_BUSY:     UART is busy.
    281            *                                HAL_TIMEOUT:  UART timed out.
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          HAL_StatusTypeDef RoadBrd_RGBReadValues( RGBLghtPtr LPtr )
    284          {
   \                     RoadBrd_RGBReadValues: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    285            HAL_StatusTypeDef Status;
    286            int num_bytes;
    287            uint8_t i2cData[6];  
    288            char tempBffr2[5];
    289            uint16_t CalcValue;
    290            int x;
    291          
    292            num_bytes = 0;    // No Data to Pass.
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4680             MOV      R8,R0
    293            i2cData[0] = 0x00;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    294          #ifdef REV_L
    295            Status = RoadBrd_I2C_Master_Transmit_CMDData_IT((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_GREENL, i2cData, (uint16_t)num_bytes);
   \   00000010   0x4640             MOV      R0,R8
   \   00000012   0x0003             MOVS     R3,R0
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x2109             MOVS     R1,#+9
   \   0000001A   0x2088             MOVS     R0,#+136
   \   0000001C   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData_IT
   \   00000020   0x0006             MOVS     R6,R0
    296            // 2. If Status was good, Time to get response.
    297            if (Status == HAL_OK)
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD123             BNE.N    ??RoadBrd_RGBReadValues_0
    298            {
    299              // Now wait for completion of XMIT.
    300              Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   00000028   0x2064             MOVS     R0,#+100
   \   0000002A   0x.... 0x....      BL       RoadBrd_WaitForState
   \   0000002E   0x0006             MOVS     R6,R0
    301              if (Status != HAL_OK)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD002             BEQ.N    ??RoadBrd_RGBReadValues_1
    302                return Status;
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE08A             B.N      ??RoadBrd_RGBReadValues_2
    303              else
    304              {
    305                Status =  RoadBrd_I2C_Master_Receive_IT((uint16_t)RGB_SNSR, i2cData, (uint16_t)6);
   \                     ??RoadBrd_RGBReadValues_1: (+1)
   \   0000003C   0x2206             MOVS     R2,#+6
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x2088             MOVS     R0,#+136
   \   00000042   0x.... 0x....      BL       RoadBrd_I2C_Master_Receive_IT
   \   00000046   0x0006             MOVS     R6,R0
    306                if (Status == HAL_OK)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD10D             BNE.N    ??RoadBrd_RGBReadValues_3
    307                {
    308                  // Now wait for completion of Receive.
    309                  Status = RoadBrd_WaitForState( (uint16_t)( I2C_TIMEOUT/5 ));
   \   0000004E   0x2064             MOVS     R0,#+100
   \   00000050   0x.... 0x....      BL       RoadBrd_WaitForState
   \   00000054   0x0006             MOVS     R6,R0
    310                  if (Status != HAL_OK)
   \   00000056   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD002             BEQ.N    ??RoadBrd_RGBReadValues_4
    311                    return Status;
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xE077             B.N      ??RoadBrd_RGBReadValues_2
    312                } // EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Receive_IT
    313                else
    314                  return Status;
    315              } // EndElse (Status != HAL_OK) RoadBrd_WaitForState
    316            }// EndIf (Status == HAL_OK) RoadBrd_I2C_Master_Transmit_CMDData_IT
    317            else
    318              return Status;
    319          #else
    320            Status = RoadBrd_I2C_Master_Transmit_CMDData((uint16_t)RGB_SNSR, (uint8_t)RGB_SNSR_GREENL, i2cData, (uint16_t)num_bytes, I2C_TIMEOUT);
    321            // 2. If Status was good, Time to get response.
    322            if (Status == HAL_OK)
    323            {
    324              Status =  RoadBrd_I2C_Master_Receive((uint16_t)RGB_SNSR, i2cData, (uint16_t)6, I2C_TIMEOUT);
    325            }
    326            else
    327              return Status;
    328          #endif
    329            if (Status == HAL_OK)
   \                     ??RoadBrd_RGBReadValues_4: (+1)
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD122             BNE.N    ??RoadBrd_RGBReadValues_5
   \   00000068   0xE005             B.N      ??RoadBrd_RGBReadValues_6
   \                     ??RoadBrd_RGBReadValues_3: (+1)
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE070             B.N      ??RoadBrd_RGBReadValues_2
   \                     ??RoadBrd_RGBReadValues_0: (+1)
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE06D             B.N      ??RoadBrd_RGBReadValues_2
    330            {
    331              // NOW, Build Data String..
    332              sprintf( (char *)LPtr->Raw, "%02x", i2cData[0]);
   \                     ??RoadBrd_RGBReadValues_6: (+1)
   \   00000076   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000007A   0x....             LDR.N    R1,??DataTable2_1
   \   0000007C   0xF114 0x0018      ADDS     R0,R4,#+24
   \   00000080   0x.... 0x....      BL       sprintf
    333              for(x=1; x<6; x++)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x0007             MOVS     R7,R0
   \                     ??RoadBrd_RGBReadValues_7: (+1)
   \   00000088   0x2F06             CMP      R7,#+6
   \   0000008A   0xDA0C             BGE.N    ??RoadBrd_RGBReadValues_8
    334              {
    335                sprintf( (char *)tempBffr2, "%02x", i2cData[x]);
   \   0000008C   0x4668             MOV      R0,SP
   \   0000008E   0x5DC2             LDRB     R2,[R0, R7]
   \   00000090   0x....             LDR.N    R1,??DataTable2_1
   \   00000092   0xA802             ADD      R0,SP,#+8
   \   00000094   0x.... 0x....      BL       sprintf
    336                strcat( (char *)LPtr->Raw, (char *)tempBffr2 );
   \   00000098   0xA902             ADD      R1,SP,#+8
   \   0000009A   0xF114 0x0018      ADDS     R0,R4,#+24
   \   0000009E   0x.... 0x....      BL       strcat
    337              }
   \   000000A2   0x1C7F             ADDS     R7,R7,#+1
   \   000000A4   0xE7F0             B.N      ??RoadBrd_RGBReadValues_7
    338              //strcat( (char *)LPtr->Raw, "Rw" );
    339              strcat( (char *)tempBffr2, "\r\n" );
   \                     ??RoadBrd_RGBReadValues_8: (+1)
   \   000000A6   0x....             ADR.N    R1,??DataTable2  ;; 0x0D, 0x0A, 0x00, 0x00
   \   000000A8   0xA802             ADD      R0,SP,#+8
   \   000000AA   0x.... 0x....      BL       strcat
    340            }
    341            
    342            // Now calculate Each RGB Value.
    343            CalcValue = i2cData[0] + (i2cData[1] * 256);
   \                     ??RoadBrd_RGBReadValues_5: (+1)
   \   000000AE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B2   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000000B6   0xF44F 0x7280      MOV      R2,#+256
   \   000000BA   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000BE   0x0005             MOVS     R5,R0
    344            sprintf( (char *)LPtr->Red, "%05.2f", ((float)CalcValue/6.6));
   \   000000C0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C2   0x0028             MOVS     R0,R5
   \   000000C4   0x.... 0x....      BL       __aeabi_ui2f
   \   000000C8   0x.... 0x....      BL       __aeabi_f2d
   \   000000CC   0xF05F 0x3266      MOVS     R2,#+1717986918
   \   000000D0   0x....             LDR.N    R3,??DataTable2_2  ;; 0x401a6666
   \   000000D2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000D6   0x0002             MOVS     R2,R0
   \   000000D8   0x000B             MOVS     R3,R1
   \   000000DA   0x....             LDR.N    R1,??DataTable2_3
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       sprintf
    345            CalcValue = i2cData[2] + (i2cData[3] * 256);
   \   000000E2   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000E6   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000000EA   0xF44F 0x7280      MOV      R2,#+256
   \   000000EE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000F2   0x0005             MOVS     R5,R0
    346            sprintf( (char *)LPtr->Green, "%05.2f", ((float)CalcValue/6.6));
   \   000000F4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       __aeabi_ui2f
   \   000000FC   0x.... 0x....      BL       __aeabi_f2d
   \   00000100   0xF05F 0x3266      MOVS     R2,#+1717986918
   \   00000104   0x....             LDR.N    R3,??DataTable2_2  ;; 0x401a6666
   \   00000106   0x.... 0x....      BL       __aeabi_ddiv
   \   0000010A   0x0002             MOVS     R2,R0
   \   0000010C   0x000B             MOVS     R3,R1
   \   0000010E   0x....             LDR.N    R1,??DataTable2_3
   \   00000110   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000114   0x.... 0x....      BL       sprintf
    347            CalcValue = i2cData[4] + (i2cData[5] * 256);
   \   00000118   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000011C   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000120   0xF44F 0x7280      MOV      R2,#+256
   \   00000124   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000128   0x0005             MOVS     R5,R0
    348            sprintf( (char *)LPtr->Blue, "%05.2f", ((float)CalcValue/6.6));
   \   0000012A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000132   0x.... 0x....      BL       __aeabi_f2d
   \   00000136   0xF05F 0x3266      MOVS     R2,#+1717986918
   \   0000013A   0x....             LDR.N    R3,??DataTable2_2  ;; 0x401a6666
   \   0000013C   0x.... 0x....      BL       __aeabi_ddiv
   \   00000140   0x0002             MOVS     R2,R0
   \   00000142   0x000B             MOVS     R3,R1
   \   00000144   0x....             LDR.N    R1,??DataTable2_3
   \   00000146   0xF114 0x0010      ADDS     R0,R4,#+16
   \   0000014A   0x.... 0x....      BL       sprintf
    349            return Status;
   \   0000014E   0x0030             MOVS     R0,R6
   \   00000150   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_RGBReadValues_2: (+1)
   \   00000152   0xB004             ADD      SP,SP,#+16
   \   00000154   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    350          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x401A6666         DC32     0x401a6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x25 0x30          DC8 "%02x"
   \              0x32 0x78    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x25 0x30          DC8 "%05.2f"
   \              0x35 0x2E    
   \              0x32 0x66    
   \              0x00         
   \   00000007   0x00               DC8 0
    351          
    352          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RoadBrd_RGBFullInit
        24   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        24   -> RoadBrd_WaitForState
      16   RoadBrd_RGBInit
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState
      24   RoadBrd_RGBReadID
        24   -> RoadBrd_I2C_Master_Receive_IT
        24   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        24   -> RoadBrd_WaitForState
        24   -> sprintf
      24   RoadBrd_RGBReadStatus
        24   -> RoadBrd_I2C_Master_Receive_IT
        24   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        24   -> RoadBrd_WaitForState
        24   -> sprintf
      40   RoadBrd_RGBReadValues
        40   -> RoadBrd_I2C_Master_Receive_IT
        40   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        40   -> RoadBrd_WaitForState
        40   -> __aeabi_ddiv
        40   -> __aeabi_f2d
        40   -> __aeabi_ui2f
        40   -> sprintf
        40   -> strcat
      16   RoadBrd_RGBReset
        16   -> RoadBrd_I2C_Master_Transmit_CMDData_IT
        16   -> RoadBrd_WaitForState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       8  ?_0
       4  ?_1
       8  ?_2
      84  RoadBrd_RGBFullInit
      80  RoadBrd_RGBInit
     142  RoadBrd_RGBReadID
     142  RoadBrd_RGBReadStatus
     344  RoadBrd_RGBReadValues
      68  RoadBrd_RGBReset

 
  20 bytes in section .rodata
 876 bytes in section .text
 
 876 bytes of CODE  memory
  20 bytes of CONST memory

Errors: none
Warnings: none
