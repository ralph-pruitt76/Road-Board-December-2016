###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       25/Jan/2018  11:28:15
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\bgm111.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\bgm111.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\bgm111.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\bgm111.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\bgm111.c
      1          /* SiLabs BGM111 module access implementation using BGLib */
      2          
      3          #include "bgm111.h"
      4          #include <string.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char const *, char const *)
   \                     strstr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strstr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
      5          #include "gecko_bglib.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct gecko_msg_le_gap_set_mode_rsp_t *gecko_cmd_le_gap_set_mode(uint8, uint8)
   \                     gecko_cmd_le_gap_set_mode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7104             STRB     R4,[R0, #+4]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x7145             STRB     R5,[R0, #+5]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_1  ;; 0x1030220
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x1D01             ADDS     R1,R0,#+4
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       gecko_handle_command
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1D00             ADDS     R0,R0,#+4
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct gecko_msg_gatt_server_write_attribute_value_rsp_t *gecko_cmd_gatt_server_write_attribute_value(uint16, uint16, uint8, uint8 const *)
   \                     gecko_cmd_gatt_server_write_attribute_value: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x8084             STRH     R4,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x80C5             STRH     R5,[R0, #+6]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x7206             STRB     R6,[R0, #+8]
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF110 0x0809      ADDS     R8,R0,#+9
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0x0039             MOVS     R1,R7
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable21_2  ;; 0x20a0520
   \   00000040   0xEB10 0x2006      ADDS     R0,R0,R6, LSL #+8
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x1D01             ADDS     R1,R0,#+4
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x.... 0x....      BL       gecko_handle_command
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x1D00             ADDS     R0,R0,#+4
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t *gecko_cmd_gatt_server_send_characteristic_notification(uint8, uint16, uint8, uint8 const *)
   \                     gecko_cmd_gatt_server_send_characteristic_notification: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x7104             STRB     R4,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF8A0 0x5005      STRH     R5,[R0, #+5]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x71C6             STRB     R6,[R0, #+7]
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF110 0x0808      ADDS     R8,R0,#+8
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x50a0420
   \   00000042   0xEB10 0x2006      ADDS     R0,R0,R6, LSL #+8
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1D01             ADDS     R1,R0,#+4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       gecko_handle_command
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x1D00             ADDS     R0,R0,#+4
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
      6          #include "stm32l1xx_hal.h"
      7          #include "usart.h"
      8          #include "gpio.h"
      9          #include "ErrorCodes.h"
     10          #include "i2c.h"
     11          #include "wwdg.h"
     12          #include "tim.h"
     13          #include "Parser.h"
     14          
     15          /* BGLib instantiation */
     16          

   \                                 In section .bss, align 4
     17          BGLIB_DEFINE();
   \                     _gecko_cmd_msg:
   \   00000000                      DS8 132

   \                                 In section .bss, align 4
   \   __absolute struct gecko_cmd_packet _gecko_rsp_msg
   \                     _gecko_rsp_msg:
   \   00000000                      DS8 132

   \                                 In section .data, align 4
   \   __absolute struct gecko_cmd_packet *gecko_cmd_msg
   \                     gecko_cmd_msg:
   \   00000000   0x........         DC32 _gecko_cmd_msg

   \                                 In section .bss, align 4
   \   __absolute struct gecko_cmd_packet *gecko_evt_msg
   \                     gecko_evt_msg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute void (*bglib_output)(uint32_t, uint8_t *)
   \                     bglib_output:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute int32_t (*bglib_input)(uint32_t, uint8_t *)
   \                     bglib_input:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute int32_t (*bglib_peek)(void)
   \                     bglib_peek:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct gecko_cmd_packet gecko_queue[30]
   \                     gecko_queue:
   \   00000000                      DS8 3960

   \                                 In section .bss, align 4
   \   __absolute int gecko_queue_w
   \                     gecko_queue_w:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute int gecko_queue_r
   \                     gecko_queue_r:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
   \   __absolute struct gecko_cmd_packet *gecko_rsp_msg
   \                     gecko_rsp_msg:
   \   00000000   0x........         DC32 _gecko_rsp_msg
     18          
     19          /* Define buffer size for BLE communication */
     20          
     21          // #define BG_DATA_LENGTH          70   // Code fills this buffer size full on the RX side...11/18/16 RP
     22          #define BG_DATA_LENGTH          200   
     23          
     24          /* Define number of free bytes in buffer when we need to process a packet
     25           * even if that means we need to wait in a loop */
     26          
     27          #define BG_DATA_LOW_WATERMARK   5
     28          #define BGM_BANNER_LENGTH       40
     29          

   \                                 In section .bss, align 4
     30          static char bgm_Bannerstr[BGM_BANNER_LENGTH];
   \                     bgm_Bannerstr:
   \   00000000                      DS8 40
     31             
     32          /* BG reception states */
     33          
     34          enum BgRxState
     35          {
     36            BGRX_SYNC,
     37            BGRX_HDR,
     38            BGRX_DATA
     39          };
     40          
     41          
     42          /* MSG LOGGER */
     43          struct
     44          {
     45            uint32_t msgBuff[BG_DATA_LENGTH];
     46            uint16_t tx_wr;

   \                                 In section .bss, align 4
     47          } static blemsgs;
   \                     blemsgs:
   \   00000000                      DS8 804
     48          
     49          /* BLE communication structure */
     50          struct
     51          {
     52            uint8_t tx_buf[BG_DATA_LENGTH];
     53            uint8_t tx_wr;
     54            volatile uint8_t tx_rd;
     55            uint8_t rx_buf[BG_DATA_LENGTH];
     56            volatile uint8_t rx_wr;
     57            uint8_t rx_rd;
     58            volatile enum BgRxState rx_state;
     59            volatile bool req_exec;
     60            bool booted;
     61            bool connection;
     62            bool data_Connection;
     63            bool CMD_Mode;
     64            uint8_t TackArmed;
     65            uint16_t TackCnt;
     66            uint8_t SyncFlag;
     67            struct gecko_cmd_packet *evt;

   \                                 In section .bss, align 4
     68          } static ble;
   \                     `ble`:
   \   00000000                      DS8 420
     69          
     70          
     71          /* BGM111 module low level init */
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void BGM111_LowLevel_Init(void)
     74          {
     75            blemsgs.tx_wr = 0;
   \                     BGM111_LowLevel_Init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000006   0xF8A1 0x0320      STRH     R0,[R1, #+800]
     76            ble.booted =  false;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000010   0xF881 0x0196      STRB     R0,[R1, #+406]
     77            ble.connection = false;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000001A   0xF881 0x0197      STRB     R0,[R1, #+407]
     78            ble.data_Connection = false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000024   0xF881 0x0198      STRB     R0,[R1, #+408]
     79            ble.CMD_Mode = false;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000002E   0xF881 0x0199      STRB     R0,[R1, #+409]
     80            ble.TackArmed = TACK_OFF;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000038   0xF881 0x019A      STRB     R0,[R1, #+410]
     81            ble.TackCnt = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000042   0xF8A1 0x019C      STRH     R0,[R1, #+412]
     82            ble.SyncFlag = SYNC_PROC;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000004C   0xF881 0x019E      STRB     R0,[R1, #+414]
     83          }
   \   00000050   0x4770             BX       LR               ;; return
     84          
     85          /* Next buffer index based on current index and buffer size */
     86          
     87          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
     88          uint8_t NextBufIdx(uint8_t idx)
     89          {
     90            idx++;
   \                     NextBufIdx: (+1)
   \   00000000   0x1C40             ADDS     R0,R0,#+1
     91            return idx < BG_DATA_LENGTH ? idx : 0;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x28C8             CMP      R0,#+200
   \   00000006   0xDB00             BLT.N    ??NextBufIdx_0
   \                     ??NextBufIdx_1: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??NextBufIdx_0: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4770             BX       LR               ;; return
     92          }
     93          
     94          /* Report if the buffer is full based on its indexes */
     95          
     96          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
     97          bool IsBufFull(uint8_t wr_idx, uint8_t rd_idx)
     98          {
   \                     IsBufFull: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     99            return NextBufIdx(wr_idx) == rd_idx;
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       NextBufIdx
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42A8             CMP      R0,R5
   \   00000012   0xD101             BNE.N    ??IsBufFull_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??IsBufFull_1
   \                     ??IsBufFull_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??IsBufFull_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    100          }
    101          
    102          /* Get the used space in the buffer based on its indexes */
    103          
    104          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
    105          uint8_t BufUsed(uint8_t wr_idx, uint8_t rd_idx)
    106          {
   \                     BufUsed: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    107            int size = (int)wr_idx - (int)rd_idx;
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x1A50             SUBS     R0,R2,R1
    108            if (size < 0)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD500             BPL.N    ??BufUsed_0
    109            {
    110              size = BG_DATA_LENGTH + size;
   \   0000000C   0x30C8             ADDS     R0,R0,#+200
    111            }
    112            return size;
   \                     ??BufUsed_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
    113          }
    114          
    115          /* Get the free space in the buffer based on its indexes */
    116          
    117          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
    118          uint8_t BufFree(uint8_t wr_idx, uint8_t rd_idx)
    119          {
   \                     BufFree: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    120            return (BG_DATA_LENGTH - 1) - BufUsed(wr_idx, rd_idx);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       BufUsed
   \   00000012   0xF1D0 0x00C7      RSBS     R0,R0,#+199
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    121          }
    122          
    123          /* Receive data from the BGM111 module */
    124          

   \                                 In section .text, align 2, keep-with-next
    125          int BGM111_Receive(uint32_t len, uint8_t *data)
    126          {
   \                     BGM111_Receive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    127            
    128            /* Wait until we received the requested number of data bytes */
    129            while (len)
   \                     ??BGM111_Receive_0: (+1)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD027             BEQ.N    ??BGM111_Receive_1
    130            {
    131              /* Is there a byte in the receive buffer? */
    132              if (ble.rx_rd != ble.rx_wr)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000000E   0xF890 0x0193      LDRB     R0,[R0, #+403]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000016   0xF891 0x1192      LDRB     R1,[R1, #+402]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD01B             BEQ.N    ??BGM111_Receive_2
    133              {
    134                /* Disable interrupt */
    135          //      NVIC_DisableIRQ(BGM111_UART_IRQn);
    136                /* Clear the request to execute the BLE stack now we're doing it */
    137                ble.req_exec = false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000024   0xF881 0x0195      STRB     R0,[R1, #+405]
    138                /* Write to the output buffer */
    139                *data++ = ble.rx_buf[ble.rx_rd];
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000030   0xF891 0x1193      LDRB     R1,[R1, #+403]
   \   00000034   0x4408             ADD      R0,R0,R1
   \   00000036   0xF890 0x00CA      LDRB     R0,[R0, #+202]
   \   0000003A   0x7028             STRB     R0,[R5, #+0]
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
    140                /* Next byte in the receive buffer */
    141                ble.rx_rd = NextBufIdx(ble.rx_rd);
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000042   0xF890 0x0193      LDRB     R0,[R0, #+403]
   \   00000046   0x.... 0x....      BL       NextBufIdx
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000004E   0xF881 0x0193      STRB     R0,[R1, #+403]
    142                /* Enable interrupt */
    143          //      NVIC_EnableIRQ(BGM111_UART_IRQn);
    144          
    145                /* One byte less to wait for */
    146                len--;
   \   00000052   0x1E64             SUBS     R4,R4,#+1
   \   00000054   0xE7D7             B.N      ??BGM111_Receive_0
    147              }
    148              else
    149              {
    150                // Time to prime the pump again....
    151                HAL_UART_EnableBGM_RX();
   \                     ??BGM111_Receive_2: (+1)
   \   00000056   0x.... 0x....      BL       HAL_UART_EnableBGM_RX
    152                break;
    153              }
    154            }
    155            return 0;
   \                     ??BGM111_Receive_1: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    156          }
    157          
    158          /* Check whether there is input data from the BGM111 module */
    159          

   \                                 In section .text, align 2, keep-with-next
    160          int BGM111_Peek(void)
    161          {
    162            return ble.req_exec;
   \                     BGM111_Peek: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x0195      LDRB     R0,[R0, #+405]
   \   00000008   0x4770             BX       LR               ;; return
    163          }
    164          
    165          /* Initialize the BGM111 module and BGLib */
    166          

   \                                 In section .text, align 2, keep-with-next
    167          void BGM111_Init(void)
    168          {
   \                     BGM111_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    169            /* Perform low level init to initialize the UART for use with the 
    170             * BGM111 module */
    171            BGM111_LowLevel_Init();
   \   00000002   0x.... 0x....      BL       BGM111_LowLevel_Init
    172            /* Pull the BGM111 reset pin low */
    173            RoadBrd_gpio_Off( gRESET_BGM111 );
   \   00000006   0x2006             MOVS     R0,#+6
   \   00000008   0x.... 0x....      BL       RoadBrd_gpio_Off
    174            /* Initialize BGLib with our transmit, receive and peek routines */
    175            BGLIB_INITIALIZE_NONBLOCK(BGM111_Transmit, BGM111_Receive, BGM111_Peek);
   \   0000000C   0x.... 0x....      ADR.W    R0,BGM111_Transmit
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable25_3
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable25_5
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable25_6
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    176            /* Release the BGM111 reset pin */
    177            RoadBrd_gpio_On( gRESET_BGM111 );
   \   0000002A   0x2006             MOVS     R0,#+6
   \   0000002C   0x.... 0x....      BL       RoadBrd_gpio_On
    178          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    179          
    180          /* Process any input from the BLE module */
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void BGM111_ProcessInput(void)
    183          {
   \                     BGM111_ProcessInput: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    184            /* Event structure */
    185            uint32_t temp1;
    186            uint8_t tempBffr2[20];
    187            bool Boot_evt = false;
   \   00000004   0x2500             MOVS     R5,#+0
    188            struct gecko_msg_le_gap_set_mode_rsp_t *Result_Ptr;
    189            /* Check whether there is an event to service */
    190            if (!ble.evt)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000000A   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??BGM111_ProcessInput_0
    191            {
    192              ble.evt = gecko_peek_event();
   \   00000012   0x.... 0x....      BL       gecko_peek_event
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000001A   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    193            }
    194            if (ble.evt)
   \                     ??BGM111_ProcessInput_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000022   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF000 0x80EF      BEQ.W    ??BGM111_ProcessInput_1
    195            {
    196              // Log Event
    197              blemsgs.msgBuff[blemsgs.tx_wr] = BGLIB_MSG_ID(ble.evt->header);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000030   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable25_8  ;; 0xffff00f8
   \   0000003A   0x4008             ANDS     R0,R1,R0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable25_1
   \   00000044   0xF8B2 0x2320      LDRH     R2,[R2, #+800]
   \   00000048   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    198              blemsgs.tx_wr = NextBufIdx(blemsgs.tx_wr);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000050   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x.... 0x....      BL       NextBufIdx
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000005E   0xF8A1 0x0320      STRH     R0,[R1, #+800]
    199              
    200              /* Service based on event header message ID */
    201              temp1 = BGLIB_MSG_ID(ble.evt->header);
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000066   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable25_8  ;; 0xffff00f8
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x0004             MOVS     R4,R0
    202              switch(temp1)
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable25_9  ;; 0x100a0
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD02A             BEQ.N    ??BGM111_ProcessInput_2
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable25_10  ;; 0x800a0
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD058             BEQ.N    ??BGM111_ProcessInput_3
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable25_11  ;; 0x900a0
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xF000 0x8082      BEQ.W    ??BGM111_ProcessInput_4
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable25_12  ;; 0x10800a0
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD029             BEQ.N    ??BGM111_ProcessInput_5
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable25_13  ;; 0x20800a0
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD079             BEQ.N    ??BGM111_ProcessInput_4
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable25_14  ;; 0x20a0020
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD057             BEQ.N    ??BGM111_ProcessInput_6
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable25_15  ;; 0x20b00a0
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xF000 0x8092      BEQ.W    ??BGM111_ProcessInput_7
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable25_16  ;; 0x30a00a0
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD05A             BEQ.N    ??BGM111_ProcessInput_8
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable25_17  ;; 0x50a0020
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD062             BEQ.N    ??BGM111_ProcessInput_9
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable25_18  ;; 0x8090020
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xD064             BEQ.N    ??BGM111_ProcessInput_4
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable25_19  ;; 0x200000a0
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD05A             BEQ.N    ??BGM111_ProcessInput_9
   \   000000D2   0xE08B             B.N      ??BGM111_ProcessInput_10
    203              //switch (BGLIB_MSG_ID(ble.evt->header))
    204              {
    205                /* System boot handler */
    206                case gecko_evt_system_boot_id:
    207                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<BGM_BOOT>");
   \                     ??BGM111_ProcessInput_2: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable25_20
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      BL       RoadBrd_UART_Transmit
    208                  Boot_evt = true;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x0005             MOVS     R5,R0
    209                  /* Flag that the BLE module has booted */
    210                  ble.booted = true;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000E8   0xF881 0x0196      STRB     R0,[R1, #+406]
    211                  /* Fallthrough intentional */
    212                /* Connection closed handler */
    213                case gecko_evt_le_connection_closed_id:
    214                  // Wait for power to stabilize...200msec
    215          //        RoadBrd_Delay( 100 );
    216          //        gecko_cmd_le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable);
    217          //        RoadBrd_Delay( 100 );
    218          //        gecko_cmd_le_gap_set_mode(le_gap_non_discoverable, le_gap_non_connectable);
    219          //        RoadBrd_Delay( 100 );
    220                  /* Set GAP mode: discoverable and connectable */
    221                  ble.connection = false;
   \                     ??BGM111_ProcessInput_5: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000F2   0xF881 0x0197      STRB     R0,[R1, #+407]
    222          //        Result_Ptr = gecko_cmd_le_gap_set_mode(le_gap_limited_discoverable, le_gap_undirected_connectable);
    223                  Result_Ptr = gecko_cmd_le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable);
   \   000000F6   0x2102             MOVS     R1,#+2
   \   000000F8   0x2002             MOVS     R0,#+2
   \   000000FA   0x.... 0x....      BL       gecko_cmd_le_gap_set_mode
   \   000000FE   0x0006             MOVS     R6,R0
    224                  if ( Result_Ptr->result == 0)
   \   00000100   0x8830             LDRH     R0,[R6, #+0]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD117             BNE.N    ??BGM111_ProcessInput_11
    225          //        if (gecko_cmd_le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable)->result == 0)
    226          //        if (gecko_cmd_le_gap_set_mode(le_gap_limited_discoverable, le_gap_undirected_connectable)->result < bg_errspc_bg)
    227                  {
    228                    // Don't reset first time. This is legitimate
    229                    // The following is a simple patch...Best way right now to recover is to force HARD Reset....
    230                    if (Boot_evt == false)
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2D00             CMP      R5,#+0
   \   0000010A   0xD10F             BNE.N    ??BGM111_ProcessInput_12
    231                    {
    232                      RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<BGM_CNCTCLOSE>");
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable25_21
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x.... 0x....      BL       RoadBrd_UART_Transmit
    233                      RdBrd_ErrCdLogErrCd( ERROR_BGM_CNNCT, MODULE_bgm111 );
   \   00000116   0x2102             MOVS     R1,#+2
   \   00000118   0x200D             MOVS     R0,#+13
   \   0000011A   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    234                      Clr_HrtBeat_Cnt();
   \   0000011E   0x.... 0x....      BL       Clr_HrtBeat_Cnt
    235                      RdBrd_BlinkErrCd( ERROR_BGM_CNNCT );
   \   00000122   0x200D             MOVS     R0,#+13
   \   00000124   0x.... 0x....      BL       RdBrd_BlinkErrCd
    236                      //RoadBrd_Delay( 1000 );
    237                      HAL_NVIC_SystemReset();
   \   00000128   0x.... 0x....      BL       HAL_NVIC_SystemReset
    238                    }
    239                    /* We succeeded, don't handle this event again */
    240                    ble.evt = NULL;
   \                     ??BGM111_ProcessInput_12: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000132   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    241                  }
    242                  break;
   \                     ??BGM111_ProcessInput_11: (+1)
   \   00000136   0xE068             B.N      ??BGM111_ProcessInput_1
    243                //case 0x000800A0:
    244                case gecko_evt_le_connection_opened_id:
    245                  /* Open Event...Set Active Connection Flag */
    246                  /* Don't handle this event again */
    247                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<BGM_CNCTOPEN>");
   \                     ??BGM111_ProcessInput_3: (+1)
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable25_22
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x.... 0x....      BL       RoadBrd_UART_Transmit
    248                  ble.connection = true;
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000148   0xF881 0x0197      STRB     R0,[R1, #+407]
    249                  ble.evt = NULL;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000152   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    250                  break;
   \   00000156   0xE058             B.N      ??BGM111_ProcessInput_1
    251                // gecko_evt_gatt_server_user_write_request_id
    252                case 0x020A0020:
    253                  // Clear Heart Beat... We have detected it.
    254                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"-*-");
   \                     ??BGM111_ProcessInput_6: (+1)
   \   00000158   0x....             ADR.N    R1,??DataTable20  ;; "-*-"
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0x.... 0x....      BL       RoadBrd_UART_Transmit
    255                  Clr_HeartBeat();
   \   00000160   0x.... 0x....      BL       Clr_HeartBeat
    256                  ble.evt = NULL;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000016A   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    257                  break;
   \   0000016E   0xE04C             B.N      ??BGM111_ProcessInput_1
    258                //case 0x030A0000:
    259                case gecko_evt_gatt_server_characteristic_status_id:
    260                  // Clear Heart Beat... We have detected it.
    261                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"-O-");
   \                     ??BGM111_ProcessInput_8: (+1)
   \   00000170   0x....             ADR.N    R1,??DataTable20_1  ;; "-O-"
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x.... 0x....      BL       RoadBrd_UART_Transmit
    262                  Clr_HeartBeat();
   \   00000178   0x.... 0x....      BL       Clr_HeartBeat
    263                  ble.evt = NULL;
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000182   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    264                  break;
   \   00000186   0xE040             B.N      ??BGM111_ProcessInput_1
    265          //      case 0x080000A0:
    266          //      case 0x020B00A0:
    267          //      case 0x000000A0:
    268                case 0x200000A0:
    269                case 0x050A0020:
    270          //      case 0x200000A0:
    271          //      case gecko_cmd_gatt_server_send_characteristic_notification_id: */
    272                /* Dummy catchall */
    273                  /* Don't handle this event again */
    274                  ble.evt = NULL;
   \                     ??BGM111_ProcessInput_9: (+1)
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000018E   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    275                  break;
   \   00000192   0xE03A             B.N      ??BGM111_ProcessInput_1
    276                case gecko_rsp_gatt_read_characteristic_value_by_uuid_id:
    277                case 0x020800A0:
    278                case 0x000900A0:
    279                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<rsp_read_ch_value_by_uuid_id>");
   \                     ??BGM111_ProcessInput_4: (+1)
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable25_23
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0x.... 0x....      BL       RoadBrd_UART_Transmit
    280                  if (ble.evt->data.evt_gatt_server_attribute_value.value.len != 0)
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   000001A2   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   000001A6   0x7A80             LDRB     R0,[R0, #+10]
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0xD00E             BEQ.N    ??BGM111_ProcessInput_13
    281                  {
    282                    sprintf( (char *)tempBffr2, "<STR:%s>", ble.evt->data.evt_gatt_server_attribute_value.value.data);
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   000001B0   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   000001B4   0xF110 0x020B      ADDS     R2,R0,#+11
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable25_24
   \   000001BC   0x4668             MOV      R0,SP
   \   000001BE   0x.... 0x....      BL       sprintf
    283                    RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \   000001C2   0x4669             MOV      R1,SP
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0x.... 0x....      BL       RoadBrd_UART_Transmit
    284                  }
    285                  ble.evt = NULL;
   \                     ??BGM111_ProcessInput_13: (+1)
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000001D0   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    286                  break;
   \   000001D4   0xE019             B.N      ??BGM111_ProcessInput_1
    287                case gecko_evt_endpoint_status_id:
    288                  RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<evt_endpoint_status_id>");
   \                     ??BGM111_ProcessInput_7: (+1)
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable25_25
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x.... 0x....      BL       RoadBrd_UART_Transmit
    289                  ble.evt = NULL;
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000001E6   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    290                  break;
   \   000001EA   0xE00E             B.N      ??BGM111_ProcessInput_1
    291                /* Dummy catchall */
    292                default:
    293                  sprintf( (char *)tempBffr2, "<UNKN:%08x>", temp1);
   \                     ??BGM111_ProcessInput_10: (+1)
   \   000001EC   0x0022             MOVS     R2,R4
   \   000001EE   0x.... 0x....      LDR.W    R1,??DataTable25_26
   \   000001F2   0x4668             MOV      R0,SP
   \   000001F4   0x.... 0x....      BL       sprintf
    294                  RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \   000001F8   0x4669             MOV      R1,SP
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0x.... 0x....      BL       RoadBrd_UART_Transmit
    295                  /* Don't handle this event again */
    296                  ble.evt = NULL;
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000206   0xF8C1 0x01A0      STR      R0,[R1, #+416]
    297                  break;
    298              };
    299              // Test RX Buffer and Set req_exec flag.
    300          //    if (BufUsed(ble.rx_wr, ble.rx_rd) != 0)
    301          //    {
    302          //      /* Indicate we need to execute the BLE stack to process 
    303          //       * the received packet */
    304          //      ble.req_exec = true;
    305          //    }
    306            } // EndIf (ble.evt)
    307          }
   \                     ??BGM111_ProcessInput_1: (+1)
   \   0000020A   0xB006             ADD      SP,SP,#+24
   \   0000020C   0xBD70             POP      {R4-R6,PC}       ;; return
    308          
    309          /* BLE write characteristic */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          void BGM111_WriteCharacteristic(uint16_t handle, uint8_t len, uint8_t *data)
    312          {
   \                     BGM111_WriteCharacteristic: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    313            /* Write the attribute */
    314            gecko_cmd_gatt_server_write_attribute_value(handle, 0, len, data);
   \   00000008   0x0033             MOVS     R3,R6
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x.... 0x....      BL       gecko_cmd_gatt_server_write_attribute_value
    315            /* Also trigger notify if enabled */
    316            gecko_cmd_gatt_server_send_characteristic_notification(0xFF,
    317                      handle, len, data);
   \   00000018   0x0033             MOVS     R3,R6
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      BL       gecko_cmd_gatt_server_send_characteristic_notification
    318          }
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    319          
    320          /**
    321            * @brief  Check whether the BLE module has booted and is ready for a command.
    322            * @retval bool:         true(1):        BGAPI IS ready.
    323            *                       false(0):         BGAPI NOT ready.
    324            */

   \                                 In section .text, align 2, keep-with-next
    325          bool BGM111_Ready(void)
    326          {
    327            return ble.booted;
   \                     BGM111_Ready: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x0196      LDRB     R0,[R0, #+406]
   \   00000008   0x4770             BX       LR               ;; return
    328          }
    329          
    330          /**
    331            * @brief  Check whether the BLE module is connected.
    332            * @retval bool:         true(1):        Connection is Active.
    333            *                       false(0):       NO Connection.
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          bool BGM111_Connected(void)
    336          {
    337            return ble.connection;
   \                     BGM111_Connected: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x0197      LDRB     R0,[R0, #+407]
   \   00000008   0x4770             BX       LR               ;; return
    338          }
    339          
    340          /**
    341            * @brief  Check whether the BLE module is DATA connected.
    342            * @retval bool:         true(1):        DATA Connection is Active.
    343            *                       false(0):       NO DATA Connection.
    344            */

   \                                 In section .text, align 2, keep-with-next
    345          bool BGM111_DataConnected(void)
    346          {
    347            return ble.data_Connection;
   \                     BGM111_DataConnected: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x0198      LDRB     R0,[R0, #+408]
   \   00000008   0x4770             BX       LR               ;; return
    348          }
    349          
    350          /**
    351            * @brief  Check whether the BLE module is in CMD Mode.
    352            * @retval bool:         true(1):        CMD Mode is Active.
    353            *                       false(0):       CMD Mode is  not Active.
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          bool BGM111_CMD_Mode(void)
    356          {
    357            return ble.CMD_Mode;
   \                     BGM111_CMD_Mode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x0199      LDRB     R0,[R0, #+409]
   \   00000008   0x4770             BX       LR               ;; return
    358          }
    359          
    360          /**
    361            * @brief  Set the BLE module is DATA connected.
    362            * @param bool:         true(1):        DATA Connection is Active.
    363            *                      false(0):       NO DATA Connection.
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void BGM111_SetDataConnected(bool NewMode)
    366          {
    367            ble.data_Connection = NewMode;
   \                     BGM111_SetDataConnected: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000004   0xF881 0x0198      STRB     R0,[R1, #+408]
    368          }
   \   00000008   0x4770             BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Set new BLE CMD Mode.
    372            * @param bool:         true(1):        CMD Mode is Active.
    373            *                      false(0):       CMD Mode is  not Active.
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          void BGM111_SetCMD_Mode(bool NewMode)
    376          {
    377            ble.CMD_Mode = NewMode;
   \                     BGM111_SetCMD_Mode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000004   0xF881 0x0199      STRB     R0,[R1, #+409]
    378          }
   \   00000008   0x4770             BX       LR               ;; return
    379          
    380          /**
    381            * @brief  Check whether the BLE module is in Sync Mode and Waiting for ACK.
    382            * @retval bool:         true(1):        Sync Ready for Processing next Frame.
    383            *                       false(0):       Sync needs to wait.
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          bool BGM111_SyncModeTest(void)
    386          {
   \                     BGM111_SyncModeTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
    387            uint8_t tempBffr2[40];
    388            bool Status = false;
   \   00000004   0x2400             MOVS     R4,#+0
    389          
    390            // Is Sync Mode armed? Yes.. Then Need to test SyncFlag
    391            if (ble.TackArmed == TACK_SYNC)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000000A   0xF890 0x019A      LDRB     R0,[R0, #+410]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD148             BNE.N    ??BGM111_SyncModeTest_0
    392            {
    393              // If SyncFlag is SYNC_PROC, then allow Frame send.
    394              if (ble.SyncFlag == SYNC_PROC)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000016   0xF890 0x019E      LDRB     R0,[R0, #+414]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD102             BNE.N    ??BGM111_SyncModeTest_1
    395              {
    396                Status = true;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x0004             MOVS     R4,R0
   \   00000022   0xE041             B.N      ??BGM111_SyncModeTest_2
    397              }
    398              // NO, then Incrment count, We are one step closer to Reset Code.
    399              else
    400              {
    401                // Test to see if we have had a timing tick yet...
    402                if ( TstRdSndReady() )
   \                     ??BGM111_SyncModeTest_1: (+1)
   \   00000024   0x.... 0x....      BL       TstRdSndReady
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD038             BEQ.N    ??BGM111_SyncModeTest_3
    403                {
    404                  // Clear Flag for next Tick Event.
    405                  ClrRdSndReady();
   \   0000002C   0x.... 0x....      BL       ClrRdSndReady
    406                  // Increment Cnt and Report...
    407                  ble.TackCnt++;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000034   0xF8B0 0x019C      LDRH     R0,[R0, #+412]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000003E   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    408                  sprintf( (char *)tempBffr2, "<TACK Strike:%d/%d>", ble.TackCnt, RoadBrd_Get_TackLimit() );
   \   00000042   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   00000046   0x0003             MOVS     R3,R0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000004C   0xF8B0 0x219C      LDRH     R2,[R0, #+412]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable25_27
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       sprintf
    409                  RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       RoadBrd_UART_Transmit
    410                  BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x.... 0x....      BL       strlen
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x.... 0x....      BL       BGM111_Transmit
    411                  
    412                  if (ble.TackCnt > RoadBrd_Get_TackLimit())
   \   0000006E   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000076   0xF8B1 0x119C      LDRH     R1,[R1, #+412]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD20F             BCS.N    ??BGM111_SyncModeTest_3
    413                  {
    414                    // Time to process error and reset code....NO Choice.
    415                    RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<BGMSYNC_CNCTCLOSE>");
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable25_28
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       RoadBrd_UART_Transmit
    416                    RdBrd_ErrCdLogErrCd( ERROR_BGM_SYNCCNCT, MODULE_bgm111 );
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x2012             MOVS     R0,#+18
   \   0000008C   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    417                    Clr_HrtBeat_Cnt();
   \   00000090   0x.... 0x....      BL       Clr_HrtBeat_Cnt
    418                    RdBrd_BlinkErrCd( ERROR_BGM_SYNCCNCT );
   \   00000094   0x2012             MOVS     R0,#+18
   \   00000096   0x.... 0x....      BL       RdBrd_BlinkErrCd
    419                    //RoadBrd_Delay( 1000 );
    420                    HAL_NVIC_SystemReset();
   \   0000009A   0x.... 0x....      BL       HAL_NVIC_SystemReset
    421                  } // EndIf (ble.TackCnt >TACK_LIMIT)
    422                } // EndIf ( TstDataReady() )
    423                Status = false;
   \                     ??BGM111_SyncModeTest_3: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0004             MOVS     R4,R0
   \   000000A2   0xE001             B.N      ??BGM111_SyncModeTest_2
    424              } // EndElse (ble.SyncFlag == SYNC_PROC)
    425            } // EndIf (ble.TackArmed == TACK_SYNC)
    426            // No....Then we can continue process. Return true.
    427            else
    428              Status = true;
   \                     ??BGM111_SyncModeTest_0: (+1)
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x0004             MOVS     R4,R0
    429            
    430            return Status;
   \                     ??BGM111_SyncModeTest_2: (+1)
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xB00A             ADD      SP,SP,#+40
   \   000000AE   0xBD10             POP      {R4,PC}          ;; return
    431          }
    432          
    433          /**
    434            * @brief  Check whether the BLE module is in Sync Mode and Waiting for ACK.
    435            * @retval bool:         true(1):        Sync Ready for Processing next Frame.
    436            *                       false(0):       Sync needs to wait.
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          bool BGM111_SyncModeTestNoInc(void)
    439          {
    440            // Is Sync Mode armed? Yes.. Then Need to test SyncFlag
    441            if (ble.TackArmed == TACK_SYNC)
   \                     BGM111_SyncModeTestNoInc: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x019A      LDRB     R0,[R0, #+410]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD109             BNE.N    ??BGM111_SyncModeTestNoInc_0
    442            {
    443              // If SyncFlag is SYNC_PROC, then allow Frame send.
    444              if (ble.SyncFlag == SYNC_PROC)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000010   0xF890 0x019E      LDRB     R0,[R0, #+414]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??BGM111_SyncModeTestNoInc_1
    445                return true;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE002             B.N      ??BGM111_SyncModeTestNoInc_2
    446              else
    447                return false;
   \                     ??BGM111_SyncModeTestNoInc_1: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE000             B.N      ??BGM111_SyncModeTestNoInc_2
    448            } // EndIf (ble.TackArmed == TACK_SYNC)
    449            // No....Then we can continue process. Return true.
    450            else
    451              return true;
   \                     ??BGM111_SyncModeTestNoInc_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \                     ??BGM111_SyncModeTestNoInc_2: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    452          }
    453          
    454          /**
    455            * @brief  Set new Value for Sync Flag.
    456            * @param uint8_t:       SYNC_WAIT(0):       Force Wait on all tests to send additional data
    457            *                       SYNC_PROC(1):       Allow sending of additional frame of data.
    458            * @retval None
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          void BGM111_SetSyncFlg(uint8_t NewFlag)
    461          {
    462            ble.SyncFlag = NewFlag;
   \                     BGM111_SetSyncFlg: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000004   0xF881 0x019E      STRB     R0,[R1, #+414]
    463          }
   \   00000008   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @brief  Set new Value for Sync Flag if in SYNC Mode.
    467            * @param uint8_t:       SYNC_WAIT(0):       Force Wait on all tests to send additional data
    468            *                       SYNC_PROC(1):       Allow sending of additional frame of data.
    469            * @retval None
    470            */

   \                                 In section .text, align 2, keep-with-next
    471          void BGM111_cntrlSetSyncFlg(uint8_t NewFlag)
    472          {
    473            // Is Sync Mode armed? Yes.. Then Need to test SyncFlag
    474            if (ble.TackArmed == TACK_SYNC)
   \                     BGM111_cntrlSetSyncFlg: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000004   0xF891 0x119A      LDRB     R1,[R1, #+410]
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0xD103             BNE.N    ??BGM111_cntrlSetSyncFlg_0
    475            {
    476              ble.SyncFlag = NewFlag;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000010   0xF881 0x019E      STRB     R0,[R1, #+414]
    477            }
    478          }
   \                     ??BGM111_cntrlSetSyncFlg_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    479          
    480          /**
    481            * @brief  Return Tack State.
    482            * @retval uint8_t:      TACK_OFF      = 0        Power Up Initialized Value.
    483            *                       TACK_ARMED    = 1        Set when Connection has been detected.
    484            *                       TACK_ARMED2   = 2        Set when First Tick Generated assuming TACK_ARMED State detected.
    485            *                       TACK_SYNC     = 3        Set when first TACK detected while a TACK_ARMED2 State detected.
    486            *                       TACK_ASYNC    = 4        Set when next TICK detected while TACK_ARMED2 State active.
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          uint8_t BGM111_GetTackState(void)
    489          {
    490            return ble.TackArmed;
   \                     BGM111_GetTackState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000004   0xF890 0x019A      LDRB     R0,[R0, #+410]
   \   00000008   0x4770             BX       LR               ;; return
    491          }
    492          
    493          /**
    494            * @brief  Set Tack State.
    495            * @param uint8_t:       TACK_OFF      = 0        Power Up Initialized Value.
    496            *                       TACK_ARMED    = 1        Set when Connection has been detected.
    497            *                       TACK_ARMED2   = 2        Set when First Tick Generated assuming TACK_ARMED State detected.
    498            *                       TACK_SYNC     = 3        Set when first TACK detected while a TACK_ARMED2 State detected.
    499            *                       TACK_ASYNC    = 4        Set when next TICK detected while TACK_ARMED2 State active.
    500            * @retval None
    501            */

   \                                 In section .text, align 2, keep-with-next
    502          void BGM111_SetTackState(uint8_t NewValue)
    503          {
    504            ble.TackArmed = NewValue;
   \                     BGM111_SetTackState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000004   0xF881 0x019A      STRB     R0,[R1, #+410]
    505          }
   \   00000008   0x4770             BX       LR               ;; return
    506          
    507          /**
    508            * @brief  This interrupt handler is called to handle the Usart3 interruptes.
    509            *         from the BGM111
    510            * @param  None
    511            * @retval None
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void BGM111_UART_IRQHandler(UART_HandleTypeDef *huart)
    514          {
   \                     BGM111_UART_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    515            /* Transmit register empty? */
    516            //if (USART_GetITStatus(BGM111_UART, USART_IT_TXE) == SET)
    517            if (__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE) == SET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0600             LSLS     R0,R0,#+24
   \   0000000A   0xD526             BPL.N    ??BGM111_UART_IRQHandler_0
    518            {
    519              /* Are we still sending data? */
    520              if (ble.tx_rd != ble.tx_wr)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000010   0xF890 0x00C9      LDRB     R0,[R0, #+201]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000018   0xF891 0x10C8      LDRB     R1,[R1, #+200]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD015             BEQ.N    ??BGM111_UART_IRQHandler_1
    521              {
    522                /* Send a byte */
    523                USART_SendData(huart, ble.tx_buf[ble.tx_rd]);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000028   0xF891 0x10C9      LDRB     R1,[R1, #+201]
   \   0000002C   0x5C41             LDRB     R1,[R0, R1]
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       USART_SendData
    524                /* Bump the index */
    525                ble.tx_rd = NextBufIdx(ble.tx_rd);
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000003A   0xF890 0x00C9      LDRB     R0,[R0, #+201]
   \   0000003E   0x.... 0x....      BL       NextBufIdx
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000046   0xF881 0x00C9      STRB     R0,[R1, #+201]
   \   0000004A   0xE006             B.N      ??BGM111_UART_IRQHandler_0
    526              }
    527              else
    528              {
    529                /* Turn off the transmit interrupt */
    530                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??BGM111_UART_IRQHandler_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0xF07F 0x0180      MVNS     R1,#+128
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x60C8             STR      R0,[R1, #+12]
    531              }
    532            }
    533            
    534            /* Was there an error? */
    535            if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE | 
    536                HAL_UART_ERROR_PE | UART_FLAG_NE | UART_FLAG_FE) == SET)
   \                     ??BGM111_UART_IRQHandler_0: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000062   0x280F             CMP      R0,#+15
   \   00000064   0xD108             BNE.N    ??BGM111_UART_IRQHandler_2
    537            {
    538              /* Reset the receive state */
    539              ble.rx_state = BGRX_SYNC;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000006C   0xF881 0x0194      STRB     R0,[R1, #+404]
    540              /* Clear the error by reading the data register */
    541              USART_ReceiveData(huart);
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       USART_ReceiveData
    542              /* We're done */
    543              return;
   \   00000076   0xE00B             B.N      ??BGM111_UART_IRQHandler_3
    544            }
    545          
    546            /* Was a new byte received? */
    547            if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE) == SET)
   \                     ??BGM111_UART_IRQHandler_2: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x0680             LSLS     R0,R0,#+26
   \   0000007E   0xD507             BPL.N    ??BGM111_UART_IRQHandler_4
    548            {
    549              /* Get the byte (this also clears the flag) */
    550              uint8_t c = USART_ReceiveData(huart);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       USART_ReceiveData
   \   00000086   0x0005             MOVS     R5,R0
    551              /* Process the received character... */
    552              RoadBrd_ProcessBGMChar(c);
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x.... 0x....      BL       RoadBrd_ProcessBGMChar
    553            }
    554          }
   \                     ??BGM111_UART_IRQHandler_4: (+1)
   \                     ??BGM111_UART_IRQHandler_3: (+1)
   \   00000090   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    555          
    556          /* Transmit data to the BGM111 module */
    557          /**
    558            * @brief  Returns the most recent received data by the USARTx peripheral.
    559            * @param  USARTx: Select the USART peripheral. 
    560            *   This parameter can be one of the following values:
    561            *   USART1, USART2, USART3, UART4 or UART5.
    562            * @retval The received data.
    563            */

   \                                 In section .text, align 4, keep-with-next
    564          void BGM111_Transmit(uint32_t len, uint8_t *data)
    565          {
   \                     BGM111_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    566            uint32_t tempmsg;
    567            uint32_t timeout_Cnt;
    568            
    569            // Log MSG into buffer
    570            tempmsg = 0xff000000 | len;
   \   00000008   0xF054 0x407F      ORRS     R0,R4,#0xFF000000
   \   0000000C   0x0006             MOVS     R6,R0
    571            blemsgs.msgBuff[blemsgs.tx_wr] = tempmsg;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000016   0xF8B1 0x1320      LDRH     R1,[R1, #+800]
   \   0000001A   0xF840 0x6021      STR      R6,[R0, R1, LSL #+2]
    572            blemsgs.tx_wr = NextBufIdx(blemsgs.tx_wr);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000022   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       NextBufIdx
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000030   0xF8A1 0x0320      STRH     R0,[R1, #+800]
    573            tempmsg = (uint32_t)(data[0]<<24) + (uint32_t)(data[1]<<16) + (uint32_t)(data[2]<<8) + (uint32_t)(data[3]);
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x7869             LDRB     R1,[R5, #+1]
   \   00000038   0x0409             LSLS     R1,R1,#+16
   \   0000003A   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   0000003E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000040   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000044   0x78E9             LDRB     R1,[R5, #+3]
   \   00000046   0x1808             ADDS     R0,R1,R0
   \   00000048   0x0006             MOVS     R6,R0
    574            blemsgs.msgBuff[blemsgs.tx_wr] = tempmsg;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000052   0xF8B1 0x1320      LDRH     R1,[R1, #+800]
   \   00000056   0xF840 0x6021      STR      R6,[R0, R1, LSL #+2]
    575            blemsgs.tx_wr = NextBufIdx(blemsgs.tx_wr);
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000005E   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x.... 0x....      BL       NextBufIdx
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000006C   0xF8A1 0x0320      STRH     R0,[R1, #+800]
    576            tempmsg = (uint32_t)(data[4]<<24) + (uint32_t)(data[5]<<16) + (uint32_t)(data[6]<<8) + (uint32_t)(data[7]);
   \   00000070   0x7928             LDRB     R0,[R5, #+4]
   \   00000072   0x7969             LDRB     R1,[R5, #+5]
   \   00000074   0x0409             LSLS     R1,R1,#+16
   \   00000076   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   0000007A   0x79A9             LDRB     R1,[R5, #+6]
   \   0000007C   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000080   0x79E9             LDRB     R1,[R5, #+7]
   \   00000082   0x1808             ADDS     R0,R1,R0
   \   00000084   0x0006             MOVS     R6,R0
    577            blemsgs.msgBuff[blemsgs.tx_wr] = tempmsg;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000008E   0xF8B1 0x1320      LDRH     R1,[R1, #+800]
   \   00000092   0xF840 0x6021      STR      R6,[R0, R1, LSL #+2]
    578            blemsgs.tx_wr = NextBufIdx(blemsgs.tx_wr);
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000009A   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x.... 0x....      BL       NextBufIdx
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   000000A8   0xF8A1 0x0320      STRH     R0,[R1, #+800]
    579            
    580            /* Add bytes when there is space, wait if necessary */
    581            // OK...But we Can't wait forever...Will place a timeout Count.
    582            timeout_Cnt = TX_TIMEOUT_CNT;
   \   000000AC   0xF44F 0x60FA      MOV      R0,#+2000
   \   000000B0   0x0007             MOVS     R7,R0
    583            
    584            while (len) {
   \                     ??BGM111_Transmit_0: (+1)
   \   000000B2   0x2C00             CMP      R4,#+0
   \   000000B4   0xD045             BEQ.N    ??BGM111_Transmit_1
    585              /* Get the next write index */
    586              uint8_t nextidx = NextBufIdx(ble.tx_wr);
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   000000BA   0xF890 0x00C8      LDRB     R0,[R0, #+200]
   \   000000BE   0x.... 0x....      BL       NextBufIdx
   \   000000C2   0x4680             MOV      R8,R0
    587              /* We're not hitting the read index? (There is space?) */
    588              if (nextidx != ble.tx_rd)
   \   000000C4   0x4640             MOV      R0,R8
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000CA   0xF891 0x10C9      LDRB     R1,[R1, #+201]
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD023             BEQ.N    ??BGM111_Transmit_2
    589              {
    590                /* Put the data in the buffer */
    591                ble.tx_buf[ble.tx_wr] = *data;
   \   000000D4   0x7828             LDRB     R0,[R5, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable25_2
   \   000000DE   0xF892 0x20C8      LDRB     R2,[R2, #+200]
   \   000000E2   0x5488             STRB     R0,[R1, R2]
    592          
    593                /* Disable interrupt */
    594                HAL_NVIC_DisableIRQ(USART3_IRQn);
   \   000000E4   0x2027             MOVS     R0,#+39
   \   000000E6   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    595                /* Trigger an interrupt if we're starting with an empty buffer */
    596                if (ble.tx_wr == ble.tx_rd)
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   000000EE   0xF890 0x00C8      LDRB     R0,[R0, #+200]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000F6   0xF891 0x10C9      LDRB     R1,[R1, #+201]
   \   000000FA   0x4288             CMP      R0,R1
   \   000000FC   0xD101             BNE.N    ??BGM111_Transmit_3
    597                {
    598                  HAL_UART_EnableBGM_TXE();
   \   000000FE   0x.... 0x....      BL       HAL_UART_EnableBGM_TXE
    599                }
    600                /* Increment the write index */
    601                ble.tx_wr = nextidx;
   \                     ??BGM111_Transmit_3: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000106   0xF880 0x80C8      STRB     R8,[R0, #+200]
    602                /* Enable interrupt */
    603                HAL_NVIC_EnableIRQ(USART3_IRQn);
   \   0000010A   0x2027             MOVS     R0,#+39
   \   0000010C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    604          
    605                /* Update the incoming data length and pointer */
    606                len--;
   \   00000110   0x1E64             SUBS     R4,R4,#+1
    607                data++;
   \   00000112   0x1C6D             ADDS     R5,R5,#+1
    608                //Found Space...Reset Count.
    609                timeout_Cnt = TX_TIMEOUT_CNT;
   \   00000114   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000118   0x0007             MOVS     R7,R0
   \   0000011A   0xE7CA             B.N      ??BGM111_Transmit_0
    610              }
    611              else
    612              {
    613                //Decrement Count
    614                if ( timeout_Cnt-- == 0)
   \                     ??BGM111_Transmit_2: (+1)
   \   0000011C   0x0038             MOVS     R0,R7
   \   0000011E   0x1E47             SUBS     R7,R0,#+1
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD1C6             BNE.N    ??BGM111_Transmit_0
    615                {
    616                  // If this happens...NOT BOOTED..Clear ths flag or infinite loop.
    617                  ble.booted = false;
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000012A   0xF881 0x0196      STRB     R0,[R1, #+406]
    618                  // We have detected a ERROR_TXBGMBUF_FULL error on BGM111...Log it!
    619                  RdBrd_ErrCdLogErrCd( ERROR_TXBGMBUF_FULL, MODULE_bgm111 );
   \   0000012E   0x2102             MOVS     R1,#+2
   \   00000130   0x200F             MOVS     R0,#+15
   \   00000132   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    620                  RdBrd_BlinkErrCd( ERROR_TXBGMBUF_FULL );
   \   00000136   0x200F             MOVS     R0,#+15
   \   00000138   0x.... 0x....      BL       RdBrd_BlinkErrCd
    621                  HAL_NVIC_SystemReset();
   \   0000013C   0x.... 0x....      BL       HAL_NVIC_SystemReset
   \   00000140   0xE7B7             B.N      ??BGM111_Transmit_0
    622                }
    623              }
    624            }
    625          }
   \                     ??BGM111_Transmit_1: (+1)
   \   00000142   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    626          
    627          /**
    628            * @brief  Transmits single data through the USARTx peripheral.
    629            * @param  USARTx: Select the USART peripheral. 
    630            *   This parameter can be one of the following values:
    631            *   USART1, USART2, USART3, UART4 or UART5.
    632            * @param  Data: the data to transmit.
    633            * @retval None.
    634            */

   \                                 In section .text, align 2, keep-with-next
    635          void USART_SendData(UART_HandleTypeDef *huart, uint16_t Data)
    636          {
    637            /* Transmit Data */
    638            huart->Instance->DR = (Data & (uint16_t)0x01FF);
   \                     USART_SendData: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x05CA             LSLS     R2,R1,#+23       ;; ZeroExtS R2,R1,#+23,#+23
   \   00000004   0x0DD2             LSRS     R2,R2,#+23
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x605A             STR      R2,[R3, #+4]
    639          }
   \   0000000A   0x4770             BX       LR               ;; return
    640          
    641          /**
    642            * @brief  Returns the most recent received data by the USARTx peripheral.
    643            * @param  USARTx: Select the USART peripheral. 
    644            *   This parameter can be one of the following values:
    645            *   USART1, USART2, USART3, UART4 or UART5.
    646            * @retval The received data.
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          uint16_t USART_ReceiveData(UART_HandleTypeDef *huart)
    649          {
    650            /* Receive Data */
    651            return (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \                     USART_ReceiveData: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000006   0x0DC0             LSRS     R0,R0,#+23
   \   00000008   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /**
    655            * @brief  This routine Process the passed character as part of the process of building status
    656            *         from the BGM111
    657            * @param  uint8_t c: Character to process.
    658            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    659            *                                HAL_ERROR:    Error found in Tasking or data passed.
    660            *                                HAL_BUSY:     UART is busy.
    661            *                                HAL_TIMEOUT:  UART timed out.
    662            */

   \                                 In section .text, align 4, keep-with-next
    663          HAL_StatusTypeDef RoadBrd_ProcessBGMChar(uint8_t c)
    664          {
   \                     RoadBrd_ProcessBGMChar: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0D9             SUB      SP,SP,#+356
   \   00000006   0x0004             MOVS     R4,R0
    665          //  static uint8_t header_cnt, payload_cnt, payload_len;
    666          #define TEMP_BUFF_LENGTH        RX_BFFR_MAX_LNGTH
    667            HAL_StatusTypeDef Status;
    668            static uint8_t tempBffr2[TEMP_BUFF_LENGTH];
    669            char* tempPstr;
    670            char tempstr[RX_BFFR_MAX_LNGTH];
    671            int x;
    672            static bool bgm_BannerFlg = false;
    673          #ifndef XML_SHRT  
    674            char tempstr2[RX_BFFR_MAX_LNGTH];
    675          #endif
    676          //  int x;
    677          
    678            uint8_t tempBffr3[80];
    679            static uint16_t in_ptr = 0;
    680            
    681            // First pull new character into buffer.
    682            tempBffr2[in_ptr++] = c;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_30
   \   00000010   0x8809             LDRH     R1,[R1, #+0]
   \   00000012   0x5444             STRB     R4,[R0, R1]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable25_30
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable25_30
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    683            // Now, Did we get a termination character?
    684            if( (c == 0x0a)  ||
    685                (c == '?') ||
    686                (in_ptr >= (uint16_t)RX_BFFR_MAX_LNGTH))
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C0A             CMP      R4,#+10
   \   00000026   0xD008             BEQ.N    ??RoadBrd_ProcessBGMChar_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C3F             CMP      R4,#+63
   \   0000002C   0xD005             BEQ.N    ??RoadBrd_ProcessBGMChar_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable25_30
   \   00000032   0x8800             LDRH     R0,[R0, #+0]
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xF340 0x822D      BLE.W    ??RoadBrd_ProcessBGMChar_1
    687            {
    688              // Reset Ptr.
    689              in_ptr = 0;
   \                     ??RoadBrd_ProcessBGMChar_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable25_30
   \   00000040   0x8008             STRH     R0,[R1, #+0]
    690          
    691              // Yes...We will now test contents of buffer. And then reset ptr back to 0.
    692              sprintf( (char *)tempBffr3, "\r\n<<FULL STRING>>: ");
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable25_31
   \   00000046   0xA804             ADD      R0,SP,#+16
   \   00000048   0x.... 0x....      BL       sprintf
    693              Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   0000004C   0xA904             ADD      R1,SP,#+16
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000054   0x0007             MOVS     R7,R0
    694              Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable25_29
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000060   0x0007             MOVS     R7,R0
    695              sprintf( (char *)tempBffr3, " \r\n");
   \   00000062   0xA1C8             ADR.N    R1,??RoadBrd_ProcessBGMChar_2  ;; " \r\n"
   \   00000064   0xA804             ADD      R0,SP,#+16
   \   00000066   0x.... 0x....      BL       sprintf
    696              Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   0000006A   0xA904             ADD      R1,SP,#+16
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000072   0x0007             MOVS     R7,R0
    697              if (Status != HAL_OK)
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x2F00             CMP      R7,#+0
   \   00000078   0xD002             BEQ.N    ??RoadBrd_ProcessBGMChar_3
    698                return Status;
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xE20B             B.N      ??RoadBrd_ProcessBGMChar_4
    699              // Test bgm_BannerFlg to determine if we have a new Banner.
    700              if ( bgm_BannerFlg )
   \                     ??RoadBrd_ProcessBGMChar_3: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable25_32
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD011             BEQ.N    ??RoadBrd_ProcessBGMChar_5
    701              {
    702                // Strip off Termination of string.
    703                tempBffr2[(strlen((char *)tempBffr2)-2)] = 0x00;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   0000008E   0x.... 0x....      BL       strlen
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable25_29
   \   00000096   0x4408             ADD      R0,R1,R0
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0xF800 0x1C02      STRB     R1,[R0, #-2]
    704                
    705                set_BGMBanner( (char *)tempBffr2 );
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   000000A2   0x.... 0x....      BL       set_BGMBanner
    706                bgm_BannerFlg = false;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable25_32
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    707              }
    708              // Test Strings for Key items.
    709              // Boot String?
    710              if (strncmp((char *)tempBffr2,"Boot",4) == 0)
   \                     ??RoadBrd_ProcessBGMChar_5: (+1)
   \   000000AE   0x2204             MOVS     R2,#+4
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable25_33
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   000000B8   0x.... 0x....      BL       strncmp
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD115             BNE.N    ??RoadBrd_ProcessBGMChar_6
    711              {
    712                // Yes....Set Boot Flag.
    713                ble.booted = true;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000C6   0xF881 0x0196      STRB     R0,[R1, #+406]
    714                // If we are booted....Then lets arm TACK Test Code.
    715                ble.data_Connection = false;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000D0   0xF881 0x0198      STRB     R0,[R1, #+408]
    716                ble.CMD_Mode = false;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000DA   0xF881 0x0199      STRB     R0,[R1, #+409]
    717                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.booted> ");
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable25_34
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000000E8   0x0007             MOVS     R7,R0
   \   000000EA   0xE1CA             B.N      ??RoadBrd_ProcessBGMChar_7
    718              }
    719              // Connection String?
    720              else if (strncmp((char *)tempBffr2,"Connected",9) == 0)
   \                     ??RoadBrd_ProcessBGMChar_6: (+1)
   \   000000EC   0x2209             MOVS     R2,#+9
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable25_35
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   000000F6   0x.... 0x....      BL       strncmp
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD11A             BNE.N    ??RoadBrd_ProcessBGMChar_8
    721              {
    722                // Yes....Set Boot Flag.
    723                ble.connection = true;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000104   0xF881 0x0197      STRB     R0,[R1, #+407]
    724                ble.TackArmed = TACK_ARMED;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000010E   0xF881 0x019A      STRB     R0,[R1, #+410]
    725                ble.TackCnt = 0;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000118   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    726                RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.TackArmed = TACK_ARMED>");
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable25_36
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x.... 0x....      BL       RoadBrd_UART_Transmit
    727                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.connection> ");
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable25_37
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000130   0x0007             MOVS     R7,R0
   \   00000132   0xE1A6             B.N      ??RoadBrd_ProcessBGMChar_7
    728          
    729              }
    730              // Disconnection String?
    731              else if (strncmp((char *)tempBffr2,"Disconnected",12) == 0)
   \                     ??RoadBrd_ProcessBGMChar_8: (+1)
   \   00000134   0x220C             MOVS     R2,#+12
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable25_38
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   0000013E   0x.... 0x....      BL       strncmp
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD12C             BNE.N    ??RoadBrd_ProcessBGMChar_9
    732              {
    733                // Yes....Clear Flags.
    734                ble.connection = false;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000014C   0xF881 0x0197      STRB     R0,[R1, #+407]
    735                ble.data_Connection = false;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000156   0xF881 0x0198      STRB     R0,[R1, #+408]
    736                ble.CMD_Mode = false;
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000160   0xF881 0x0199      STRB     R0,[R1, #+409]
    737                ble.TackArmed = TACK_ARMED;
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000016A   0xF881 0x019A      STRB     R0,[R1, #+410]
    738                ble.TackCnt = 0;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000174   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    739                Clr_CMD_Md_Cnt();
   \   00000178   0x.... 0x....      BL       Clr_CMD_Md_Cnt
    740                Clr_Frame_Ratio();
   \   0000017C   0x.... 0x....      BL       Clr_Frame_Ratio
    741                RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.TackArmed = TACK_ARMED>");
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable25_36
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x.... 0x....      BL       RoadBrd_UART_Transmit
    742                ClrDataStructure();                           // Clear Backup data structure.
   \   0000018A   0x.... 0x....      BL       ClrDataStructure
    743                ClrAnalyticsRepeat();                          // Clear Frame Repeat Count.
   \   0000018E   0x.... 0x....      BL       ClrAnalyticsRepeat
    744                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<DISCONNECTED> ");
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable25_39
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000019C   0x0007             MOVS     R7,R0
   \   0000019E   0xE170             B.N      ??RoadBrd_ProcessBGMChar_7
    745              }
    746              // Data String?
    747              else if (strncmp((char *)tempBffr2,"DATA",4) == 0)
   \                     ??RoadBrd_ProcessBGMChar_9: (+1)
   \   000001A0   0x2204             MOVS     R2,#+4
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable25_40
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable25_29
   \   000001AA   0x.... 0x....      BL       strncmp
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD174             BNE.N    ??RoadBrd_ProcessBGMChar_10
    748              {
    749                // 1. Send String to Server to indicate new CMD Mode.
    750                //sprintf( (char *)tempBffr2, "<STATUS>CMD</STATUS>" );
    751                if (RoadBrd_Get_UnitsFlag())
   \   000001B2   0x.... 0x....      BL       RoadBrd_Get_UnitsFlag
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD02B             BEQ.N    ??RoadBrd_ProcessBGMChar_11
    752                {
    753                  sprintf( (char *)tempBffr2, "<STATUS>CMD|%3.1f|%3.1f|%d|%d|ENABLED</STATUS>",
    754                          ((float)RoadBrd_Get_RdSndTickCnt()/10),
    755                          ((float)RoadBrd_Get_SnsrTickCnt()/10),
    756                          RoadBrd_Get_TackLimit(),
    757                          RoadBrd_Get_BootDelay());
   \   000001BA   0x.... 0x....      BL       RoadBrd_Get_BootDelay
   \   000001BE   0x4681             MOV      R9,R0
   \   000001C0   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   000001C4   0x4682             MOV      R10,R0
   \   000001C6   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   000001CA   0x4683             MOV      R11,R0
   \   000001CC   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   000001D0   0x4680             MOV      R8,R0
   \   000001D2   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   000001D6   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   000001DA   0x4658             MOV      R0,R11
   \   000001DC   0x.... 0x....      BL       __aeabi_ui2f
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable25_41  ;; 0x41200000
   \   000001E4   0x.... 0x....      BL       __aeabi_fdiv
   \   000001E8   0x.... 0x....      BL       __aeabi_f2d
   \   000001EC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000001F0   0x4640             MOV      R0,R8
   \   000001F2   0x.... 0x....      BL       __aeabi_ui2f
   \   000001F6   0x.... 0x....      LDR.W    R1,??DataTable25_41  ;; 0x41200000
   \   000001FA   0x.... 0x....      BL       __aeabi_fdiv
   \   000001FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000202   0x0002             MOVS     R2,R0
   \   00000204   0x000B             MOVS     R3,R1
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable25_42
   \   0000020A   0x....             LDR.N    R0,??DataTable25_29
   \   0000020C   0x.... 0x....      BL       sprintf
   \   00000210   0xE027             B.N      ??RoadBrd_ProcessBGMChar_12
    758                }
    759                else
    760                {
    761                  sprintf( (char *)tempBffr2, "<STATUS>CMD|%3.1f|%3.1f|%d|%d|DISABLED</STATUS>",
    762                          ((float)RoadBrd_Get_RdSndTickCnt()/10),
    763                          ((float)RoadBrd_Get_SnsrTickCnt()/10),
    764                          RoadBrd_Get_TackLimit(),
    765                          RoadBrd_Get_BootDelay());
   \                     ??RoadBrd_ProcessBGMChar_11: (+1)
   \   00000212   0x.... 0x....      BL       RoadBrd_Get_BootDelay
   \   00000216   0x4681             MOV      R9,R0
   \   00000218   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   0000021C   0x4682             MOV      R10,R0
   \   0000021E   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   00000222   0x4683             MOV      R11,R0
   \   00000224   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   00000228   0x4680             MOV      R8,R0
   \   0000022A   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   0000022E   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   00000232   0x4658             MOV      R0,R11
   \   00000234   0x.... 0x....      BL       __aeabi_ui2f
   \   00000238   0x....             LDR.N    R1,??DataTable25_41  ;; 0x41200000
   \   0000023A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000023E   0x.... 0x....      BL       __aeabi_f2d
   \   00000242   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000246   0x4640             MOV      R0,R8
   \   00000248   0x.... 0x....      BL       __aeabi_ui2f
   \   0000024C   0x....             LDR.N    R1,??DataTable25_41  ;; 0x41200000
   \   0000024E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000252   0x.... 0x....      BL       __aeabi_f2d
   \   00000256   0x0002             MOVS     R2,R0
   \   00000258   0x000B             MOVS     R3,R1
   \   0000025A   0x....             LDR.N    R1,??DataTable25_43
   \   0000025C   0x....             LDR.N    R0,??DataTable25_29
   \   0000025E   0x.... 0x....      BL       sprintf
    766                }
    767                Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \                     ??RoadBrd_ProcessBGMChar_12: (+1)
   \   00000262   0x....             LDR.N    R1,??DataTable25_29
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000026A   0x0007             MOVS     R7,R0
    768                if (Status != HAL_OK)
   \   0000026C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000026E   0x2F00             CMP      R7,#+0
   \   00000270   0xD002             BEQ.N    ??RoadBrd_ProcessBGMChar_13
    769                  return Status;
   \   00000272   0x0038             MOVS     R0,R7
   \   00000274   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000276   0xE10F             B.N      ??RoadBrd_ProcessBGMChar_4
    770                BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \                     ??RoadBrd_ProcessBGMChar_13: (+1)
   \   00000278   0x....             LDR.N    R0,??DataTable25_29
   \   0000027A   0x.... 0x....      BL       strlen
   \   0000027E   0x....             LDR.N    R1,??DataTable25_29
   \   00000280   0x.... 0x....      BL       BGM111_Transmit
    771                
    772                // 2. Set the Timer to the RD_Sound at 1 Second Increments.
    773                RoadBrd_Set_TmpRdSndTickCnt( CMD_TIME );                  // One Second Ticks.
   \   00000284   0x200A             MOVS     R0,#+10
   \   00000286   0x.... 0x....      BL       RoadBrd_Set_TmpRdSndTickCnt
    774                
    775                // 3. Set CMD_Mode Active.
    776                BGM111_SetCMD_Mode( true );
   \   0000028A   0x2001             MOVS     R0,#+1
   \   0000028C   0x.... 0x....      BL       BGM111_SetCMD_Mode
    777                
    778                // Final Status.
    779                //ble.data_Connection = true;
    780                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.data_Connection> ");
   \   00000290   0x....             LDR.N    R1,??DataTable25_44
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000298   0x0007             MOVS     R7,R0
   \   0000029A   0xE0F2             B.N      ??RoadBrd_ProcessBGMChar_7
    781              }
    782              // "RP SPP server..." Tag?
    783              else if (strncmp((char *)tempBffr2,"RP SPP server...",16) == 0)
   \                     ??RoadBrd_ProcessBGMChar_10: (+1)
   \   0000029C   0x2210             MOVS     R2,#+16
   \   0000029E   0x....             LDR.N    R1,??DataTable25_45
   \   000002A0   0x....             LDR.N    R0,??DataTable25_29
   \   000002A2   0x.... 0x....      BL       strncmp
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD108             BNE.N    ??RoadBrd_ProcessBGMChar_14
    784              {
    785                // Ok Set Flag so that Next String is grabbed as BGM Banner Tag."
    786                bgm_BannerFlg = true;
   \   000002AA   0x2001             MOVS     R0,#+1
   \   000002AC   0x....             LDR.N    R1,??DataTable25_32
   \   000002AE   0x7008             STRB     R0,[R1, #+0]
    787                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<BGM Banner Tag Found.> ");
   \   000002B0   0x....             LDR.N    R1,??DataTable25_46
   \   000002B2   0x2000             MOVS     R0,#+0
   \   000002B4   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000002B8   0x0007             MOVS     R7,R0
   \   000002BA   0xE0E2             B.N      ??RoadBrd_ProcessBGMChar_7
    788              }
    789              
    790              // TACK String?
    791              else if (strncmp((char *)tempBffr2,"<TACK>",6) == 0)
   \                     ??RoadBrd_ProcessBGMChar_14: (+1)
   \   000002BC   0x2206             MOVS     R2,#+6
   \   000002BE   0x....             LDR.N    R1,??DataTable25_47
   \   000002C0   0x....             LDR.N    R0,??DataTable25_29
   \   000002C2   0x.... 0x....      BL       strncmp
   \   000002C6   0x2800             CMP      R0,#+0
   \   000002C8   0xF040 0x80C5      BNE.W    ??RoadBrd_ProcessBGMChar_15
    792              {
    793                // CMD_Mode active?
    794                if ( BGM111_CMD_Mode() )
   \   000002CC   0x.... 0x....      BL       BGM111_CMD_Mode
   \   000002D0   0x2800             CMP      R0,#+0
   \   000002D2   0xD02E             BEQ.N    ??RoadBrd_ProcessBGMChar_16
    795                {
    796                  // Send String to Server.
    797                  sprintf( (char *)tempBffr3, "<STATUS>DATA_SYNC</STATUS>" );
   \   000002D4   0x....             LDR.N    R1,??DataTable25_48
   \   000002D6   0xA804             ADD      R0,SP,#+16
   \   000002D8   0x.... 0x....      BL       sprintf
    798                  Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   000002DC   0xA904             ADD      R1,SP,#+16
   \   000002DE   0x2000             MOVS     R0,#+0
   \   000002E0   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000002E4   0x0007             MOVS     R7,R0
    799                  if (Status != HAL_OK)
   \   000002E6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002E8   0x2F00             CMP      R7,#+0
   \   000002EA   0xD002             BEQ.N    ??RoadBrd_ProcessBGMChar_17
    800                    return Status;
   \   000002EC   0x0038             MOVS     R0,R7
   \   000002EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002F0   0xE0D2             B.N      ??RoadBrd_ProcessBGMChar_4
    801                  BGM111_Transmit((uint32_t)(strlen((char *)tempBffr3)), tempBffr3);
   \                     ??RoadBrd_ProcessBGMChar_17: (+1)
   \   000002F2   0xA804             ADD      R0,SP,#+16
   \   000002F4   0x.... 0x....      BL       strlen
   \   000002F8   0xA904             ADD      R1,SP,#+16
   \   000002FA   0x.... 0x....      BL       BGM111_Transmit
    802                  // Clear CMD_Mode.
    803                  BGM111_SetCMD_Mode( false );
   \   000002FE   0x2000             MOVS     R0,#+0
   \   00000300   0x.... 0x....      BL       BGM111_SetCMD_Mode
    804                  // Set Data_Connection Mode.
    805                  BGM111_SetDataConnected( true );
   \   00000304   0x2001             MOVS     R0,#+1
   \   00000306   0x.... 0x....      BL       BGM111_SetDataConnected
    806                  // Change RD_Sound Timer to correct value for Data Mode.
    807                  // First Reload FLASH Frames
    808                  RoadBrd_WWDG_VerifyFrame();
   \   0000030A   0x.... 0x....      BL       RoadBrd_WWDG_VerifyFrame
    809                  // NOW...Reload Active Timer.
    810                  Set_RdSndTickCnt( RoadBrd_Get_RdSndTickCnt() );
   \   0000030E   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   00000312   0x.... 0x....      BL       Set_RdSndTickCnt
    811                  // Now Set Correct SYNC Mode.
    812                  ble.TackArmed = TACK_SYNC;
   \   00000316   0x2003             MOVS     R0,#+3
   \   00000318   0x....             LDR.N    R1,??DataTable25_2
   \   0000031A   0xF881 0x019A      STRB     R0,[R1, #+410]
    813                  ble.TackCnt = 0;
   \   0000031E   0x2000             MOVS     R0,#+0
   \   00000320   0x....             LDR.N    R1,??DataTable25_2
   \   00000322   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    814                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.TackArmed=TACK_SYNC>");
   \   00000326   0x....             LDR.N    R1,??DataTable25_49
   \   00000328   0x2000             MOVS     R0,#+0
   \   0000032A   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000032E   0x0007             MOVS     R7,R0
   \   00000330   0xE03B             B.N      ??RoadBrd_ProcessBGMChar_18
    815                }
    816                else if (ble.TackArmed == TACK_ARMED2)
   \                     ??RoadBrd_ProcessBGMChar_16: (+1)
   \   00000332   0x....             LDR.N    R0,??DataTable25_2
   \   00000334   0xF890 0x019A      LDRB     R0,[R0, #+410]
   \   00000338   0x2802             CMP      R0,#+2
   \   0000033A   0xD125             BNE.N    ??RoadBrd_ProcessBGMChar_19
    817                {
    818                  ble.TackArmed = TACK_SYNC;
   \   0000033C   0x2003             MOVS     R0,#+3
   \   0000033E   0x....             LDR.N    R1,??DataTable25_2
   \   00000340   0xF881 0x019A      STRB     R0,[R1, #+410]
    819                  ble.TackCnt = 0;
   \   00000344   0x2000             MOVS     R0,#+0
   \   00000346   0x....             LDR.N    R1,??DataTable25_2
   \   00000348   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    820                  sprintf( (char *)tempBffr3, "<STATUS>DATA_SYNC</STATUS>" );
   \   0000034C   0x....             LDR.N    R1,??DataTable25_48
   \   0000034E   0xA804             ADD      R0,SP,#+16
   \   00000350   0x.... 0x....      BL       sprintf
    821                  Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   00000354   0xA904             ADD      R1,SP,#+16
   \   00000356   0x2000             MOVS     R0,#+0
   \   00000358   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000035C   0x0007             MOVS     R7,R0
    822                  if (Status != HAL_OK)
   \   0000035E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000360   0x2F00             CMP      R7,#+0
   \   00000362   0xD002             BEQ.N    ??RoadBrd_ProcessBGMChar_20
    823                    return Status;
   \   00000364   0x0038             MOVS     R0,R7
   \   00000366   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000368   0xE096             B.N      ??RoadBrd_ProcessBGMChar_4
    824                  BGM111_Transmit((uint32_t)(strlen((char *)tempBffr3)), tempBffr3);
   \                     ??RoadBrd_ProcessBGMChar_20: (+1)
   \   0000036A   0xA804             ADD      R0,SP,#+16
   \   0000036C   0x.... 0x....      BL       strlen
   \   00000370   0xA904             ADD      R1,SP,#+16
   \   00000372   0x.... 0x....      BL       BGM111_Transmit
    825                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<ble.TackArmed=TACK_SYNC>");
   \   00000376   0x....             LDR.N    R1,??DataTable25_49
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000037E   0x0007             MOVS     R7,R0
   \   00000380   0xE013             B.N      ??RoadBrd_ProcessBGMChar_18
   \   00000382   0xBF00             Nop      
   \                     ??RoadBrd_ProcessBGMChar_2:
   \   00000384   0x20 0x0D          DC8      " \r\n"
   \              0x0A 0x00    
    826                }
    827                else if (ble.TackArmed == TACK_SYNC)
   \                     ??RoadBrd_ProcessBGMChar_19: (+1)
   \   00000388   0x....             LDR.N    R0,??DataTable25_2
   \   0000038A   0xF890 0x019A      LDRB     R0,[R0, #+410]
   \   0000038E   0x2803             CMP      R0,#+3
   \   00000390   0xD10B             BNE.N    ??RoadBrd_ProcessBGMChar_18
    828                {
    829                  ble.TackCnt = 0;
   \   00000392   0x2000             MOVS     R0,#+0
   \   00000394   0x....             LDR.N    R1,??DataTable25_2
   \   00000396   0xF8A1 0x019C      STRH     R0,[R1, #+412]
    830                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<TACK Received.>");
   \   0000039A   0x....             LDR.N    R1,??DataTable25_50
   \   0000039C   0x2000             MOVS     R0,#+0
   \   0000039E   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000003A2   0x0007             MOVS     R7,R0
    831                  // Set Sync Flag for Frame.
    832                    BGM111_SetSyncFlg( SYNC_PROC );
   \   000003A4   0x2001             MOVS     R0,#+1
   \   000003A6   0x.... 0x....      BL       BGM111_SetSyncFlg
    833                }
    834                // OK...Now we need to process what is in the TACK Section.
    835          #ifdef XML_SHRT      
    836                //********************************************************************************
    837                //*
    838                //*  Abbreviate XML Code Processing here for Platinum Initial Release
    839                //*
    840                //********************************************************************************
    841                // A. Strip off Opening <TACK>.
    842                tempPstr = (char *)&tempBffr2[6];
   \                     ??RoadBrd_ProcessBGMChar_18: (+1)
   \   000003AA   0x....             LDR.N    R0,??DataTable25_51
   \   000003AC   0x0005             MOVS     R5,R0
    843                strcpy(tempstr, tempPstr);
   \   000003AE   0x0029             MOVS     R1,R5
   \   000003B0   0xA818             ADD      R0,SP,#+96
   \   000003B2   0x.... 0x....      BL       strcpy
    844                //************************ SEQUENCE OF TEST TO TYPE OF OPERATION
    845                // B. Time to Test String
    846                // Is this a <CMD>/Monitor Command
    847                tempPstr = strstr( tempstr, "</TACK>" );
   \   000003B6   0x....             LDR.N    R1,??DataTable25_52
   \   000003B8   0xA818             ADD      R0,SP,#+96
   \   000003BA   0x.... 0x....      BL       strstr
   \   000003BE   0x0005             MOVS     R5,R0
    848                if (tempPstr  != NULL)
   \   000003C0   0x2D00             CMP      R5,#+0
   \   000003C2   0xD02F             BEQ.N    ??RoadBrd_ProcessBGMChar_21
    849                {
    850                  // Now NULL Out where Tag is at.
    851                  *tempPstr = NULL;
   \   000003C4   0x2000             MOVS     R0,#+0
   \   000003C6   0x7028             STRB     R0,[R5, #+0]
    852                  // Is this a Monitor Command?
    853                  if (strlen(tempstr) > 0)
   \   000003C8   0xA818             ADD      R0,SP,#+96
   \   000003CA   0x.... 0x....      BL       strlen
   \   000003CE   0x2800             CMP      R0,#+0
   \   000003D0   0xD028             BEQ.N    ??RoadBrd_ProcessBGMChar_21
    854                  {
    855                    // Finally, Send string to Parser.
    856                    Status = RoadBrd_ParserTsk(tempstr);
   \   000003D2   0xA818             ADD      R0,SP,#+96
   \   000003D4   0x.... 0x....      BL       RoadBrd_ParserTsk
   \   000003D8   0x0007             MOVS     R7,R0
    857                    if (Status == HAL_BUSY)
   \   000003DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000003DC   0x2F02             CMP      R7,#+2
   \   000003DE   0xD10F             BNE.N    ??RoadBrd_ProcessBGMChar_22
    858                    {
    859                      sprintf( (char *)tempBffr3, "<STATUS>CMD_BUSY</STATUS>" );
   \   000003E0   0x....             LDR.N    R1,??DataTable25_53
   \   000003E2   0xA804             ADD      R0,SP,#+16
   \   000003E4   0x.... 0x....      BL       sprintf
    860                      Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   000003E8   0xA904             ADD      R1,SP,#+16
   \   000003EA   0x2000             MOVS     R0,#+0
   \   000003EC   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000003F0   0x0007             MOVS     R7,R0
    861                      BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \   000003F2   0x....             LDR.N    R0,??DataTable25_29
   \   000003F4   0x.... 0x....      BL       strlen
   \   000003F8   0x....             LDR.N    R1,??DataTable25_29
   \   000003FA   0x.... 0x....      BL       BGM111_Transmit
   \   000003FE   0xE011             B.N      ??RoadBrd_ProcessBGMChar_21
    862                    }
    863                    else if (Status != HAL_OK)
   \                     ??RoadBrd_ProcessBGMChar_22: (+1)
   \   00000400   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000402   0x2F00             CMP      R7,#+0
   \   00000404   0xD00E             BEQ.N    ??RoadBrd_ProcessBGMChar_21
    864                    {
    865                      sprintf( (char *)tempBffr3, "<STATUS>CMD_ERROR</STATUS>" );
   \   00000406   0x....             LDR.N    R1,??DataTable25_54
   \   00000408   0xA804             ADD      R0,SP,#+16
   \   0000040A   0x.... 0x....      BL       sprintf
    866                      Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
   \   0000040E   0xA904             ADD      R1,SP,#+16
   \   00000410   0x2000             MOVS     R0,#+0
   \   00000412   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000416   0x0007             MOVS     R7,R0
    867                      BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \   00000418   0x....             LDR.N    R0,??DataTable25_29
   \   0000041A   0x.... 0x....      BL       strlen
   \   0000041E   0x....             LDR.N    R1,??DataTable25_29
   \   00000420   0x.... 0x....      BL       BGM111_Transmit
    868                    }
    869                  }
    870                }
    871                // Generate an ACK Report.
    872                sprintf( (char *)tempBffr2, "<STATUS>ST_ACK:%s</STATUS>", RoadBrd_WWDG_GetTickString() );
   \                     ??RoadBrd_ProcessBGMChar_21: (+1)
   \   00000424   0x.... 0x....      BL       RoadBrd_WWDG_GetTickString
   \   00000428   0x0002             MOVS     R2,R0
   \   0000042A   0x....             LDR.N    R1,??DataTable25_55
   \   0000042C   0x....             LDR.N    R0,??DataTable25_29
   \   0000042E   0x.... 0x....      BL       sprintf
    873                Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
   \   00000432   0x....             LDR.N    R1,??DataTable25_29
   \   00000434   0x2000             MOVS     R0,#+0
   \   00000436   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000043A   0x0007             MOVS     R7,R0
    874                if (Status != HAL_OK)
   \   0000043C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000043E   0x2F00             CMP      R7,#+0
   \   00000440   0xD002             BEQ.N    ??RoadBrd_ProcessBGMChar_23
    875                  return Status;
   \   00000442   0x0038             MOVS     R0,R7
   \   00000444   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000446   0xE027             B.N      ??RoadBrd_ProcessBGMChar_4
    876                BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \                     ??RoadBrd_ProcessBGMChar_23: (+1)
   \   00000448   0x....             LDR.N    R0,??DataTable25_29
   \   0000044A   0x.... 0x....      BL       strlen
   \   0000044E   0x....             LDR.N    R1,??DataTable25_29
   \   00000450   0x.... 0x....      BL       BGM111_Transmit
   \   00000454   0xE015             B.N      ??RoadBrd_ProcessBGMChar_7
    877                //********************************************************************************
    878                //*  END OF CUSTOM SECTION...Abbreviate XML Code Processing here for Platinum Initial Release
    879                //********************************************************************************
    880          #else      
    881                //********************************************************************************
    882                //*
    883                //*  Normal XML Code Processing here for Platinum Release
    884                //*
    885                //********************************************************************************
    886                // A. Strip off Opening <TACK>.
    887                tempPstr = (char *)&tempBffr2[6];
    888                strcpy(tempstr, tempPstr);
    889                // A1. Find if we have a <DATE> Tag.
    890                tempPstr = strstr( tempstr, "<DATE>" );
    891                if (tempPstr != NULL)
    892                {
    893                  // Found DATE TAG....Set Focus to DATE Tag.
    894                  strcpy(tempstr, tempPstr);
    895                  // Now Strip out DATE Tag and Get Date.
    896                  tempPstr = (char *)&tempstr[6];
    897                  strcpy(tempstr2, tempPstr);
    898                  strcpy(tempstr, tempPstr);
    899                  // Find </DATE>
    900                  tempPstr = strstr( tempstr2, "</DATE>" );
    901                  if (tempPstr != NULL)
    902                  {
    903                    // Found Second String.....NULL It so that we can get Date
    904                    //x = (int)tempPstr;
    905                    //tempstr[x] = NULL;
    906                    *tempPstr = NULL;
    907                    //Now save Date String.
    908                    RoadBrd_WWDG_SetDateString(tempstr2);
    909                  }
    910                  // Let's Advance past this date string.
    911                  tempPstr = strstr( tempstr, "</DATE>" );
    912                  strcpy(tempstr, tempPstr);
    913                  // Now Strip out /DATE Tag and Get Date.
    914                  tempPstr = (char *)&tempstr[7];
    915                  strcpy(tempstr, tempPstr);
    916                } 
    917                //************************ SEQUENCE OF TEST TO TYPE OF OPERATION
    918                // B. Time to Test String
    919                // Is this a <CMD>/Monitor Command
    920                tempPstr = strstr( tempstr, "<CMD>" );
    921                if (tempPstr  != NULL)
    922                {
    923                  // Yes This is a Monitor CMD... Parse out Key CMD and pass to parser.
    924                  strcpy((char *)tempBffr2, tempPstr);
    925                  tempPstr = (char *)&tempBffr2[5];
    926                  strcpy(tempstr, tempPstr);
    927                  // Finally, Send string to Parser.
    928                  Status = RoadBrd_ParserTsk(tempstr);
    929                  if (Status == HAL_BUSY)
    930                  {
    931                    sprintf( (char *)tempBffr3, "<STATUS>CMD_BUSY</STATUS>" );
    932                    Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
    933                  }
    934                  else if (Status != HAL_OK)
    935                  {
    936                    sprintf( (char *)tempBffr3, "<STATUS>CMD_ERROR</STATUS>" );
    937                    Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr3);
    938                  }
    939                }
    940                else
    941                {
    942                  // Generate an ACK Report.
    943                  sprintf( (char *)tempBffr2, "<STATUS>ST_ACK:%s</STATUS>", RoadBrd_WWDG_GetDateString() );
    944                  Status = RoadBrd_UART_Transmit(MONITOR_UART, tempBffr2);
    945                  if (Status != HAL_OK)
    946                    return Status;
    947                  BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
    948                }
    949                //********************************************************************************
    950                //*  END OF CUSTOM SECTION...Normal XML Code Processing here for Platinum Release
    951                //********************************************************************************
    952          #endif      
    953              } // EndIf (strncmp((char *)tempBffr2,"<TACK>",6) == 0)
    954              // NOW TEST ERROR CONDITIONS!!!
    955              // OVERFLOW?
    956              else if (strncmp((char *)tempBffr2,"OVERFLOW",8) == 0)
   \                     ??RoadBrd_ProcessBGMChar_15: (+1)
   \   00000456   0x2208             MOVS     R2,#+8
   \   00000458   0x....             LDR.N    R1,??DataTable25_56
   \   0000045A   0x....             LDR.N    R0,??DataTable25_29
   \   0000045C   0x.... 0x....      BL       strncmp
   \   00000460   0x2800             CMP      R0,#+0
   \   00000462   0xD109             BNE.N    ??RoadBrd_ProcessBGMChar_24
    957              {
    958                // Yes....Report Error and Reset.
    959                // We have detected a ERROR_TXBGMBUF_FULL error on BGM111...Log it!
    960                RdBrd_ErrCdLogErrCd( ERROR_BGM_OVERFLOW, MODULE_bgm111 );
   \   00000464   0x2102             MOVS     R1,#+2
   \   00000466   0x2011             MOVS     R0,#+17
   \   00000468   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    961                RdBrd_BlinkErrCd( ERROR_BGM_OVERFLOW );
   \   0000046C   0x2011             MOVS     R0,#+17
   \   0000046E   0x.... 0x....      BL       RdBrd_BlinkErrCd
    962                HAL_NVIC_SystemReset();
   \   00000472   0x.... 0x....      BL       HAL_NVIC_SystemReset
   \   00000476   0xE004             B.N      ??RoadBrd_ProcessBGMChar_7
    963              }
    964              else
    965              {
    966                Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"<UNKNOWN STATUS> ");
   \                     ??RoadBrd_ProcessBGMChar_24: (+1)
   \   00000478   0x....             LDR.N    R1,??DataTable25_57
   \   0000047A   0x2000             MOVS     R0,#+0
   \   0000047C   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000480   0x0007             MOVS     R7,R0
    967              }
    968              // Finally Clear the Buffer. We have completed the parsing of this event.
    969              for (x=0; x<TEMP_BUFF_LENGTH; x++)
   \                     ??RoadBrd_ProcessBGMChar_7: (+1)
   \   00000482   0x2000             MOVS     R0,#+0
   \   00000484   0x0006             MOVS     R6,R0
   \                     ??RoadBrd_ProcessBGMChar_25: (+1)
   \   00000486   0x2EFF             CMP      R6,#+255
   \   00000488   0xDC04             BGT.N    ??RoadBrd_ProcessBGMChar_1
    970              {
    971                tempBffr2[x]= NULL;
   \   0000048A   0x2000             MOVS     R0,#+0
   \   0000048C   0x....             LDR.N    R1,??DataTable25_29
   \   0000048E   0x5588             STRB     R0,[R1, R6]
    972              }
   \   00000490   0x1C76             ADDS     R6,R6,#+1
   \   00000492   0xE7F8             B.N      ??RoadBrd_ProcessBGMChar_25
    973            } // EndIf ( (c == 0x0a)  || (c == '?') )
    974            //tempBffr2[0] = c;
    975            //tempBffr2[1] = 0x00;
    976            //Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    977            return Status;
   \                     ??RoadBrd_ProcessBGMChar_1: (+1)
   \   00000494   0x0038             MOVS     R0,R7
   \   00000496   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_ProcessBGMChar_4: (+1)
   \   00000498   0xB059             ADD      SP,SP,#+356
   \   0000049A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    978          #if 0
    979              Status = HAL_OK;
    980              // Test Buffer. If we are full, An error has occured. Must at least log that.
    981              if (IsBufFull(ble.rx_wr, ble.rx_rd))
    982              {
    983                RdBrd_ErrCdLogErrCd( ERROR_BGMBUF_FULL, MODULE_bgm111 );
    984                Clr_HrtBeat_Cnt();
    985                RdBrd_BlinkErrCd( ERROR_BGMBUF_FULL );
    986                //RoadBrd_Delay( 1000 );
    987                HAL_NVIC_SystemReset();
    988                return HAL_ERROR;
    989              }
    990              /* Execution based on state */
    991              switch (ble.rx_state)
    992              {
    993                /* Waiting for a valid start of header */
    994                default:
    995                case BGRX_SYNC:
    996                  /* Valid start of header? (response or event) */
    997                  if ((c & 0xF8) ==
    998                      ((uint8_t)gecko_dev_type_gecko | (uint8_t)gecko_msg_type_rsp) ||
    999                      (c & 0xF8) ==
   1000                      ((uint8_t)gecko_dev_type_gecko | (uint8_t)gecko_msg_type_evt))
   1001                  {
   1002                    /* Receiving header */
   1003                    ble.rx_state = BGRX_HDR;
   1004                    /* Initialize header byte counter */
   1005                    header_cnt = 0;
   1006                  }
   1007                  else
   1008                  {
   1009                    /* Stay in sync state until we receive a valid start of header */
   1010                    // We have detected a SYNC error on BGM111...Log it!
   1011                    RdBrd_ErrCdLogErrCd( ERROR_BGMSYNC, MODULE_bgm111 );
   1012                    Clr_HrtBeat_Cnt();
   1013                    if (ble.booted)
   1014                      RdBrd_BlinkErrCd( ERROR_BGMSYNC );
   1015                    //RoadBrd_Delay( 1000 );
   1016                    HAL_NVIC_SystemReset();
   1017                    break;
   1018                  }
   1019                  /* Fallthrough intentional */
   1020                /* Receiving header */
   1021                case BGRX_HDR:
   1022                  if (IsBufFull(ble.rx_wr, ble.rx_rd))
   1023                  {
   1024                    // Oops...Detected a fatal error...RESET!!!
   1025                    // We have detected a SYNC error on BGM111...Log it!
   1026                    RdBrd_ErrCdLogErrCd( ERROR_BGMSYNC, MODULE_bgm111 );
   1027                    /* Indicate we need to execute the BLE stack, it's the
   1028                     * only way to get more space in the buffer */
   1029                    ble.req_exec = true;
   1030                    /* We're back to synchronizing */
   1031                    ble.rx_state = BGRX_SYNC;
   1032                  }
   1033                  else
   1034                  {
   1035                    /* Save the received byte */
   1036                    /* Save the received byte */
   1037                    ble.rx_buf[ble.rx_wr] = c;
   1038                    /* Increment the index and header byte counter */
   1039                    ble.rx_wr = NextBufIdx(ble.rx_wr);
   1040                    header_cnt++;
   1041                    /* If this is the second header byte, we can grab the payload
   1042                     * length.  We ignore the first byte, since the spec says that
   1043                     * due to memory limitations in the modules, the packet is
   1044                     * never more than 64 bytes. */
   1045                    if (header_cnt == 2)
   1046                    {
   1047                      /* Get the payload length */
   1048                      payload_len = c;
   1049                      /* If we have a payload bigger than 60 bytes, something's wrong */
   1050                      if (payload_len > 60)
   1051                      {
   1052                        // We have detected a SYNC error on BGM111...Log it!
   1053                        RdBrd_ErrCdLogErrCd( ERROR_BGMSYNC, MODULE_bgm111 );
   1054                        /* Reset receive state to synchronizing */
   1055                        ble.rx_state = BGRX_SYNC;
   1056                        /* Indicate we need to execute the BLE stack to free space */
   1057                        ble.req_exec = true;
   1058                        Status = HAL_ERROR;
   1059                      }
   1060                    } // EndIf (header_cnt == 2)
   1061                    /* Are we done with the header? */
   1062                    if (header_cnt >= BGLIB_MSG_HEADER_LEN)
   1063                    {
   1064                      /* Is there no payload? */
   1065                      if (payload_len == 0)
   1066                      {
   1067                        /* Reset receive state to synchronizing */
   1068                        ble.rx_state = BGRX_SYNC;
   1069                        /* Indicate we need to execute the BLE stack to process 
   1070                         * the received packet */
   1071                        ble.req_exec = true;
   1072                      }
   1073                      else
   1074                      {
   1075                        /* Start receiving payload data */
   1076                        ble.rx_state = BGRX_DATA;
   1077                        /* Initialize the payload counter */
   1078                        payload_cnt = 0;
   1079                      }
   1080                    } // EndIf (header_cnt >= BGLIB_MSG_HEADER_LEN)
   1081                  } // EndElse (IsBufFull(ble.rx_wr, ble.rx_rd))
   1082                  break;
   1083                /* Receiving data */
   1084                case BGRX_DATA:
   1085                  /* Did we receive a byte, but the buffer is full? */
   1086                  if (IsBufFull(ble.rx_wr, ble.rx_rd))
   1087                  {
   1088                    /* Indicate we need to execute the BLE stack, it's the
   1089                     * only way to get more space in the buffer */
   1090                    ble.req_exec = true;
   1091                    /* We're back to synchronizing */
   1092                    ble.rx_state = BGRX_SYNC;
   1093                  }
   1094                  else
   1095                  {
   1096                    /* Store the byte */
   1097                    ble.rx_buf[ble.rx_wr] = c;
   1098                    /* Increment the index and payload byte counter */
   1099                    ble.rx_wr = NextBufIdx(ble.rx_wr);
   1100                    payload_cnt++;
   1101                    /* Is this the end of the packet? */
   1102                    if (payload_cnt >= payload_len)
   1103                    {
   1104                      /* Reset receive state to synchronizing */
   1105                      ble.rx_state = BGRX_SYNC;
   1106                      /* Indicate we need to execute the BLE stack to process 
   1107                       * the received packet */
   1108                      ble.req_exec = true;
   1109                    }
   1110                    /* Is the buffer almost full? */
   1111                    if (BufFree(ble.rx_wr, ble.rx_rd) <= BG_DATA_LOW_WATERMARK)
   1112                    {
   1113                      /* Indicate we need to execute the BLE stack so it can
   1114                       * start reading data from the buffer */
   1115                      ble.req_exec = true;
   1116                    }
   1117                  } // EndElse (IsBufFull(ble.rx_wr, ble.rx_rd))
   1118                  break;
   1119              } // EndSwitch (ble.rx_state)
   1120              return Status;
   1121          #endif
   1122          }

   \                                 In section .bss, align 4
   \                     `RoadBrd_ProcessBGMChar::tempBffr2`:
   \   00000000                      DS8 256

   \                                 In section .bss, align 1
   \                     `RoadBrd_ProcessBGMChar::bgm_BannerFlg`:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     `RoadBrd_ProcessBGMChar::in_ptr`:
   \   00000000                      DS8 2
   1123          
   1124          /**
   1125            * @brief  This routine returns the status of the ble.req_exec flag
   1126            *         from the BGM111
   1127            * @param  None
   1128            * @retval bool:     true(1):     Processing of packet about to start
   1129            *                   false(0):      No processing pending.
   1130            */

   \                                 In section .text, align 2, keep-with-next
   1131          bool RoadBrd_tstReqexec( void )
   1132          {
   1133            return ble.req_exec;
   \                     RoadBrd_tstReqexec: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable25_2
   \   00000002   0xF890 0x0195      LDRB     R0,[R0, #+405]
   \   00000006   0x4770             BX       LR               ;; return
   1134          }
   1135          
   1136          /**
   1137            * @brief  This routine tests the passed string and then updates bgm_Bannerstr.
   1138            * @param  char *string1: Character string to be saved.
   1139            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
   1140            *                                HAL_ERROR:    Error found in Tasking or data passed.
   1141            */

   \                                 In section .text, align 2, keep-with-next
   1142          HAL_StatusTypeDef set_BGMBanner( char *string1 )
   1143          {
   \                     set_BGMBanner: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1144            int x;
   1145            
   1146            // Check Length of passed String
   1147            if (strlen(string1) > BGM_BANNER_LENGTH)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       strlen
   \   0000000A   0x2829             CMP      R0,#+41
   \   0000000C   0xD301             BCC.N    ??set_BGMBanner_0
   1148              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE00D             B.N      ??set_BGMBanner_1
   1149            else
   1150            {
   1151              for (x=0; x<BGM_BANNER_LENGTH; x++)
   \                     ??set_BGMBanner_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0005             MOVS     R5,R0
   \                     ??set_BGMBanner_2: (+1)
   \   00000016   0x2D28             CMP      R5,#+40
   \   00000018   0xDA04             BGE.N    ??set_BGMBanner_3
   1152                bgm_Bannerstr[x] = 0x00;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable25_58
   \   0000001E   0x5548             STRB     R0,[R1, R5]
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0xE7F8             B.N      ??set_BGMBanner_2
   1153              // Copy Passed string into bgm_Bannerstr
   1154              strcpy( bgm_Bannerstr, string1 );
   \                     ??set_BGMBanner_3: (+1)
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x....             LDR.N    R0,??DataTable25_58
   \   00000028   0x.... 0x....      BL       strcpy
   1155              return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??set_BGMBanner_1: (+1)
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1156            }
   1157          }
   1158          
   1159          /**
   1160            * @brief  This routine returns a pointer to the BGM Banner String.
   1161            * @retval char *string1: Character string to be saved.
   1162            */

   \                                 In section .text, align 2, keep-with-next
   1163          char *get_BGMBanner( void )
   1164          {
   1165            return ( bgm_Bannerstr );
   \                     get_BGMBanner: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable25_58
   \   00000002   0x4770             BX       LR               ;; return
   1166          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x2D 0x2A          DC8      "-*-"
   \              0x2D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x2D 0x4F          DC8      "-O-"
   \              0x2D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     gecko_cmd_msg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x01030220         DC32     0x1030220

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x020A0520         DC32     0x20a0520

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x050A0420         DC32     0x50a0420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     gecko_rsp_msg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     blemsgs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     `ble`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x........         DC32     bglib_output

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x........         DC32     BGM111_Receive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x........         DC32     bglib_input

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x........         DC32     BGM111_Peek

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x........         DC32     bglib_peek

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0xFFFF00F8         DC32     0xffff00f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x000100A0         DC32     0x100a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x000800A0         DC32     0x800a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x000900A0         DC32     0x900a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x010800A0         DC32     0x10800a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x020800A0         DC32     0x20800a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x020A0020         DC32     0x20a0020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0x020B00A0         DC32     0x20b00a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0x030A00A0         DC32     0x30a00a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_17:
   \   00000000   0x050A0020         DC32     0x50a0020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_18:
   \   00000000   0x08090020         DC32     0x8090020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_19:
   \   00000000   0x200000A0         DC32     0x200000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_20:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_21:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_22:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_23:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_24:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_25:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_26:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_27:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_28:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_29:
   \   00000000   0x........         DC32     `RoadBrd_ProcessBGMChar::tempBffr2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_30:
   \   00000000   0x........         DC32     `RoadBrd_ProcessBGMChar::in_ptr`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_31:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_32:
   \   00000000   0x........         DC32     `RoadBrd_ProcessBGMChar::bgm_BannerFlg`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_33:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_34:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_35:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_36:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_37:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_38:
   \   00000000   0x........         DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_39:
   \   00000000   0x........         DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_40:
   \   00000000   0x........         DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_41:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_42:
   \   00000000   0x........         DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_43:
   \   00000000   0x........         DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_44:
   \   00000000   0x........         DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_45:
   \   00000000   0x........         DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_46:
   \   00000000   0x........         DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_47:
   \   00000000   0x........         DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_48:
   \   00000000   0x........         DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_49:
   \   00000000   0x........         DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_50:
   \   00000000   0x........         DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_51:
   \   00000000   0x........         DC32     `RoadBrd_ProcessBGMChar::tempBffr2`+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_52:
   \   00000000   0x........         DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_53:
   \   00000000   0x........         DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_54:
   \   00000000   0x........         DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_55:
   \   00000000   0x........         DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_56:
   \   00000000   0x........         DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_57:
   \   00000000   0x........         DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_58:
   \   00000000   0x........         DC32     bgm_Bannerstr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3C 0x42          DC8 "<BGM_BOOT>"
   \              0x47 0x4D    
   \              0x5F 0x42    
   \              0x4F 0x4F    
   \              0x54 0x3E    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x3C 0x42          DC8 "<BGM_CNCTCLOSE>"
   \              0x47 0x4D    
   \              0x5F 0x43    
   \              0x4E 0x43    
   \              0x54 0x43    
   \              0x4C 0x4F    
   \              0x53 0x45    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x3C 0x42          DC8 "<BGM_CNCTOPEN>"
   \              0x47 0x4D    
   \              0x5F 0x43    
   \              0x4E 0x43    
   \              0x54 0x4F    
   \              0x50 0x45    
   \              0x4E 0x3E    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x2D 0x2A          DC8 "-*-"
   \              0x2D 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x2D 0x4F          DC8 "-O-"
   \              0x2D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x3C 0x72          DC8 "<rsp_read_ch_value_by_uuid_id>"
   \              0x73 0x70    
   \              0x5F 0x72    
   \              0x65 0x61    
   \              0x64 0x5F    
   \              0x63 0x68    
   \              0x5F 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x5F 0x62    
   \              0x79 0x5F    
   \              0x75 0x75    
   \              0x69 0x64    
   \              0x5F 0x69    
   \              0x64 0x3E    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x3C 0x53          DC8 "<STR:%s>"
   \              0x54 0x52    
   \              0x3A 0x25    
   \              0x73 0x3E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x3C 0x65          DC8 "<evt_endpoint_status_id>"
   \              0x76 0x74    
   \              0x5F 0x65    
   \              0x6E 0x64    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x5F    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x5F 0x69    
   \              0x64 0x3E    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x3C 0x55          DC8 "<UNKN:%08x>"
   \              0x4E 0x4B    
   \              0x4E 0x3A    
   \              0x25 0x30    
   \              0x38 0x78    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x3C 0x54          DC8 "<TACK Strike:%d/%d>"
   \              0x41 0x43    
   \              0x4B 0x20    
   \              0x53 0x74    
   \              0x72 0x69    
   \              0x6B 0x65    
   \              0x3A 0x25    
   \              0x64 0x2F    
   \              0x25 0x64    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x3C 0x42          DC8 "<BGMSYNC_CNCTCLOSE>"
   \              0x47 0x4D    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x5F 0x43    
   \              0x4E 0x43    
   \              0x54 0x43    
   \              0x4C 0x4F    
   \              0x53 0x45    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x0D 0x0A          DC8 "\015\012<<FULL STRING>>: "
   \              0x3C 0x3C    
   \              0x46 0x55    
   \              0x4C 0x4C    
   \              0x20 0x53    
   \              0x54 0x52    
   \              0x49 0x4E    
   \              0x47 0x3E    
   \              0x3E 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x20 0x0D          DC8 " \015\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x42 0x6F          DC8 "Boot"
   \              0x6F 0x74    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x3C 0x62          DC8 "<ble.booted> "
   \              0x6C 0x65    
   \              0x2E 0x62    
   \              0x6F 0x6F    
   \              0x74 0x65    
   \              0x64 0x3E    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x43 0x6F          DC8 "Connected"
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x3C 0x62          DC8 "<ble.TackArmed = TACK_ARMED>"
   \              0x6C 0x65    
   \              0x2E 0x54    
   \              0x61 0x63    
   \              0x6B 0x41    
   \              0x72 0x6D    
   \              0x65 0x64    
   \              0x20 0x3D    
   \              0x20 0x54    
   \              0x41 0x43    
   \              0x4B 0x5F    
   \              0x41 0x52    
   \              0x4D 0x45    
   \              0x44 0x3E    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x3C 0x62          DC8 "<ble.connection> "
   \              0x6C 0x65    
   \              0x2E 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3E    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_18:
   \   00000000   0x44 0x69          DC8 "Disconnected"
   \              0x73 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_19:
   \   00000000   0x3C 0x44          DC8 "<DISCONNECTED> "
   \              0x49 0x53    
   \              0x43 0x4F    
   \              0x4E 0x4E    
   \              0x45 0x43    
   \              0x54 0x45    
   \              0x44 0x3E    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_20:
   \   00000000   0x44 0x41          DC8 "DATA"
   \              0x54 0x41    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_21:
   \   00000000   0x3C 0x53          DC8 "<STATUS>CMD|%3.1f|%3.1f|%d|%d|ENABLED</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x43 0x4D    
   \              0x44 0x7C    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x7C    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x7C    
   \              0x25 0x64    
   \              0x7C 0x25    
   \              0x64 0x7C    
   \              0x45 0x4E    
   \              0x41 0x42    
   \              0x4C 0x45    
   \              0x44 0x3C    
   \              0x2F 0x53    
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_22:
   \   00000000   0x3C 0x53          DC8 "<STATUS>CMD|%3.1f|%3.1f|%d|%d|DISABLED</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x43 0x4D    
   \              0x44 0x7C    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x7C    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x7C    
   \              0x25 0x64    
   \              0x7C 0x25    
   \              0x64 0x7C    
   \              0x44 0x49    
   \              0x53 0x41    
   \              0x42 0x4C    
   \              0x45 0x44    
   \              0x3C 0x2F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x55 0x53    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_23:
   \   00000000   0x3C 0x62          DC8 "<ble.data_Connection> "
   \              0x6C 0x65    
   \              0x2E 0x64    
   \              0x61 0x74    
   \              0x61 0x5F    
   \              0x43 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x3E 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_24:
   \   00000000   0x52 0x50          DC8 "RP SPP server..."
   \              0x20 0x53    
   \              0x50 0x50    
   \              0x20 0x73    
   \              0x65 0x72    
   \              0x76 0x65    
   \              0x72 0x2E    
   \              0x2E 0x2E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_25:
   \   00000000   0x3C 0x42          DC8 "<BGM Banner Tag Found.> "
   \              0x47 0x4D    
   \              0x20 0x42    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x72 0x20    
   \              0x54 0x61    
   \              0x67 0x20    
   \              0x46 0x6F    
   \              0x75 0x6E    
   \              0x64 0x2E    
   \              0x3E 0x20    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_26:
   \   00000000   0x3C 0x54          DC8 "<TACK>"
   \              0x41 0x43    
   \              0x4B 0x3E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_27:
   \   00000000   0x3C 0x53          DC8 "<STATUS>DATA_SYNC</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x44 0x41    
   \              0x54 0x41    
   \              0x5F 0x53    
   \              0x59 0x4E    
   \              0x43 0x3C    
   \              0x2F 0x53    
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_28:
   \   00000000   0x3C 0x62          DC8 "<ble.TackArmed=TACK_SYNC>"
   \              0x6C 0x65    
   \              0x2E 0x54    
   \              0x61 0x63    
   \              0x6B 0x41    
   \              0x72 0x6D    
   \              0x65 0x64    
   \              0x3D 0x54    
   \              0x41 0x43    
   \              0x4B 0x5F    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x3E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_29:
   \   00000000   0x3C 0x54          DC8 "<TACK Received.>"
   \              0x41 0x43    
   \              0x4B 0x20    
   \              0x52 0x65    
   \              0x63 0x65    
   \              0x69 0x76    
   \              0x65 0x64    
   \              0x2E 0x3E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_30:
   \   00000000   0x3C 0x2F          DC8 "</TACK>"
   \              0x54 0x41    
   \              0x43 0x4B    
   \              0x3E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_31:
   \   00000000   0x3C 0x53          DC8 "<STATUS>CMD_BUSY</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x43 0x4D    
   \              0x44 0x5F    
   \              0x42 0x55    
   \              0x53 0x59    
   \              0x3C 0x2F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x55 0x53    
   \              0x3E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_32:
   \   00000000   0x3C 0x53          DC8 "<STATUS>CMD_ERROR</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x43 0x4D    
   \              0x44 0x5F    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x3C    
   \              0x2F 0x53    
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_33:
   \   00000000   0x3C 0x53          DC8 "<STATUS>ST_ACK:%s</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x53 0x54    
   \              0x5F 0x41    
   \              0x43 0x4B    
   \              0x3A 0x25    
   \              0x73 0x3C    
   \              0x2F 0x53    
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_34:
   \   00000000   0x4F 0x56          DC8 "OVERFLOW"
   \              0x45 0x52    
   \              0x46 0x4C    
   \              0x4F 0x57    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_35:
   \   00000000   0x3C 0x55          DC8 "<UNKNOWN STATUS> "
   \              0x4E 0x4B    
   \              0x4E 0x4F    
   \              0x57 0x4E    
   \              0x20 0x53    
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BGM111_CMD_Mode
       0   BGM111_Connected
       0   BGM111_DataConnected
       0   BGM111_GetTackState
       8   BGM111_Init
         8   -> BGM111_LowLevel_Init
         8   -> RoadBrd_gpio_Off
         8   -> RoadBrd_gpio_On
       0   BGM111_LowLevel_Init
       0   BGM111_Peek
      40   BGM111_ProcessInput
        40   -> Clr_HeartBeat
        40   -> Clr_HrtBeat_Cnt
        40   -> HAL_NVIC_SystemReset
        40   -> NextBufIdx
        40   -> RdBrd_BlinkErrCd
        40   -> RdBrd_ErrCdLogErrCd
        40   -> RoadBrd_UART_Transmit
        40   -> gecko_cmd_le_gap_set_mode
        40   -> gecko_peek_event
        40   -> sprintf
       0   BGM111_Ready
      16   BGM111_Receive
        16   -> HAL_UART_EnableBGM_RX
        16   -> NextBufIdx
       0   BGM111_SetCMD_Mode
       0   BGM111_SetDataConnected
       0   BGM111_SetSyncFlg
       0   BGM111_SetTackState
      48   BGM111_SyncModeTest
        48   -> BGM111_Transmit
        48   -> ClrRdSndReady
        48   -> Clr_HrtBeat_Cnt
        48   -> HAL_NVIC_SystemReset
        48   -> RdBrd_BlinkErrCd
        48   -> RdBrd_ErrCdLogErrCd
        48   -> RoadBrd_Get_TackLimit
        48   -> RoadBrd_UART_Transmit
        48   -> TstRdSndReady
        48   -> sprintf
        48   -> strlen
       0   BGM111_SyncModeTestNoInc
      24   BGM111_Transmit
        24   -> HAL_NVIC_DisableIRQ
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SystemReset
        24   -> HAL_UART_EnableBGM_TXE
        24   -> NextBufIdx
        24   -> RdBrd_BlinkErrCd
        24   -> RdBrd_ErrCdLogErrCd
      16   BGM111_UART_IRQHandler
        16   -> NextBufIdx
        16   -> RoadBrd_ProcessBGMChar
        16   -> USART_ReceiveData
        16   -> USART_SendData
      16   BGM111_WriteCharacteristic
        16   -> gecko_cmd_gatt_server_send_characteristic_notification
        16   -> gecko_cmd_gatt_server_write_attribute_value
       0   BGM111_cntrlSetSyncFlg
      16   BufFree
        16   -> BufUsed
       0   BufUsed
      16   IsBufFull
        16   -> NextBufIdx
       0   NextBufIdx
     392   RoadBrd_ProcessBGMChar
       392   -> BGM111_CMD_Mode
       392   -> BGM111_SetCMD_Mode
       392   -> BGM111_SetDataConnected
       392   -> BGM111_SetSyncFlg
       392   -> BGM111_Transmit
       392   -> ClrAnalyticsRepeat
       392   -> ClrDataStructure
       392   -> Clr_CMD_Md_Cnt
       392   -> Clr_Frame_Ratio
       392   -> HAL_NVIC_SystemReset
       392   -> RdBrd_BlinkErrCd
       392   -> RdBrd_ErrCdLogErrCd
       392   -> RoadBrd_Get_BootDelay
       392   -> RoadBrd_Get_RdSndTickCnt
       392   -> RoadBrd_Get_SnsrTickCnt
       392   -> RoadBrd_Get_TackLimit
       392   -> RoadBrd_Get_UnitsFlag
       392   -> RoadBrd_ParserTsk
       392   -> RoadBrd_Set_TmpRdSndTickCnt
       392   -> RoadBrd_UART_Transmit
       392   -> RoadBrd_WWDG_GetTickString
       392   -> RoadBrd_WWDG_VerifyFrame
       392   -> Set_RdSndTickCnt
       392   -> __aeabi_f2d
       392   -> __aeabi_fdiv
       392   -> __aeabi_ui2f
       392   -> set_BGMBanner
       392   -> sprintf
       392   -> strcpy
       392   -> strlen
       392   -> strncmp
       392   -> strstr
       0   RoadBrd_tstReqexec
       0   USART_ReceiveData
       0   USART_SendData
      24   gecko_cmd_gatt_server_send_characteristic_notification
        24   -> __aeabi_memcpy
        24   -> gecko_handle_command
      24   gecko_cmd_gatt_server_write_attribute_value
        24   -> __aeabi_memcpy
        24   -> gecko_handle_command
      16   gecko_cmd_le_gap_set_mode
        16   -> gecko_handle_command
       0   get_BGMBanner
      16   set_BGMBanner
        16   -> strcpy
        16   -> strlen
      16   strstr
        16   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable23
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_23
       4  ??DataTable25_24
       4  ??DataTable25_25
       4  ??DataTable25_26
       4  ??DataTable25_27
       4  ??DataTable25_28
       4  ??DataTable25_29
       4  ??DataTable25_3
       4  ??DataTable25_30
       4  ??DataTable25_31
       4  ??DataTable25_32
       4  ??DataTable25_33
       4  ??DataTable25_34
       4  ??DataTable25_35
       4  ??DataTable25_36
       4  ??DataTable25_37
       4  ??DataTable25_38
       4  ??DataTable25_39
       4  ??DataTable25_4
       4  ??DataTable25_40
       4  ??DataTable25_41
       4  ??DataTable25_42
       4  ??DataTable25_43
       4  ??DataTable25_44
       4  ??DataTable25_45
       4  ??DataTable25_46
       4  ??DataTable25_47
       4  ??DataTable25_48
       4  ??DataTable25_49
       4  ??DataTable25_5
       4  ??DataTable25_50
       4  ??DataTable25_51
       4  ??DataTable25_52
       4  ??DataTable25_53
       4  ??DataTable25_54
       4  ??DataTable25_55
       4  ??DataTable25_56
       4  ??DataTable25_57
       4  ??DataTable25_58
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
      12  ?_0
      16  ?_1
      20  ?_10
      20  ?_11
       4  ?_12
       8  ?_13
      16  ?_14
      12  ?_15
      32  ?_16
      20  ?_17
      16  ?_18
      16  ?_19
      16  ?_2
       8  ?_20
      48  ?_21
      48  ?_22
      24  ?_23
      20  ?_24
      28  ?_25
       8  ?_26
      28  ?_27
      28  ?_28
      20  ?_29
       4  ?_3
       8  ?_30
      28  ?_31
      28  ?_32
      28  ?_33
      12  ?_34
      20  ?_35
       4  ?_4
      32  ?_5
      12  ?_6
      28  ?_7
      12  ?_8
      20  ?_9
      10  BGM111_CMD_Mode
      10  BGM111_Connected
      10  BGM111_DataConnected
      10  BGM111_GetTackState
      50  BGM111_Init
      82  BGM111_LowLevel_Init
      10  BGM111_Peek
     526  BGM111_ProcessInput
      10  BGM111_Ready
      94  BGM111_Receive
      10  BGM111_SetCMD_Mode
      10  BGM111_SetDataConnected
      10  BGM111_SetSyncFlg
      10  BGM111_SetTackState
     176  BGM111_SyncModeTest
      36  BGM111_SyncModeTestNoInc
     326  BGM111_Transmit
     146  BGM111_UART_IRQHandler
      42  BGM111_WriteCharacteristic
      22  BGM111_cntrlSetSyncFlg
      26  BufFree
      18  BufUsed
      30  IsBufFull
      14  NextBufIdx
    1182  RoadBrd_ProcessBGMChar
       8  RoadBrd_tstReqexec
      10  USART_ReceiveData
      12  USART_SendData
     132  _gecko_cmd_msg
     132  _gecko_rsp_msg
       4  bglib_input
       4  bglib_output
       4  bglib_peek
       1  bgm_BannerFlg
      40  bgm_Bannerstr
     420  ble
     804  blemsgs
     110  gecko_cmd_gatt_server_send_characteristic_notification
     108  gecko_cmd_gatt_server_write_attribute_value
      64  gecko_cmd_le_gap_set_mode
       4  gecko_cmd_msg
       4  gecko_evt_msg
    3960  gecko_queue
       4  gecko_queue_r
       4  gecko_queue_w
       4  gecko_rsp_msg
       4  get_BGMBanner
       2  in_ptr
      48  set_BGMBanner
      16  strstr
     256  tempBffr2

 
 5 771 bytes in section .bss
     8 bytes in section .data
   704 bytes in section .rodata
 3 510 bytes in section .text
 
 3 494 bytes of CODE  memory (+ 16 bytes shared)
   704 bytes of CONST memory
 5 779 bytes of DATA  memory

Errors: none
Warnings: none
