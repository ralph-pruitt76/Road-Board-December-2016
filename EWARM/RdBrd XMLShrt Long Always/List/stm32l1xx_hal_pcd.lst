###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Dec/2017  20:12:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_pcd.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_pcd.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_pcd.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_pcd.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_pcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_pcd.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   PCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The PCD HAL driver can be used as follows:
     21          
     22               (#) Declare a PCD_HandleTypeDef handle structure, for example:
     23                   PCD_HandleTypeDef  hpcd;
     24                  
     25               (#) Fill parameters of Init structure in HCD handle
     26            
     27               (#) Call HAL_PCD_Init() API to initialize the HCD peripheral (Core, Device core, ...) 
     28          
     29               (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:
     30                   (##) Enable the PCD/USB Low Level interface clock using 
     31                        (+++) __HAL_RCC_USB_CLK_ENABLE);
     32                     
     33                   (##) Initialize the related GPIO clocks
     34                   (##) Configure PCD pin-out
     35                   (##) Configure PCD NVIC interrupt
     36              
     37               (#)Associate the Upper USB device stack to the HAL PCD Driver:
     38                   (##) hpcd.pData = pdev;
     39          
     40               (#)Enable HCD transmission and reception:
     41                   (##) HAL_PCD_Start();
     42          
     43            @endverbatim
     44            ******************************************************************************
     45            * @attention
     46            *
     47            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     48            *
     49            * Redistribution and use in source and binary forms, with or without modification,
     50            * are permitted provided that the following conditions are met:
     51            *   1. Redistributions of source code must retain the above copyright notice,
     52            *      this list of conditions and the following disclaimer.
     53            *   2. Redistributions in binary form must reproduce the above copyright notice,
     54            *      this list of conditions and the following disclaimer in the documentation
     55            *      and/or other materials provided with the distribution.
     56            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     57            *      may be used to endorse or promote products derived from this software
     58            *      without specific prior written permission.
     59            *
     60            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     61            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     62            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     63            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     64            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     65            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     66            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     67            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     68            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     69            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     70            *
     71            ******************************************************************************
     72            */
     73          
     74          /* Includes ------------------------------------------------------------------*/
     75          #include "stm32l1xx_hal.h"
     76          
     77          /** @addtogroup STM32L1xx_HAL_Driver
     78            * @{
     79            */
     80          
     81          /** @defgroup PCD PCD
     82            * @brief PCD HAL module driver
     83            * @{
     84            */
     85          
     86          #ifdef HAL_PCD_MODULE_ENABLED
     87          
     88          /* Private typedef -----------------------------------------------------------*/
     89          /* Private define ------------------------------------------------------------*/
     90          
     91          /** @defgroup PCD_Private_Define PCD Private Define
     92            * @{
     93            */ 
     94          #define BTABLE_ADDRESS                  (0x000)  
     95          /**
     96            * @}
     97            */
     98          
     99          /* Private macro -------------------------------------------------------------*/
    100          /* Private variables ---------------------------------------------------------*/
    101          /* Private function prototypes -----------------------------------------------*/
    102          /** @defgroup PCD_Private_Functions PCD Private Functions
    103            * @{
    104            */
    105          static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd);
    106          static void PCD_WritePMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes);
    107          static void PCD_ReadPMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes);
    108          
    109          /**
    110            * @}
    111            */
    112          
    113          /* Exported functions ---------------------------------------------------------*/
    114          
    115          /** @defgroup PCD_Exported_Functions PCD Exported Functions
    116            * @{
    117            */
    118          
    119          /** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    120           *  @brief    Initialization and Configuration functions 
    121           *
    122          @verbatim
    123           ===============================================================================
    124                      ##### Initialization and de-initialization functions #####
    125           ===============================================================================
    126              [..]  This section provides functions allowing to:
    127           
    128          @endverbatim
    129            * @{
    130            */
    131          
    132          /**
    133            * @brief  Initializes the PCD according to the specified
    134            *         parameters in the PCD_InitTypeDef and create the associated handle.
    135            * @param  hpcd: PCD handle
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
    139          { 
   \                     HAL_PCD_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    140            uint32_t i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    141          
    142            uint32_t wInterrupt_Mask = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    143            
    144            /* Check the PCD handle allocation */
    145            if(hpcd == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Init_0
    146            {
    147              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE086             B.N      ??HAL_PCD_Init_1
    148            }
    149            
    150            /* Check the parameters */
    151            assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
    152          
    153            if(hpcd->State == HAL_PCD_STATE_RESET)
   \                     ??HAL_PCD_Init_0: (+1)
   \   00000010   0xF894 0x01E9      LDRB     R0,[R4, #+489]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_PCD_Init_2
    154            {
    155              /* Allocate lock resource and initialize it */
    156              hpcd->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x01E8      STRB     R0,[R4, #+488]
    157          
    158              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    159              HAL_PCD_MspInit(hpcd);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_PCD_MspInit
    160            }
    161          
    162            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_Init_2: (+1)
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xF884 0x01E9      STRB     R0,[R4, #+489]
    163          
    164           /* Init endpoints structures */
    165           for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0005             MOVS     R5,R0
   \                     ??HAL_PCD_Init_3: (+1)
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD227             BCS.N    ??HAL_PCD_Init_4
    166           {
    167             /* Init ep structure */
    168             hpcd->IN_ep[i].is_in = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x211C             MOVS     R1,#+28
   \   00000038   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000003C   0x4421             ADD      R1,R4,R1
   \   0000003E   0xF881 0x0029      STRB     R0,[R1, #+41]
    169             hpcd->IN_ep[i].num = i;
   \   00000042   0x201C             MOVS     R0,#+28
   \   00000044   0xFB00 0xF005      MUL      R0,R0,R5
   \   00000048   0x4420             ADD      R0,R4,R0
   \   0000004A   0xF880 0x5028      STRB     R5,[R0, #+40]
    170             /* Control until ep is actvated */
    171             hpcd->IN_ep[i].type = PCD_EP_TYPE_CTRL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x211C             MOVS     R1,#+28
   \   00000052   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000056   0x4421             ADD      R1,R4,R1
   \   00000058   0xF881 0x002B      STRB     R0,[R1, #+43]
    172             hpcd->IN_ep[i].maxpacket =  0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x211C             MOVS     R1,#+28
   \   00000060   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000064   0x4421             ADD      R1,R4,R1
   \   00000066   0x6348             STR      R0,[R1, #+52]
    173             hpcd->IN_ep[i].xfer_buff = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x211C             MOVS     R1,#+28
   \   0000006C   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000070   0x4421             ADD      R1,R4,R1
   \   00000072   0x6388             STR      R0,[R1, #+56]
    174             hpcd->IN_ep[i].xfer_len = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x211C             MOVS     R1,#+28
   \   00000078   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000007C   0x4421             ADD      R1,R4,R1
   \   0000007E   0x63C8             STR      R0,[R1, #+60]
    175           }
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
   \   00000082   0xE7D4             B.N      ??HAL_PCD_Init_3
    176           
    177           for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
   \                     ??HAL_PCD_Init_4: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x0005             MOVS     R5,R0
   \                     ??HAL_PCD_Init_5: (+1)
   \   00000088   0x6860             LDR      R0,[R4, #+4]
   \   0000008A   0x4285             CMP      R5,R0
   \   0000008C   0xD22A             BCS.N    ??HAL_PCD_Init_6
    178           {
    179             hpcd->OUT_ep[i].is_in = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x211C             MOVS     R1,#+28
   \   00000092   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000096   0x4421             ADD      R1,R4,R1
   \   00000098   0xF881 0x0109      STRB     R0,[R1, #+265]
    180             hpcd->OUT_ep[i].num = i;
   \   0000009C   0x201C             MOVS     R0,#+28
   \   0000009E   0xFB00 0xF005      MUL      R0,R0,R5
   \   000000A2   0x4420             ADD      R0,R4,R0
   \   000000A4   0xF880 0x5108      STRB     R5,[R0, #+264]
    181             /* Control until ep is activated */
    182             hpcd->OUT_ep[i].type = PCD_EP_TYPE_CTRL;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x211C             MOVS     R1,#+28
   \   000000AC   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000B0   0x4421             ADD      R1,R4,R1
   \   000000B2   0xF881 0x010B      STRB     R0,[R1, #+267]
    183             hpcd->OUT_ep[i].maxpacket = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x211C             MOVS     R1,#+28
   \   000000BA   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000BE   0x4421             ADD      R1,R4,R1
   \   000000C0   0xF8C1 0x0114      STR      R0,[R1, #+276]
    184             hpcd->OUT_ep[i].xfer_buff = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x211C             MOVS     R1,#+28
   \   000000C8   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000CC   0x4421             ADD      R1,R4,R1
   \   000000CE   0xF8C1 0x0118      STR      R0,[R1, #+280]
    185             hpcd->OUT_ep[i].xfer_len = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x211C             MOVS     R1,#+28
   \   000000D6   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000DA   0x4421             ADD      R1,R4,R1
   \   000000DC   0xF8C1 0x011C      STR      R0,[R1, #+284]
    186           }
   \   000000E0   0x1C6D             ADDS     R5,R5,#+1
   \   000000E2   0xE7D1             B.N      ??HAL_PCD_Init_5
    187            
    188           /* Init Device */
    189           /*CNTR_FRES = 1*/
    190           hpcd->Instance->CNTR = USB_CNTR_FRES;
   \                     ??HAL_PCD_Init_6: (+1)
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    191           
    192           /*CNTR_FRES = 0*/
    193           hpcd->Instance->CNTR = 0;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    194           
    195           /*Clear pending interrupts*/
    196           hpcd->Instance->ISTR = 0;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x6821             LDR      R1,[R4, #+0]
   \   000000F8   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    197           
    198            /*Set Btable Adress*/
    199           hpcd->Instance->BTABLE = BTABLE_ADDRESS;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x6821             LDR      R1,[R4, #+0]
   \   00000100   0xF8A1 0x0050      STRH     R0,[R1, #+80]
    200            
    201            /*set wInterrupt_Mask global variable*/
    202            wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    203              | USB_CNTR_ESOFM | USB_CNTR_RESETM;
   \   00000104   0xF44F 0x403D      MOV      R0,#+48384
   \   00000108   0x0006             MOVS     R6,R0
    204            
    205            /*Set interrupt mask*/
    206            hpcd->Instance->CNTR = wInterrupt_Mask;
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0xF8A0 0x6040      STRH     R6,[R0, #+64]
    207            
    208            hpcd->USB_Address = 0;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF884 0x0024      STRB     R0,[R4, #+36]
    209            hpcd->State= HAL_PCD_STATE_READY;
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xF884 0x01E9      STRB     R0,[R4, #+489]
    210          
    211           return HAL_OK;
   \   0000011C   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Init_1: (+1)
   \   0000011E   0xBD70             POP      {R4-R6,PC}       ;; return
    212          }
    213          
    214          /**
    215            * @brief  DeInitializes the PCD peripheral 
    216            * @param  hpcd: PCD handle
    217            * @retval HAL status
    218            */

   \                                 In section .text, align 2, keep-with-next
    219          HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
    220          {
   \                     HAL_PCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    221            /* Check the PCD handle allocation */
    222            if(hpcd == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_PCD_DeInit_0
    223            {
    224              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE00C             B.N      ??HAL_PCD_DeInit_1
    225            }
    226          
    227            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_DeInit_0: (+1)
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x01E9      STRB     R0,[R4, #+489]
    228            
    229            /* Stop Device */
    230            HAL_PCD_Stop(hpcd);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       HAL_PCD_Stop
    231              
    232            /* DeInit the low level hardware */
    233            HAL_PCD_MspDeInit(hpcd);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_PCD_MspDeInit
    234            
    235            hpcd->State = HAL_PCD_STATE_RESET; 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x01E9      STRB     R0,[R4, #+489]
    236            
    237            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DeInit_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    238          }
    239          
    240          /**
    241            * @brief  Initializes the PCD MSP.
    242            * @param  hpcd: PCD handle
    243            * @retval None
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
    246          {
    247            /* Prevent unused argument(s) compilation warning */
    248            UNUSED(hpcd);
    249          
    250            /* NOTE : This function should not be modified, when the callback is needed,
    251                      the HAL_PCD_MspInit could be implemented in the user file
    252             */
    253          }
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @brief  DeInitializes PCD MSP.
    257            * @param  hpcd: PCD handle
    258            * @retval None
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    261          {
    262            /* Prevent unused argument(s) compilation warning */
    263            UNUSED(hpcd);
    264          
    265            /* NOTE : This function should not be modified, when the callback is needed,
    266                      the HAL_PCD_MspDeInit could be implemented in the user file
    267             */
    268          }
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    269          
    270          /**
    271            * @}
    272            */
    273          
    274          /** @defgroup PCD_Exported_Functions_Group2 IO operation functions 
    275           *  @brief   Data transfers functions 
    276           *
    277          @verbatim   
    278           ===============================================================================
    279                                ##### IO operation functions #####
    280           ===============================================================================  
    281              [..]
    282              This subsection provides a set of functions allowing to manage the PCD data 
    283              transfers.
    284          
    285          @endverbatim
    286            * @{
    287            */
    288            
    289          /**
    290            * @brief  Start the USB device.
    291            * @param  hpcd: PCD handle
    292            * @retval HAL status
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
    295          { 
   \                     HAL_PCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    296            HAL_PCDEx_SetConnectionState (hpcd, 1);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       HAL_PCDEx_SetConnectionState
    297          
    298            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    299          }
    300          
    301          /**
    302            * @brief  Stop the USB device.
    303            * @param  hpcd: PCD handle
    304            * @retval HAL status
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
    307          { 
   \                     HAL_PCD_Stop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    308            __HAL_LOCK(hpcd); 
   \   00000002   0xF891 0x01E8      LDRB     R0,[R1, #+488]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_PCD_Stop_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_PCD_Stop_1
   \                     ??HAL_PCD_Stop_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x01E8      STRB     R0,[R1, #+488]
    309            
    310              /* disable all interrupts and force USB reset */
    311            hpcd->Instance->CNTR = USB_CNTR_FRES;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xF8A2 0x0040      STRH     R0,[R2, #+64]
    312            
    313            /* clear interrupt status register */
    314            hpcd->Instance->ISTR = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0xF8A2 0x0044      STRH     R0,[R2, #+68]
    315            
    316            /* switch-off device */
    317            hpcd->Instance->CNTR = (USB_CNTR_FRES | USB_CNTR_PDWN);
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0xF8A2 0x0040      STRH     R0,[R2, #+64]
    318            
    319            __HAL_UNLOCK(hpcd); 
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x01E8      STRB     R0,[R1, #+488]
    320            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Stop_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    321          }
    322          /**
    323            * @}
    324            */
    325          
    326          /**
    327            * @}
    328            */  
    329          
    330          /** @addtogroup PCD_Private_Functions PCD Private Functions
    331            * @{
    332            */
    333          /**
    334            * @brief  This function handles PCD Endpoint interrupt request.
    335            * @param  hpcd: PCD handle
    336            * @retval HAL status
    337            */

   \                                 In section .text, align 2, keep-with-next
    338          static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
    339          {
   \                     PCD_EP_ISR_Handler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    340            PCD_EPTypeDef *ep;
    341            uint16_t count=0;
   \   00000004   0x2600             MOVS     R6,#+0
    342            uint8_t EPindex;
    343            __IO uint16_t wIstr;  
    344            __IO uint16_t wEPVal = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    345            
    346            /* stay in loop while pending interrupts */
    347            while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
   \                     ??PCD_EP_ISR_Handler_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000012   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000016   0x0400             LSLS     R0,R0,#+16
   \   00000018   0xF140 0x820D      BPL.W    ??PCD_EP_ISR_Handler_1
    348            {
    349              /* extract highest priority endpoint number */
    350              EPindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
   \   0000001C   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000020   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000024   0x0007             MOVS     R7,R0
    351              
    352              if (EPindex == 0)
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xF040 0x80C8      BNE.W    ??PCD_EP_ISR_Handler_2
    353              {
    354                /* Decode and service control endpoint interrupt */
    355                
    356                /* DIR bit = origin of the interrupt */   
    357                if ((wIstr & USB_ISTR_DIR) == 0)
   \   0000002E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000032   0x06C0             LSLS     R0,R0,#+27
   \   00000034   0xD432             BMI.N    ??PCD_EP_ISR_Handler_3
    358                {
    359                  /* DIR = 0 */
    360                  
    361                  /* DIR = 0      => IN  int */
    362                  /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
    363                  PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0xF648 0x710F      MOVW     R1,#+36623
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x8008             STRH     R0,[R1, #+0]
    364                  ep = &hpcd->IN_ep[0];
   \   00000044   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000048   0x0005             MOVS     R5,R0
    365                  
    366                  ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000050   0x7829             LDRB     R1,[R5, #+0]
   \   00000052   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   0000005C   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000064   0x0D80             LSRS     R0,R0,#+22
   \   00000066   0x61A8             STR      R0,[R5, #+24]
    367                  ep->xfer_buff += ep->xfer_count;
   \   00000068   0x6928             LDR      R0,[R5, #+16]
   \   0000006A   0x69A9             LDR      R1,[R5, #+24]
   \   0000006C   0x4408             ADD      R0,R0,R1
   \   0000006E   0x6128             STR      R0,[R5, #+16]
    368           
    369                  /* TX COMPLETE */
    370                  HAL_PCD_DataInStageCallback(hpcd, 0);
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
    371                  
    372                  
    373                  if((hpcd->USB_Address > 0)&& ( ep->xfer_len == 0))
   \   00000078   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD0C5             BEQ.N    ??PCD_EP_ISR_Handler_0
   \   00000080   0x6968             LDR      R0,[R5, #+20]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1C2             BNE.N    ??PCD_EP_ISR_Handler_0
    374                  {
    375                    hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
   \   00000086   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000008A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0xF8A1 0x004C      STRH     R0,[R1, #+76]
    376                    hpcd->USB_Address = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   0000009A   0xE7B7             B.N      ??PCD_EP_ISR_Handler_0
    377                  }
    378                  
    379                }
    380                else
    381                {
    382                  /* DIR = 1 */
    383                  
    384                  /* DIR = 1 & CTR_RX       => SETUP or OUT int */
    385                  /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
    386                  ep = &hpcd->OUT_ep[0];
   \                     ??PCD_EP_ISR_Handler_3: (+1)
   \   0000009C   0xF44F 0x7084      MOV      R0,#+264
   \   000000A0   0x4420             ADD      R0,R4,R0
   \   000000A2   0x0005             MOVS     R5,R0
    387                  wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x8800             LDRH     R0,[R0, #+0]
   \   000000A8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    388                  
    389                  if ((wEPVal & USB_EP_SETUP) != 0)
   \   000000AC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B0   0x0500             LSLS     R0,R0,#+20
   \   000000B2   0xD523             BPL.N    ??PCD_EP_ISR_Handler_4
    390                  {
    391                    /* Get SETUP Packet*/
    392                    ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   000000BA   0x7829             LDRB     R1,[R5, #+0]
   \   000000BC   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   000000C6   0xF200 0x400C      ADDW     R0,R0,#+1036
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   000000CE   0x0D80             LSRS     R0,R0,#+22
   \   000000D0   0x61A8             STR      R0,[R5, #+24]
    393                    PCD_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
   \   000000D2   0x69AB             LDR      R3,[R5, #+24]
   \   000000D4   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000D6   0x88AA             LDRH     R2,[R5, #+4]
   \   000000D8   0xF44F 0x70F6      MOV      R0,#+492
   \   000000DC   0xEB04 0x0100      ADD      R1,R4,R0
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       PCD_ReadPMA
    394                    /* SETUP bit kept frozen while CTR_RX = 1*/ 
    395                    PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x8800             LDRH     R0,[R0, #+0]
   \   000000EA   0xF640 0x718F      MOVW     R1,#+3983
   \   000000EE   0x4008             ANDS     R0,R1,R0
   \   000000F0   0x6821             LDR      R1,[R4, #+0]
   \   000000F2   0x8008             STRH     R0,[R1, #+0]
    396                    
    397                    /* Process SETUP Packet*/
    398                    HAL_PCD_SetupStageCallback(hpcd);
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       HAL_PCD_SetupStageCallback
   \   000000FA   0xE787             B.N      ??PCD_EP_ISR_Handler_0
    399                  }
    400                  
    401                  else if ((wEPVal & USB_EP_CTR_RX) != 0)
   \                     ??PCD_EP_ISR_Handler_4: (+1)
   \   000000FC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000100   0x0400             LSLS     R0,R0,#+16
   \   00000102   0xD583             BPL.N    ??PCD_EP_ISR_Handler_0
    402                  {
    403                    PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x8800             LDRH     R0,[R0, #+0]
   \   00000108   0xF640 0x718F      MOVW     R1,#+3983
   \   0000010C   0x4008             ANDS     R0,R1,R0
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x8008             STRH     R0,[R1, #+0]
    404                    /* Get Control Data OUT Packet*/
    405                    ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000118   0x7829             LDRB     R1,[R5, #+0]
   \   0000011A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000124   0xF200 0x400C      ADDW     R0,R0,#+1036
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   0000012C   0x0D80             LSRS     R0,R0,#+22
   \   0000012E   0x61A8             STR      R0,[R5, #+24]
    406                    
    407                    if (ep->xfer_count != 0)
   \   00000130   0x69A8             LDR      R0,[R5, #+24]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD00A             BEQ.N    ??PCD_EP_ISR_Handler_5
    408                    {
    409                      PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
   \   00000136   0x69AB             LDR      R3,[R5, #+24]
   \   00000138   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000013A   0x88AA             LDRH     R2,[R5, #+4]
   \   0000013C   0x6929             LDR      R1,[R5, #+16]
   \   0000013E   0x6820             LDR      R0,[R4, #+0]
   \   00000140   0x.... 0x....      BL       PCD_ReadPMA
    410                      ep->xfer_buff+=ep->xfer_count;
   \   00000144   0x6928             LDR      R0,[R5, #+16]
   \   00000146   0x69A9             LDR      R1,[R5, #+24]
   \   00000148   0x4408             ADD      R0,R0,R1
   \   0000014A   0x6128             STR      R0,[R5, #+16]
    411                    }
    412                    
    413                    /* Process Control Data OUT Packet*/
    414                     HAL_PCD_DataOutStageCallback(hpcd, 0);
   \                     ??PCD_EP_ISR_Handler_5: (+1)
   \   0000014C   0x2100             MOVS     R1,#+0
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
    415                    
    416                    PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
   \   00000154   0x6821             LDR      R1,[R4, #+0]
   \   00000156   0xF8B1 0x1050      LDRH     R1,[R1, #+80]
   \   0000015A   0x6822             LDR      R2,[R4, #+0]
   \   0000015C   0xEB12 0x0141      ADDS     R1,R2,R1, LSL #+1
   \   00000160   0xF201 0x410C      ADDW     R1,R1,#+1036
   \   00000164   0x0008             MOVS     R0,R1
   \   00000166   0x68EA             LDR      R2,[R5, #+12]
   \   00000168   0x2A3F             CMP      R2,#+63
   \   0000016A   0xD30D             BCC.N    ??PCD_EP_ISR_Handler_6
   \   0000016C   0x68EA             LDR      R2,[R5, #+12]
   \   0000016E   0x0952             LSRS     R2,R2,#+5
   \   00000170   0x0011             MOVS     R1,R2
   \   00000172   0x7B2A             LDRB     R2,[R5, #+12]
   \   00000174   0xF012 0x0F1F      TST      R2,#0x1F
   \   00000178   0xD100             BNE.N    ??PCD_EP_ISR_Handler_7
   \   0000017A   0x1E49             SUBS     R1,R1,#+1
   \                     ??PCD_EP_ISR_Handler_7: (+1)
   \   0000017C   0x0289             LSLS     R1,R1,#+10
   \   0000017E   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000182   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000184   0x6001             STR      R1,[R0, #+0]
   \   00000186   0xE009             B.N      ??PCD_EP_ISR_Handler_8
   \                     ??PCD_EP_ISR_Handler_6: (+1)
   \   00000188   0x68EA             LDR      R2,[R5, #+12]
   \   0000018A   0x0852             LSRS     R2,R2,#+1
   \   0000018C   0x0011             MOVS     R1,R2
   \   0000018E   0x7B2A             LDRB     R2,[R5, #+12]
   \   00000190   0x07D2             LSLS     R2,R2,#+31
   \   00000192   0xD500             BPL.N    ??PCD_EP_ISR_Handler_9
   \   00000194   0x1C49             ADDS     R1,R1,#+1
   \                     ??PCD_EP_ISR_Handler_9: (+1)
   \   00000196   0x0289             LSLS     R1,R1,#+10
   \   00000198   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000019A   0x6001             STR      R1,[R0, #+0]
    417                    PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
   \                     ??PCD_EP_ISR_Handler_8: (+1)
   \   0000019C   0x6821             LDR      R1,[R4, #+0]
   \   0000019E   0x8809             LDRH     R1,[R1, #+0]
   \   000001A0   0xF64B 0x728F      MOVW     R2,#+49039
   \   000001A4   0x4011             ANDS     R1,R2,R1
   \   000001A6   0x0008             MOVS     R0,R1
   \   000001A8   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   000001AC   0xF490 0x5000      EORS     R0,R0,#0x2000
   \   000001B0   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000001B4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001B8   0x6821             LDR      R1,[R4, #+0]
   \   000001BA   0x8008             STRH     R0,[R1, #+0]
   \   000001BC   0xE726             B.N      ??PCD_EP_ISR_Handler_0
    418                  }
    419                }
    420              }
    421              else
    422              {
    423                
    424                /* Decode and service non control endpoints interrupt  */
    425                
    426                /* process related endpoint register */
    427                wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, EPindex);
   \                     ??PCD_EP_ISR_Handler_2: (+1)
   \   000001BE   0x6820             LDR      R0,[R4, #+0]
   \   000001C0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001C2   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000001C6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    428                if ((wEPVal & USB_EP_CTR_RX) != 0)
   \   000001CA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000001CE   0x0400             LSLS     R0,R0,#+16
   \   000001D0   0xF140 0x8093      BPL.W    ??PCD_EP_ISR_Handler_10
    429                {  
    430                  /* clear int flag */
    431                  PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
   \   000001D4   0x6820             LDR      R0,[R4, #+0]
   \   000001D6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001D8   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000001DC   0xF640 0x718F      MOVW     R1,#+3983
   \   000001E0   0x4008             ANDS     R0,R1,R0
   \   000001E2   0x6821             LDR      R1,[R4, #+0]
   \   000001E4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001E6   0xF821 0x0027      STRH     R0,[R1, R7, LSL #+2]
    432                  ep = &hpcd->OUT_ep[EPindex];
   \   000001EA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001EC   0x201C             MOVS     R0,#+28
   \   000001EE   0xFB00 0xF007      MUL      R0,R0,R7
   \   000001F2   0x4420             ADD      R0,R4,R0
   \   000001F4   0xF44F 0x7184      MOV      R1,#+264
   \   000001F8   0x4408             ADD      R0,R0,R1
   \   000001FA   0x0005             MOVS     R5,R0
    433                  
    434                  /* OUT double Buffering*/
    435                  if (ep->doublebuffer == 0)
   \   000001FC   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001FE   0x2800             CMP      R0,#+0
   \   00000200   0xD119             BNE.N    ??PCD_EP_ISR_Handler_11
    436                  {
    437                    count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
   \   00000202   0x6820             LDR      R0,[R4, #+0]
   \   00000204   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000208   0x7829             LDRB     R1,[R5, #+0]
   \   0000020A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000020E   0x6821             LDR      R1,[R4, #+0]
   \   00000210   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000214   0xF200 0x400C      ADDW     R0,R0,#+1036
   \   00000218   0x6800             LDR      R0,[R0, #+0]
   \   0000021A   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   0000021C   0x0D80             LSRS     R0,R0,#+22
   \   0000021E   0x0006             MOVS     R6,R0
    438                    if (count != 0)
   \   00000220   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000222   0x2E00             CMP      R6,#+0
   \   00000224   0xD04F             BEQ.N    ??PCD_EP_ISR_Handler_12
    439                    {
    440                      PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
   \   00000226   0x0033             MOVS     R3,R6
   \   00000228   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000022A   0x88AA             LDRH     R2,[R5, #+4]
   \   0000022C   0x6929             LDR      R1,[R5, #+16]
   \   0000022E   0x6820             LDR      R0,[R4, #+0]
   \   00000230   0x.... 0x....      BL       PCD_ReadPMA
   \   00000234   0xE047             B.N      ??PCD_EP_ISR_Handler_12
    441                    }
    442                  }
    443                  else
    444                  {
    445                    if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
   \                     ??PCD_EP_ISR_Handler_11: (+1)
   \   00000236   0x6820             LDR      R0,[R4, #+0]
   \   00000238   0x7829             LDRB     R1,[R5, #+0]
   \   0000023A   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   0000023E   0x0440             LSLS     R0,R0,#+17
   \   00000240   0xD519             BPL.N    ??PCD_EP_ISR_Handler_13
    446                    {
    447                      /*read from endpoint BUF0Addr buffer*/
    448                      count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
   \   00000242   0x6820             LDR      R0,[R4, #+0]
   \   00000244   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000248   0x7829             LDRB     R1,[R5, #+0]
   \   0000024A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000024E   0x6821             LDR      R1,[R4, #+0]
   \   00000250   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000254   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   0000025C   0x0D80             LSRS     R0,R0,#+22
   \   0000025E   0x0006             MOVS     R6,R0
    449                      if (count != 0)
   \   00000260   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000262   0x2E00             CMP      R6,#+0
   \   00000264   0xD020             BEQ.N    ??PCD_EP_ISR_Handler_14
    450                      {
    451                        PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
   \   00000266   0x0033             MOVS     R3,R6
   \   00000268   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000026A   0x88EA             LDRH     R2,[R5, #+6]
   \   0000026C   0x6929             LDR      R1,[R5, #+16]
   \   0000026E   0x6820             LDR      R0,[R4, #+0]
   \   00000270   0x.... 0x....      BL       PCD_ReadPMA
   \   00000274   0xE018             B.N      ??PCD_EP_ISR_Handler_14
    452                      }
    453                    }
    454                    else
    455                    {
    456                      /*read from endpoint BUF1Addr buffer*/
    457                      count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
   \                     ??PCD_EP_ISR_Handler_13: (+1)
   \   00000276   0x6820             LDR      R0,[R4, #+0]
   \   00000278   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   0000027C   0x7829             LDRB     R1,[R5, #+0]
   \   0000027E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000282   0x6821             LDR      R1,[R4, #+0]
   \   00000284   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000288   0xF200 0x400C      ADDW     R0,R0,#+1036
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000290   0x0D80             LSRS     R0,R0,#+22
   \   00000292   0x0006             MOVS     R6,R0
    458                      if (count != 0)
   \   00000294   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000296   0x2E00             CMP      R6,#+0
   \   00000298   0xD006             BEQ.N    ??PCD_EP_ISR_Handler_14
    459                      {
    460                        PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
   \   0000029A   0x0033             MOVS     R3,R6
   \   0000029C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000029E   0x892A             LDRH     R2,[R5, #+8]
   \   000002A0   0x6929             LDR      R1,[R5, #+16]
   \   000002A2   0x6820             LDR      R0,[R4, #+0]
   \   000002A4   0x.... 0x....      BL       PCD_ReadPMA
    461                      }
    462                    }
    463                    PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
   \                     ??PCD_EP_ISR_Handler_14: (+1)
   \   000002A8   0x6820             LDR      R0,[R4, #+0]
   \   000002AA   0x7829             LDRB     R1,[R5, #+0]
   \   000002AC   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   000002B0   0xF648 0x718F      MOVW     R1,#+36751
   \   000002B4   0x4008             ANDS     R0,R1,R0
   \   000002B6   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000002BA   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   000002BE   0x6821             LDR      R1,[R4, #+0]
   \   000002C0   0x782A             LDRB     R2,[R5, #+0]
   \   000002C2   0xF821 0x0022      STRH     R0,[R1, R2, LSL #+2]
    464                  }
    465                  /*multi-packet on the NON control OUT endpoint*/
    466                  ep->xfer_count+=count;
   \                     ??PCD_EP_ISR_Handler_12: (+1)
   \   000002C6   0x69A8             LDR      R0,[R5, #+24]
   \   000002C8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000002CA   0x1830             ADDS     R0,R6,R0
   \   000002CC   0x61A8             STR      R0,[R5, #+24]
    467                  ep->xfer_buff+=count;
   \   000002CE   0x6928             LDR      R0,[R5, #+16]
   \   000002D0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000002D2   0x4430             ADD      R0,R0,R6
   \   000002D4   0x6128             STR      R0,[R5, #+16]
    468                 
    469                  if ((ep->xfer_len == 0) || (count < ep->maxpacket))
   \   000002D6   0x6968             LDR      R0,[R5, #+20]
   \   000002D8   0x2800             CMP      R0,#+0
   \   000002DA   0xD003             BEQ.N    ??PCD_EP_ISR_Handler_15
   \   000002DC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000002DE   0x68E8             LDR      R0,[R5, #+12]
   \   000002E0   0x4286             CMP      R6,R0
   \   000002E2   0xD204             BCS.N    ??PCD_EP_ISR_Handler_16
    470                  {
    471                    /* RX COMPLETE */
    472                    HAL_PCD_DataOutStageCallback(hpcd, ep->num);
   \                     ??PCD_EP_ISR_Handler_15: (+1)
   \   000002E4   0x7829             LDRB     R1,[R5, #+0]
   \   000002E6   0x0020             MOVS     R0,R4
   \   000002E8   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
   \   000002EC   0xE005             B.N      ??PCD_EP_ISR_Handler_10
    473                  }
    474                  else
    475                  {
    476                    HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
   \                     ??PCD_EP_ISR_Handler_16: (+1)
   \   000002EE   0x696B             LDR      R3,[R5, #+20]
   \   000002F0   0x692A             LDR      R2,[R5, #+16]
   \   000002F2   0x7829             LDRB     R1,[R5, #+0]
   \   000002F4   0x0020             MOVS     R0,R4
   \   000002F6   0x.... 0x....      BL       HAL_PCD_EP_Receive
    477                  }
    478                  
    479                } /* if((wEPVal & EP_CTR_RX) */
    480                
    481                if ((wEPVal & USB_EP_CTR_TX) != 0)
   \                     ??PCD_EP_ISR_Handler_10: (+1)
   \   000002FA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000002FE   0x0600             LSLS     R0,R0,#+24
   \   00000300   0xF57F 0xAE84      BPL.W    ??PCD_EP_ISR_Handler_0
    482                {
    483                  ep = &hpcd->IN_ep[EPindex];
   \   00000304   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000306   0x201C             MOVS     R0,#+28
   \   00000308   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000030C   0x4420             ADD      R0,R4,R0
   \   0000030E   0x3028             ADDS     R0,R0,#+40
   \   00000310   0x0005             MOVS     R5,R0
    484                  
    485                  /* clear int flag */
    486                  PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
   \   00000312   0x6820             LDR      R0,[R4, #+0]
   \   00000314   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000316   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   0000031A   0xF648 0x710F      MOVW     R1,#+36623
   \   0000031E   0x4008             ANDS     R0,R1,R0
   \   00000320   0x6821             LDR      R1,[R4, #+0]
   \   00000322   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000324   0xF821 0x0027      STRH     R0,[R1, R7, LSL #+2]
    487                  
    488                  /* IN double Buffering*/
    489                  if (ep->doublebuffer == 0)
   \   00000328   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000032A   0x2800             CMP      R0,#+0
   \   0000032C   0xD119             BNE.N    ??PCD_EP_ISR_Handler_17
    490                  {
    491                    ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
   \   0000032E   0x6820             LDR      R0,[R4, #+0]
   \   00000330   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000334   0x7829             LDRB     R1,[R5, #+0]
   \   00000336   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000033A   0x6821             LDR      R1,[R4, #+0]
   \   0000033C   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000340   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000344   0x6800             LDR      R0,[R0, #+0]
   \   00000346   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000348   0x0D80             LSRS     R0,R0,#+22
   \   0000034A   0x61A8             STR      R0,[R5, #+24]
    492                    if (ep->xfer_count != 0)
   \   0000034C   0x69A8             LDR      R0,[R5, #+24]
   \   0000034E   0x2800             CMP      R0,#+0
   \   00000350   0xD04F             BEQ.N    ??PCD_EP_ISR_Handler_18
    493                    {
    494                      PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
   \   00000352   0x69AB             LDR      R3,[R5, #+24]
   \   00000354   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000356   0x88AA             LDRH     R2,[R5, #+4]
   \   00000358   0x6929             LDR      R1,[R5, #+16]
   \   0000035A   0x6820             LDR      R0,[R4, #+0]
   \   0000035C   0x.... 0x....      BL       PCD_WritePMA
   \   00000360   0xE047             B.N      ??PCD_EP_ISR_Handler_18
    495                    }
    496                  }
    497                  else
    498                  {
    499                    if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
   \                     ??PCD_EP_ISR_Handler_17: (+1)
   \   00000362   0x6820             LDR      R0,[R4, #+0]
   \   00000364   0x7829             LDRB     R1,[R5, #+0]
   \   00000366   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   0000036A   0x0640             LSLS     R0,R0,#+25
   \   0000036C   0xD519             BPL.N    ??PCD_EP_ISR_Handler_19
    500                    {
    501                      /*read from endpoint BUF0Addr buffer*/
    502                      ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
   \   0000036E   0x6820             LDR      R0,[R4, #+0]
   \   00000370   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000374   0x7829             LDRB     R1,[R5, #+0]
   \   00000376   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000037A   0x6821             LDR      R1,[R4, #+0]
   \   0000037C   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000380   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000388   0x0D80             LSRS     R0,R0,#+22
   \   0000038A   0x61A8             STR      R0,[R5, #+24]
    503                      if (ep->xfer_count != 0)
   \   0000038C   0x69A8             LDR      R0,[R5, #+24]
   \   0000038E   0x2800             CMP      R0,#+0
   \   00000390   0xD020             BEQ.N    ??PCD_EP_ISR_Handler_20
    504                      {
    505                        PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
   \   00000392   0x69AB             LDR      R3,[R5, #+24]
   \   00000394   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000396   0x88EA             LDRH     R2,[R5, #+6]
   \   00000398   0x6929             LDR      R1,[R5, #+16]
   \   0000039A   0x6820             LDR      R0,[R4, #+0]
   \   0000039C   0x.... 0x....      BL       PCD_WritePMA
   \   000003A0   0xE018             B.N      ??PCD_EP_ISR_Handler_20
    506                      }
    507                    }
    508                    else
    509                    {
    510                      /*read from endpoint BUF1Addr buffer*/
    511                      ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
   \                     ??PCD_EP_ISR_Handler_19: (+1)
   \   000003A2   0x6820             LDR      R0,[R4, #+0]
   \   000003A4   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   000003A8   0x7829             LDRB     R1,[R5, #+0]
   \   000003AA   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000003AE   0x6821             LDR      R1,[R4, #+0]
   \   000003B0   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   000003B4   0xF200 0x400C      ADDW     R0,R0,#+1036
   \   000003B8   0x6800             LDR      R0,[R0, #+0]
   \   000003BA   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   000003BC   0x0D80             LSRS     R0,R0,#+22
   \   000003BE   0x61A8             STR      R0,[R5, #+24]
    512                      if (ep->xfer_count != 0)
   \   000003C0   0x69A8             LDR      R0,[R5, #+24]
   \   000003C2   0x2800             CMP      R0,#+0
   \   000003C4   0xD006             BEQ.N    ??PCD_EP_ISR_Handler_20
    513                      {
    514                        PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
   \   000003C6   0x69AB             LDR      R3,[R5, #+24]
   \   000003C8   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000003CA   0x892A             LDRH     R2,[R5, #+8]
   \   000003CC   0x6929             LDR      R1,[R5, #+16]
   \   000003CE   0x6820             LDR      R0,[R4, #+0]
   \   000003D0   0x.... 0x....      BL       PCD_WritePMA
    515                      }
    516                    }
    517                    PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
   \                     ??PCD_EP_ISR_Handler_20: (+1)
   \   000003D4   0x6820             LDR      R0,[R4, #+0]
   \   000003D6   0x7829             LDRB     R1,[R5, #+0]
   \   000003D8   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   000003DC   0xF648 0x718F      MOVW     R1,#+36751
   \   000003E0   0x4008             ANDS     R0,R1,R0
   \   000003E2   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000003E6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000003EA   0x6821             LDR      R1,[R4, #+0]
   \   000003EC   0x782A             LDRB     R2,[R5, #+0]
   \   000003EE   0xF821 0x0022      STRH     R0,[R1, R2, LSL #+2]
    518                  }
    519                  /*multi-packet on the NON control IN endpoint*/
    520                  ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
   \                     ??PCD_EP_ISR_Handler_18: (+1)
   \   000003F2   0x6820             LDR      R0,[R4, #+0]
   \   000003F4   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   000003F8   0x7829             LDRB     R1,[R5, #+0]
   \   000003FA   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000003FE   0x6821             LDR      R1,[R4, #+0]
   \   00000400   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000404   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000408   0x6800             LDR      R0,[R0, #+0]
   \   0000040A   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   0000040C   0x0D80             LSRS     R0,R0,#+22
   \   0000040E   0x61A8             STR      R0,[R5, #+24]
    521                  ep->xfer_buff+=ep->xfer_count;
   \   00000410   0x6928             LDR      R0,[R5, #+16]
   \   00000412   0x69A9             LDR      R1,[R5, #+24]
   \   00000414   0x4408             ADD      R0,R0,R1
   \   00000416   0x6128             STR      R0,[R5, #+16]
    522                 
    523                  /* Zero Length Packet? */
    524                  if (ep->xfer_len == 0)
   \   00000418   0x6968             LDR      R0,[R5, #+20]
   \   0000041A   0x2800             CMP      R0,#+0
   \   0000041C   0xD104             BNE.N    ??PCD_EP_ISR_Handler_21
    525                  {
    526                    /* TX COMPLETE */
    527                    HAL_PCD_DataInStageCallback(hpcd, ep->num);
   \   0000041E   0x7829             LDRB     R1,[R5, #+0]
   \   00000420   0x0020             MOVS     R0,R4
   \   00000422   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
   \   00000426   0xE5F1             B.N      ??PCD_EP_ISR_Handler_0
    528                  }
    529                  else
    530                  {
    531                    HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
   \                     ??PCD_EP_ISR_Handler_21: (+1)
   \   00000428   0x696B             LDR      R3,[R5, #+20]
   \   0000042A   0x692A             LDR      R2,[R5, #+16]
   \   0000042C   0x7829             LDRB     R1,[R5, #+0]
   \   0000042E   0x0020             MOVS     R0,R4
   \   00000430   0x.... 0x....      BL       HAL_PCD_EP_Transmit
   \   00000434   0xE5EA             B.N      ??PCD_EP_ISR_Handler_0
    532                  }
    533                } 
    534              }
    535            }
    536            return HAL_OK;
   \                     ??PCD_EP_ISR_Handler_1: (+1)
   \   00000436   0x2000             MOVS     R0,#+0
   \   00000438   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    537          }
    538          
    539          /**
    540            * @brief Copy a buffer from user memory area to packet memory area (PMA)
    541            * @param   USBx    = pointer to USB register.
    542            * @param   pbUsrBuf: pointer to user memory area.
    543            * @param   wPMABufAddr: address into PMA.
    544            * @param   wNBytes: no. of bytes to be copied.
    545            * @retval None
    546            */

   \                                 In section .text, align 2, keep-with-next
    547          static void PCD_WritePMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
    548          {
   \                     PCD_WritePMA: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    549            uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
   \   00000002   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000004   0x1C5C             ADDS     R4,R3,#+1
   \   00000006   0x1064             ASRS     R4,R4,#+1
    550            uint32_t i, temp1, temp2;
    551            uint16_t *pdwVal;
    552            pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0xEB10 0x0E42      ADDS     LR,R0,R2, LSL #+1
   \   0000000E   0xF51E 0x6E80      ADDS     LR,LR,#+1024
   \   00000012   0x46F4             MOV      R12,LR
    553            for (i = n; i != 0; i--)
   \   00000014   0x0025             MOVS     R5,R4
   \                     ??PCD_WritePMA_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD011             BEQ.N    ??PCD_WritePMA_1
    554            {
    555              temp1 = (uint16_t) * pbUsrBuf;
   \   0000001A   0xF891 0xE000      LDRB     LR,[R1, #+0]
   \   0000001E   0x4676             MOV      R6,LR
    556              pbUsrBuf++;
   \   00000020   0x1C49             ADDS     R1,R1,#+1
    557              temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
   \   00000022   0xF891 0xE000      LDRB     LR,[R1, #+0]
   \   00000026   0xEA56 0x2E0E      ORRS     LR,R6,LR, LSL #+8
   \   0000002A   0x4677             MOV      R7,LR
    558              *pdwVal++ = temp2;
   \   0000002C   0xF8AC 0x7000      STRH     R7,[R12, #+0]
   \   00000030   0xF11C 0x0C02      ADDS     R12,R12,#+2
    559              pdwVal++;
   \   00000034   0xF11C 0x0C02      ADDS     R12,R12,#+2
    560              pbUsrBuf++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    561            }
   \   0000003A   0x1E6D             SUBS     R5,R5,#+1
   \   0000003C   0xE7EB             B.N      ??PCD_WritePMA_0
    562          }
   \                     ??PCD_WritePMA_1: (+1)
   \   0000003E   0xBDF0             POP      {R4-R7,PC}       ;; return
    563          
    564          /**
    565            * @brief Copy a buffer from user memory area to packet memory area (PMA)
    566            * @param   USBx    = pointer to USB register.
    567            * @param   pbUsrBuf    = pointer to user memory area.
    568            * @param   wPMABufAddr: address into PMA.
    569            * @param   wNBytes: no. of bytes to be copied.
    570            * @retval None
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          static void PCD_ReadPMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
    573          {
   \                     PCD_ReadPMA: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    574            uint32_t n = (wNBytes + 1) >> 1;/* /2*/
   \   00000002   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000004   0x1C5C             ADDS     R4,R3,#+1
   \   00000006   0x1064             ASRS     R4,R4,#+1
    575            uint32_t i;
    576            uint32_t *pdwVal;
    577            pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0xEB10 0x0742      ADDS     R7,R0,R2, LSL #+1
   \   0000000E   0xF517 0x6780      ADDS     R7,R7,#+1024
   \   00000012   0x003E             MOVS     R6,R7
    578            for (i = n; i != 0; i--)
   \   00000014   0x0025             MOVS     R5,R4
   \                     ??PCD_ReadPMA_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD006             BEQ.N    ??PCD_ReadPMA_1
    579            {
    580              *(uint16_t*)pbUsrBuf++ = *pdwVal++;
   \   0000001A   0x6837             LDR      R7,[R6, #+0]
   \   0000001C   0x800F             STRH     R7,[R1, #+0]
   \   0000001E   0x1D36             ADDS     R6,R6,#+4
   \   00000020   0x1C49             ADDS     R1,R1,#+1
    581              pbUsrBuf++;
   \   00000022   0x1C49             ADDS     R1,R1,#+1
    582            }
   \   00000024   0x1E6D             SUBS     R5,R5,#+1
   \   00000026   0xE7F6             B.N      ??PCD_ReadPMA_0
    583          }
   \                     ??PCD_ReadPMA_1: (+1)
   \   00000028   0xBCF0             POP      {R4-R7}
   \   0000002A   0x4770             BX       LR               ;; return
    584          
    585          /**
    586            * @}
    587            */
    588          
    589          /** @addtogroup PCD_Exported_Functions
    590            * @{
    591            */
    592          
    593          /** @defgroup PCD_Exported_Functions_Group2 IO operation functions 
    594           * @{
    595           */
    596          
    597          /**
    598            * @brief  This function handles PCD interrupt request.
    599            * @param  hpcd: PCD handle
    600            * @retval HAL status
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
    603          {
   \                     HAL_PCD_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    604            uint32_t wInterrupt_Mask = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    605            
    606            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD502             BPL.N    ??HAL_PCD_IRQHandler_0
    607            {
    608              /* servicing of the endpoint correct transfer interrupt */
    609              /* clear of the CTR flag into the sub */
    610              PCD_EP_ISR_Handler(hpcd);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       PCD_EP_ISR_Handler
    611            }
    612          
    613            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
   \                     ??HAL_PCD_IRQHandler_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000001C   0x0540             LSLS     R0,R0,#+21
   \   0000001E   0xD50F             BPL.N    ??HAL_PCD_IRQHandler_1
    614            {
    615              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000026   0xF64F 0x31FF      MOVW     R1,#+64511
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    616              HAL_PCD_ResetCallback(hpcd);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       HAL_PCD_ResetCallback
    617              HAL_PCD_SetAddress(hpcd, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_PCD_SetAddress
    618            }
    619          
    620            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
   \                     ??HAL_PCD_IRQHandler_1: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000046   0x0440             LSLS     R0,R0,#+17
   \   00000048   0xD508             BPL.N    ??HAL_PCD_IRQHandler_2
    621            {
    622              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000050   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    623            }
    624            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
   \                     ??HAL_PCD_IRQHandler_2: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000062   0x0480             LSLS     R0,R0,#+18
   \   00000064   0xD508             BPL.N    ??HAL_PCD_IRQHandler_3
    625            {
    626              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000006C   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    627            }
    628          
    629            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
   \                     ??HAL_PCD_IRQHandler_3: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000007E   0x04C0             LSLS     R0,R0,#+19
   \   00000080   0xD51A             BPL.N    ??HAL_PCD_IRQHandler_4
    630            {  
    631              hpcd->Instance->CNTR &= ~(USB_CNTR_LPMODE);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000088   0xF64F 0x71FB      MOVW     R1,#+65531
   \   0000008C   0x4008             ANDS     R0,R1,R0
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    632              
    633              /*set wInterrupt_Mask global variable*/
    634              wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    635                | USB_CNTR_ESOFM | USB_CNTR_RESETM;
   \   00000094   0xF44F 0x403D      MOV      R0,#+48384
   \   00000098   0x0005             MOVS     R5,R0
    636              
    637              /*Set interrupt mask*/
    638              hpcd->Instance->CNTR = wInterrupt_Mask;
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF8A0 0x5040      STRH     R5,[R0, #+64]
    639              
    640              HAL_PCD_ResumeCallback(hpcd);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       HAL_PCD_ResumeCallback
    641              
    642              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   000000AC   0xF64E 0x71FF      MOVW     R1,#+61439
   \   000000B0   0x4008             ANDS     R0,R1,R0
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    643            }
    644          
    645            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
   \                     ??HAL_PCD_IRQHandler_4: (+1)
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   000000BE   0x0500             LSLS     R0,R0,#+20
   \   000000C0   0xD520             BPL.N    ??HAL_PCD_IRQHandler_5
    646            {    
    647              /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    648              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   000000C8   0xF24F 0x71FF      MOVW     R1,#+63487
   \   000000CC   0x4008             ANDS     R0,R1,R0
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    649              
    650              /* Force low-power mode in the macrocell */
    651              hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   000000DA   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    652              hpcd->Instance->CNTR |= USB_CNTR_LPMODE;
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   000000EA   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0xF8A1 0x0040      STRH     R0,[R1, #+64]
    653              if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   000000FA   0x04C0             LSLS     R0,R0,#+19
   \   000000FC   0xD402             BMI.N    ??HAL_PCD_IRQHandler_5
    654              {
    655                HAL_PCD_SuspendCallback(hpcd);
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    656              }
    657            }
    658          
    659            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
   \                     ??HAL_PCD_IRQHandler_5: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000010A   0x0580             LSLS     R0,R0,#+22
   \   0000010C   0xD50B             BPL.N    ??HAL_PCD_IRQHandler_6
    660            {
    661              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000114   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000118   0x4008             ANDS     R0,R1,R0
   \   0000011A   0x6821             LDR      R1,[R4, #+0]
   \   0000011C   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    662              HAL_PCD_SOFCallback(hpcd);
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       HAL_PCD_SOFCallback
    663            }
    664          
    665            if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
   \                     ??HAL_PCD_IRQHandler_6: (+1)
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   0000012C   0x05C0             LSLS     R0,R0,#+23
   \   0000012E   0xD508             BPL.N    ??HAL_PCD_IRQHandler_7
    666            {
    667              /* clear ESOF flag in ISTR */
    668              __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0xF8B0 0x0044      LDRH     R0,[R0, #+68]
   \   00000136   0xF64F 0x61FF      MOVW     R1,#+65279
   \   0000013A   0x4008             ANDS     R0,R1,R0
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0xF8A1 0x0044      STRH     R0,[R1, #+68]
    669            }
    670          }
   \                     ??HAL_PCD_IRQHandler_7: (+1)
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    671          
    672          /**
    673            * @brief  Data out stage callbacks
    674            * @param  hpcd: PCD handle
    675            * @param  epnum: endpoint number
    676            * @retval None
    677            */

   \                                 In section .text, align 2, keep-with-next
    678           __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    679          {
    680            /* Prevent unused argument(s) compilation warning */
    681            UNUSED(hpcd);
    682            UNUSED(epnum);
    683          
    684            /* NOTE : This function should not be modified, when the callback is needed,
    685                      the HAL_PCD_DataOutStageCallback could be implemented in the user file
    686             */ 
    687          }
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    688          
    689          /**
    690            * @brief  Data IN stage callbacks
    691            * @param  hpcd: PCD handle
    692            * @param  epnum: endpoint number
    693            * @retval None
    694            */

   \                                 In section .text, align 2, keep-with-next
    695           __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    696          {
    697            /* Prevent unused argument(s) compilation warning */
    698            UNUSED(hpcd);
    699            UNUSED(epnum);
    700          
    701            /* NOTE : This function should not be modified, when the callback is needed,
    702                      the HAL_PCD_DataInStageCallback could be implemented in the user file
    703             */ 
    704          }
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    705          /**
    706            * @brief  Setup stage callback
    707            * @param  hpcd: PCD handle
    708            * @retval None
    709            */

   \                                 In section .text, align 2, keep-with-next
    710           __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    711          {
    712            /* Prevent unused argument(s) compilation warning */
    713            UNUSED(hpcd);
    714          
    715            /* NOTE : This function should not be modified, when the callback is needed,
    716                      the HAL_PCD_SetupStageCallback could be implemented in the user file
    717             */ 
    718          }
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    719          
    720          /**
    721            * @brief  USB Start Of Frame callbacks
    722            * @param  hpcd: PCD handle
    723            * @retval None
    724            */

   \                                 In section .text, align 2, keep-with-next
    725           __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    726          {
    727            /* Prevent unused argument(s) compilation warning */
    728            UNUSED(hpcd);
    729          
    730            /* NOTE : This function should not be modified, when the callback is needed,
    731                      the HAL_PCD_SOFCallback could be implemented in the user file
    732             */ 
    733          }
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    734          
    735          /**
    736            * @brief  USB Reset callbacks
    737            * @param  hpcd: PCD handle
    738            * @retval None
    739            */

   \                                 In section .text, align 2, keep-with-next
    740           __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    741          {
    742            /* Prevent unused argument(s) compilation warning */
    743            UNUSED(hpcd);
    744          
    745            /* NOTE : This function should not be modified, when the callback is needed,
    746                      the HAL_PCD_ResetCallback could be implemented in the user file
    747             */ 
    748          }
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    749          
    750          
    751          /**
    752            * @brief  Suspend event callbacks
    753            * @param  hpcd: PCD handle
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756           __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    757          {
    758            /* Prevent unused argument(s) compilation warning */
    759            UNUSED(hpcd);
    760          
    761            /* NOTE : This function should not be modified, when the callback is needed,
    762                      the HAL_PCD_SuspendCallback could be implemented in the user file
    763             */ 
    764          }
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    765          
    766          /**
    767            * @brief  Resume event callbacks
    768            * @param  hpcd: PCD handle
    769            * @retval None
    770            */

   \                                 In section .text, align 2, keep-with-next
    771           __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    772          {
    773            /* Prevent unused argument(s) compilation warning */
    774            UNUSED(hpcd);
    775          
    776            /* NOTE : This function should not be modified, when the callback is needed,
    777                      the HAL_PCD_ResumeCallback could be implemented in the user file
    778             */ 
    779          }
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    780          
    781          /**
    782            * @brief  Incomplete ISO OUT callbacks
    783            * @param  hpcd: PCD handle
    784            * @param  epnum: endpoint number
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787           __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    788          {
    789            /* Prevent unused argument(s) compilation warning */
    790            UNUSED(hpcd);
    791            UNUSED(epnum);
    792          
    793            /* NOTE : This function should not be modified, when the callback is needed,
    794                      the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
    795             */ 
    796          }
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    797          
    798          /**
    799            * @brief  Incomplete ISO IN  callbacks
    800            * @param  hpcd: PCD handle
    801            * @param  epnum: endpoint number
    802            * @retval None
    803            */

   \                                 In section .text, align 2, keep-with-next
    804           __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    805          {
    806            /* Prevent unused argument(s) compilation warning */
    807            UNUSED(hpcd);
    808            UNUSED(epnum);
    809          
    810            /* NOTE : This function should not be modified, when the callback is needed,
    811                      the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
    812             */ 
    813          }
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    814          
    815          /**
    816            * @brief  Connection event callbacks
    817            * @param  hpcd: PCD handle
    818            * @retval None
    819            */

   \                                 In section .text, align 2, keep-with-next
    820           __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    821          {
    822            /* Prevent unused argument(s) compilation warning */
    823            UNUSED(hpcd);
    824          
    825            /* NOTE : This function should not be modified, when the callback is needed,
    826                      the HAL_PCD_ConnectCallback could be implemented in the user file
    827             */ 
    828          }
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    829          
    830          /**
    831            * @brief  Disconnection event callbacks
    832            * @param  hpcd: PCD handle
    833            * @retval None
    834            */

   \                                 In section .text, align 2, keep-with-next
    835           __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    836          {
    837            /* Prevent unused argument(s) compilation warning */
    838            UNUSED(hpcd);
    839          
    840            /* NOTE : This function should not be modified, when the callback is needed,
    841                      the HAL_PCD_DisconnectCallback could be implemented in the user file
    842             */ 
    843          }
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    844          /**
    845            * @}
    846            */
    847            
    848          /** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions 
    849           *  @brief   management functions 
    850           *
    851          @verbatim   
    852           ===============================================================================
    853                                ##### Peripheral Control functions #####
    854           ===============================================================================  
    855              [..]
    856              This subsection provides a set of functions allowing to control the PCD data 
    857              transfers.
    858          
    859          @endverbatim
    860            * @{
    861            */
    862          
    863          /**
    864            * @brief  Connect the USB device 
    865            * @param  hpcd: PCD handle
    866            * @retval HAL status
    867            */

   \                                 In section .text, align 2, keep-with-next
    868          HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
    869          {
   \                     HAL_PCD_DevConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    870            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x01E8      LDRB     R0,[R4, #+488]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevConnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00A             B.N      ??HAL_PCD_DevConnect_1
   \                     ??HAL_PCD_DevConnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x01E8      STRB     R0,[R4, #+488]
    871            
    872            /* Enabling DP Pull-Down bit to Connect internal pull-up on USB DP line */
    873             HAL_PCDEx_SetConnectionState (hpcd, 1);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_PCDEx_SetConnectionState
    874            
    875            __HAL_UNLOCK(hpcd); 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x01E8      STRB     R0,[R4, #+488]
    876            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevConnect_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    877          }
    878          
    879          /**
    880            * @brief  Disconnect the USB device 
    881            * @param  hpcd: PCD handle
    882            * @retval HAL status
    883            */

   \                                 In section .text, align 2, keep-with-next
    884          HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
    885          {
   \                     HAL_PCD_DevDisconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    886            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x01E8      LDRB     R0,[R4, #+488]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevDisconnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00A             B.N      ??HAL_PCD_DevDisconnect_1
   \                     ??HAL_PCD_DevDisconnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x01E8      STRB     R0,[R4, #+488]
    887            
    888            /* Disable DP Pull-Down bit*/
    889            HAL_PCDEx_SetConnectionState (hpcd, 0);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_PCDEx_SetConnectionState
    890            
    891            __HAL_UNLOCK(hpcd); 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x01E8      STRB     R0,[R4, #+488]
    892            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevDisconnect_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    893          }
    894          
    895          /**
    896            * @brief  Set the USB Device address 
    897            * @param  hpcd: PCD handle
    898            * @param  address: new device address
    899            * @retval HAL status
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
    902          {
   \                     HAL_PCD_SetAddress: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    903             __HAL_LOCK(hpcd); 
   \   00000002   0xF892 0x01E8      LDRB     R0,[R2, #+488]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_PCD_SetAddress_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE010             B.N      ??HAL_PCD_SetAddress_1
   \                     ??HAL_PCD_SetAddress_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF882 0x01E8      STRB     R0,[R2, #+488]
    904          
    905             if(address == 0) 
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD104             BNE.N    ??HAL_PCD_SetAddress_2
    906             {
    907               /* set device address and enable function */
    908               hpcd->Instance->DADDR = USB_DADDR_EF;
   \   0000001A   0x2080             MOVS     R0,#+128
   \   0000001C   0x6813             LDR      R3,[R2, #+0]
   \   0000001E   0xF8A3 0x004C      STRH     R0,[R3, #+76]
   \   00000022   0xE001             B.N      ??HAL_PCD_SetAddress_3
    909             }
    910             else /* USB Address will be applied later */
    911             {
    912               hpcd->USB_Address = address;
   \                     ??HAL_PCD_SetAddress_2: (+1)
   \   00000024   0xF882 0x1024      STRB     R1,[R2, #+36]
    913             }
    914          
    915            __HAL_UNLOCK(hpcd);   
   \                     ??HAL_PCD_SetAddress_3: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF882 0x01E8      STRB     R0,[R2, #+488]
    916            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_SetAddress_1: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    917          }
    918          /**
    919            * @brief  Open and configure an endpoint
    920            * @param  hpcd: PCD handle
    921            * @param  ep_addr: endpoint address
    922            * @param  ep_mps: endpoint max packet size
    923            * @param  ep_type: endpoint type   
    924            * @retval HAL status
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
    927          {
   \                     HAL_PCD_EP_Open: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
    928            HAL_StatusTypeDef  ret = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    929            PCD_EPTypeDef *ep;
    930            
    931            if ((ep_addr & 0x80) == 0x80)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x0608             LSLS     R0,R1,#+24
   \   0000000A   0xD508             BPL.N    ??HAL_PCD_EP_Open_0
    932            {
    933              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000012   0x271C             MOVS     R7,#+28
   \   00000014   0x4378             MULS     R0,R7,R0
   \   00000016   0x4420             ADD      R0,R4,R0
   \   00000018   0x3028             ADDS     R0,R0,#+40
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xE009             B.N      ??HAL_PCD_EP_Open_1
    934            }
    935            else
    936            {
    937              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Open_0: (+1)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000024   0x271C             MOVS     R7,#+28
   \   00000026   0x4378             MULS     R0,R7,R0
   \   00000028   0x4420             ADD      R0,R4,R0
   \   0000002A   0xF44F 0x7784      MOV      R7,#+264
   \   0000002E   0x4438             ADD      R0,R0,R7
   \   00000030   0x0006             MOVS     R6,R0
    938            }
    939            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Open_1: (+1)
   \   00000032   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    940            
    941            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000038   0x0008             MOVS     R0,R1
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x09C0             LSRS     R0,R0,#+7
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
    942            ep->maxpacket = ep_mps;
   \   00000040   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000042   0x60F2             STR      R2,[R6, #+12]
    943            ep->type = ep_type;
   \   00000044   0x70F3             STRB     R3,[R6, #+3]
    944            
    945            __HAL_LOCK(hpcd); 
   \   00000046   0xF894 0x01E8      LDRB     R0,[R4, #+488]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??HAL_PCD_EP_Open_2
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xE20F             B.N      ??HAL_PCD_EP_Open_3
   \                     ??HAL_PCD_EP_Open_2: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF884 0x01E8      STRB     R0,[R4, #+488]
    946          
    947          /* initialize Endpoint */
    948            switch (ep->type)
   \   00000058   0x78F0             LDRB     R0,[R6, #+3]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD005             BEQ.N    ??HAL_PCD_EP_Open_4
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD012             BEQ.N    ??HAL_PCD_EP_Open_5
   \   00000062   0xD32D             BCC.N    ??HAL_PCD_EP_Open_6
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD01C             BEQ.N    ??HAL_PCD_EP_Open_7
   \   00000068   0xE039             B.N      ??HAL_PCD_EP_Open_8
    949            {
    950            case PCD_EP_TYPE_CTRL:
    951              PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_CONTROL);
   \                     ??HAL_PCD_EP_Open_4: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x7837             LDRB     R7,[R6, #+0]
   \   0000006E   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000072   0xF648 0x178F      MOVW     R7,#+35215
   \   00000076   0x4038             ANDS     R0,R7,R0
   \   00000078   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000007C   0x6827             LDR      R7,[R4, #+0]
   \   0000007E   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000082   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    952              break;
   \   00000086   0xE02A             B.N      ??HAL_PCD_EP_Open_9
    953            case PCD_EP_TYPE_BULK:
    954              PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_BULK);
   \                     ??HAL_PCD_EP_Open_5: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x7837             LDRB     R7,[R6, #+0]
   \   0000008C   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000090   0xF648 0x178F      MOVW     R7,#+35215
   \   00000094   0x4038             ANDS     R0,R7,R0
   \   00000096   0x6827             LDR      R7,[R4, #+0]
   \   00000098   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000009C   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    955              break;
   \   000000A0   0xE01D             B.N      ??HAL_PCD_EP_Open_9
    956            case PCD_EP_TYPE_INTR:
    957              PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
   \                     ??HAL_PCD_EP_Open_7: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x7837             LDRB     R7,[R6, #+0]
   \   000000A6   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000000AA   0xF648 0x178F      MOVW     R7,#+35215
   \   000000AE   0x4038             ANDS     R0,R7,R0
   \   000000B0   0xF450 0x60C0      ORRS     R0,R0,#0x600
   \   000000B4   0x6827             LDR      R7,[R4, #+0]
   \   000000B6   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000000BA   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    958              break;
   \   000000BE   0xE00E             B.N      ??HAL_PCD_EP_Open_9
    959            case PCD_EP_TYPE_ISOC:
    960              PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
   \                     ??HAL_PCD_EP_Open_6: (+1)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x7837             LDRB     R7,[R6, #+0]
   \   000000C4   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000000C8   0xF648 0x178F      MOVW     R7,#+35215
   \   000000CC   0x4038             ANDS     R0,R7,R0
   \   000000CE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000D2   0x6827             LDR      R7,[R4, #+0]
   \   000000D4   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000000D8   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    961              break;
   \   000000DC   0xE7FF             B.N      ??HAL_PCD_EP_Open_9
    962            default:
    963                break;
    964            } 
    965            
    966            PCD_SET_EP_ADDRESS(hpcd->Instance, ep->num, ep->num);
   \                     ??HAL_PCD_EP_Open_8: (+1)
   \                     ??HAL_PCD_EP_Open_9: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x7837             LDRB     R7,[R6, #+0]
   \   000000E2   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000000E6   0xF648 0x778F      MOVW     R7,#+36751
   \   000000EA   0x4038             ANDS     R0,R7,R0
   \   000000EC   0x7837             LDRB     R7,[R6, #+0]
   \   000000EE   0x4338             ORRS     R0,R7,R0
   \   000000F0   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000F4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F8   0x6827             LDR      R7,[R4, #+0]
   \   000000FA   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000000FE   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    967            
    968            if (ep->doublebuffer == 0) 
   \   00000102   0x7AB0             LDRB     R0,[R6, #+10]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xF040 0x80B1      BNE.W    ??HAL_PCD_EP_Open_10
    969            {
    970              if (ep->is_in)
   \   0000010A   0x7870             LDRB     R0,[R6, #+1]
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD03C             BEQ.N    ??HAL_PCD_EP_Open_11
    971              {
    972                /*Set the endpoint Transmit buffer address */
    973                PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000116   0x7837             LDRB     R7,[R6, #+0]
   \   00000118   0xEB10 0x00C7      ADDS     R0,R0,R7, LSL #+3
   \   0000011C   0x6827             LDR      R7,[R4, #+0]
   \   0000011E   0xEB17 0x0040      ADDS     R0,R7,R0, LSL #+1
   \   00000122   0xF510 0x6080      ADDS     R0,R0,#+1024
   \   00000126   0x88B7             LDRH     R7,[R6, #+4]
   \   00000128   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000012A   0x087F             LSRS     R7,R7,#+1
   \   0000012C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000012E   0x007F             LSLS     R7,R7,#+1
   \   00000130   0x6007             STR      R7,[R0, #+0]
    974                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x7837             LDRB     R7,[R6, #+0]
   \   00000136   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   0000013A   0x0640             LSLS     R0,R0,#+25
   \   0000013C   0xD50F             BPL.N    ??HAL_PCD_EP_Open_12
   \   0000013E   0x6820             LDR      R0,[R4, #+0]
   \   00000140   0x7837             LDRB     R7,[R6, #+0]
   \   00000142   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000146   0xF648 0x778F      MOVW     R7,#+36751
   \   0000014A   0x4038             ANDS     R0,R7,R0
   \   0000014C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000150   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   00000154   0x6827             LDR      R7,[R4, #+0]
   \   00000156   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000015A   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    975                /* Configure NAK status for the Endpoint*/
    976                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_NAK); 
   \                     ??HAL_PCD_EP_Open_12: (+1)
   \   0000015E   0x6827             LDR      R7,[R4, #+0]
   \   00000160   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000164   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   00000168   0xF648 0x7CBF      MOVW     R12,#+36799
   \   0000016C   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000170   0x0038             MOVS     R0,R7
   \   00000172   0xF090 0x0020      EORS     R0,R0,#0x20
   \   00000176   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000017A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000017E   0x6827             LDR      R7,[R4, #+0]
   \   00000180   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000184   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   \   00000188   0xE16E             B.N      ??HAL_PCD_EP_Open_13
    977              }
    978              else
    979              {
    980                /*Set the endpoint Receive buffer address */
    981                PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
   \                     ??HAL_PCD_EP_Open_11: (+1)
   \   0000018A   0x6820             LDR      R0,[R4, #+0]
   \   0000018C   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000190   0x7837             LDRB     R7,[R6, #+0]
   \   00000192   0xEB10 0x00C7      ADDS     R0,R0,R7, LSL #+3
   \   00000196   0x6827             LDR      R7,[R4, #+0]
   \   00000198   0xEB17 0x0040      ADDS     R0,R7,R0, LSL #+1
   \   0000019C   0xF510 0x6081      ADDS     R0,R0,#+1032
   \   000001A0   0x88B7             LDRH     R7,[R6, #+4]
   \   000001A2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001A4   0x087F             LSRS     R7,R7,#+1
   \   000001A6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001A8   0x007F             LSLS     R7,R7,#+1
   \   000001AA   0x6007             STR      R7,[R0, #+0]
    982                /*Set the endpoint Receive buffer counter*/
    983                PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket);
   \   000001AC   0x6827             LDR      R7,[R4, #+0]
   \   000001AE   0xF8B7 0x7050      LDRH     R7,[R7, #+80]
   \   000001B2   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000001B6   0xEB17 0x07CC      ADDS     R7,R7,R12, LSL #+3
   \   000001BA   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \   000001BE   0xEB1C 0x0747      ADDS     R7,R12,R7, LSL #+1
   \   000001C2   0xF207 0x470C      ADDW     R7,R7,#+1036
   \   000001C6   0x0038             MOVS     R0,R7
   \   000001C8   0xF8D6 0xC00C      LDR      R12,[R6, #+12]
   \   000001CC   0xF1BC 0x0F3F      CMP      R12,#+63
   \   000001D0   0xD310             BCC.N    ??HAL_PCD_EP_Open_14
   \   000001D2   0xF8D6 0xC00C      LDR      R12,[R6, #+12]
   \   000001D6   0xEA5F 0x1C5C      LSRS     R12,R12,#+5
   \   000001DA   0x4667             MOV      R7,R12
   \   000001DC   0xF896 0xC00C      LDRB     R12,[R6, #+12]
   \   000001E0   0xF01C 0x0F1F      TST      R12,#0x1F
   \   000001E4   0xD100             BNE.N    ??HAL_PCD_EP_Open_15
   \   000001E6   0x1E7F             SUBS     R7,R7,#+1
   \                     ??HAL_PCD_EP_Open_15: (+1)
   \   000001E8   0x02BF             LSLS     R7,R7,#+10
   \   000001EA   0xF457 0x4700      ORRS     R7,R7,#0x8000
   \   000001EE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F0   0x6007             STR      R7,[R0, #+0]
   \   000001F2   0xE00D             B.N      ??HAL_PCD_EP_Open_16
   \                     ??HAL_PCD_EP_Open_14: (+1)
   \   000001F4   0xF8D6 0xC00C      LDR      R12,[R6, #+12]
   \   000001F8   0xEA5F 0x0C5C      LSRS     R12,R12,#+1
   \   000001FC   0x4667             MOV      R7,R12
   \   000001FE   0xF896 0xC00C      LDRB     R12,[R6, #+12]
   \   00000202   0xEA5F 0x7CCC      LSLS     R12,R12,#+31
   \   00000206   0xD500             BPL.N    ??HAL_PCD_EP_Open_17
   \   00000208   0x1C7F             ADDS     R7,R7,#+1
   \                     ??HAL_PCD_EP_Open_17: (+1)
   \   0000020A   0x02BF             LSLS     R7,R7,#+10
   \   0000020C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000020E   0x6007             STR      R7,[R0, #+0]
    984                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_16: (+1)
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0x7837             LDRB     R7,[R6, #+0]
   \   00000214   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000218   0x0440             LSLS     R0,R0,#+17
   \   0000021A   0xD50F             BPL.N    ??HAL_PCD_EP_Open_18
   \   0000021C   0x6820             LDR      R0,[R4, #+0]
   \   0000021E   0x7837             LDRB     R7,[R6, #+0]
   \   00000220   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000224   0xF648 0x778F      MOVW     R7,#+36751
   \   00000228   0x4038             ANDS     R0,R7,R0
   \   0000022A   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   0000022E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000232   0x6827             LDR      R7,[R4, #+0]
   \   00000234   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000238   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    985                /* Configure VALID status for the Endpoint*/
    986                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
   \                     ??HAL_PCD_EP_Open_18: (+1)
   \   0000023C   0x6827             LDR      R7,[R4, #+0]
   \   0000023E   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000242   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   00000246   0xF64B 0x7C8F      MOVW     R12,#+49039
   \   0000024A   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   0000024E   0x0038             MOVS     R0,R7
   \   00000250   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   00000254   0xF490 0x5000      EORS     R0,R0,#0x2000
   \   00000258   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000025C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000260   0x6827             LDR      R7,[R4, #+0]
   \   00000262   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000266   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   \   0000026A   0xE0FD             B.N      ??HAL_PCD_EP_Open_13
    987              }
    988            }
    989            /*Double Buffer*/
    990            else
    991            {
    992              /*Set the endpoint as double buffered*/
    993              PCD_SET_EP_DBUF(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_10: (+1)
   \   0000026C   0x6820             LDR      R0,[R4, #+0]
   \   0000026E   0x7837             LDRB     R7,[R6, #+0]
   \   00000270   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000274   0xF648 0x778F      MOVW     R7,#+36751
   \   00000278   0x4038             ANDS     R0,R7,R0
   \   0000027A   0xF440 0x4001      ORR      R0,R0,#0x8100
   \   0000027E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000282   0x6827             LDR      R7,[R4, #+0]
   \   00000284   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000288   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
    994              /*Set buffer address for double buffered mode*/
    995              PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1);
   \   0000028C   0x6820             LDR      R0,[R4, #+0]
   \   0000028E   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000292   0x7837             LDRB     R7,[R6, #+0]
   \   00000294   0xEB10 0x00C7      ADDS     R0,R0,R7, LSL #+3
   \   00000298   0x6827             LDR      R7,[R4, #+0]
   \   0000029A   0xEB17 0x0040      ADDS     R0,R7,R0, LSL #+1
   \   0000029E   0xF510 0x6080      ADDS     R0,R0,#+1024
   \   000002A2   0x88F7             LDRH     R7,[R6, #+6]
   \   000002A4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000002A6   0x087F             LSRS     R7,R7,#+1
   \   000002A8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000002AA   0x007F             LSLS     R7,R7,#+1
   \   000002AC   0x6007             STR      R7,[R0, #+0]
   \   000002AE   0x6820             LDR      R0,[R4, #+0]
   \   000002B0   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   000002B4   0x7837             LDRB     R7,[R6, #+0]
   \   000002B6   0xEB10 0x00C7      ADDS     R0,R0,R7, LSL #+3
   \   000002BA   0x6827             LDR      R7,[R4, #+0]
   \   000002BC   0xEB17 0x0040      ADDS     R0,R7,R0, LSL #+1
   \   000002C0   0xF510 0x6081      ADDS     R0,R0,#+1032
   \   000002C4   0x8937             LDRH     R7,[R6, #+8]
   \   000002C6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000002C8   0x087F             LSRS     R7,R7,#+1
   \   000002CA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000002CC   0x007F             LSLS     R7,R7,#+1
   \   000002CE   0x6007             STR      R7,[R0, #+0]
    996              
    997              if (ep->is_in==0)
   \   000002D0   0x7870             LDRB     R0,[R6, #+1]
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD166             BNE.N    ??HAL_PCD_EP_Open_19
    998              {
    999                /* Clear the data toggle bits for the endpoint IN/OUT*/
   1000                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \   000002D6   0x6820             LDR      R0,[R4, #+0]
   \   000002D8   0x7837             LDRB     R7,[R6, #+0]
   \   000002DA   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000002DE   0x0440             LSLS     R0,R0,#+17
   \   000002E0   0xD50F             BPL.N    ??HAL_PCD_EP_Open_20
   \   000002E2   0x6820             LDR      R0,[R4, #+0]
   \   000002E4   0x7837             LDRB     R7,[R6, #+0]
   \   000002E6   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000002EA   0xF648 0x778F      MOVW     R7,#+36751
   \   000002EE   0x4038             ANDS     R0,R7,R0
   \   000002F0   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000002F4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002F8   0x6827             LDR      R7,[R4, #+0]
   \   000002FA   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000002FE   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1001                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_20: (+1)
   \   00000302   0x6820             LDR      R0,[R4, #+0]
   \   00000304   0x7837             LDRB     R7,[R6, #+0]
   \   00000306   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   0000030A   0x0640             LSLS     R0,R0,#+25
   \   0000030C   0xD50F             BPL.N    ??HAL_PCD_EP_Open_21
   \   0000030E   0x6820             LDR      R0,[R4, #+0]
   \   00000310   0x7837             LDRB     R7,[R6, #+0]
   \   00000312   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000316   0xF648 0x778F      MOVW     R7,#+36751
   \   0000031A   0x4038             ANDS     R0,R7,R0
   \   0000031C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000320   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   00000324   0x6827             LDR      R7,[R4, #+0]
   \   00000326   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000032A   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1002                
   1003                /* Reset value of the data toggle bits for the endpoint out*/
   1004                PCD_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_21: (+1)
   \   0000032E   0x6820             LDR      R0,[R4, #+0]
   \   00000330   0x7837             LDRB     R7,[R6, #+0]
   \   00000332   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000336   0xF648 0x778F      MOVW     R7,#+36751
   \   0000033A   0x4038             ANDS     R0,R7,R0
   \   0000033C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000340   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   00000344   0x6827             LDR      R7,[R4, #+0]
   \   00000346   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000034A   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1005                
   1006                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
   \   0000034E   0x6827             LDR      R7,[R4, #+0]
   \   00000350   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000354   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   00000358   0xF64B 0x7C8F      MOVW     R12,#+49039
   \   0000035C   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000360   0x0038             MOVS     R0,R7
   \   00000362   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   00000366   0xF490 0x5000      EORS     R0,R0,#0x2000
   \   0000036A   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000036E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000372   0x6827             LDR      R7,[R4, #+0]
   \   00000374   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000378   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1007                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
   \   0000037C   0x6827             LDR      R7,[R4, #+0]
   \   0000037E   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000382   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   00000386   0xF648 0x7CBF      MOVW     R12,#+36799
   \   0000038A   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   0000038E   0x0038             MOVS     R0,R7
   \   00000390   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000394   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000398   0x6827             LDR      R7,[R4, #+0]
   \   0000039A   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000039E   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   \   000003A2   0xE061             B.N      ??HAL_PCD_EP_Open_13
   1008              }
   1009              else
   1010              {
   1011                /* Clear the data toggle bits for the endpoint IN/OUT*/
   1012                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_19: (+1)
   \   000003A4   0x6820             LDR      R0,[R4, #+0]
   \   000003A6   0x7837             LDRB     R7,[R6, #+0]
   \   000003A8   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000003AC   0x0440             LSLS     R0,R0,#+17
   \   000003AE   0xD50F             BPL.N    ??HAL_PCD_EP_Open_22
   \   000003B0   0x6820             LDR      R0,[R4, #+0]
   \   000003B2   0x7837             LDRB     R7,[R6, #+0]
   \   000003B4   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000003B8   0xF648 0x778F      MOVW     R7,#+36751
   \   000003BC   0x4038             ANDS     R0,R7,R0
   \   000003BE   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000003C2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000003C6   0x6827             LDR      R7,[R4, #+0]
   \   000003C8   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000003CC   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1013                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_22: (+1)
   \   000003D0   0x6820             LDR      R0,[R4, #+0]
   \   000003D2   0x7837             LDRB     R7,[R6, #+0]
   \   000003D4   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000003D8   0x0640             LSLS     R0,R0,#+25
   \   000003DA   0xD50F             BPL.N    ??HAL_PCD_EP_Open_23
   \   000003DC   0x6820             LDR      R0,[R4, #+0]
   \   000003DE   0x7837             LDRB     R7,[R6, #+0]
   \   000003E0   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   000003E4   0xF648 0x778F      MOVW     R7,#+36751
   \   000003E8   0x4038             ANDS     R0,R7,R0
   \   000003EA   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000003EE   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   000003F2   0x6827             LDR      R7,[R4, #+0]
   \   000003F4   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000003F8   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1014                PCD_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Open_23: (+1)
   \   000003FC   0x6820             LDR      R0,[R4, #+0]
   \   000003FE   0x7837             LDRB     R7,[R6, #+0]
   \   00000400   0xF830 0x0027      LDRH     R0,[R0, R7, LSL #+2]
   \   00000404   0xF648 0x778F      MOVW     R7,#+36751
   \   00000408   0x4038             ANDS     R0,R7,R0
   \   0000040A   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   0000040E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000412   0x6827             LDR      R7,[R4, #+0]
   \   00000414   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000418   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1015                /* Configure DISABLE status for the Endpoint*/
   1016                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
   \   0000041C   0x6827             LDR      R7,[R4, #+0]
   \   0000041E   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000422   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   00000426   0xF648 0x7CBF      MOVW     R12,#+36799
   \   0000042A   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   0000042E   0x0038             MOVS     R0,R7
   \   00000430   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000434   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000438   0x6827             LDR      R7,[R4, #+0]
   \   0000043A   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000043E   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1017                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
   \   00000442   0x6827             LDR      R7,[R4, #+0]
   \   00000444   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000448   0xF837 0x702C      LDRH     R7,[R7, R12, LSL #+2]
   \   0000044C   0xF64B 0x7C8F      MOVW     R12,#+49039
   \   00000450   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000454   0x0038             MOVS     R0,R7
   \   00000456   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000045A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000045E   0x6827             LDR      R7,[R4, #+0]
   \   00000460   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   00000464   0xF827 0x002C      STRH     R0,[R7, R12, LSL #+2]
   1018              }
   1019            } 
   1020            
   1021            __HAL_UNLOCK(hpcd);   
   \                     ??HAL_PCD_EP_Open_13: (+1)
   \   00000468   0x2000             MOVS     R0,#+0
   \   0000046A   0xF884 0x01E8      STRB     R0,[R4, #+488]
   1022            return ret;
   \   0000046E   0x0028             MOVS     R0,R5
   \   00000470   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_PCD_EP_Open_3: (+1)
   \   00000472   0xBCF0             POP      {R4-R7}
   \   00000474   0x4770             BX       LR               ;; return
   1023          }
   1024          
   1025          
   1026          /**
   1027            * @brief  Deactivate an endpoint
   1028            * @param  hpcd: PCD handle
   1029            * @param  ep_addr: endpoint address
   1030            * @retval HAL status
   1031            */

   \                                 In section .text, align 2, keep-with-next
   1032          HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1033          {  
   \                     HAL_PCD_EP_Close: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1034            PCD_EPTypeDef *ep;
   1035            
   1036            if ((ep_addr & 0x80) == 0x80)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x0608             LSLS     R0,R1,#+24
   \   00000008   0xD508             BPL.N    ??HAL_PCD_EP_Close_0
   1037            {
   1038              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000010   0x241C             MOVS     R4,#+28
   \   00000012   0x4360             MULS     R0,R4,R0
   \   00000014   0x4410             ADD      R0,R2,R0
   \   00000016   0x3028             ADDS     R0,R0,#+40
   \   00000018   0x0003             MOVS     R3,R0
   \   0000001A   0xE009             B.N      ??HAL_PCD_EP_Close_1
   1039            }
   1040            else
   1041            {
   1042              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Close_0: (+1)
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000022   0x241C             MOVS     R4,#+28
   \   00000024   0x4360             MULS     R0,R4,R0
   \   00000026   0x4410             ADD      R0,R2,R0
   \   00000028   0xF44F 0x7484      MOV      R4,#+264
   \   0000002C   0x4420             ADD      R0,R0,R4
   \   0000002E   0x0003             MOVS     R3,R0
   1043            }
   1044            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Close_1: (+1)
   \   00000030   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000034   0x7018             STRB     R0,[R3, #+0]
   1045            
   1046            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0x7058             STRB     R0,[R3, #+1]
   1047            
   1048            __HAL_LOCK(hpcd); 
   \   0000003E   0xF892 0x01E8      LDRB     R0,[R2, #+488]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??HAL_PCD_EP_Close_2
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE10E             B.N      ??HAL_PCD_EP_Close_3
   \                     ??HAL_PCD_EP_Close_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1049          
   1050            if (ep->doublebuffer == 0) 
   \   00000050   0x7A98             LDRB     R0,[R3, #+10]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD14E             BNE.N    ??HAL_PCD_EP_Close_4
   1051            {
   1052              if (ep->is_in)
   \   00000056   0x7858             LDRB     R0,[R3, #+1]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD025             BEQ.N    ??HAL_PCD_EP_Close_5
   1053              {
   1054                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \   0000005C   0x6810             LDR      R0,[R2, #+0]
   \   0000005E   0x781C             LDRB     R4,[R3, #+0]
   \   00000060   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000064   0x0640             LSLS     R0,R0,#+25
   \   00000066   0xD50E             BPL.N    ??HAL_PCD_EP_Close_6
   \   00000068   0x6810             LDR      R0,[R2, #+0]
   \   0000006A   0x781C             LDRB     R4,[R3, #+0]
   \   0000006C   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000070   0xF648 0x748F      MOVW     R4,#+36751
   \   00000074   0x4020             ANDS     R0,R4,R0
   \   00000076   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000007A   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   0000007E   0x6814             LDR      R4,[R2, #+0]
   \   00000080   0x781D             LDRB     R5,[R3, #+0]
   \   00000082   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1055                /* Configure DISABLE status for the Endpoint*/
   1056                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS); 
   \                     ??HAL_PCD_EP_Close_6: (+1)
   \   00000086   0x6814             LDR      R4,[R2, #+0]
   \   00000088   0x781D             LDRB     R5,[R3, #+0]
   \   0000008A   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   0000008E   0xF648 0x75BF      MOVW     R5,#+36799
   \   00000092   0x402C             ANDS     R4,R5,R4
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000009A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000009E   0x6814             LDR      R4,[R2, #+0]
   \   000000A0   0x781D             LDRB     R5,[R3, #+0]
   \   000000A2   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   000000A6   0xE0DB             B.N      ??HAL_PCD_EP_Close_7
   1057              }
   1058              else
   1059              {
   1060                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_5: (+1)
   \   000000A8   0x6810             LDR      R0,[R2, #+0]
   \   000000AA   0x781C             LDRB     R4,[R3, #+0]
   \   000000AC   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000000B0   0x0440             LSLS     R0,R0,#+17
   \   000000B2   0xD50E             BPL.N    ??HAL_PCD_EP_Close_8
   \   000000B4   0x6810             LDR      R0,[R2, #+0]
   \   000000B6   0x781C             LDRB     R4,[R3, #+0]
   \   000000B8   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000000BC   0xF648 0x748F      MOVW     R4,#+36751
   \   000000C0   0x4020             ANDS     R0,R4,R0
   \   000000C2   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000000C6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000CA   0x6814             LDR      R4,[R2, #+0]
   \   000000CC   0x781D             LDRB     R5,[R3, #+0]
   \   000000CE   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1061                /* Configure DISABLE status for the Endpoint*/
   1062                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
   \                     ??HAL_PCD_EP_Close_8: (+1)
   \   000000D2   0x6814             LDR      R4,[R2, #+0]
   \   000000D4   0x781D             LDRB     R5,[R3, #+0]
   \   000000D6   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   000000DA   0xF64B 0x758F      MOVW     R5,#+49039
   \   000000DE   0x402C             ANDS     R4,R5,R4
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000E6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000EA   0x6814             LDR      R4,[R2, #+0]
   \   000000EC   0x781D             LDRB     R5,[R3, #+0]
   \   000000EE   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   000000F2   0xE0B5             B.N      ??HAL_PCD_EP_Close_7
   1063              }
   1064            }
   1065            /*Double Buffer*/
   1066            else
   1067            { 
   1068              if (ep->is_in==0)
   \                     ??HAL_PCD_EP_Close_4: (+1)
   \   000000F4   0x7858             LDRB     R0,[R3, #+1]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD159             BNE.N    ??HAL_PCD_EP_Close_9
   1069              {
   1070                /* Clear the data toggle bits for the endpoint IN/OUT*/
   1071                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \   000000FA   0x6810             LDR      R0,[R2, #+0]
   \   000000FC   0x781C             LDRB     R4,[R3, #+0]
   \   000000FE   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000102   0x0440             LSLS     R0,R0,#+17
   \   00000104   0xD50E             BPL.N    ??HAL_PCD_EP_Close_10
   \   00000106   0x6810             LDR      R0,[R2, #+0]
   \   00000108   0x781C             LDRB     R4,[R3, #+0]
   \   0000010A   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   0000010E   0xF648 0x748F      MOVW     R4,#+36751
   \   00000112   0x4020             ANDS     R0,R4,R0
   \   00000114   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   00000118   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000011C   0x6814             LDR      R4,[R2, #+0]
   \   0000011E   0x781D             LDRB     R5,[R3, #+0]
   \   00000120   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1072                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_10: (+1)
   \   00000124   0x6810             LDR      R0,[R2, #+0]
   \   00000126   0x781C             LDRB     R4,[R3, #+0]
   \   00000128   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   0000012C   0x0640             LSLS     R0,R0,#+25
   \   0000012E   0xD50E             BPL.N    ??HAL_PCD_EP_Close_11
   \   00000130   0x6810             LDR      R0,[R2, #+0]
   \   00000132   0x781C             LDRB     R4,[R3, #+0]
   \   00000134   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000138   0xF648 0x748F      MOVW     R4,#+36751
   \   0000013C   0x4020             ANDS     R0,R4,R0
   \   0000013E   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000142   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   00000146   0x6814             LDR      R4,[R2, #+0]
   \   00000148   0x781D             LDRB     R5,[R3, #+0]
   \   0000014A   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1073                
   1074                /* Reset value of the data toggle bits for the endpoint out*/
   1075                PCD_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_11: (+1)
   \   0000014E   0x6810             LDR      R0,[R2, #+0]
   \   00000150   0x781C             LDRB     R4,[R3, #+0]
   \   00000152   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000156   0xF648 0x748F      MOVW     R4,#+36751
   \   0000015A   0x4020             ANDS     R0,R4,R0
   \   0000015C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000160   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   00000164   0x6814             LDR      R4,[R2, #+0]
   \   00000166   0x781D             LDRB     R5,[R3, #+0]
   \   00000168   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1076                
   1077                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
   \   0000016C   0x6814             LDR      R4,[R2, #+0]
   \   0000016E   0x781D             LDRB     R5,[R3, #+0]
   \   00000170   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000174   0xF64B 0x758F      MOVW     R5,#+49039
   \   00000178   0x402C             ANDS     R4,R5,R4
   \   0000017A   0x0020             MOVS     R0,R4
   \   0000017C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000180   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000184   0x6814             LDR      R4,[R2, #+0]
   \   00000186   0x781D             LDRB     R5,[R3, #+0]
   \   00000188   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1078                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
   \   0000018C   0x6814             LDR      R4,[R2, #+0]
   \   0000018E   0x781D             LDRB     R5,[R3, #+0]
   \   00000190   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000194   0xF648 0x75BF      MOVW     R5,#+36799
   \   00000198   0x402C             ANDS     R4,R5,R4
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000001A0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001A4   0x6814             LDR      R4,[R2, #+0]
   \   000001A6   0x781D             LDRB     R5,[R3, #+0]
   \   000001A8   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   000001AC   0xE058             B.N      ??HAL_PCD_EP_Close_7
   1079              }
   1080              else
   1081              {
   1082                /* Clear the data toggle bits for the endpoint IN/OUT*/
   1083                PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_9: (+1)
   \   000001AE   0x6810             LDR      R0,[R2, #+0]
   \   000001B0   0x781C             LDRB     R4,[R3, #+0]
   \   000001B2   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000001B6   0x0440             LSLS     R0,R0,#+17
   \   000001B8   0xD50E             BPL.N    ??HAL_PCD_EP_Close_12
   \   000001BA   0x6810             LDR      R0,[R2, #+0]
   \   000001BC   0x781C             LDRB     R4,[R3, #+0]
   \   000001BE   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000001C2   0xF648 0x748F      MOVW     R4,#+36751
   \   000001C6   0x4020             ANDS     R0,R4,R0
   \   000001C8   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000001CC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001D0   0x6814             LDR      R4,[R2, #+0]
   \   000001D2   0x781D             LDRB     R5,[R3, #+0]
   \   000001D4   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1084                PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_12: (+1)
   \   000001D8   0x6810             LDR      R0,[R2, #+0]
   \   000001DA   0x781C             LDRB     R4,[R3, #+0]
   \   000001DC   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000001E0   0x0640             LSLS     R0,R0,#+25
   \   000001E2   0xD50E             BPL.N    ??HAL_PCD_EP_Close_13
   \   000001E4   0x6810             LDR      R0,[R2, #+0]
   \   000001E6   0x781C             LDRB     R4,[R3, #+0]
   \   000001E8   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000001EC   0xF648 0x748F      MOVW     R4,#+36751
   \   000001F0   0x4020             ANDS     R0,R4,R0
   \   000001F2   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000001F6   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   000001FA   0x6814             LDR      R4,[R2, #+0]
   \   000001FC   0x781D             LDRB     R5,[R3, #+0]
   \   000001FE   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1085                PCD_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_Close_13: (+1)
   \   00000202   0x6810             LDR      R0,[R2, #+0]
   \   00000204   0x781C             LDRB     R4,[R3, #+0]
   \   00000206   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   0000020A   0xF648 0x748F      MOVW     R4,#+36751
   \   0000020E   0x4020             ANDS     R0,R4,R0
   \   00000210   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   00000214   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000218   0x6814             LDR      R4,[R2, #+0]
   \   0000021A   0x781D             LDRB     R5,[R3, #+0]
   \   0000021C   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1086                /* Configure DISABLE status for the Endpoint*/
   1087                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
   \   00000220   0x6814             LDR      R4,[R2, #+0]
   \   00000222   0x781D             LDRB     R5,[R3, #+0]
   \   00000224   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000228   0xF648 0x75BF      MOVW     R5,#+36799
   \   0000022C   0x402C             ANDS     R4,R5,R4
   \   0000022E   0x0020             MOVS     R0,R4
   \   00000230   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000234   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000238   0x6814             LDR      R4,[R2, #+0]
   \   0000023A   0x781D             LDRB     R5,[R3, #+0]
   \   0000023C   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1088                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
   \   00000240   0x6814             LDR      R4,[R2, #+0]
   \   00000242   0x781D             LDRB     R5,[R3, #+0]
   \   00000244   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000248   0xF64B 0x758F      MOVW     R5,#+49039
   \   0000024C   0x402C             ANDS     R4,R5,R4
   \   0000024E   0x0020             MOVS     R0,R4
   \   00000250   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000254   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000258   0x6814             LDR      R4,[R2, #+0]
   \   0000025A   0x781D             LDRB     R5,[R3, #+0]
   \   0000025C   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1089              }
   1090            } 
   1091            
   1092            __HAL_UNLOCK(hpcd);   
   \                     ??HAL_PCD_EP_Close_7: (+1)
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1093            return HAL_OK;
   \   00000266   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Close_3: (+1)
   \   00000268   0xBC30             POP      {R4,R5}
   \   0000026A   0x4770             BX       LR               ;; return
   1094          }
   1095          
   1096          
   1097          /**
   1098            * @brief  Receive an amount of data  
   1099            * @param  hpcd: PCD handle
   1100            * @param  ep_addr: endpoint address
   1101            * @param  pBuf: pointer to the reception buffer   
   1102            * @param  len: amount of data to be received
   1103            * @retval HAL status
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
   1106          {
   \                     HAL_PCD_EP_Receive: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
   1107            
   1108           PCD_EPTypeDef *ep;
   1109            
   1110            ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   0000000A   0x261C             MOVS     R6,#+28
   \   0000000C   0x4370             MULS     R0,R6,R0
   \   0000000E   0x4420             ADD      R0,R4,R0
   \   00000010   0xF44F 0x7684      MOV      R6,#+264
   \   00000014   0x4430             ADD      R0,R0,R6
   \   00000016   0x0005             MOVS     R5,R0
   1111            
   1112            /*setup and start the Xfer */
   1113            ep->xfer_buff = pBuf;  
   \   00000018   0x612A             STR      R2,[R5, #+16]
   1114            ep->xfer_len = len;
   \   0000001A   0x616B             STR      R3,[R5, #+20]
   1115            ep->xfer_count = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61A8             STR      R0,[R5, #+24]
   1116            ep->is_in = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7068             STRB     R0,[R5, #+1]
   1117            ep->num = ep_addr & 0x7F;
   \   00000024   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000028   0x7028             STRB     R0,[R5, #+0]
   1118             
   1119            __HAL_LOCK(hpcd); 
   \   0000002A   0xF894 0x01E8      LDRB     R0,[R4, #+488]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??HAL_PCD_EP_Receive_0
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE0B8             B.N      ??HAL_PCD_EP_Receive_1
   \                     ??HAL_PCD_EP_Receive_0: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x01E8      STRB     R0,[R4, #+488]
   1120             
   1121            /* Multi packet transfer*/
   1122            if (ep->xfer_len > ep->maxpacket)
   \   0000003C   0x68E8             LDR      R0,[R5, #+12]
   \   0000003E   0x696E             LDR      R6,[R5, #+20]
   \   00000040   0x42B0             CMP      R0,R6
   \   00000042   0xD205             BCS.N    ??HAL_PCD_EP_Receive_2
   1123            {
   1124              len=ep->maxpacket;
   \   00000044   0x68E8             LDR      R0,[R5, #+12]
   \   00000046   0x0003             MOVS     R3,R0
   1125              ep->xfer_len-=len; 
   \   00000048   0x6968             LDR      R0,[R5, #+20]
   \   0000004A   0x1AC0             SUBS     R0,R0,R3
   \   0000004C   0x6168             STR      R0,[R5, #+20]
   \   0000004E   0xE003             B.N      ??HAL_PCD_EP_Receive_3
   1126            }
   1127            else
   1128            {
   1129              len=ep->xfer_len;
   \                     ??HAL_PCD_EP_Receive_2: (+1)
   \   00000050   0x6968             LDR      R0,[R5, #+20]
   \   00000052   0x0003             MOVS     R3,R0
   1130              ep->xfer_len =0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x6168             STR      R0,[R5, #+20]
   1131            }
   1132            
   1133            /* configure and validate Rx endpoint */
   1134            if (ep->doublebuffer == 0) 
   \                     ??HAL_PCD_EP_Receive_3: (+1)
   \   00000058   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD122             BNE.N    ??HAL_PCD_EP_Receive_4
   1135            {
   1136              /*Set RX buffer count*/
   1137              PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, len);
   \   0000005E   0x6826             LDR      R6,[R4, #+0]
   \   00000060   0xF8B6 0x6050      LDRH     R6,[R6, #+80]
   \   00000064   0x782F             LDRB     R7,[R5, #+0]
   \   00000066   0xEB16 0x06C7      ADDS     R6,R6,R7, LSL #+3
   \   0000006A   0x6827             LDR      R7,[R4, #+0]
   \   0000006C   0xEB17 0x0646      ADDS     R6,R7,R6, LSL #+1
   \   00000070   0xF206 0x460C      ADDW     R6,R6,#+1036
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x2B3F             CMP      R3,#+63
   \   00000078   0xD30B             BCC.N    ??HAL_PCD_EP_Receive_5
   \   0000007A   0x095F             LSRS     R7,R3,#+5
   \   0000007C   0x003E             MOVS     R6,R7
   \   0000007E   0xF013 0x0F1F      TST      R3,#0x1F
   \   00000082   0xD100             BNE.N    ??HAL_PCD_EP_Receive_6
   \   00000084   0x1E76             SUBS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_6: (+1)
   \   00000086   0x02B6             LSLS     R6,R6,#+10
   \   00000088   0xF456 0x4600      ORRS     R6,R6,#0x8000
   \   0000008C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000008E   0x6006             STR      R6,[R0, #+0]
   \   00000090   0xE072             B.N      ??HAL_PCD_EP_Receive_7
   \                     ??HAL_PCD_EP_Receive_5: (+1)
   \   00000092   0x085F             LSRS     R7,R3,#+1
   \   00000094   0x003E             MOVS     R6,R7
   \   00000096   0x07DF             LSLS     R7,R3,#+31
   \   00000098   0xD500             BPL.N    ??HAL_PCD_EP_Receive_8
   \   0000009A   0x1C76             ADDS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_8: (+1)
   \   0000009C   0x02B6             LSLS     R6,R6,#+10
   \   0000009E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A0   0x6006             STR      R6,[R0, #+0]
   \   000000A2   0xE069             B.N      ??HAL_PCD_EP_Receive_7
   1138            }
   1139            else
   1140            {
   1141              /*Set the Double buffer counter*/
   1142              PCD_SET_EP_DBUF_CNT(hpcd->Instance, ep->num, ep->is_in, len);
   \                     ??HAL_PCD_EP_Receive_4: (+1)
   \   000000A4   0x7868             LDRB     R0,[R5, #+1]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD122             BNE.N    ??HAL_PCD_EP_Receive_9
   \   000000AA   0x6826             LDR      R6,[R4, #+0]
   \   000000AC   0xF8B6 0x6050      LDRH     R6,[R6, #+80]
   \   000000B0   0x782F             LDRB     R7,[R5, #+0]
   \   000000B2   0xEB16 0x06C7      ADDS     R6,R6,R7, LSL #+3
   \   000000B6   0x6827             LDR      R7,[R4, #+0]
   \   000000B8   0xEB17 0x0646      ADDS     R6,R7,R6, LSL #+1
   \   000000BC   0xF206 0x4604      ADDW     R6,R6,#+1028
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x2B3F             CMP      R3,#+63
   \   000000C4   0xD30B             BCC.N    ??HAL_PCD_EP_Receive_10
   \   000000C6   0x095F             LSRS     R7,R3,#+5
   \   000000C8   0x003E             MOVS     R6,R7
   \   000000CA   0xF013 0x0F1F      TST      R3,#0x1F
   \   000000CE   0xD100             BNE.N    ??HAL_PCD_EP_Receive_11
   \   000000D0   0x1E76             SUBS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_11: (+1)
   \   000000D2   0x02B6             LSLS     R6,R6,#+10
   \   000000D4   0xF456 0x4600      ORRS     R6,R6,#0x8000
   \   000000D8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000DA   0x6006             STR      R6,[R0, #+0]
   \   000000DC   0xE017             B.N      ??HAL_PCD_EP_Receive_12
   \                     ??HAL_PCD_EP_Receive_10: (+1)
   \   000000DE   0x085F             LSRS     R7,R3,#+1
   \   000000E0   0x003E             MOVS     R6,R7
   \   000000E2   0x07DF             LSLS     R7,R3,#+31
   \   000000E4   0xD500             BPL.N    ??HAL_PCD_EP_Receive_13
   \   000000E6   0x1C76             ADDS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_13: (+1)
   \   000000E8   0x02B6             LSLS     R6,R6,#+10
   \   000000EA   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EC   0x6006             STR      R6,[R0, #+0]
   \   000000EE   0xE00E             B.N      ??HAL_PCD_EP_Receive_12
   \                     ??HAL_PCD_EP_Receive_9: (+1)
   \   000000F0   0x7868             LDRB     R0,[R5, #+1]
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD10B             BNE.N    ??HAL_PCD_EP_Receive_12
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   000000FC   0x782E             LDRB     R6,[R5, #+0]
   \   000000FE   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   00000102   0x6826             LDR      R6,[R4, #+0]
   \   00000104   0xEB16 0x0040      ADDS     R0,R6,R0, LSL #+1
   \   00000108   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   0000010C   0x6003             STR      R3,[R0, #+0]
   \                     ??HAL_PCD_EP_Receive_12: (+1)
   \   0000010E   0x7868             LDRB     R0,[R5, #+1]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD122             BNE.N    ??HAL_PCD_EP_Receive_14
   \   00000114   0x6826             LDR      R6,[R4, #+0]
   \   00000116   0xF8B6 0x6050      LDRH     R6,[R6, #+80]
   \   0000011A   0x782F             LDRB     R7,[R5, #+0]
   \   0000011C   0xEB16 0x06C7      ADDS     R6,R6,R7, LSL #+3
   \   00000120   0x6827             LDR      R7,[R4, #+0]
   \   00000122   0xEB17 0x0646      ADDS     R6,R7,R6, LSL #+1
   \   00000126   0xF206 0x460C      ADDW     R6,R6,#+1036
   \   0000012A   0x0030             MOVS     R0,R6
   \   0000012C   0x2B3F             CMP      R3,#+63
   \   0000012E   0xD30B             BCC.N    ??HAL_PCD_EP_Receive_15
   \   00000130   0x095F             LSRS     R7,R3,#+5
   \   00000132   0x003E             MOVS     R6,R7
   \   00000134   0xF013 0x0F1F      TST      R3,#0x1F
   \   00000138   0xD100             BNE.N    ??HAL_PCD_EP_Receive_16
   \   0000013A   0x1E76             SUBS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_16: (+1)
   \   0000013C   0x02B6             LSLS     R6,R6,#+10
   \   0000013E   0xF456 0x4600      ORRS     R6,R6,#0x8000
   \   00000142   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000144   0x6006             STR      R6,[R0, #+0]
   \   00000146   0xE017             B.N      ??HAL_PCD_EP_Receive_7
   \                     ??HAL_PCD_EP_Receive_15: (+1)
   \   00000148   0x085F             LSRS     R7,R3,#+1
   \   0000014A   0x003E             MOVS     R6,R7
   \   0000014C   0x07DF             LSLS     R7,R3,#+31
   \   0000014E   0xD500             BPL.N    ??HAL_PCD_EP_Receive_17
   \   00000150   0x1C76             ADDS     R6,R6,#+1
   \                     ??HAL_PCD_EP_Receive_17: (+1)
   \   00000152   0x02B6             LSLS     R6,R6,#+10
   \   00000154   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000156   0x6006             STR      R6,[R0, #+0]
   \   00000158   0xE00E             B.N      ??HAL_PCD_EP_Receive_7
   \                     ??HAL_PCD_EP_Receive_14: (+1)
   \   0000015A   0x7868             LDRB     R0,[R5, #+1]
   \   0000015C   0x2801             CMP      R0,#+1
   \   0000015E   0xD10B             BNE.N    ??HAL_PCD_EP_Receive_7
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000166   0x782E             LDRB     R6,[R5, #+0]
   \   00000168   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   0000016C   0x6826             LDR      R6,[R4, #+0]
   \   0000016E   0xEB16 0x0040      ADDS     R0,R6,R0, LSL #+1
   \   00000172   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000176   0x6003             STR      R3,[R0, #+0]
   1143            } 
   1144            
   1145            PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
   \                     ??HAL_PCD_EP_Receive_7: (+1)
   \   00000178   0x6826             LDR      R6,[R4, #+0]
   \   0000017A   0x782F             LDRB     R7,[R5, #+0]
   \   0000017C   0xF836 0x6027      LDRH     R6,[R6, R7, LSL #+2]
   \   00000180   0xF64B 0x778F      MOVW     R7,#+49039
   \   00000184   0x403E             ANDS     R6,R7,R6
   \   00000186   0x0030             MOVS     R0,R6
   \   00000188   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   0000018C   0xF490 0x5000      EORS     R0,R0,#0x2000
   \   00000190   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000194   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000198   0x6826             LDR      R6,[R4, #+0]
   \   0000019A   0x782F             LDRB     R7,[R5, #+0]
   \   0000019C   0xF826 0x0027      STRH     R0,[R6, R7, LSL #+2]
   1146            
   1147            __HAL_UNLOCK(hpcd); 
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xF884 0x01E8      STRB     R0,[R4, #+488]
   1148            
   1149            return HAL_OK;
   \   000001A6   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Receive_1: (+1)
   \   000001A8   0xBCF0             POP      {R4-R7}
   \   000001AA   0x4770             BX       LR               ;; return
   1150          }
   1151          
   1152          /**
   1153            * @brief  Get Received Data Size
   1154            * @param  hpcd: PCD handle
   1155            * @param  ep_addr: endpoint address
   1156            * @retval Data Size
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1159          {
   1160            return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
   \                     HAL_PCD_EP_GetRxCount: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000006   0x221C             MOVS     R2,#+28
   \   00000008   0x4351             MULS     R1,R2,R1
   \   0000000A   0x4408             ADD      R0,R0,R1
   \   0000000C   0xF8D0 0x0120      LDR      R0,[R0, #+288]
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x4770             BX       LR               ;; return
   1161          }
   1162          /**
   1163            * @brief  Send an amount of data  
   1164            * @param  hpcd: PCD handle
   1165            * @param  ep_addr: endpoint address
   1166            * @param  pBuf: pointer to the transmission buffer   
   1167            * @param  len: amount of data to be sent
   1168            * @retval HAL status
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
   1171          {
   \                     HAL_PCD_EP_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1172            PCD_EPTypeDef *ep;
   1173            uint16_t pmabuffer = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   1174              
   1175            ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000016   0x211C             MOVS     R1,#+28
   \   00000018   0x4348             MULS     R0,R1,R0
   \   0000001A   0x4420             ADD      R0,R4,R0
   \   0000001C   0x3028             ADDS     R0,R0,#+40
   \   0000001E   0x4680             MOV      R8,R0
   1176            
   1177            /*setup and start the Xfer */
   1178            ep->xfer_buff = pBuf;  
   \   00000020   0xF8C8 0x6010      STR      R6,[R8, #+16]
   1179            ep->xfer_len = len;
   \   00000024   0xF8C8 0x7014      STR      R7,[R8, #+20]
   1180            ep->xfer_count = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8C8 0x0018      STR      R0,[R8, #+24]
   1181            ep->is_in = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF888 0x0001      STRB     R0,[R8, #+1]
   1182            ep->num = ep_addr & 0x7F;
   \   00000034   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000038   0xF888 0x0000      STRB     R0,[R8, #+0]
   1183            
   1184            __HAL_LOCK(hpcd); 
   \   0000003C   0xF894 0x01E8      LDRB     R0,[R4, #+488]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD101             BNE.N    ??HAL_PCD_EP_Transmit_0
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xE100             B.N      ??HAL_PCD_EP_Transmit_1
   \                     ??HAL_PCD_EP_Transmit_0: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x01E8      STRB     R0,[R4, #+488]
   1185            
   1186            /*Multi packet transfer*/
   1187            if (ep->xfer_len > ep->maxpacket)
   \   0000004E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000052   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD208             BCS.N    ??HAL_PCD_EP_Transmit_2
   1188            {
   1189              len=ep->maxpacket;
   \   0000005A   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   0000005E   0x0007             MOVS     R7,R0
   1190              ep->xfer_len-=len; 
   \   00000060   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   00000064   0x1BC0             SUBS     R0,R0,R7
   \   00000066   0xF8C8 0x0014      STR      R0,[R8, #+20]
   \   0000006A   0xE005             B.N      ??HAL_PCD_EP_Transmit_3
   1191            }
   1192            else
   1193            {  
   1194              len=ep->xfer_len;
   \                     ??HAL_PCD_EP_Transmit_2: (+1)
   \   0000006C   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   00000070   0x0007             MOVS     R7,R0
   1195              ep->xfer_len =0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF8C8 0x0014      STR      R0,[R8, #+20]
   1196            }
   1197            
   1198            /* configure and validate Tx endpoint */
   1199            if (ep->doublebuffer == 0) 
   \                     ??HAL_PCD_EP_Transmit_3: (+1)
   \   00000078   0xF898 0x000A      LDRB     R0,[R8, #+10]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD116             BNE.N    ??HAL_PCD_EP_Transmit_4
   1200            {
   1201              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, len);
   \   00000080   0x003B             MOVS     R3,R7
   \   00000082   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000084   0xF8B8 0x2004      LDRH     R2,[R8, #+4]
   \   00000088   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       PCD_WritePMA
   1202              PCD_SET_EP_TX_CNT(hpcd->Instance, ep->num, len);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   00000098   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   0000009C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   000000A6   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   000000AA   0x6007             STR      R7,[R0, #+0]
   \   000000AC   0xE0B3             B.N      ??HAL_PCD_EP_Transmit_5
   1203            }
   1204            else
   1205            {
   1206              /*Set the Double buffer counter */
   1207              PCD_SET_EP_DBUF_CNT(hpcd->Instance, ep->num, ep->is_in, len);
   \                     ??HAL_PCD_EP_Transmit_4: (+1)
   \   000000AE   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD123             BNE.N    ??HAL_PCD_EP_Transmit_6
   \   000000B6   0x6821             LDR      R1,[R4, #+0]
   \   000000B8   0xF8B1 0x1050      LDRH     R1,[R1, #+80]
   \   000000BC   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   000000C0   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000000C4   0x6822             LDR      R2,[R4, #+0]
   \   000000C6   0xEB12 0x0141      ADDS     R1,R2,R1, LSL #+1
   \   000000CA   0xF201 0x4104      ADDW     R1,R1,#+1028
   \   000000CE   0x0008             MOVS     R0,R1
   \   000000D0   0x2F3F             CMP      R7,#+63
   \   000000D2   0xD30B             BCC.N    ??HAL_PCD_EP_Transmit_7
   \   000000D4   0x097A             LSRS     R2,R7,#+5
   \   000000D6   0x0011             MOVS     R1,R2
   \   000000D8   0xF017 0x0F1F      TST      R7,#0x1F
   \   000000DC   0xD100             BNE.N    ??HAL_PCD_EP_Transmit_8
   \   000000DE   0x1E49             SUBS     R1,R1,#+1
   \                     ??HAL_PCD_EP_Transmit_8: (+1)
   \   000000E0   0x0289             LSLS     R1,R1,#+10
   \   000000E2   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   000000E6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E8   0x6001             STR      R1,[R0, #+0]
   \   000000EA   0xE019             B.N      ??HAL_PCD_EP_Transmit_9
   \                     ??HAL_PCD_EP_Transmit_7: (+1)
   \   000000EC   0x087A             LSRS     R2,R7,#+1
   \   000000EE   0x0011             MOVS     R1,R2
   \   000000F0   0x07FA             LSLS     R2,R7,#+31
   \   000000F2   0xD500             BPL.N    ??HAL_PCD_EP_Transmit_10
   \   000000F4   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_PCD_EP_Transmit_10: (+1)
   \   000000F6   0x0289             LSLS     R1,R1,#+10
   \   000000F8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000FA   0x6001             STR      R1,[R0, #+0]
   \   000000FC   0xE010             B.N      ??HAL_PCD_EP_Transmit_9
   \                     ??HAL_PCD_EP_Transmit_6: (+1)
   \   000000FE   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xD10C             BNE.N    ??HAL_PCD_EP_Transmit_9
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   0000010C   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000110   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000114   0x6821             LDR      R1,[R4, #+0]
   \   00000116   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   0000011A   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   0000011E   0x6007             STR      R7,[R0, #+0]
   \                     ??HAL_PCD_EP_Transmit_9: (+1)
   \   00000120   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD123             BNE.N    ??HAL_PCD_EP_Transmit_11
   \   00000128   0x6821             LDR      R1,[R4, #+0]
   \   0000012A   0xF8B1 0x1050      LDRH     R1,[R1, #+80]
   \   0000012E   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   00000132   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000136   0x6822             LDR      R2,[R4, #+0]
   \   00000138   0xEB12 0x0141      ADDS     R1,R2,R1, LSL #+1
   \   0000013C   0xF201 0x410C      ADDW     R1,R1,#+1036
   \   00000140   0x0008             MOVS     R0,R1
   \   00000142   0x2F3F             CMP      R7,#+63
   \   00000144   0xD30B             BCC.N    ??HAL_PCD_EP_Transmit_12
   \   00000146   0x097A             LSRS     R2,R7,#+5
   \   00000148   0x0011             MOVS     R1,R2
   \   0000014A   0xF017 0x0F1F      TST      R7,#0x1F
   \   0000014E   0xD100             BNE.N    ??HAL_PCD_EP_Transmit_13
   \   00000150   0x1E49             SUBS     R1,R1,#+1
   \                     ??HAL_PCD_EP_Transmit_13: (+1)
   \   00000152   0x0289             LSLS     R1,R1,#+10
   \   00000154   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000158   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000015A   0x6001             STR      R1,[R0, #+0]
   \   0000015C   0xE019             B.N      ??HAL_PCD_EP_Transmit_14
   \                     ??HAL_PCD_EP_Transmit_12: (+1)
   \   0000015E   0x087A             LSRS     R2,R7,#+1
   \   00000160   0x0011             MOVS     R1,R2
   \   00000162   0x07FA             LSLS     R2,R7,#+31
   \   00000164   0xD500             BPL.N    ??HAL_PCD_EP_Transmit_15
   \   00000166   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_PCD_EP_Transmit_15: (+1)
   \   00000168   0x0289             LSLS     R1,R1,#+10
   \   0000016A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000016C   0x6001             STR      R1,[R0, #+0]
   \   0000016E   0xE010             B.N      ??HAL_PCD_EP_Transmit_14
   \                     ??HAL_PCD_EP_Transmit_11: (+1)
   \   00000170   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000174   0x2801             CMP      R0,#+1
   \   00000176   0xD10C             BNE.N    ??HAL_PCD_EP_Transmit_14
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0xF8B0 0x0050      LDRH     R0,[R0, #+80]
   \   0000017E   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000182   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000186   0x6821             LDR      R1,[R4, #+0]
   \   00000188   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   0000018C   0xF200 0x4004      ADDW     R0,R0,#+1028
   \   00000190   0x6007             STR      R7,[R0, #+0]
   1208              
   1209              /*Write the data to the USB endpoint*/
   1210              if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX)
   \                     ??HAL_PCD_EP_Transmit_14: (+1)
   \   00000192   0x6820             LDR      R0,[R4, #+0]
   \   00000194   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000198   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   0000019C   0x0640             LSLS     R0,R0,#+25
   \   0000019E   0xD503             BPL.N    ??HAL_PCD_EP_Transmit_16
   1211              {
   1212                pmabuffer = ep->pmaaddr1;
   \   000001A0   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   000001A4   0x4681             MOV      R9,R0
   \   000001A6   0xE002             B.N      ??HAL_PCD_EP_Transmit_17
   1213              }
   1214              else
   1215              {
   1216                pmabuffer = ep->pmaaddr0;
   \                     ??HAL_PCD_EP_Transmit_16: (+1)
   \   000001A8   0xF8B8 0x0006      LDRH     R0,[R8, #+6]
   \   000001AC   0x4681             MOV      R9,R0
   1217              }
   1218          
   1219              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
   \                     ??HAL_PCD_EP_Transmit_17: (+1)
   \   000001AE   0x003B             MOVS     R3,R7
   \   000001B0   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000001B2   0x464A             MOV      R2,R9
   \   000001B4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001B6   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   000001BA   0x6820             LDR      R0,[R4, #+0]
   \   000001BC   0x.... 0x....      BL       PCD_WritePMA
   1220              PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in);
   \   000001C0   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000001C4   0x2800             CMP      R0,#+0
   \   000001C6   0xD111             BNE.N    ??HAL_PCD_EP_Transmit_18
   \   000001C8   0x6820             LDR      R0,[R4, #+0]
   \   000001CA   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   000001CE   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   000001D2   0xF648 0x718F      MOVW     R1,#+36751
   \   000001D6   0x4008             ANDS     R0,R1,R0
   \   000001D8   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000001DC   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   000001E0   0x6821             LDR      R1,[R4, #+0]
   \   000001E2   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   000001E6   0xF821 0x0022      STRH     R0,[R1, R2, LSL #+2]
   \   000001EA   0xE014             B.N      ??HAL_PCD_EP_Transmit_5
   \                     ??HAL_PCD_EP_Transmit_18: (+1)
   \   000001EC   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000001F0   0x2801             CMP      R0,#+1
   \   000001F2   0xD110             BNE.N    ??HAL_PCD_EP_Transmit_5
   \   000001F4   0x6820             LDR      R0,[R4, #+0]
   \   000001F6   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   000001FA   0xF830 0x0021      LDRH     R0,[R0, R1, LSL #+2]
   \   000001FE   0xF648 0x718F      MOVW     R1,#+36751
   \   00000202   0x4008             ANDS     R0,R1,R0
   \   00000204   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   00000208   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000020C   0x6821             LDR      R1,[R4, #+0]
   \   0000020E   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   00000212   0xF821 0x0022      STRH     R0,[R1, R2, LSL #+2]
   1221            }
   1222          
   1223            PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
   \                     ??HAL_PCD_EP_Transmit_5: (+1)
   \   00000216   0x6821             LDR      R1,[R4, #+0]
   \   00000218   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   0000021C   0xF831 0x1022      LDRH     R1,[R1, R2, LSL #+2]
   \   00000220   0xF648 0x72BF      MOVW     R2,#+36799
   \   00000224   0x4011             ANDS     R1,R2,R1
   \   00000226   0x0008             MOVS     R0,R1
   \   00000228   0xF090 0x0010      EORS     R0,R0,#0x10
   \   0000022C   0xF090 0x0020      EORS     R0,R0,#0x20
   \   00000230   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000234   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000238   0x6821             LDR      R1,[R4, #+0]
   \   0000023A   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   0000023E   0xF821 0x0022      STRH     R0,[R1, R2, LSL #+2]
   1224            
   1225            __HAL_UNLOCK(hpcd);
   \   00000242   0x2000             MOVS     R0,#+0
   \   00000244   0xF884 0x01E8      STRB     R0,[R4, #+488]
   1226               
   1227            return HAL_OK;
   \   00000248   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Transmit_1: (+1)
   \   0000024A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1228          }
   1229          
   1230          /**
   1231            * @brief  Set a STALL condition over an endpoint
   1232            * @param  hpcd: PCD handle
   1233            * @param  ep_addr: endpoint address
   1234            * @retval HAL status
   1235            */

   \                                 In section .text, align 2, keep-with-next
   1236          HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1237          {
   \                     HAL_PCD_EP_SetStall: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1238            PCD_EPTypeDef *ep;
   1239             
   1240            __HAL_LOCK(hpcd); 
   \   00000004   0xF892 0x01E8      LDRB     R0,[R2, #+488]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_EP_SetStall_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE064             B.N      ??HAL_PCD_EP_SetStall_1
   \                     ??HAL_PCD_EP_SetStall_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1241             
   1242            if ((0x80 & ep_addr) == 0x80)
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0608             LSLS     R0,R1,#+24
   \   0000001A   0xD508             BPL.N    ??HAL_PCD_EP_SetStall_2
   1243            {
   1244              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000022   0x241C             MOVS     R4,#+28
   \   00000024   0x4360             MULS     R0,R4,R0
   \   00000026   0x4410             ADD      R0,R2,R0
   \   00000028   0x3028             ADDS     R0,R0,#+40
   \   0000002A   0x0003             MOVS     R3,R0
   \   0000002C   0xE008             B.N      ??HAL_PCD_EP_SetStall_3
   1245            }
   1246            else
   1247            {
   1248              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_SetStall_2: (+1)
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x201C             MOVS     R0,#+28
   \   00000032   0xFB00 0xF001      MUL      R0,R0,R1
   \   00000036   0x4410             ADD      R0,R2,R0
   \   00000038   0xF44F 0x7484      MOV      R4,#+264
   \   0000003C   0x4420             ADD      R0,R0,R4
   \   0000003E   0x0003             MOVS     R3,R0
   1249            }
   1250            
   1251            ep->is_stall = 1;
   \                     ??HAL_PCD_EP_SetStall_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7098             STRB     R0,[R3, #+2]
   1252            ep->num   = ep_addr & 0x7F;
   \   00000044   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000048   0x7018             STRB     R0,[R3, #+0]
   1253            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   0000004A   0x0008             MOVS     R0,R1
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x09C0             LSRS     R0,R0,#+7
   \   00000050   0x7058             STRB     R0,[R3, #+1]
   1254            
   1255            if (ep->num == 0)
   \   00000052   0x7818             LDRB     R0,[R3, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD114             BNE.N    ??HAL_PCD_EP_SetStall_4
   1256            {
   1257              /* This macro sets STALL status for RX & TX*/ 
   1258              PCD_SET_EP_TXRX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL); 
   \   00000058   0x6814             LDR      R4,[R2, #+0]
   \   0000005A   0x781D             LDRB     R5,[R3, #+0]
   \   0000005C   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000060   0xF64B 0x75BF      MOVW     R5,#+49087
   \   00000064   0x402C             ANDS     R4,R5,R4
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   0000006C   0xF090 0x0010      EORS     R0,R0,#0x10
   \   00000070   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000074   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000078   0x6814             LDR      R4,[R2, #+0]
   \   0000007A   0x781D             LDRB     R5,[R3, #+0]
   \   0000007C   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   00000080   0xE027             B.N      ??HAL_PCD_EP_SetStall_5
   1259            }
   1260            else
   1261            {
   1262              if (ep->is_in)
   \                     ??HAL_PCD_EP_SetStall_4: (+1)
   \   00000082   0x7858             LDRB     R0,[R3, #+1]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD012             BEQ.N    ??HAL_PCD_EP_SetStall_6
   1263              {
   1264                PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL); 
   \   00000088   0x6814             LDR      R4,[R2, #+0]
   \   0000008A   0x781D             LDRB     R5,[R3, #+0]
   \   0000008C   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   00000090   0xF648 0x75BF      MOVW     R5,#+36799
   \   00000094   0x402C             ANDS     R4,R5,R4
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0xF090 0x0010      EORS     R0,R0,#0x10
   \   0000009C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000A0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A4   0x6814             LDR      R4,[R2, #+0]
   \   000000A6   0x781D             LDRB     R5,[R3, #+0]
   \   000000A8   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   000000AC   0xE011             B.N      ??HAL_PCD_EP_SetStall_5
   1265              }
   1266              else
   1267              {
   1268                PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL);
   \                     ??HAL_PCD_EP_SetStall_6: (+1)
   \   000000AE   0x6814             LDR      R4,[R2, #+0]
   \   000000B0   0x781D             LDRB     R5,[R3, #+0]
   \   000000B2   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   000000B6   0xF64B 0x758F      MOVW     R5,#+49039
   \   000000BA   0x402C             ANDS     R4,R5,R4
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   000000C2   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000C6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000CA   0x6814             LDR      R4,[R2, #+0]
   \   000000CC   0x781D             LDRB     R5,[R3, #+0]
   \   000000CE   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1269              }
   1270            }
   1271            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_SetStall_5: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1272            
   1273            return HAL_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_SetStall_1: (+1)
   \   000000DA   0xBC30             POP      {R4,R5}
   \   000000DC   0x4770             BX       LR               ;; return
   1274          }
   1275          
   1276          /**
   1277            * @brief  Clear a STALL condition over in an endpoint
   1278            * @param  hpcd: PCD handle
   1279            * @param  ep_addr: endpoint address
   1280            * @retval HAL status
   1281            */

   \                                 In section .text, align 2, keep-with-next
   1282          HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1283          {
   \                     HAL_PCD_EP_ClrStall: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1284            PCD_EPTypeDef *ep;
   1285            
   1286            if ((0x80 & ep_addr) == 0x80)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x0608             LSLS     R0,R1,#+24
   \   00000008   0xD508             BPL.N    ??HAL_PCD_EP_ClrStall_0
   1287            {
   1288              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000010   0x241C             MOVS     R4,#+28
   \   00000012   0x4360             MULS     R0,R4,R0
   \   00000014   0x4410             ADD      R0,R2,R0
   \   00000016   0x3028             ADDS     R0,R0,#+40
   \   00000018   0x0003             MOVS     R3,R0
   \   0000001A   0xE008             B.N      ??HAL_PCD_EP_ClrStall_1
   1289            }
   1290            else
   1291            {
   1292              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_ClrStall_0: (+1)
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x201C             MOVS     R0,#+28
   \   00000020   0xFB00 0xF001      MUL      R0,R0,R1
   \   00000024   0x4410             ADD      R0,R2,R0
   \   00000026   0xF44F 0x7484      MOV      R4,#+264
   \   0000002A   0x4420             ADD      R0,R0,R4
   \   0000002C   0x0003             MOVS     R3,R0
   1293            }
   1294            
   1295            ep->is_stall = 0;
   \                     ??HAL_PCD_EP_ClrStall_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7098             STRB     R0,[R3, #+2]
   1296            ep->num   = ep_addr & 0x7F;
   \   00000032   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   00000036   0x7018             STRB     R0,[R3, #+0]
   1297            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   00000038   0x0008             MOVS     R0,R1
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x09C0             LSRS     R0,R0,#+7
   \   0000003E   0x7058             STRB     R0,[R3, #+1]
   1298            
   1299            __HAL_LOCK(hpcd); 
   \   00000040   0xF892 0x01E8      LDRB     R0,[R2, #+488]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD101             BNE.N    ??HAL_PCD_EP_ClrStall_2
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xE05C             B.N      ??HAL_PCD_EP_ClrStall_3
   \                     ??HAL_PCD_EP_ClrStall_2: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1300            
   1301            if (ep->is_in)
   \   00000052   0x7858             LDRB     R0,[R3, #+1]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD029             BEQ.N    ??HAL_PCD_EP_ClrStall_4
   1302            {
   1303              PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
   \   00000058   0x6810             LDR      R0,[R2, #+0]
   \   0000005A   0x781C             LDRB     R4,[R3, #+0]
   \   0000005C   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   00000060   0x0640             LSLS     R0,R0,#+25
   \   00000062   0xD50E             BPL.N    ??HAL_PCD_EP_ClrStall_5
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0x781C             LDRB     R4,[R3, #+0]
   \   00000068   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   0000006C   0xF648 0x748F      MOVW     R4,#+36751
   \   00000070   0x4020             ANDS     R0,R4,R0
   \   00000072   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000076   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   0000007A   0x6814             LDR      R4,[R2, #+0]
   \   0000007C   0x781D             LDRB     R5,[R3, #+0]
   \   0000007E   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1304              PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
   \                     ??HAL_PCD_EP_ClrStall_5: (+1)
   \   00000082   0x6814             LDR      R4,[R2, #+0]
   \   00000084   0x781D             LDRB     R5,[R3, #+0]
   \   00000086   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   0000008A   0xF648 0x75BF      MOVW     R5,#+36799
   \   0000008E   0x402C             ANDS     R4,R5,R4
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0xF090 0x0010      EORS     R0,R0,#0x10
   \   00000096   0xF090 0x0020      EORS     R0,R0,#0x20
   \   0000009A   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000009E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A2   0x6814             LDR      R4,[R2, #+0]
   \   000000A4   0x781D             LDRB     R5,[R3, #+0]
   \   000000A6   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   \   000000AA   0xE028             B.N      ??HAL_PCD_EP_ClrStall_6
   1305            }
   1306            else
   1307            {
   1308              PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
   \                     ??HAL_PCD_EP_ClrStall_4: (+1)
   \   000000AC   0x6810             LDR      R0,[R2, #+0]
   \   000000AE   0x781C             LDRB     R4,[R3, #+0]
   \   000000B0   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000000B4   0x0440             LSLS     R0,R0,#+17
   \   000000B6   0xD50E             BPL.N    ??HAL_PCD_EP_ClrStall_7
   \   000000B8   0x6810             LDR      R0,[R2, #+0]
   \   000000BA   0x781C             LDRB     R4,[R3, #+0]
   \   000000BC   0xF830 0x0024      LDRH     R0,[R0, R4, LSL #+2]
   \   000000C0   0xF648 0x748F      MOVW     R4,#+36751
   \   000000C4   0x4020             ANDS     R0,R4,R0
   \   000000C6   0xF440 0x4040      ORR      R0,R0,#0xC000
   \   000000CA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000CE   0x6814             LDR      R4,[R2, #+0]
   \   000000D0   0x781D             LDRB     R5,[R3, #+0]
   \   000000D2   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1309              PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
   \                     ??HAL_PCD_EP_ClrStall_7: (+1)
   \   000000D6   0x6814             LDR      R4,[R2, #+0]
   \   000000D8   0x781D             LDRB     R5,[R3, #+0]
   \   000000DA   0xF834 0x4025      LDRH     R4,[R4, R5, LSL #+2]
   \   000000DE   0xF64B 0x758F      MOVW     R5,#+49039
   \   000000E2   0x402C             ANDS     R4,R5,R4
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0xF490 0x5080      EORS     R0,R0,#0x1000
   \   000000EA   0xF490 0x5000      EORS     R0,R0,#0x2000
   \   000000EE   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000F2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F6   0x6814             LDR      R4,[R2, #+0]
   \   000000F8   0x781D             LDRB     R5,[R3, #+0]
   \   000000FA   0xF824 0x0025      STRH     R0,[R4, R5, LSL #+2]
   1310            }
   1311            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_ClrStall_6: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF882 0x01E8      STRB     R0,[R2, #+488]
   1312              
   1313            return HAL_OK;
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_ClrStall_3: (+1)
   \   00000106   0xBC30             POP      {R4,R5}
   \   00000108   0x4770             BX       LR               ;; return
   1314          }
   1315          
   1316          /**
   1317            * @brief  Flush an endpoint
   1318            * @param  hpcd: PCD handle
   1319            * @param  ep_addr: endpoint address
   1320            * @retval HAL status
   1321            */

   \                                 In section .text, align 2, keep-with-next
   1322          HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1323          { 
   \                     HAL_PCD_EP_Flush: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1324            return HAL_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
   1325          }
   1326          
   1327          /**
   1328            * @brief  HAL_PCD_ActivateRemoteWakeup : active remote wakeup signalling
   1329            * @param  hpcd: PCD handle
   1330            * @retval HAL status
   1331            */

   \                                 In section .text, align 2, keep-with-next
   1332          HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1333          {
   \                     HAL_PCD_ActivateRemoteWakeup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1334            hpcd->Instance->CNTR |= USB_CNTR_RESUME;
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000008   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0xF8A2 0x0040      STRH     R0,[R2, #+64]
   1335            return HAL_OK;  
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
   1336          }
   1337          
   1338          /**
   1339            * @brief  HAL_PCD_DeActivateRemoteWakeup : de-active remote wakeup signalling
   1340            * @param  hpcd: PCD handle
   1341            * @retval HAL status
   1342            */

   \                                 In section .text, align 2, keep-with-next
   1343          HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1344          {
   \                     HAL_PCD_DeActivateRemoteWakeup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1345            hpcd->Instance->CNTR &= ~(USB_CNTR_RESUME);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000008   0xF64F 0x72EF      MOVW     R2,#+65519
   \   0000000C   0x4010             ANDS     R0,R2,R0
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0xF8A2 0x0040      STRH     R0,[R2, #+64]
   1346            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   1347          }
   1348          
   1349          /**
   1350            * @}
   1351            */
   1352            
   1353          /** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions 
   1354           *  @brief   Peripheral State functions 
   1355           *
   1356          @verbatim   
   1357           ===============================================================================
   1358                                ##### Peripheral State functions #####
   1359           ===============================================================================  
   1360              [..]
   1361              This subsection permits to get in run-time the status of the peripheral 
   1362              and the data flow.
   1363          
   1364          @endverbatim
   1365            * @{
   1366            */
   1367          
   1368          
   1369          /**
   1370            * @brief  Return the PCD state
   1371            * @param  hpcd : PCD handle
   1372            * @retval HAL state
   1373            */

   \                                 In section .text, align 2, keep-with-next
   1374          PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
   1375          {
   1376            return hpcd->State;
   \                     HAL_PCD_GetState: (+1)
   \   00000000   0xF890 0x01E9      LDRB     R0,[R0, #+489]
   \   00000004   0x4770             BX       LR               ;; return
   1377          }
   1378          
   1379          
   1380          /**
   1381            * @brief  Software Device Connection
   1382            * @param  hpcd: PCD handle
   1383            * @param  state: Device state
   1384            * @retval None
   1385            */

   \                                 In section .text, align 2, keep-with-next
   1386           __weak void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
   1387          {
   1388            /* Prevent unused argument(s) compilation warning */
   1389            UNUSED(hpcd);
   1390            UNUSED(state);
   1391          
   1392            /* NOTE : This function should not be modified, when the callback is needed,
   1393                      the HAL_PCDEx_SetConnectionState could be implenetd in the user file
   1394             */ 
   1395          }
   \                     HAL_PCDEx_SetConnectionState: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1396          
   1397          /**
   1398            * @}
   1399            */
   1400          
   1401          /**
   1402            * @}
   1403            */
   1404          
   1405          
   1406          #endif /* HAL_PCD_MODULE_ENABLED */
   1407          /**
   1408            * @}
   1409            */
   1410          
   1411          /**
   1412            * @}
   1413            */
   1414          
   1415          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PCDEx_SetConnectionState
       0   HAL_PCD_ActivateRemoteWakeup
       0   HAL_PCD_ConnectCallback
       0   HAL_PCD_DataInStageCallback
       0   HAL_PCD_DataOutStageCallback
       0   HAL_PCD_DeActivateRemoteWakeup
       8   HAL_PCD_DeInit
         8   -> HAL_PCD_MspDeInit
         8   -> HAL_PCD_Stop
       8   HAL_PCD_DevConnect
         8   -> HAL_PCDEx_SetConnectionState
       8   HAL_PCD_DevDisconnect
         8   -> HAL_PCDEx_SetConnectionState
       0   HAL_PCD_DisconnectCallback
       8   HAL_PCD_EP_Close
       8   HAL_PCD_EP_ClrStall
       0   HAL_PCD_EP_Flush
       0   HAL_PCD_EP_GetRxCount
      16   HAL_PCD_EP_Open
      16   HAL_PCD_EP_Receive
       8   HAL_PCD_EP_SetStall
      32   HAL_PCD_EP_Transmit
        32   -> PCD_WritePMA
       0   HAL_PCD_GetState
      16   HAL_PCD_IRQHandler
        16   -> HAL_PCD_ResetCallback
        16   -> HAL_PCD_ResumeCallback
        16   -> HAL_PCD_SOFCallback
        16   -> HAL_PCD_SetAddress
        16   -> HAL_PCD_SuspendCallback
        16   -> PCD_EP_ISR_Handler
       0   HAL_PCD_ISOINIncompleteCallback
       0   HAL_PCD_ISOOUTIncompleteCallback
      16   HAL_PCD_Init
        16   -> HAL_PCD_MspInit
       0   HAL_PCD_MspDeInit
       0   HAL_PCD_MspInit
       0   HAL_PCD_ResetCallback
       0   HAL_PCD_ResumeCallback
       0   HAL_PCD_SOFCallback
       0   HAL_PCD_SetAddress
       0   HAL_PCD_SetupStageCallback
       8   HAL_PCD_Start
         8   -> HAL_PCDEx_SetConnectionState
       0   HAL_PCD_Stop
       0   HAL_PCD_SuspendCallback
      24   PCD_EP_ISR_Handler
        24   -> HAL_PCD_DataInStageCallback
        24   -> HAL_PCD_DataOutStageCallback
        24   -> HAL_PCD_EP_Receive
        24   -> HAL_PCD_EP_Transmit
        24   -> HAL_PCD_SetupStageCallback
        24   -> PCD_ReadPMA
        24   -> PCD_WritePMA
      16   PCD_ReadPMA
      20   PCD_WritePMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  HAL_PCDEx_SetConnectionState
      22  HAL_PCD_ActivateRemoteWakeup
       2  HAL_PCD_ConnectCallback
       2  HAL_PCD_DataInStageCallback
       2  HAL_PCD_DataOutStageCallback
      24  HAL_PCD_DeActivateRemoteWakeup
      40  HAL_PCD_DeInit
      40  HAL_PCD_DevConnect
      40  HAL_PCD_DevDisconnect
       2  HAL_PCD_DisconnectCallback
     620  HAL_PCD_EP_Close
     266  HAL_PCD_EP_ClrStall
       6  HAL_PCD_EP_Flush
      20  HAL_PCD_EP_GetRxCount
    1142  HAL_PCD_EP_Open
     428  HAL_PCD_EP_Receive
     222  HAL_PCD_EP_SetStall
     590  HAL_PCD_EP_Transmit
       6  HAL_PCD_GetState
     324  HAL_PCD_IRQHandler
       2  HAL_PCD_ISOINIncompleteCallback
       2  HAL_PCD_ISOOUTIncompleteCallback
     288  HAL_PCD_Init
       2  HAL_PCD_MspDeInit
       2  HAL_PCD_MspInit
       2  HAL_PCD_ResetCallback
       2  HAL_PCD_ResumeCallback
       2  HAL_PCD_SOFCallback
      50  HAL_PCD_SetAddress
       2  HAL_PCD_SetupStageCallback
      16  HAL_PCD_Start
      54  HAL_PCD_Stop
       2  HAL_PCD_SuspendCallback
    1082  PCD_EP_ISR_Handler
      44  PCD_ReadPMA
      64  PCD_WritePMA

 
 5 416 bytes in section .text
 
 5 416 bytes of CODE memory

Errors: none
Warnings: none
