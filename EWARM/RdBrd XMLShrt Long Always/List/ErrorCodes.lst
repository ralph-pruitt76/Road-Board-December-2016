###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       03/Jan/2018  15:19:24
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\ErrorCodes.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\ErrorCodes.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\ErrorCodes.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\ErrorCodes.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\ErrorCodes.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : ErrorCodes.c
      4            * Description        : This file provides code for the processing and control
      5            * error buffer.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 WeatherCloud
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of WeatherCloud nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "ErrorCodes.h"
     37          #include "usart.h"
     38          #include "gpio.h"
     39          #include "i2c.h"
     40          #include <stdio.h>
     41          #include <string.h>
     42          
     43          
     44          // Constant Strings Definition

   \                                 In section .rodata, align 4
     45          const char * const CodesArray[] = { "       ",                      // CODE 000: NULL...NO Error Code
   \                     CodesArray:
   \   00000000   0x........         DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7, ?_8, ?_9, ?_10, ?_11, ?_12
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000034   0x........         DC32 ?_13, ?_14, ?_15, ?_16, ?_17, ?_18, ?_19, ?_20, ?_0, ?_0, ?_0
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     46                                              "I2CBUSY",                      // CODE 001: I2C Bus detected busy. Rogue I2C part holding bus low.
     47                                              "VM_INIT",                      // CODE 002: Initialization of V Monitor Code failed.
     48                                              "BGMSYNC",                      // CODE 003: BGM111 processing code has detected a sync error on traffic from BGM111.
     49                                              "GEYE_IN",                      // CODE 004: Initialization of Grid Eye Sensor failed.
     50                                              "PRSS_IN",                      // CODE 005: Initialization of Pressure Sensor failed.
     51                                              "BGMRFUL",                      // CODE 006: BGM111 processing code has detected a Receive Buffer Full error on traffic from BGM111.
     52                                              "HUMD_IN",                      // CODE 007: Initialization of Humidity Sensor failed.
     53                                              "RGBINIT",                      // CODE 008: Initialization of RGB Sensor failed.
     54                                              "TEMPINI",                      // CODE 009: Initialization of Temperature Sensor failed.
     55                                              "CEYE_IN",                      // CODE 010: Initialization of Cool Eye Sensor failed.
     56                                              "I2CSCLK",                      // CODE 011: I2C Bus Test Failed. SCLK held low.
     57                                              "I2CSDAT",                      // CODE 012: I2C Bus Test Failed. SDAT held low.
     58                                              "BGMCNCT",                      // CODE 013: BGM111 processing code has detected a Connection Dropped Event.
     59                                              "BGMHRBT",                      // CODE 014: BGM111 processing code has detected a Heart Beat Timeout Event.
     60                                              "BGTXFUL",                      // CODE 015: BGM111 processing code has detected a Transmit Buffer Full error on traffic to BGM111.
     61                                              "FRMINIT",                      // CODE 016: Could not Initialize Flash Frame.
     62                                              "BGMOVFL",                      // CODE 017: BGM111 processing code has detected Serial Stream Overflow.
     63                                              "BGMSCNC",                      // CODE 018: BGM111 processing code has detected a SYNC Connection Dropped Event.
     64                                              "CALINIT",                      // CODE 019: Could not Initialize Calibration Flash Structure.
     65                                              "RPR_I2C",                      // CODE 020: I2C Bus has been repaired.
     66                                              "       ",                      // CODE 021: NULL...
     67                                              "       ",                      // CODE 022: NULL...
     68                                              "       " };                    // CODE 023: NULL...

   \                                 In section .rodata, align 4
     69          const char * const ModuleArray[] = { "       ",                     // CODE 000: NULL...NO Device Code
   \                     ModuleArray:
   \   00000000   0x........         DC32 ?_0, ?_21, ?_22, ?_23, ?_24, ?_0, ?_0, ?_0
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     70                                               "   main",                     // CODE 001: module: main.c
     71                                               " bgm111",                     // CODE 002: module: bgm111.c
     72                                               "    i2c",                     // CODE 003: module: i2c.c...
     73                                               "AppData",                     // CODE 004: module: app_data.c
     74                                               "       ",                     // CODE 005: module: NULL...
     75                                               "       ",                     // CODE 006: module: NULL...
     76                                               "       " };                   // CODE 007: module: NULL...
     77              
     78          /* Error Code structure */
     79          struct
     80          {
     81            ErrorElement error_buf[ERR_DATA_LENGTH];
     82            volatile uint16_t error_wr;
     83            uint16_t error_rd;

   \                                 In section .bss, align 4
     84          } static errStruct;
   \                     errStruct:
   \   00000000                      DS8 804
     85          
     86          //*
     87          //* Define Internal Buffer handling routines.
     88          //* 
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void RBBuffer_LowLevel_Init(void)
     91          {
     92            errStruct.error_wr = 0;
   \                     RBBuffer_LowLevel_Init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0xF8A1 0x0320      STRH     R0,[R1, #+800]
     93            errStruct.error_rd = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable4
   \   0000000C   0xF8A1 0x0322      STRH     R0,[R1, #+802]
     94          }
   \   00000010   0x4770             BX       LR               ;; return
     95          
     96          /* Next buffer index based on current index and buffer size */
     97          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
     98          uint16_t RBNextBufIdx(uint16_t idx)
     99          {
    100            idx++;
   \                     RBNextBufIdx: (+1)
   \   00000000   0x1C40             ADDS     R0,R0,#+1
    101            return idx < ERR_DATA_LENGTH ? idx : 0;
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2864             CMP      R0,#+100
   \   00000006   0xDB00             BLT.N    ??RBNextBufIdx_0
   \                     ??RBNextBufIdx_1: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??RBNextBufIdx_0: (+1)
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    102          }
    103          
    104          /* Report if the buffer is full based on its indexes */
    105          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
    106          bool RBIsBufFull(uint16_t wr_idx, uint16_t rd_idx)
    107          {
   \                     RBIsBufFull: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    108            return RBNextBufIdx(wr_idx) == rd_idx;
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0x.... 0x....      BL       RBNextBufIdx
   \   0000000E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000010   0x42A8             CMP      R0,R5
   \   00000012   0xD101             BNE.N    ??RBIsBufFull_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??RBIsBufFull_1
   \                     ??RBIsBufFull_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??RBIsBufFull_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    109          }
    110          
    111          /* Get the used space in the buffer based on its indexes */
    112          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
    113          uint16_t RBBufUsed(uint16_t wr_idx, uint16_t rd_idx)
    114          {
   \                     RBBufUsed: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    115            int size = (int)wr_idx - (int)rd_idx;
   \   00000002   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x1A50             SUBS     R0,R2,R1
    116            if (size < 0)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD500             BPL.N    ??RBBufUsed_0
    117            {
    118              size = ERR_DATA_LENGTH + size;
   \   0000000C   0x3064             ADDS     R0,R0,#+100
    119            }
    120            return size;
   \                     ??RBBufUsed_0: (+1)
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x4770             BX       LR               ;; return
    121          }
    122          
    123          /* Get the free space in the buffer based on its indexes */
    124          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
    125          uint16_t RBBufFree(uint16_t wr_idx, uint16_t rd_idx)
    126          {
   \                     RBBufFree: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    127            return (ERR_DATA_LENGTH - 1) - RBBufUsed(wr_idx, rd_idx);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x.... 0x....      BL       RBBufUsed
   \   00000012   0xF1D0 0x0063      RSBS     R0,R0,#+99
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    128          }
    129          
    130          /**
    131            * @brief  This function initializes the Error Code Tracking Structure.
    132            * @retval HAL_StatusTypeDef:     HAL_OK:       No Errors
    133            *                                HAL_ERROR:    Error Found during initialization.
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          HAL_StatusTypeDef RdBrd_ErrCdInit( void )
    136          {
   \                     RdBrd_ErrCdInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    137            RBBuffer_LowLevel_Init();              // Reset all Internal Pointers.
   \   00000002   0x.... 0x....      BL       RBBuffer_LowLevel_Init
    138            return HAL_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    139          }
    140          
    141          /**
    142            * @brief  This function returns the current Error Count in the Error Buffer..
    143            * @retval uint16_t:     Number of errors being tracked
    144            */

   \                                 In section .text, align 2, keep-with-next
    145          uint16_t  RdBrd_ErrCdGetErrCnt( void )
    146          {
   \                     RdBrd_ErrCdGetErrCnt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    147            return RBBufUsed(errStruct.error_wr, errStruct.error_rd);
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0xF8B0 0x1322      LDRH     R1,[R0, #+802]
   \   00000008   0x....             LDR.N    R0,??DataTable4
   \   0000000A   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   0000000E   0x.... 0x....      BL       RBBufUsed
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    148          }
    149          
    150           /**
    151            * @brief  This function returns the current pointer at the next code to be processed.
    152            * @retval ErrorElmntPtr:     Points to the next code to be processed.
    153            */

   \                                 In section .text, align 2, keep-with-next
    154          ErrorElmntPtr  RdBrd_ErrCdGetCrntErrCd( void )
    155          {
    156            return &errStruct.error_buf[errStruct.error_rd];
   \                     RdBrd_ErrCdGetCrntErrCd: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0xF8B1 0x1322      LDRH     R1,[R1, #+802]
   \   00000008   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000000C   0x4770             BX       LR               ;; return
    157          }
    158          
    159           /**
    160            * @brief  This function returns the current pointer at the next code to be processed and
    161            * 		   and increments the pointer to the next code.
    162            * @retval ErrorElmntPtr:     Points to the next code to be processed.
    163            */

   \                                 In section .text, align 2, keep-with-next
    164          ErrorElmntPtr  RdBrd_ErrCdGetNxtErrCd( void )
    165          {
   \                     RdBrd_ErrCdGetNxtErrCd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    166            ErrorElmntPtr TempPtr;
    167            
    168            // Get Current Pointer
    169            TempPtr = &errStruct.error_buf[errStruct.error_rd];
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x....             LDR.N    R1,??DataTable4
   \   00000006   0xF8B1 0x1322      LDRH     R1,[R1, #+802]
   \   0000000A   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000000E   0x0004             MOVS     R4,R0
    170            // Update Read Pointer and return.
    171            errStruct.error_rd = RBNextBufIdx(errStruct.error_rd);
   \   00000010   0x....             LDR.N    R0,??DataTable4
   \   00000012   0xF8B0 0x0322      LDRH     R0,[R0, #+802]
   \   00000016   0x.... 0x....      BL       RBNextBufIdx
   \   0000001A   0x....             LDR.N    R1,??DataTable4
   \   0000001C   0xF8A1 0x0322      STRH     R0,[R1, #+802]
    172            return TempPtr;
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    173          }
    174          
    175          /**
    176            * @brief  This function returns the current pointer at the next code to be processed and
    177            * 		   and increments the pointer to the next code.
    178            * @retval HAL_StatusTypeDef:     HAL_OK:       Error Code logged
    179            *                                HAL_ERROR:    Error Log full or Bad Code
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          HAL_StatusTypeDef RdBrd_ErrCdLogErrCd( ErrorCodes ErrorCd, ModuleCodes DeviceCd )
    182          {
   \                     RdBrd_ErrCdLogErrCd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    183            uint8_t tempBffr2[80];
    184            HAL_StatusTypeDef Status;
    185            
    186            // Is Buffer Full?
    187            if ( RBIsBufFull(errStruct.error_wr, errStruct.error_rd) )
   \   00000008   0x....             LDR.N    R0,??DataTable4
   \   0000000A   0xF8B0 0x1322      LDRH     R1,[R0, #+802]
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   00000014   0x.... 0x....      BL       RBIsBufFull
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??RdBrd_ErrCdLogErrCd_0
    188              return HAL_ERROR;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE060             B.N      ??RdBrd_ErrCdLogErrCd_1
    189            
    190            // Pass passed Information to indexed Entry.
    191            errStruct.error_buf[errStruct.error_wr].DeviceCd = DeviceCd;
   \                     ??RdBrd_ErrCdLogErrCd_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable4
   \   00000022   0x....             LDR.N    R1,??DataTable4
   \   00000024   0xF8B1 0x1320      LDRH     R1,[R1, #+800]
   \   00000028   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000002C   0x8045             STRH     R5,[R0, #+2]
    192            errStruct.error_buf[errStruct.error_wr].ErrorCd = ErrorCd;
   \   0000002E   0x....             LDR.N    R0,??DataTable4
   \   00000030   0x....             LDR.N    R1,??DataTable4
   \   00000032   0xF8B1 0x1320      LDRH     R1,[R1, #+800]
   \   00000036   0xF820 0x4031      STRH     R4,[R0, R1, LSL #+3]
    193            errStruct.error_buf[errStruct.error_wr].halTick = HAL_GetTick();
   \   0000003A   0x....             LDR.N    R0,??DataTable4
   \   0000003C   0xF8B0 0x7320      LDRH     R7,[R0, #+800]
   \   00000040   0x.... 0x....      BL       HAL_GetTick
   \   00000044   0x....             LDR.N    R1,??DataTable4
   \   00000046   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000048   0xEB01 0x01C7      ADD      R1,R1,R7, LSL #+3
   \   0000004C   0x6048             STR      R0,[R1, #+4]
    194            
    195            // Update Write Pointer.
    196            errStruct.error_wr = RBNextBufIdx(errStruct.error_wr);
   \   0000004E   0x....             LDR.N    R0,??DataTable4
   \   00000050   0xF8B0 0x0320      LDRH     R0,[R0, #+800]
   \   00000054   0x.... 0x....      BL       RBNextBufIdx
   \   00000058   0x....             LDR.N    R1,??DataTable4
   \   0000005A   0xF8A1 0x0320      STRH     R0,[R1, #+800]
    197            //strcpy( (char *)tempBffr2, "ERROR: ERROR_I2CBUSY\r\n\r\n");
    198            //strcpy( (char *)tempBffr2, CodesArray[ErrorCd]);
    199            sprintf( (char *)tempBffr2, "%s ERROR: %s\r\n\r\n", ModuleArray[DeviceCd], CodesArray[ErrorCd]);
   \   0000005E   0x....             LDR.N    R0,??DataTable4_1
   \   00000060   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000062   0xF850 0x3024      LDR      R3,[R0, R4, LSL #+2]
   \   00000066   0x....             LDR.N    R0,??DataTable4_2
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0xF850 0x2025      LDR      R2,[R0, R5, LSL #+2]
   \   0000006E   0x....             LDR.N    R1,??DataTable4_3
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x.... 0x....      BL       sprintf
    200            // Send msg to App via Characteristics.
    201            SendApp_String( tempBffr2 );
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x.... 0x....      BL       SendApp_String
    202            // Send string to UART..
    203          /*#ifdef REV_L
    204            Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
    205            // Wait for msg to be completed.
    206            while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    207            {
    208            }
    209            // Clear State for Next Transfer.
    210            clrUsartState( MONITOR_UART );
    211          #else */
    212            Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000084   0x0006             MOVS     R6,R0
    213            // Only Generate BLEHD messages once BLEHD Channel active.
    214            if ( BGM111_DataConnected())
   \   00000086   0x.... 0x....      BL       BGM111_DataConnected
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD027             BEQ.N    ??RdBrd_ErrCdLogErrCd_2
    215            {
    216              // Generate BLEHD Status Message
    217              sprintf( (char *)tempBffr2, "<STATUS>%s ERROR: %s</STATUS>",
    218                      ModuleArray[DeviceCd],
    219                      CodesArray[ErrorCd]);
   \   0000008E   0x....             LDR.N    R0,??DataTable4_1
   \   00000090   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000092   0xF850 0x3024      LDR      R3,[R0, R4, LSL #+2]
   \   00000096   0x....             LDR.N    R0,??DataTable4_2
   \   00000098   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009A   0xF850 0x2025      LDR      R2,[R0, R5, LSL #+2]
   \   0000009E   0x....             LDR.N    R1,??DataTable4_4
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x.... 0x....      BL       sprintf
    220              Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000000A6   0x4669             MOV      R1,SP
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000000AE   0x0006             MOVS     R6,R0
    221              if (Status != HAL_OK)
   \   000000B0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B2   0x2E00             CMP      R6,#+0
   \   000000B4   0xD002             BEQ.N    ??RdBrd_ErrCdLogErrCd_3
    222                return Status;
   \   000000B6   0x0030             MOVS     R0,R6
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0xE012             B.N      ??RdBrd_ErrCdLogErrCd_1
    223              Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)"\r\n\r\n");
   \                     ??RdBrd_ErrCdLogErrCd_3: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable4_5
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   000000C4   0x0006             MOVS     R6,R0
    224              if (Status != HAL_OK)
   \   000000C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C8   0x2E00             CMP      R6,#+0
   \   000000CA   0xD002             BEQ.N    ??RdBrd_ErrCdLogErrCd_4
    225                return Status;
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0xE007             B.N      ??RdBrd_ErrCdLogErrCd_1
    226              BGM111_Transmit((uint32_t)(strlen((char *)tempBffr2)), tempBffr2);
   \                     ??RdBrd_ErrCdLogErrCd_4: (+1)
   \   000000D2   0x4668             MOV      R0,SP
   \   000000D4   0x.... 0x....      BL       strlen
   \   000000D8   0x4669             MOV      R1,SP
   \   000000DA   0x.... 0x....      BL       BGM111_Transmit
    227            }
    228          
    229          //#endif
    230            
    231            return Status;
   \                     ??RdBrd_ErrCdLogErrCd_2: (+1)
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RdBrd_ErrCdLogErrCd_1: (+1)
   \   000000E2   0xB015             ADD      SP,SP,#+84
   \   000000E4   0xBDF0             POP      {R4-R7,PC}       ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void RdBrd_BlinkErrCd( ErrorCodes ErrorCd )
    235          {
   \                     RdBrd_BlinkErrCd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    236            int x;
    237            // Pull the BGM111 reset pin low 
    238            RoadBrd_gpio_Off( gRESET_BGM111 );
   \   00000004   0x2006             MOVS     R0,#+6
   \   00000006   0x.... 0x....      BL       RoadBrd_gpio_Off
    239          
    240            for (x=0; x<ErrorCd; x++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??RdBrd_BlinkErrCd_0: (+1)
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x42A5             CMP      R5,R4
   \   00000012   0xDA0D             BGE.N    ??RdBrd_BlinkErrCd_1
    241            {
    242              //SetLED(true);
    243              RoadBrd_gpio_On(BLUE_LED);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       RoadBrd_gpio_On
    244              RoadBrd_Delay2( 100 );
   \   0000001A   0x2064             MOVS     R0,#+100
   \   0000001C   0x.... 0x....      BL       RoadBrd_Delay2
    245              //SetLED(false);
    246              RoadBrd_gpio_Off(BLUE_LED);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       RoadBrd_gpio_Off
    247              RoadBrd_Delay2( 100 );
   \   00000026   0x2064             MOVS     R0,#+100
   \   00000028   0x.... 0x....      BL       RoadBrd_Delay2
    248            }
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \   0000002E   0xE7EE             B.N      ??RdBrd_BlinkErrCd_0
    249            //SetLED(true);
    250            RoadBrd_gpio_On(BLUE_LED);
   \                     ??RdBrd_BlinkErrCd_1: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       RoadBrd_gpio_On
    251            RoadBrd_Delay2( 1000 );
   \   00000036   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003A   0x.... 0x....      BL       RoadBrd_Delay2
    252            //SetLED(false
    253            RoadBrd_gpio_Off(BLUE_LED);
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       RoadBrd_gpio_Off
    254            RoadBrd_Delay2( 1000 );
   \   00000044   0xF44F 0x707A      MOV      R0,#+1000
   \   00000048   0x.... 0x....      BL       RoadBrd_Delay2
    255          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    256          
    257          /**
    258            * @brief  void RoadBrd_Delay( __IO uint32_t Delay ): Implement Delay by calling looping.
    259            *             NOTE: This avoids HAL_Delay since this could hang the processor in error handling.
    260            * @param Delay: specifies the delay time length, in milliseconds.
    261            * @retval None
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          void RoadBrd_Delay2( __IO uint32_t Delay )
    264          {
   \                     RoadBrd_Delay2: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    265            while( Delay != 0)
   \                     ??RoadBrd_Delay2_0: (+1)
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??RoadBrd_Delay2_1
    266            {
    267              delay_1ms();
   \   00000008   0x.... 0x....      BL       delay_1ms
    268              Delay--;
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0xE7F6             B.N      ??RoadBrd_Delay2_0
    269            }
    270          }
   \                     ??RoadBrd_Delay2_1: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    271          
    272          /**
    273            * @brief  This routine delays for 1 msec and returns
    274            *         from the BGM111
    275            * @param  none
    276            * @retval none
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          void delay_1ms( void )
    279          {
    280            uint32_t count = 4400;      // Delay loop for 10msec
   \                     delay_1ms: (+1)
   \   00000000   0xF241 0x1030      MOVW     R0,#+4400
    281            
    282            while (count != 0)
   \                     ??delay_1ms_0: (+1)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??delay_1ms_1
    283            {
    284              count--;
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0xE7FB             B.N      ??delay_1ms_0
    285            }
    286          }
   \                     ??delay_1ms_1: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    287          
    288          //*****************************************************************************************************
    289          //*
    290          //* Exception Processing Code Here
    291          //*
    292          //*****************************************************************************************************
    293          
    294          /**
    295            * @brief  Hard Fault Exception Handler
    296            * @param  none
    297            * @retval none
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          void HardFault_Handler(void)
    300          { 
   \                     HardFault_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    301            SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    302            RdBrd_ErrCdLogErrCd( ERROR_BGM_OVERFLOW, MODULE_bgm111 );
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x2011             MOVS     R0,#+17
   \   0000000A   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    303            HAL_NVIC_SystemReset();
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_SystemReset
    304          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    305          
    306          /**
    307            * @brief  Hard Fault Exception Handler
    308            * @param  none
    309            * @retval none
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          void MemManage_Handler(void)
    312          { 
   \                     MemManage_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    313            SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    314            RdBrd_ErrCdLogErrCd( ERROR_BGM_OVERFLOW, MODULE_bgm111 );
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x2011             MOVS     R0,#+17
   \   0000000A   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    315            HAL_NVIC_SystemReset();
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_SystemReset
    316          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    317          
    318          /**
    319            * @brief  Useage Fault Exception Handler
    320            * @param  none
    321            * @retval none
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          void UsageFault_Handler(void)
    324          { 
   \                     UsageFault_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    325            SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    326            RdBrd_ErrCdLogErrCd( ERROR_BGM_OVERFLOW, MODULE_bgm111 );
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x2011             MOVS     R0,#+17
   \   0000000A   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    327            HAL_NVIC_SystemReset();
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_SystemReset
    328          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     errStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     CodesArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     ModuleArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     ?_27

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x20 0x20          DC8 "       "
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x49 0x32          DC8 "I2CBUSY"
   \              0x43 0x42    
   \              0x55 0x53    
   \              0x59 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x56 0x4D          DC8 "VM_INIT"
   \              0x5F 0x49    
   \              0x4E 0x49    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x42 0x47          DC8 "BGMSYNC"
   \              0x4D 0x53    
   \              0x59 0x4E    
   \              0x43 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x47 0x45          DC8 "GEYE_IN"
   \              0x59 0x45    
   \              0x5F 0x49    
   \              0x4E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x50 0x52          DC8 "PRSS_IN"
   \              0x53 0x53    
   \              0x5F 0x49    
   \              0x4E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x42 0x47          DC8 "BGMRFUL"
   \              0x4D 0x52    
   \              0x46 0x55    
   \              0x4C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x48 0x55          DC8 "HUMD_IN"
   \              0x4D 0x44    
   \              0x5F 0x49    
   \              0x4E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x52 0x47          DC8 "RGBINIT"
   \              0x42 0x49    
   \              0x4E 0x49    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x54 0x45          DC8 "TEMPINI"
   \              0x4D 0x50    
   \              0x49 0x4E    
   \              0x49 0x00    

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x43 0x45          DC8 "CEYE_IN"
   \              0x59 0x45    
   \              0x5F 0x49    
   \              0x4E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x49 0x32          DC8 "I2CSCLK"
   \              0x43 0x53    
   \              0x43 0x4C    
   \              0x4B 0x00    

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x49 0x32          DC8 "I2CSDAT"
   \              0x43 0x53    
   \              0x44 0x41    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x42 0x47          DC8 "BGMCNCT"
   \              0x4D 0x43    
   \              0x4E 0x43    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x42 0x47          DC8 "BGMHRBT"
   \              0x4D 0x48    
   \              0x52 0x42    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x42 0x47          DC8 "BGTXFUL"
   \              0x54 0x58    
   \              0x46 0x55    
   \              0x4C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x46 0x52          DC8 "FRMINIT"
   \              0x4D 0x49    
   \              0x4E 0x49    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x42 0x47          DC8 "BGMOVFL"
   \              0x4D 0x4F    
   \              0x56 0x46    
   \              0x4C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_18:
   \   00000000   0x42 0x47          DC8 "BGMSCNC"
   \              0x4D 0x53    
   \              0x43 0x4E    
   \              0x43 0x00    

   \                                 In section .rodata, align 4
   \                     ?_19:
   \   00000000   0x43 0x41          DC8 "CALINIT"
   \              0x4C 0x49    
   \              0x4E 0x49    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_20:
   \   00000000   0x52 0x50          DC8 "RPR_I2C"
   \              0x52 0x5F    
   \              0x49 0x32    
   \              0x43 0x00    

   \                                 In section .rodata, align 4
   \                     ?_21:
   \   00000000   0x20 0x20          DC8 "   main"
   \              0x20 0x6D    
   \              0x61 0x69    
   \              0x6E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_22:
   \   00000000   0x20 0x62          DC8 " bgm111"
   \              0x67 0x6D    
   \              0x31 0x31    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     ?_23:
   \   00000000   0x20 0x20          DC8 "    i2c"
   \              0x20 0x20    
   \              0x69 0x32    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_24:
   \   00000000   0x41 0x70          DC8 "AppData"
   \              0x70 0x44    
   \              0x61 0x74    
   \              0x61 0x00    

   \                                 In section .rodata, align 4
   \                     ?_25:
   \   00000000   0x25 0x73          DC8 "%s ERROR: %s\015\012\015\012"
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x0D 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_26:
   \   00000000   0x3C 0x53          DC8 "<STATUS>%s ERROR: %s</STATUS>"
   \              0x54 0x41    
   \              0x54 0x55    
   \              0x53 0x3E    
   \              0x25 0x73    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x3C 0x2F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x55 0x53    
   \              0x3E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_27:
   \   00000000   0x0D 0x0A          DC8 "\015\012\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    329          
    330          
    331          
    332          /************************ (C) COPYRIGHT WeatherCloud *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HardFault_Handler
         8   -> HAL_NVIC_SystemReset
         8   -> RdBrd_ErrCdLogErrCd
         8   -> SystemInit
       8   MemManage_Handler
         8   -> HAL_NVIC_SystemReset
         8   -> RdBrd_ErrCdLogErrCd
         8   -> SystemInit
      16   RBBufFree
        16   -> RBBufUsed
       0   RBBufUsed
       0   RBBuffer_LowLevel_Init
      16   RBIsBufFull
        16   -> RBNextBufIdx
       0   RBNextBufIdx
      16   RdBrd_BlinkErrCd
        16   -> RoadBrd_Delay2
        16   -> RoadBrd_gpio_Off
        16   -> RoadBrd_gpio_On
       0   RdBrd_ErrCdGetCrntErrCd
       8   RdBrd_ErrCdGetErrCnt
         8   -> RBBufUsed
       8   RdBrd_ErrCdGetNxtErrCd
         8   -> RBNextBufIdx
       8   RdBrd_ErrCdInit
         8   -> RBBuffer_LowLevel_Init
     104   RdBrd_ErrCdLogErrCd
       104   -> BGM111_DataConnected
       104   -> BGM111_Transmit
       104   -> HAL_GetTick
       104   -> RBIsBufFull
       104   -> RBNextBufIdx
       104   -> RoadBrd_UART_Transmit
       104   -> SendApp_String
       104   -> sprintf
       104   -> strlen
       8   RoadBrd_Delay2
         8   -> delay_1ms
       8   UsageFault_Handler
         8   -> HAL_NVIC_SystemReset
         8   -> RdBrd_ErrCdLogErrCd
         8   -> SystemInit
       0   delay_1ms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       8  ?_0
       8  ?_1
       8  ?_10
       8  ?_11
       8  ?_12
       8  ?_13
       8  ?_14
       8  ?_15
       8  ?_16
       8  ?_17
       8  ?_18
       8  ?_19
       8  ?_2
       8  ?_20
       8  ?_21
       8  ?_22
       8  ?_23
       8  ?_24
      20  ?_25
      32  ?_26
       8  ?_27
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
       8  ?_8
       8  ?_9
      96  CodesArray
      20  HardFault_Handler
      20  MemManage_Handler
      32  ModuleArray
      26  RBBufFree
      18  RBBufUsed
      18  RBBuffer_LowLevel_Init
      30  RBIsBufFull
      14  RBNextBufIdx
      78  RdBrd_BlinkErrCd
      14  RdBrd_ErrCdGetCrntErrCd
      20  RdBrd_ErrCdGetErrCnt
      36  RdBrd_ErrCdGetNxtErrCd
      10  RdBrd_ErrCdInit
     230  RdBrd_ErrCdLogErrCd
      22  RoadBrd_Delay2
      20  UsageFault_Handler
      14  delay_1ms
     804  errStruct

 
 804 bytes in section .bss
 388 bytes in section .rodata
 614 bytes in section .text
 
 614 bytes of CODE  memory
 388 bytes of CONST memory
 804 bytes of DATA  memory

Errors: none
Warnings: none
