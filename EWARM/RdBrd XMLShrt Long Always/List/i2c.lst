###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       08/Dec/2017  07:22:54
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\i2c.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\i2c.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : I2C.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the I2C instances.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "i2c.h"
     37          #include "wwdg.h"
     38          
     39          #include "gpio.h"
     40              
     41          /* USER CODE BEGIN 0 */
     42          #include "stm32l1xx_hal.h"
     43          #include "ErrorCodes.h"
     44          #include "app_data.h"
     45          #include "usart.h"
     46          
     47          #define I2C_TIMEOUT_FLAG          ((uint32_t)35)      /* 35 ms */
     48          
     49          static HAL_StatusTypeDef RdBrdI2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
     50          
     51          /* USER CODE END 0 */
     52          

   \                                 In section .bss, align 4
     53          I2C_HandleTypeDef hi2c1;
   \                     hi2c1:
   \   00000000                      DS8 60
     54          
     55          /* I2C1 init function */

   \                                 In section .text, align 2, keep-with-next
     56          void MX_I2C1_Init(void)
     57          {
   \                     MX_I2C1_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     58          
     59            hi2c1.Instance = I2C1;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     60            hi2c1.Init.ClockSpeed = 20000;
   \   0000000C   0xF644 0x6020      MOVW     R0,#+20000
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000014   0x6048             STR      R0,[R1, #+4]
     61            //hi2c1.Init.ClockSpeed = 10000;
     62            hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     63            hi2c1.Init.OwnAddress1 = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     64            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   00000026   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000002E   0x6108             STR      R0,[R1, #+16]
     65            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000036   0x6148             STR      R0,[R1, #+20]
     66            hi2c1.Init.OwnAddress2 = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000003E   0x6188             STR      R0,[R1, #+24]
     67            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000046   0x61C8             STR      R0,[R1, #+28]
     68            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000004E   0x6208             STR      R0,[R1, #+32]
     69            if (HAL_I2C_Init(&hi2c1) != HAL_OK)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000054   0x.... 0x....      BL       HAL_I2C_Init
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??MX_I2C1_Init_0
     70            {
     71              Error_Handler();
   \   0000005C   0x.... 0x....      BL       Error_Handler
     72            }
     73          
     74          }
   \                     ??MX_I2C1_Init_0: (+1)
   \   00000060   0xBD01             POP      {R0,PC}          ;; return
     75          

   \                                 In section .text, align 2, keep-with-next
     76          void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
     77          {
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
     78          
     79            GPIO_InitTypeDef GPIO_InitStruct;
     80            if(i2cHandle->Instance==I2C1)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40005400
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD11D             BNE.N    ??HAL_I2C_MspInit_0
     81            {
     82            /* USER CODE BEGIN I2C1_MspInit 0 */
     83          
     84            /* USER CODE END I2C1_MspInit 0 */
     85            
     86              /**I2C1 GPIO Configuration    
     87              PB6     ------> I2C1_SCL
     88              PB7     ------> I2C1_SDA 
     89              */
     90              GPIO_InitStruct.Pin = I2C_SCL_Pin|I2C_SDA_Pin;
   \   00000010   0x20C0             MOVS     R0,#+192
   \   00000012   0x9001             STR      R0,[SP, #+4]
     91              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x9002             STR      R0,[SP, #+8]
     92              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9003             STR      R0,[SP, #+12]
     93              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x9004             STR      R0,[SP, #+16]
     94              GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x9005             STR      R0,[SP, #+20]
     95              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40020400
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_Init
     96          
     97              /* Peripheral clock enable */
     98              __HAL_RCC_I2C1_CLK_ENABLE();
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023824
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
     99            /* USER CODE BEGIN I2C1_MspInit 1 */
    100          
    101            /* USER CODE END I2C1_MspInit 1 */
    102            }
    103          }
   \                     ??HAL_I2C_MspInit_0: (+1)
   \   0000004C   0xB006             ADD      SP,SP,#+24
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
    106          {
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    107          
    108            if(i2cHandle->Instance==I2C1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40005400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD10C             BNE.N    ??HAL_I2C_MspDeInit_0
    109            {
    110            /* USER CODE BEGIN I2C1_MspDeInit 0 */
    111          
    112            /* USER CODE END I2C1_MspDeInit 0 */
    113              /* Peripheral clock disable */
    114              __HAL_RCC_I2C1_CLK_DISABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023824
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    115            
    116              /**I2C1 GPIO Configuration    
    117              PB6     ------> I2C1_SCL
    118              PB7     ------> I2C1_SDA 
    119              */
    120              HAL_GPIO_DeInit(GPIOB, I2C_SCL_Pin|I2C_SDA_Pin);
   \   0000001E   0x21C0             MOVS     R1,#+192
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40020400
   \   00000024   0x.... 0x....      BL       HAL_GPIO_DeInit
    121          
    122            }
    123            /* USER CODE BEGIN I2C1_MspDeInit 1 */
    124          
    125            /* USER CODE END I2C1_MspDeInit 1 */
    126          } 
   \                     ??HAL_I2C_MspDeInit_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    127          
    128          /* USER CODE BEGIN 1 */
    129          /* I2C1 Reset Function */

   \                                 In section .text, align 2, keep-with-next
    130          void MX_I2C1_Reset(void)
    131          {
   \                     MX_I2C1_Reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    132            // Disabe I2C first.
    133            __HAL_I2C_DISABLE(&hi2c1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
    134            
    135            // Soft Reset I2C Now.
    136            SET_BIT(hi2c1.Instance->CR1, I2C_CR1_SWRST);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
    137            
    138            // Hold Reset for 5 msec.
    139            RoadBrd_Delay( 5 );
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0x.... 0x....      BL       RoadBrd_Delay
    140             
    141            // Clear Reset State.
    142            CLEAR_BIT(hi2c1.Instance->CR1, I2C_CR1_SWRST);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x6008             STR      R0,[R1, #+0]
    143            
    144            // Wait for 5 msec.
    145            RoadBrd_Delay( 5 );
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x.... 0x....      BL       RoadBrd_Delay
    146          
    147            // Call Init Function.
    148            MX_I2C1_Init();
   \   0000004A   0x.... 0x....      BL       MX_I2C1_Init
    149          }
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    150          
    151          /**
    152            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData_IT(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size)
    153            * @param  DevAddress Target device address
    154            * @param  Command 8 bit Command to be tasked as the first byte to the I2C Channel.
    155            * @param  pData Pointer to data buffer                
    156            * @param  Size Amount of data to be sent  TXBUFFERSIZE=80 Bytes
    157            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    158            *                                HAL_ERROR:    Error found in Tasking or data passed.
    159            *                                HAL_BUSY:     UART is busy.
    160            *                                HAL_TIMEOUT:  UART timed out.
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData_IT(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size)
    163          { 
   \                     RoadBrd_I2C_Master_Transmit_CMDData_IT: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    164            int x;
    165            uint8_t TempBuffer[TXBUFFERSIZE+2];
    166            
    167            // Test o see if data is legal.
    168            if (Size <= TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F79             CMP      R7,#+121
   \   00000012   0xDA25             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_0
    169            {
    170              // Now build Temp Buffer for tasking.
    171              TempBuffer[0] = Command;
   \   00000014   0xF88D 0x5000      STRB     R5,[SP, #+0]
    172              if( Size>0 )
   \   00000018   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD013             BEQ.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_1
    173              {
    174                for(x=0; x<Size; x++)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4680             MOV      R8,R0
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_2: (+1)
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x45B8             CMP      R8,R7
   \   00000026   0xDA07             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_3
    175                  TempBuffer[x+1] = pData[x];
   \   00000028   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x4441             ADD      R1,R1,R8
   \   00000030   0x7048             STRB     R0,[R1, #+1]
   \   00000032   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000036   0xE7F4             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_2
    176                TempBuffer[Size+1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x4439             ADD      R1,R1,R7
   \   00000040   0x7048             STRB     R0,[R1, #+1]
    177                Size++;
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \   00000044   0xE004             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_4
    178              }
    179              else
    180              {
    181                TempBuffer[1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0001      STRB     R0,[SP, #+1]
    182                Size = 1;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0007             MOVS     R7,R0
    183              }
    184              return RoadBrd_I2C_Master_Transmit_IT(DevAddress, TempBuffer, Size);
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_4: (+1)
   \   00000050   0x003A             MOVS     R2,R7
   \   00000052   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000054   0x4669             MOV      R1,SP
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_IT
   \   0000005E   0xE000             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_5
    185            }
    186            else
    187              return HAL_ERROR;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_0: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_5: (+1)
   \   00000062   0xB020             ADD      SP,SP,#+128
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    188          }
    189          
    190          /**
    191            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    192            * @param  DevAddress Target device address
    193            * @param  Command 8 bit Command to be tasked as the first byte to the I2C Channel.
    194            * @param  pData Pointer to data buffer                
    195            * @param  Size Amount of data to be sent  TXBUFFERSIZE=80 Bytes
    196            * @param  Timeout NUmber of 1ms ticks to wait.
    197            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    198            *                                HAL_ERROR:    Error found in Tasking or data passed.
    199            *                                HAL_BUSY:     UART is busy.
    200            *                                HAL_TIMEOUT:  UART timed out.
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    203          { 
   \                     RoadBrd_I2C_Master_Transmit_CMDData: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB09F             SUB      SP,SP,#+124
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8098      LDR      R8,[SP, #+152]
    204            int x;
    205            uint8_t TempBuffer[TXBUFFERSIZE+2];
    206            
    207            // Test o see if data is legal.
    208            if (Size <= TXBUFFERSIZE)
   \   00000012   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000014   0x2F79             CMP      R7,#+121
   \   00000016   0xDA26             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_0
    209            {
    210              // Now build Temp Buffer for tasking.
    211              TempBuffer[0] = Command;
   \   00000018   0xF88D 0x5000      STRB     R5,[SP, #+0]
    212              if( Size>0 )
   \   0000001C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD013             BEQ.N    ??RoadBrd_I2C_Master_Transmit_CMDData_1
    213              {
    214                for(x=0; x<Size; x++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4681             MOV      R9,R0
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_2: (+1)
   \   00000026   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000028   0x45B9             CMP      R9,R7
   \   0000002A   0xDA07             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_3
    215                  TempBuffer[x+1] = pData[x];
   \   0000002C   0xF816 0x0009      LDRB     R0,[R6, R9]
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x4449             ADD      R1,R1,R9
   \   00000034   0x7048             STRB     R0,[R1, #+1]
   \   00000036   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000003A   0xE7F4             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_2
    216                TempBuffer[Size+1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000042   0x4439             ADD      R1,R1,R7
   \   00000044   0x7048             STRB     R0,[R1, #+1]
    217                Size++;
   \   00000046   0x1C7F             ADDS     R7,R7,#+1
   \   00000048   0xE004             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_4
    218              }
    219              else
    220              {
    221                TempBuffer[1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    222                Size = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0007             MOVS     R7,R0
    223              }
    224              return RoadBrd_I2C_Master_Transmit(DevAddress, TempBuffer, Size, Timeout);
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_4: (+1)
   \   00000054   0x4643             MOV      R3,R8
   \   00000056   0x003A             MOVS     R2,R7
   \   00000058   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit
   \   00000064   0xE000             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_5
    225            }
    226            else
    227              return HAL_ERROR;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_0: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_5: (+1)
   \   00000068   0xB01F             ADD      SP,SP,#+124
   \   0000006A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    228          }
    229          
    230          /**
    231            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    232            * @param  DevAddress Target device address
    233            * @param  pData Pointer to data buffer
    234            * @param  Size Amount of data to be sent
    235            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    236            *                                HAL_ERROR:    Error found in Tasking or data passed.
    237            *                                HAL_BUSY:     UART is busy.
    238            *                                HAL_TIMEOUT:  UART timed out.
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    241          { 
   \                     RoadBrd_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    242              HAL_StatusTypeDef Status;
    243          
    244              // Turn On STATUS_LED LED.
    245          #ifndef NUCLEO
    246          #ifndef LED_OFF
    247          RoadBrd_gpio_On( STATUS_LED );
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       RoadBrd_gpio_On
    248          #endif
    249          #endif
    250              Status = HAL_I2C_Master_Transmit_IT(&hi2c1, (uint16_t)DevAddress, (uint8_t*)pData, Size);
   \   0000000E   0x0033             MOVS     R3,R6
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000001C   0x.... 0x....      BL       HAL_I2C_Master_Transmit_IT
   \   00000020   0x0007             MOVS     R7,R0
    251              // Turn Off STATUS_LED LED.
    252          #ifndef NUCLEO
    253          #ifndef LED_OFF
    254              RoadBrd_gpio_Off( STATUS_LED );
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      BL       RoadBrd_gpio_Off
    255          #endif
    256          #endif
    257              
    258              return Status;
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    259          }
    260          
    261          /**
    262            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    263            * @param  DevAddress Target device address
    264            * @param  pData Pointer to data buffer
    265            * @param  Size Amount of data to be sent
    266            * @param  Timeout NUmber of 1ms ticks to wait.
    267            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    268            *                                HAL_ERROR:    Error found in Tasking or data passed.
    269            *                                HAL_BUSY:     UART is busy.
    270            *                                HAL_TIMEOUT:  UART timed out.
    271            */

   \                                 In section .text, align 2, keep-with-next
    272          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    273          { 
   \                     RoadBrd_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    274              HAL_StatusTypeDef Status;
    275          
    276              // Turn On STATUS_LED LED.
    277          #ifndef NUCLEO
    278          #ifndef LED_OFF
    279              RoadBrd_gpio_On( STATUS_LED );
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_gpio_On
    280          #endif
    281          #endif
    282              Status = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)DevAddress, (uint8_t*)pData, Size, Timeout);
   \   00000014   0x9700             STR      R7,[SP, #+0]
   \   00000016   0x0033             MOVS     R3,R6
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x....             LDR.N    R0,??DataTable13_1
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000026   0x4680             MOV      R8,R0
    283              // Turn Off STATUS_LED LED.
    284          #ifndef NUCLEO
    285          #ifndef LED_OFF
    286              RoadBrd_gpio_Off( STATUS_LED );
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       RoadBrd_gpio_Off
    287          #endif
    288          #endif
    289              
    290              return Status;
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    291          }
    292          
    293          /**
    294            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_CmdReceive(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout): 
    295            *             Receive in master mode an amount of data in blocking mode with Interrupt
    296            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    297            *                the configuration information for the specified I2C.
    298            * @param  DevAddress Target device address
    299            * @param  pData Pointer to data buffer
    300            * @param  Size Amount of data to be received.
    301            * @param  Timeout NUmber of 1ms ticks to wait.
    302            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    303            *                                HAL_ERROR:    Error found in Tasking or data passed.
    304            *                                HAL_BUSY:     UART is busy.
    305            *                                HAL_TIMEOUT:  UART timed out.
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          HAL_StatusTypeDef RoadBrd_I2C_Master_CmdReceive(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    308          {
   \                     RoadBrd_I2C_Master_CmdReceive: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    309            HAL_StatusTypeDef Status;
    310            uint8_t TempBuffer[2];
    311          
    312            // Now build Temp Buffer for tasking.
    313            TempBuffer[0] = Command;
   \   00000012   0xF88D 0x5004      STRB     R5,[SP, #+4]
    314            TempBuffer[1] = 0x00;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0005      STRB     R0,[SP, #+5]
    315            
    316            // Turn On STATUS_LED LED.
    317          #ifndef NUCLEO
    318          #ifndef LED_OFF
    319            RoadBrd_gpio_On( STATUS_LED );
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x.... 0x....      BL       RoadBrd_gpio_On
    320          #endif
    321          #endif
    322            Status = RoadBrd_I2C_Master_Transmit(DevAddress, TempBuffer, 1, Timeout);
   \   00000022   0x4643             MOV      R3,R8
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit
   \   00000030   0x4681             MOV      R9,R0
    323            if(Status != HAL_OK)
   \   00000032   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_I2C_Master_CmdReceive_0
    324              return Status;
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE00C             B.N      ??RoadBrd_I2C_Master_CmdReceive_1
    325            
    326            Status = HAL_I2C_Master_Receive(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size, Timeout);
   \                     ??RoadBrd_I2C_Master_CmdReceive_0: (+1)
   \   00000042   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000046   0x003B             MOVS     R3,R7
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0x0021             MOVS     R1,R4
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x....             LDR.N    R0,??DataTable13_1
   \   00000052   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000056   0x4681             MOV      R9,R0
    327            // Turn Off STATUS_LED LED.
    328          #ifndef NUCLEO
    329          #ifndef LED_OFF
    330            //RoadBrd_gpio_Off( STATUS_LED );
    331          #endif
    332          #endif
    333              
    334            return Status;
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_I2C_Master_CmdReceive_1: (+1)
   \   0000005C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    335          }
    336          
    337          /**
    338            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Receive(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout): 
    339            *             Receive in master mode an amount of data in non-blocking mode with Interrupt
    340            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    341            *                the configuration information for the specified I2C.
    342            * @param  DevAddress Target device address
    343            * @param  pData Pointer to data buffer
    344            * @param  Size Amount of data to be received.
    345            * @param  Timeout NUmber of 1ms ticks to wait.
    346            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    347            *                                HAL_ERROR:    Error found in Tasking or data passed.
    348            *                                HAL_BUSY:     UART is busy.
    349            *                                HAL_TIMEOUT:  UART timed out.
    350            */

   \                                 In section .text, align 2, keep-with-next
    351          HAL_StatusTypeDef RoadBrd_I2C_Master_Receive(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    352          {
   \                     RoadBrd_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    353              HAL_StatusTypeDef Status;
    354          
    355              // Turn On STATUS_LED LED.
    356          #ifndef NUCLEO
    357          #ifndef LED_OFF
    358              RoadBrd_gpio_On( STATUS_LED );
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_gpio_On
    359          #endif
    360          #endif
    361              Status = HAL_I2C_Master_Receive(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size, Timeout);
   \   00000014   0x9700             STR      R7,[SP, #+0]
   \   00000016   0x0033             MOVS     R3,R6
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x....             LDR.N    R0,??DataTable13_1
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000026   0x4680             MOV      R8,R0
    362              // Turn Off STATUS_LED LED.
    363          #ifndef NUCLEO
    364          #ifndef LED_OFF
    365              RoadBrd_gpio_Off( STATUS_LED );
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       RoadBrd_gpio_Off
    366          #endif
    367          #endif
    368              
    369              return Status;
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    370          }
    371          
    372          /**
    373            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Receive_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size): 
    374            *             Receive in master mode an amount of data in non-blocking mode with Interrupt
    375            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    376            *                the configuration information for the specified I2C.
    377            * @param  DevAddress Target device address
    378            * @param  pData Pointer to data buffer
    379            * @param  Size Amount of data to be received.
    380            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    381            *                                HAL_ERROR:    Error found in Tasking or data passed.
    382            *                                HAL_BUSY:     UART is busy.
    383            *                                HAL_TIMEOUT:  UART timed out.
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          HAL_StatusTypeDef RoadBrd_I2C_Master_Receive_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    386          {
   \                     RoadBrd_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    387              HAL_StatusTypeDef Status;
    388              
    389              // Turn On STATUS_LED LED.
    390          #ifndef NUCLEO
    391          #ifndef LED_OFF
    392              RoadBrd_gpio_On( STATUS_LED );
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       RoadBrd_gpio_On
    393          #endif
    394          #endif
    395              Status = HAL_I2C_Master_Receive_IT(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size);
   \   0000000E   0x0033             MOVS     R3,R6
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable13_1
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Master_Receive_IT
   \   0000001E   0x0007             MOVS     R7,R0
    396              // Turn Off STATUS_LED LED.
    397          #ifndef NUCLEO
    398          #ifndef LED_OFF
    399              RoadBrd_gpio_Off( STATUS_LED );
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       RoadBrd_gpio_Off
    400          #endif
    401          #endif
    402              
    403              return Status;
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    404          }
    405          
    406          /**
    407          * @brief  Return the I2C error code.
    408            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    409            *              the configuration information for the specified I2C.
    410            * @retval I2C Error Code
    411          */

   \                                 In section .text, align 2, keep-with-next
    412          uint32_t RoadBrd_I2C_GetError( void )
    413          {
   \                     RoadBrd_I2C_GetError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    414            return HAL_I2C_GetError(&hi2c1);
   \   00000002   0x....             LDR.N    R0,??DataTable13_1
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    415          }
    416          
    417          
    418          /**
    419            * @brief  HAL_I2C_StateTypeDef RoadBrd_I2C_GetState( void ): Return the I2C handle state.
    420            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    421            *                the configuration information for the specified I2C.
    422            * @retval HAL state   :   HAL_I2C_STATE_RESET             = 0x00,   Peripheral is not yet Initialized         
    423            *                         HAL_I2C_STATE_READY             = 0x20,   Peripheral Initialized and ready for use
    424            *                         HAL_I2C_STATE_BUSY              = 0x24,   An internal process is ongoing             
    425            *                         HAL_I2C_STATE_BUSY_TX           = 0x21,   Data Transmission process is ongoing  
    426            *                         HAL_I2C_STATE_BUSY_RX           = 0x22,   Data Reception process is ongoing        
    427            *                         HAL_I2C_STATE_TIMEOUT           = 0xA0,   Timeout state                            
    428            *                         HAL_I2C_STATE_ERROR             = 0xE0    Error                                    
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          HAL_I2C_StateTypeDef RoadBrd_I2C_GetState( void )
    431          {
   \                     RoadBrd_I2C_GetState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    432            return HAL_I2C_GetState(&hi2c1);
   \   00000002   0x....             LDR.N    R0,??DataTable13_1
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetState
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    433          }
    434          
    435          /**
    436            * @brief  HAL_I2C_StateTypeDef RoadBrd_WaitForState( uint16_t WaitCnt ): Wait for state to change
    437            * @param  uint16_t WaitCnt: Count of 5msec ticks to wait before timing out.
    438            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    439            *                                HAL_TIMEOUT:  UART timed out.
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          HAL_StatusTypeDef RoadBrd_WaitForState( uint16_t WaitCnt )
    442          {
   \                     RoadBrd_WaitForState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    443            uint16_t x;
    444            
    445            // Now wait for transaction to complete.
    446            for( x=0; x<=WaitCnt; x++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??RoadBrd_WaitForState_0: (+1)
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD30A             BCC.N    ??RoadBrd_WaitForState_1
    447            {
    448              // Need to Service Watch Dog or we die here....
    449              RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   00000014   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
    450              // Test to see if event finished.
    451              if (RoadBrd_I2C_GetState() == HAL_I2C_STATE_READY)
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_GetState
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xD004             BEQ.N    ??RoadBrd_WaitForState_1
    452                break;
    453              // Wait 5msec.
    454              RoadBrd_Delay(5);
   \                     ??RoadBrd_WaitForState_2: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0x.... 0x....      BL       RoadBrd_Delay
    455            }
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \   00000028   0xE7EE             B.N      ??RoadBrd_WaitForState_0
    456            // Test for timeout.
    457            if( x == WaitCnt)
   \                     ??RoadBrd_WaitForState_1: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD101             BNE.N    ??RoadBrd_WaitForState_3
    458              return HAL_TIMEOUT;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE000             B.N      ??RoadBrd_WaitForState_4
    459            else
    460              return HAL_OK;
   \                     ??RoadBrd_WaitForState_3: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??RoadBrd_WaitForState_4: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    461          }
    462          
    463          /**
    464            * @brief  void RoadBrd_Delay( __IO uint32_t Delay ): Implement Delay by calling HAL_Delay.
    465            *             NOTE: This currently uses HAL_Delay. This may se a tasking delay in the future.
    466            * @param Delay: specifies the delay time length, in milliseconds.
    467            * @retval None
    468            */

   \                                 In section .text, align 2, keep-with-next
    469          void RoadBrd_Delay( __IO uint32_t Delay )
    470          {
   \                     RoadBrd_Delay: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    471            HAL_Delay( Delay );
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x.... 0x....      BL       HAL_Delay
    472          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    473          

   \                                 In section .text, align 2, keep-with-next
    474          HAL_StatusTypeDef I2C_WaitBusyFlag( void )
    475          {
   \                     I2C_WaitBusyFlag: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    476            return(RdBrdI2C_WaitOnFlagUntilTimeout(&hi2c1, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_FLAG));
   \   00000002   0x2323             MOVS     R3,#+35
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000000A   0x....             LDR.N    R0,??DataTable13_1
   \   0000000C   0x.... 0x....      BL       RdBrdI2C_WaitOnFlagUntilTimeout
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    477          }
    478          
    479          /**
    480            * @brief  This function handles I2C Communication Timeout.
    481            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
    482            *         the configuration information for I2C module
    483            * @param  Flag specifies the I2C flag to check.
    484            * @param  Status The new Flag status (SET or RESET).
    485            * @param  Timeout Timeout duration
    486            * @retval HAL status
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          static HAL_StatusTypeDef RdBrdI2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
    489          {
   \                     RdBrdI2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    490            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    491          
    492            /* Get tick */
    493            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
    494          
    495            /* Wait until flag is set */
    496            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD12D             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    497            {
    498              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x0C28             LSRS     R0,R5,#+16
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10A             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_2
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6940             LDR      R0,[R0, #+20]
   \   00000028   0x4028             ANDS     R0,R5,R0
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE00B             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE009             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_2: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x4028             ANDS     R0,R5,R0
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_5
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_5: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_4: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD140             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_6
    499              {
    500                /* Check for the Timeout */
    501                if(Timeout != HAL_MAX_DELAY)
   \   00000052   0xF5B7 0x4F00      CMP      R7,#+32768
   \   00000056   0xD0E1             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_1
    502                {
    503                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD005             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_7
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000064   0x4287             CMP      R7,R0
   \   00000066   0xD2D9             BCS.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_1
    504                  {
    505                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_7: (+1)
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0xF884 0x0035      STRB     R0,[R4, #+53]
    506          
    507                    /* Process Unlocked */
    508                    __HAL_UNLOCK(hi2c);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF884 0x0034      STRB     R0,[R4, #+52]
    509          
    510                    return HAL_TIMEOUT;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE02E             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_8
    511                  }
    512                }
    513              }
    514            }
    515            else
    516            {
    517              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_0: (+1)
   \   00000078   0x0C28             LSRS     R0,R5,#+16
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD10A             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_9
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6940             LDR      R0,[R0, #+20]
   \   00000084   0x4028             ANDS     R0,R5,R0
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_10
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE00B             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_10: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE009             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_9: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0x4028             ANDS     R0,R5,R0
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_12
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_12: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_11: (+1)
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD012             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_6
    518              {
    519                /* Check for the Timeout */
    520                if(Timeout != HAL_MAX_DELAY)
   \   000000AE   0xF5B7 0x4F00      CMP      R7,#+32768
   \   000000B2   0xD0E1             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    521                {
    522                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD005             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_13
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000C0   0x4287             CMP      R7,R0
   \   000000C2   0xD2D9             BCS.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    523                  {
    524                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_13: (+1)
   \   000000C4   0x2020             MOVS     R0,#+32
   \   000000C6   0xF884 0x0035      STRB     R0,[R4, #+53]
    525          
    526                    /* Process Unlocked */
    527                    __HAL_UNLOCK(hi2c);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0034      STRB     R0,[R4, #+52]
    528          
    529                    return HAL_TIMEOUT;
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_8
    530                  }
    531                }
    532              }
    533            }
    534            return HAL_OK;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_6: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_8: (+1)
   \   000000D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    535          }
    536          
    537          
    538          /**
    539            * @brief  Attempts to Clear I2C channel Data Pin by pulsing SDA Line 9 times.
    540            * @param None.
    541            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to I2C success.
    542            *                                HAL_ERROR:    Error found in Tasking or data passed.
    543            */

   \                                 In section .text, align 2, keep-with-next
    544          HAL_StatusTypeDef RoadBrd_I2CRepair( void )
    545          {
   \                     RoadBrd_I2CRepair: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    546            GPIO_InitTypeDef GPIO_InitStructure;
    547            HAL_StatusTypeDef Status;
    548            int x, loop_cnt;
    549            char tempBffr2[8];
    550            
    551            Status = HAL_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
    552          
    553            GPIO_InitStructure.Pin = I2C_SDA_Pin;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    554            GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    555            GPIO_InitStructure.Pull = GPIO_NOPULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9002             STR      R0,[SP, #+8]
    556            GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_MEDIUM;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
    557            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_Init
    558          
    559            // Wait for Hardware to stabilize....10ms
    560            RoadBrd_Delay( 10 );
   \   00000020   0x200A             MOVS     R0,#+10
   \   00000022   0x.... 0x....      BL       RoadBrd_Delay
    561            
    562            GPIO_InitStructure.Pin = I2C_SCL_Pin;
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x9000             STR      R0,[SP, #+0]
    563            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9001             STR      R0,[SP, #+4]
    564            GPIO_InitStructure.Pull = GPIO_NOPULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9002             STR      R0,[SP, #+8]
    565            GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_MEDIUM;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x9003             STR      R0,[SP, #+12]
    566            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_Init
    567          
    568            // Wait for Hardware to stabilize....100ms
    569            RoadBrd_Delay( 100 );
   \   0000003E   0x2064             MOVS     R0,#+100
   \   00000040   0x.... 0x....      BL       RoadBrd_Delay
    570            for (loop_cnt=0; loop_cnt<I2C_LOOPCNT; loop_cnt++)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0006             MOVS     R6,R0
   \                     ??RoadBrd_I2CRepair_0: (+1)
   \   00000048   0x2E05             CMP      R6,#+5
   \   0000004A   0xDA31             BGE.N    ??RoadBrd_I2CRepair_1
    571            {
    572              // Print Loop Count
    573              sprintf( (char *)tempBffr2, "**%02d.", loop_cnt);
   \   0000004C   0x0032             MOVS     R2,R6
   \   0000004E   0x....             LDR.N    R1,??DataTable13_4
   \   00000050   0xA805             ADD      R0,SP,#+20
   \   00000052   0x.... 0x....      BL       sprintf
    574              RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   \   00000056   0xA905             ADD      R1,SP,#+20
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       RoadBrd_UART_Transmit
    575              RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   0000005E   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
    576              
    577              // Now...Pulse SDA Pin I2C_CLKRPRCNT Times.
    578              for (x=0; x<I2C_CLKRPRCNT; x++)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0005             MOVS     R5,R0
   \                     ??RoadBrd_I2CRepair_2: (+1)
   \   00000066   0x2D14             CMP      R5,#+20
   \   00000068   0xDA0D             BGE.N    ??RoadBrd_I2CRepair_3
    579              {
    580                RoadBrd_gpio_Off( gI2C_CLK );
   \   0000006A   0x2009             MOVS     R0,#+9
   \   0000006C   0x.... 0x....      BL       RoadBrd_gpio_Off
    581                RoadBrd_Delay( 10 );               // Wait 10ms;
   \   00000070   0x200A             MOVS     R0,#+10
   \   00000072   0x.... 0x....      BL       RoadBrd_Delay
    582                RoadBrd_gpio_On(gI2C_CLK);   // Set Clock High.
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0x.... 0x....      BL       RoadBrd_gpio_On
    583                RoadBrd_Delay( 10 );               // Wait 10ms;
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0x.... 0x....      BL       RoadBrd_Delay
    584              } // EndFor (x=0; x<I2C_CLKRPRCNT; x++)
   \   00000082   0x1C6D             ADDS     R5,R5,#+1
   \   00000084   0xE7EF             B.N      ??RoadBrd_I2CRepair_2
    585              
    586              // Finally Reset Clock LOW.
    587              RoadBrd_gpio_Off(gI2C_CLK);  // Set Clock Low.
   \                     ??RoadBrd_I2CRepair_3: (+1)
   \   00000086   0x2009             MOVS     R0,#+9
   \   00000088   0x.... 0x....      BL       RoadBrd_gpio_Off
    588              
    589              // Wait for Hardware to stabilize....100ms
    590              RoadBrd_Delay( 100 );
   \   0000008C   0x2064             MOVS     R0,#+100
   \   0000008E   0x.... 0x....      BL       RoadBrd_Delay
    591              
    592              // Test Data Pin State.
    593              if ( HAL_GPIO_ReadPin( GPIOB, I2C_SDA_Pin) == GPIO_PIN_RESET)
   \   00000092   0x2180             MOVS     R1,#+128
   \   00000094   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000096   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD106             BNE.N    ??RoadBrd_I2CRepair_4
    594              {
    595                Status = HAL_ERROR;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x0004             MOVS     R4,R0
    596              }
    597              else
    598              {
    599                // If High, Then we have been succesful. Time to Indicate Repaired and Init I2C BUS.
    600                //SkPck_ErrCdLogErrCd( REPAIR_I2C, MODULE_i2c );
    601                // Enable all I2C Sensors.
    602                //Set_DriverStates( I2C_STATE, DRIVER_ON );
    603                //Set_DriverStates( IMU_STATE_TASK, DRIVER_ON );
    604                //Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_ON );
    605                //Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_ON );
    606                // Now Reinit I2C Bus.
    607                //I2C_LowLevel_Init();
    608                return HAL_OK;
    609              }
    610              RoadBrd_Delay( 100 );
   \   000000A2   0x2064             MOVS     R0,#+100
   \   000000A4   0x.... 0x....      BL       RoadBrd_Delay
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   \   000000AA   0xE7CD             B.N      ??RoadBrd_I2CRepair_0
   \                     ??RoadBrd_I2CRepair_4: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE001             B.N      ??RoadBrd_I2CRepair_5
    611            } // EndFor (loop_cnt=0; loop_cnt<I2C_LOOPCNT; loop_cnt++)
    612            return Status;
   \                     ??RoadBrd_I2CRepair_1: (+1)
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_I2CRepair_5: (+1)
   \   000000B4   0xB008             ADD      SP,SP,#+32
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
    613          }
    614          
    615          /**
    616            * @brief  Tests I2C channel and sets error codes if failed.
    617            * @param None.
    618            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    619            *                                HAL_ERROR:    Error found in Tasking or data passed.
    620            *                                HAL_BUSY:     UART is busy.
    621            *                                HAL_TIMEOUT:  UART timed out.
    622            */

   \                                 In section .text, align 2, keep-with-next
    623          HAL_StatusTypeDef RoadBrd_TestI2C( void )
    624          {
   \                     RoadBrd_TestI2C: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    625            GPIO_InitTypeDef GPIO_InitStruct;
    626            HAL_StatusTypeDef Status;
    627            
    628            GPIO_InitStruct.Pin = I2C_SCL_Pin|I2C_SDA_Pin;
   \   00000004   0x20C0             MOVS     R0,#+192
   \   00000006   0x9000             STR      R0,[SP, #+0]
    629            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    630            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9002             STR      R0,[SP, #+8]
    631            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000014   0x.... 0x....      BL       HAL_GPIO_Init
    632            
    633            // Wait for Hardware to stabilize....10ms
    634            RoadBrd_Delay( 10 );
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       RoadBrd_Delay
    635            
    636            // Test I2C Clock
    637            if ( HAL_GPIO_ReadPin( GPIOB, I2C_SCL_Pin) == GPIO_PIN_RESET )
   \   0000001E   0x2140             MOVS     R1,#+64
   \   00000020   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000022   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD114             BNE.N    ??RoadBrd_TestI2C_0
    638            {
    639              // If low....Then SCLK has failed...Record Error.
    640              RdBrd_ErrCdLogErrCd( ERROR_I2C_SCLK, MODULE_i2c );
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x200B             MOVS     R0,#+11
   \   0000002E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    641              Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x2007             MOVS     R0,#+7
   \   00000036   0x.... 0x....      BL       Set_DriverStates
    642              Status = HAL_ERROR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0004             MOVS     R4,R0
    643              
    644              // Time to test SDAT
    645              if ( HAL_GPIO_ReadPin( GPIOB, I2C_SDA_Pin) == GPIO_PIN_RESET)
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000042   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD11B             BNE.N    ??RoadBrd_TestI2C_1
    646              {
    647                // If low....Then SDAT has failed...Record Error.
    648                RdBrd_ErrCdLogErrCd( ERROR_I2C_SDAT, MODULE_i2c );
   \   0000004A   0x2103             MOVS     R1,#+3
   \   0000004C   0x200C             MOVS     R0,#+12
   \   0000004E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
   \   00000052   0xE016             B.N      ??RoadBrd_TestI2C_1
    649              }
    650            }
    651            else
    652            {
    653              // Passed, Time to test SDAT
    654              if ( HAL_GPIO_ReadPin( GPIOB, I2C_SDA_Pin) == GPIO_PIN_RESET)
   \                     ??RoadBrd_TestI2C_0: (+1)
   \   00000054   0x2180             MOVS     R1,#+128
   \   00000056   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000058   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD10A             BNE.N    ??RoadBrd_TestI2C_2
    655              {
    656                // If low....Then SDAT has failed...Record Error.
    657                RdBrd_ErrCdLogErrCd( ERROR_I2C_SDAT, MODULE_i2c );
   \   00000060   0x2103             MOVS     R1,#+3
   \   00000062   0x200C             MOVS     R0,#+12
   \   00000064   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    658                Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x2007             MOVS     R0,#+7
   \   0000006C   0x.... 0x....      BL       Set_DriverStates
    659                Status = HAL_ERROR;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x0004             MOVS     R4,R0
   \   00000074   0xE005             B.N      ??RoadBrd_TestI2C_1
    660              }
    661              else
    662              {
    663                Set_DriverStates( I2C_STATE, DRIVER_ON );
   \                     ??RoadBrd_TestI2C_2: (+1)
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x2007             MOVS     R0,#+7
   \   0000007A   0x.... 0x....      BL       Set_DriverStates
    664                Status = HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0004             MOVS     R4,R0
    665              }
    666            }
    667            
    668            return Status;
   \                     ??RoadBrd_TestI2C_1: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0xB006             ADD      SP,SP,#+24
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
    669          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2A 0x2A          DC8 "**%02d."
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x2E 0x00    
    670          /* USER CODE END 1 */
    671          
    672          /**
    673            * @}
    674            */
    675          
    676          /**
    677            * @}
    678            */
    679          
    680          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_MspDeInit
         8   -> HAL_GPIO_DeInit
      32   HAL_I2C_MspInit
        32   -> HAL_GPIO_Init
       8   I2C_WaitBusyFlag
         8   -> RdBrdI2C_WaitOnFlagUntilTimeout
       8   MX_I2C1_Init
         8   -> Error_Handler
         8   -> HAL_I2C_Init
       8   MX_I2C1_Reset
         8   -> MX_I2C1_Init
         8   -> RoadBrd_Delay
      24   RdBrdI2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
       8   RoadBrd_Delay
         8   -> HAL_Delay
      48   RoadBrd_I2CRepair
        48   -> HAL_GPIO_Init
        48   -> HAL_GPIO_ReadPin
        48   -> RoadBrd_Delay
        48   -> RoadBrd_UART_Transmit
        48   -> RoadBrd_WWDG_Refresh
        48   -> RoadBrd_gpio_Off
        48   -> RoadBrd_gpio_On
        48   -> sprintf
       8   RoadBrd_I2C_GetError
         8   -> HAL_I2C_GetError
       8   RoadBrd_I2C_GetState
         8   -> HAL_I2C_GetState
      40   RoadBrd_I2C_Master_CmdReceive
        40   -> HAL_I2C_Master_Receive
        40   -> RoadBrd_I2C_Master_Transmit
        40   -> RoadBrd_gpio_On
      32   RoadBrd_I2C_Master_Receive
        32   -> HAL_I2C_Master_Receive
        32   -> RoadBrd_gpio_Off
        32   -> RoadBrd_gpio_On
      24   RoadBrd_I2C_Master_Receive_IT
        24   -> HAL_I2C_Master_Receive_IT
        24   -> RoadBrd_gpio_Off
        24   -> RoadBrd_gpio_On
      32   RoadBrd_I2C_Master_Transmit
        32   -> HAL_I2C_Master_Transmit
        32   -> RoadBrd_gpio_Off
        32   -> RoadBrd_gpio_On
     152   RoadBrd_I2C_Master_Transmit_CMDData
       152   -> RoadBrd_I2C_Master_Transmit
     152   RoadBrd_I2C_Master_Transmit_CMDData_IT
       152   -> RoadBrd_I2C_Master_Transmit_IT
      24   RoadBrd_I2C_Master_Transmit_IT
        24   -> HAL_I2C_Master_Transmit_IT
        24   -> RoadBrd_gpio_Off
        24   -> RoadBrd_gpio_On
      32   RoadBrd_TestI2C
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_ReadPin
        32   -> RdBrd_ErrCdLogErrCd
        32   -> RoadBrd_Delay
        32   -> Set_DriverStates
      16   RoadBrd_WaitForState
        16   -> RoadBrd_Delay
        16   -> RoadBrd_I2C_GetState
        16   -> RoadBrd_WWDG_Refresh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       8  ?_0
      42  HAL_I2C_MspDeInit
      80  HAL_I2C_MspInit
      18  I2C_WaitBusyFlag
      98  MX_I2C1_Init
      80  MX_I2C1_Reset
     218  RdBrdI2C_WaitOnFlagUntilTimeout
      10  RoadBrd_Delay
     184  RoadBrd_I2CRepair
      10  RoadBrd_I2C_GetError
      10  RoadBrd_I2C_GetState
      96  RoadBrd_I2C_Master_CmdReceive
      54  RoadBrd_I2C_Master_Receive
      44  RoadBrd_I2C_Master_Receive_IT
      54  RoadBrd_I2C_Master_Transmit
     110  RoadBrd_I2C_Master_Transmit_CMDData
     104  RoadBrd_I2C_Master_Transmit_CMDData_IT
      46  RoadBrd_I2C_Master_Transmit_IT
     138  RoadBrd_TestI2C
      62  RoadBrd_WaitForState
      60  hi2c1

 
    60 bytes in section .bss
     8 bytes in section .rodata
 1 478 bytes in section .text
 
 1 478 bytes of CODE  memory
     8 bytes of CONST memory
    60 bytes of DATA  memory

Errors: none
Warnings: none
