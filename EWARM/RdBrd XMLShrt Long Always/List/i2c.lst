###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Dec/2017  20:36:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\i2c.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\i2c.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\i2c.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : I2C.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the I2C instances.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "i2c.h"
     37          #include "wwdg.h"
     38          
     39          #include "gpio.h"
     40              
     41          /* USER CODE BEGIN 0 */
     42          #include "stm32l1xx_hal.h"
     43          #include "ErrorCodes.h"
     44          #include "app_data.h"
     45          
     46          #define I2C_TIMEOUT_FLAG          ((uint32_t)35)      /* 35 ms */
     47          
     48          static HAL_StatusTypeDef RdBrdI2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
     49          
     50          /* USER CODE END 0 */
     51          

   \                                 In section .bss, align 4
     52          I2C_HandleTypeDef hi2c1;
   \                     hi2c1:
   \   00000000                      DS8 60
     53          
     54          /* I2C1 init function */

   \                                 In section .text, align 2, keep-with-next
     55          void MX_I2C1_Init(void)
     56          {
   \                     MX_I2C1_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     57          
     58            hi2c1.Instance = I2C1;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40005400
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     59            hi2c1.Init.ClockSpeed = 20000;
   \   0000000C   0xF644 0x6020      MOVW     R0,#+20000
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000014   0x6048             STR      R0,[R1, #+4]
     60            //hi2c1.Init.ClockSpeed = 10000;
     61            hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     62            hi2c1.Init.OwnAddress1 = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     63            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   00000026   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000002E   0x6108             STR      R0,[R1, #+16]
     64            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000036   0x6148             STR      R0,[R1, #+20]
     65            hi2c1.Init.OwnAddress2 = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000003E   0x6188             STR      R0,[R1, #+24]
     66            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000046   0x61C8             STR      R0,[R1, #+28]
     67            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000004E   0x6208             STR      R0,[R1, #+32]
     68            if (HAL_I2C_Init(&hi2c1) != HAL_OK)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000054   0x.... 0x....      BL       HAL_I2C_Init
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??MX_I2C1_Init_0
     69            {
     70              Error_Handler();
   \   0000005C   0x.... 0x....      BL       Error_Handler
     71            }
     72          
     73          }
   \                     ??MX_I2C1_Init_0: (+1)
   \   00000060   0xBD01             POP      {R0,PC}          ;; return
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
     76          {
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
     77          
     78            GPIO_InitTypeDef GPIO_InitStruct;
     79            if(i2cHandle->Instance==I2C1)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40005400
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD11D             BNE.N    ??HAL_I2C_MspInit_0
     80            {
     81            /* USER CODE BEGIN I2C1_MspInit 0 */
     82          
     83            /* USER CODE END I2C1_MspInit 0 */
     84            
     85              /**I2C1 GPIO Configuration    
     86              PB6     ------> I2C1_SCL
     87              PB7     ------> I2C1_SDA 
     88              */
     89              GPIO_InitStruct.Pin = I2C_SCL_Pin|I2C_SDA_Pin;
   \   00000010   0x20C0             MOVS     R0,#+192
   \   00000012   0x9001             STR      R0,[SP, #+4]
     90              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x9002             STR      R0,[SP, #+8]
     91              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9003             STR      R0,[SP, #+12]
     92              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x9004             STR      R0,[SP, #+16]
     93              GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x9005             STR      R0,[SP, #+20]
     94              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020400
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_Init
     95          
     96              /* Peripheral clock enable */
     97              __HAL_RCC_I2C1_CLK_ENABLE();
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023824
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40023824
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023824
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
     98            /* USER CODE BEGIN I2C1_MspInit 1 */
     99          
    100            /* USER CODE END I2C1_MspInit 1 */
    101            }
    102          }
   \                     ??HAL_I2C_MspInit_0: (+1)
   \   0000004C   0xB006             ADD      SP,SP,#+24
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
    105          {
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    106          
    107            if(i2cHandle->Instance==I2C1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40005400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD10C             BNE.N    ??HAL_I2C_MspDeInit_0
    108            {
    109            /* USER CODE BEGIN I2C1_MspDeInit 0 */
    110          
    111            /* USER CODE END I2C1_MspDeInit 0 */
    112              /* Peripheral clock disable */
    113              __HAL_RCC_I2C1_CLK_DISABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40023824
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    114            
    115              /**I2C1 GPIO Configuration    
    116              PB6     ------> I2C1_SCL
    117              PB7     ------> I2C1_SDA 
    118              */
    119              HAL_GPIO_DeInit(GPIOB, I2C_SCL_Pin|I2C_SDA_Pin);
   \   0000001E   0x21C0             MOVS     R1,#+192
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020400
   \   00000024   0x.... 0x....      BL       HAL_GPIO_DeInit
    120          
    121            }
    122            /* USER CODE BEGIN I2C1_MspDeInit 1 */
    123          
    124            /* USER CODE END I2C1_MspDeInit 1 */
    125          } 
   \                     ??HAL_I2C_MspDeInit_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    126          
    127          /* USER CODE BEGIN 1 */
    128          /* I2C1 Reset Function */

   \                                 In section .text, align 2, keep-with-next
    129          void MX_I2C1_Reset(void)
    130          {
   \                     MX_I2C1_Reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    131            // Disabe I2C first.
    132            __HAL_I2C_DISABLE(&hi2c1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
    133            
    134            // Soft Reset I2C Now.
    135            SET_BIT(hi2c1.Instance->CR1, I2C_CR1_SWRST);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
    136            
    137            // Hold Reset for 5 msec.
    138            RoadBrd_Delay( 5 );
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0x.... 0x....      BL       RoadBrd_Delay
    139             
    140            // Clear Reset State.
    141            CLEAR_BIT(hi2c1.Instance->CR1, I2C_CR1_SWRST);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x6008             STR      R0,[R1, #+0]
    142            
    143            // Wait for 5 msec.
    144            RoadBrd_Delay( 5 );
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x.... 0x....      BL       RoadBrd_Delay
    145          
    146            // Call Init Function.
    147            MX_I2C1_Init();
   \   0000004A   0x.... 0x....      BL       MX_I2C1_Init
    148          }
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    149          
    150          /**
    151            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData_IT(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size)
    152            * @param  DevAddress Target device address
    153            * @param  Command 8 bit Command to be tasked as the first byte to the I2C Channel.
    154            * @param  pData Pointer to data buffer                
    155            * @param  Size Amount of data to be sent  TXBUFFERSIZE=80 Bytes
    156            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    157            *                                HAL_ERROR:    Error found in Tasking or data passed.
    158            *                                HAL_BUSY:     UART is busy.
    159            *                                HAL_TIMEOUT:  UART timed out.
    160            */

   \                                 In section .text, align 2, keep-with-next
    161          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData_IT(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size)
    162          { 
   \                     RoadBrd_I2C_Master_Transmit_CMDData_IT: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    163            int x;
    164            uint8_t TempBuffer[TXBUFFERSIZE+2];
    165            
    166            // Test o see if data is legal.
    167            if (Size <= TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F79             CMP      R7,#+121
   \   00000012   0xDA25             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_0
    168            {
    169              // Now build Temp Buffer for tasking.
    170              TempBuffer[0] = Command;
   \   00000014   0xF88D 0x5000      STRB     R5,[SP, #+0]
    171              if( Size>0 )
   \   00000018   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD013             BEQ.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_1
    172              {
    173                for(x=0; x<Size; x++)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4680             MOV      R8,R0
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_2: (+1)
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x45B8             CMP      R8,R7
   \   00000026   0xDA07             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_IT_3
    174                  TempBuffer[x+1] = pData[x];
   \   00000028   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x4441             ADD      R1,R1,R8
   \   00000030   0x7048             STRB     R0,[R1, #+1]
   \   00000032   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000036   0xE7F4             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_2
    175                TempBuffer[Size+1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x4439             ADD      R1,R1,R7
   \   00000040   0x7048             STRB     R0,[R1, #+1]
    176                Size++;
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \   00000044   0xE004             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_4
    177              }
    178              else
    179              {
    180                TempBuffer[1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0001      STRB     R0,[SP, #+1]
    181                Size = 1;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0007             MOVS     R7,R0
    182              }
    183              return RoadBrd_I2C_Master_Transmit_IT(DevAddress, TempBuffer, Size);
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_4: (+1)
   \   00000050   0x003A             MOVS     R2,R7
   \   00000052   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000054   0x4669             MOV      R1,SP
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_IT
   \   0000005E   0xE000             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_IT_5
    184            }
    185            else
    186              return HAL_ERROR;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_0: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_IT_5: (+1)
   \   00000062   0xB020             ADD      SP,SP,#+128
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    187          }
    188          
    189          /**
    190            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    191            * @param  DevAddress Target device address
    192            * @param  Command 8 bit Command to be tasked as the first byte to the I2C Channel.
    193            * @param  pData Pointer to data buffer                
    194            * @param  Size Amount of data to be sent  TXBUFFERSIZE=80 Bytes
    195            * @param  Timeout NUmber of 1ms ticks to wait.
    196            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    197            *                                HAL_ERROR:    Error found in Tasking or data passed.
    198            *                                HAL_BUSY:     UART is busy.
    199            *                                HAL_TIMEOUT:  UART timed out.
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_CMDData(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    202          { 
   \                     RoadBrd_I2C_Master_Transmit_CMDData: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB09F             SUB      SP,SP,#+124
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8098      LDR      R8,[SP, #+152]
    203            int x;
    204            uint8_t TempBuffer[TXBUFFERSIZE+2];
    205            
    206            // Test o see if data is legal.
    207            if (Size <= TXBUFFERSIZE)
   \   00000012   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000014   0x2F79             CMP      R7,#+121
   \   00000016   0xDA26             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_0
    208            {
    209              // Now build Temp Buffer for tasking.
    210              TempBuffer[0] = Command;
   \   00000018   0xF88D 0x5000      STRB     R5,[SP, #+0]
    211              if( Size>0 )
   \   0000001C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD013             BEQ.N    ??RoadBrd_I2C_Master_Transmit_CMDData_1
    212              {
    213                for(x=0; x<Size; x++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4681             MOV      R9,R0
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_2: (+1)
   \   00000026   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000028   0x45B9             CMP      R9,R7
   \   0000002A   0xDA07             BGE.N    ??RoadBrd_I2C_Master_Transmit_CMDData_3
    214                  TempBuffer[x+1] = pData[x];
   \   0000002C   0xF816 0x0009      LDRB     R0,[R6, R9]
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x4449             ADD      R1,R1,R9
   \   00000034   0x7048             STRB     R0,[R1, #+1]
   \   00000036   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000003A   0xE7F4             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_2
    215                TempBuffer[Size+1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000042   0x4439             ADD      R1,R1,R7
   \   00000044   0x7048             STRB     R0,[R1, #+1]
    216                Size++;
   \   00000046   0x1C7F             ADDS     R7,R7,#+1
   \   00000048   0xE004             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_4
    217              }
    218              else
    219              {
    220                TempBuffer[1] = 0x00;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    221                Size = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0007             MOVS     R7,R0
    222              }
    223              return RoadBrd_I2C_Master_Transmit(DevAddress, TempBuffer, Size, Timeout);
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_4: (+1)
   \   00000054   0x4643             MOV      R3,R8
   \   00000056   0x003A             MOVS     R2,R7
   \   00000058   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit
   \   00000064   0xE000             B.N      ??RoadBrd_I2C_Master_Transmit_CMDData_5
    224            }
    225            else
    226              return HAL_ERROR;
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_0: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_I2C_Master_Transmit_CMDData_5: (+1)
   \   00000068   0xB01F             ADD      SP,SP,#+124
   \   0000006A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    227          }
    228          
    229          /**
    230            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    231            * @param  DevAddress Target device address
    232            * @param  pData Pointer to data buffer
    233            * @param  Size Amount of data to be sent
    234            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    235            *                                HAL_ERROR:    Error found in Tasking or data passed.
    236            *                                HAL_BUSY:     UART is busy.
    237            *                                HAL_TIMEOUT:  UART timed out.
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    240          { 
   \                     RoadBrd_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    241              HAL_StatusTypeDef Status;
    242          
    243              // Turn On STATUS_LED LED.
    244          #ifndef NUCLEO
    245          #ifndef LED_OFF
    246          RoadBrd_gpio_On( STATUS_LED );
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       RoadBrd_gpio_On
    247          #endif
    248          #endif
    249              Status = HAL_I2C_Master_Transmit_IT(&hi2c1, (uint16_t)DevAddress, (uint8_t*)pData, Size);
   \   0000000E   0x0033             MOVS     R3,R6
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable12_1
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Master_Transmit_IT
   \   0000001E   0x0007             MOVS     R7,R0
    250              // Turn Off STATUS_LED LED.
    251          #ifndef NUCLEO
    252          #ifndef LED_OFF
    253              RoadBrd_gpio_Off( STATUS_LED );
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       RoadBrd_gpio_Off
    254          #endif
    255          #endif
    256              
    257              return Status;
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    258          }
    259          
    260          /**
    261            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    262            * @param  DevAddress Target device address
    263            * @param  pData Pointer to data buffer
    264            * @param  Size Amount of data to be sent
    265            * @param  Timeout NUmber of 1ms ticks to wait.
    266            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    267            *                                HAL_ERROR:    Error found in Tasking or data passed.
    268            *                                HAL_BUSY:     UART is busy.
    269            *                                HAL_TIMEOUT:  UART timed out.
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          HAL_StatusTypeDef RoadBrd_I2C_Master_Transmit(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    272          { 
   \                     RoadBrd_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    273              HAL_StatusTypeDef Status;
    274          
    275              // Turn On STATUS_LED LED.
    276          #ifndef NUCLEO
    277          #ifndef LED_OFF
    278              RoadBrd_gpio_On( STATUS_LED );
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_gpio_On
    279          #endif
    280          #endif
    281              Status = HAL_I2C_Master_Transmit(&hi2c1, (uint16_t)DevAddress, (uint8_t*)pData, Size, Timeout);
   \   00000014   0x9700             STR      R7,[SP, #+0]
   \   00000016   0x0033             MOVS     R3,R6
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x....             LDR.N    R0,??DataTable12_1
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000026   0x4680             MOV      R8,R0
    282              // Turn Off STATUS_LED LED.
    283          #ifndef NUCLEO
    284          #ifndef LED_OFF
    285              RoadBrd_gpio_Off( STATUS_LED );
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       RoadBrd_gpio_Off
    286          #endif
    287          #endif
    288              
    289              return Status;
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    290          }
    291          
    292          /**
    293            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_CmdReceive(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout): 
    294            *             Receive in master mode an amount of data in blocking mode with Interrupt
    295            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    296            *                the configuration information for the specified I2C.
    297            * @param  DevAddress Target device address
    298            * @param  pData Pointer to data buffer
    299            * @param  Size Amount of data to be received.
    300            * @param  Timeout NUmber of 1ms ticks to wait.
    301            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    302            *                                HAL_ERROR:    Error found in Tasking or data passed.
    303            *                                HAL_BUSY:     UART is busy.
    304            *                                HAL_TIMEOUT:  UART timed out.
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          HAL_StatusTypeDef RoadBrd_I2C_Master_CmdReceive(uint16_t DevAddress, uint8_t Command, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    307          {
   \                     RoadBrd_I2C_Master_CmdReceive: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    308            HAL_StatusTypeDef Status;
    309            uint8_t TempBuffer[2];
    310          
    311            // Now build Temp Buffer for tasking.
    312            TempBuffer[0] = Command;
   \   00000012   0xF88D 0x5004      STRB     R5,[SP, #+4]
    313            TempBuffer[1] = 0x00;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0005      STRB     R0,[SP, #+5]
    314            
    315            // Turn On STATUS_LED LED.
    316          #ifndef NUCLEO
    317          #ifndef LED_OFF
    318            RoadBrd_gpio_On( STATUS_LED );
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x.... 0x....      BL       RoadBrd_gpio_On
    319          #endif
    320          #endif
    321            Status = RoadBrd_I2C_Master_Transmit(DevAddress, TempBuffer, 1, Timeout);
   \   00000022   0x4643             MOV      R3,R8
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit
   \   00000030   0x4681             MOV      R9,R0
    322            if(Status != HAL_OK)
   \   00000032   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_I2C_Master_CmdReceive_0
    323              return Status;
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE00C             B.N      ??RoadBrd_I2C_Master_CmdReceive_1
    324            
    325            Status = HAL_I2C_Master_Receive(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size, Timeout);
   \                     ??RoadBrd_I2C_Master_CmdReceive_0: (+1)
   \   00000042   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000046   0x003B             MOVS     R3,R7
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0x0021             MOVS     R1,R4
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x....             LDR.N    R0,??DataTable12_1
   \   00000052   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000056   0x4681             MOV      R9,R0
    326            // Turn Off STATUS_LED LED.
    327          #ifndef NUCLEO
    328          #ifndef LED_OFF
    329            //RoadBrd_gpio_Off( STATUS_LED );
    330          #endif
    331          #endif
    332              
    333            return Status;
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??RoadBrd_I2C_Master_CmdReceive_1: (+1)
   \   0000005C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    334          }
    335          
    336          /**
    337            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Receive(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout): 
    338            *             Receive in master mode an amount of data in non-blocking mode with Interrupt
    339            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    340            *                the configuration information for the specified I2C.
    341            * @param  DevAddress Target device address
    342            * @param  pData Pointer to data buffer
    343            * @param  Size Amount of data to be received.
    344            * @param  Timeout NUmber of 1ms ticks to wait.
    345            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    346            *                                HAL_ERROR:    Error found in Tasking or data passed.
    347            *                                HAL_BUSY:     UART is busy.
    348            *                                HAL_TIMEOUT:  UART timed out.
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          HAL_StatusTypeDef RoadBrd_I2C_Master_Receive(uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    351          {
   \                     RoadBrd_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    352              HAL_StatusTypeDef Status;
    353          
    354              // Turn On STATUS_LED LED.
    355          #ifndef NUCLEO
    356          #ifndef LED_OFF
    357              RoadBrd_gpio_On( STATUS_LED );
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_gpio_On
    358          #endif
    359          #endif
    360              Status = HAL_I2C_Master_Receive(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size, Timeout);
   \   00000014   0x9700             STR      R7,[SP, #+0]
   \   00000016   0x0033             MOVS     R3,R6
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x....             LDR.N    R0,??DataTable12_1
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000026   0x4680             MOV      R8,R0
    361              // Turn Off STATUS_LED LED.
    362          #ifndef NUCLEO
    363          #ifndef LED_OFF
    364              RoadBrd_gpio_Off( STATUS_LED );
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       RoadBrd_gpio_Off
    365          #endif
    366          #endif
    367              
    368              return Status;
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    369          }
    370          
    371          /**
    372            * @brief  HAL_StatusTypeDef RoadBrd_I2C_Master_Receive_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size): 
    373            *             Receive in master mode an amount of data in non-blocking mode with Interrupt
    374            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    375            *                the configuration information for the specified I2C.
    376            * @param  DevAddress Target device address
    377            * @param  pData Pointer to data buffer
    378            * @param  Size Amount of data to be received.
    379            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    380            *                                HAL_ERROR:    Error found in Tasking or data passed.
    381            *                                HAL_BUSY:     UART is busy.
    382            *                                HAL_TIMEOUT:  UART timed out.
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          HAL_StatusTypeDef RoadBrd_I2C_Master_Receive_IT(uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    385          {
   \                     RoadBrd_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    386              HAL_StatusTypeDef Status;
    387              
    388              // Turn On STATUS_LED LED.
    389          #ifndef NUCLEO
    390          #ifndef LED_OFF
    391              RoadBrd_gpio_On( STATUS_LED );
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       RoadBrd_gpio_On
    392          #endif
    393          #endif
    394              Status = HAL_I2C_Master_Receive_IT(&hi2c1, (uint16_t)DevAddress, (uint8_t *)pData, Size);
   \   0000000E   0x0033             MOVS     R3,R6
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable12_1
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Master_Receive_IT
   \   0000001E   0x0007             MOVS     R7,R0
    395              // Turn Off STATUS_LED LED.
    396          #ifndef NUCLEO
    397          #ifndef LED_OFF
    398              RoadBrd_gpio_Off( STATUS_LED );
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       RoadBrd_gpio_Off
    399          #endif
    400          #endif
    401              
    402              return Status;
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    403          }
    404          
    405          /**
    406          * @brief  Return the I2C error code.
    407            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    408            *              the configuration information for the specified I2C.
    409            * @retval I2C Error Code
    410          */

   \                                 In section .text, align 2, keep-with-next
    411          uint32_t RoadBrd_I2C_GetError( void )
    412          {
   \                     RoadBrd_I2C_GetError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    413            return HAL_I2C_GetError(&hi2c1);
   \   00000002   0x....             LDR.N    R0,??DataTable12_1
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    414          }
    415          
    416          
    417          /**
    418            * @brief  HAL_I2C_StateTypeDef RoadBrd_I2C_GetState( void ): Return the I2C handle state.
    419            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    420            *                the configuration information for the specified I2C.
    421            * @retval HAL state   :   HAL_I2C_STATE_RESET             = 0x00,   Peripheral is not yet Initialized         
    422            *                         HAL_I2C_STATE_READY             = 0x20,   Peripheral Initialized and ready for use
    423            *                         HAL_I2C_STATE_BUSY              = 0x24,   An internal process is ongoing             
    424            *                         HAL_I2C_STATE_BUSY_TX           = 0x21,   Data Transmission process is ongoing  
    425            *                         HAL_I2C_STATE_BUSY_RX           = 0x22,   Data Reception process is ongoing        
    426            *                         HAL_I2C_STATE_TIMEOUT           = 0xA0,   Timeout state                            
    427            *                         HAL_I2C_STATE_ERROR             = 0xE0    Error                                    
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          HAL_I2C_StateTypeDef RoadBrd_I2C_GetState( void )
    430          {
   \                     RoadBrd_I2C_GetState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    431            return HAL_I2C_GetState(&hi2c1);
   \   00000002   0x....             LDR.N    R0,??DataTable12_1
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetState
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    432          }
    433          
    434          /**
    435            * @brief  HAL_I2C_StateTypeDef RoadBrd_WaitForState( uint16_t WaitCnt ): Wait for state to change
    436            * @param  uint16_t WaitCnt: Count of 5msec ticks to wait before timing out.
    437            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    438            *                                HAL_TIMEOUT:  UART timed out.
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          HAL_StatusTypeDef RoadBrd_WaitForState( uint16_t WaitCnt )
    441          {
   \                     RoadBrd_WaitForState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    442            uint16_t x;
    443            
    444            // Now wait for transaction to complete.
    445            for( x=0; x<=WaitCnt; x++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??RoadBrd_WaitForState_0: (+1)
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD30A             BCC.N    ??RoadBrd_WaitForState_1
    446            {
    447              // Need to Service Watch Dog or we die here....
    448              RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   00000014   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
    449              // Test to see if event finished.
    450              if (RoadBrd_I2C_GetState() == HAL_I2C_STATE_READY)
   \   00000018   0x.... 0x....      BL       RoadBrd_I2C_GetState
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xD004             BEQ.N    ??RoadBrd_WaitForState_1
    451                break;
    452              // Wait 5msec.
    453              RoadBrd_Delay(5);
   \                     ??RoadBrd_WaitForState_2: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0x.... 0x....      BL       RoadBrd_Delay
    454            }
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \   00000028   0xE7EE             B.N      ??RoadBrd_WaitForState_0
    455            // Test for timeout.
    456            if( x == WaitCnt)
   \                     ??RoadBrd_WaitForState_1: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD101             BNE.N    ??RoadBrd_WaitForState_3
    457              return HAL_TIMEOUT;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE000             B.N      ??RoadBrd_WaitForState_4
    458            else
    459              return HAL_OK;
   \                     ??RoadBrd_WaitForState_3: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??RoadBrd_WaitForState_4: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    460          }
    461          
    462          /**
    463            * @brief  void RoadBrd_Delay( __IO uint32_t Delay ): Implement Delay by calling HAL_Delay.
    464            *             NOTE: This currently uses HAL_Delay. This may se a tasking delay in the future.
    465            * @param Delay: specifies the delay time length, in milliseconds.
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          void RoadBrd_Delay( __IO uint32_t Delay )
    469          {
   \                     RoadBrd_Delay: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    470            HAL_Delay( Delay );
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x.... 0x....      BL       HAL_Delay
    471          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    472          

   \                                 In section .text, align 2, keep-with-next
    473          HAL_StatusTypeDef I2C_WaitBusyFlag( void )
    474          {
   \                     I2C_WaitBusyFlag: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    475            return(RdBrdI2C_WaitOnFlagUntilTimeout(&hi2c1, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_FLAG));
   \   00000002   0x2323             MOVS     R3,#+35
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF05F 0x1102      MOVS     R1,#+131074
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1
   \   0000000C   0x.... 0x....      BL       RdBrdI2C_WaitOnFlagUntilTimeout
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    476          }
    477          
    478          /**
    479            * @brief  This function handles I2C Communication Timeout.
    480            * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
    481            *         the configuration information for I2C module
    482            * @param  Flag specifies the I2C flag to check.
    483            * @param  Status The new Flag status (SET or RESET).
    484            * @param  Timeout Timeout duration
    485            * @retval HAL status
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          static HAL_StatusTypeDef RdBrdI2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
    488          {
   \                     RdBrdI2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    489            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    490          
    491            /* Get tick */
    492            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
    493          
    494            /* Wait until flag is set */
    495            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD12D             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    496            {
    497              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x0C28             LSRS     R0,R5,#+16
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10A             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_2
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6940             LDR      R0,[R0, #+20]
   \   00000028   0x4028             ANDS     R0,R5,R0
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE00B             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE009             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_2: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x4028             ANDS     R0,R5,R0
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_5
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_4
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_5: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_4: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD140             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_6
    498              {
    499                /* Check for the Timeout */
    500                if(Timeout != HAL_MAX_DELAY)
   \   00000052   0xF5B7 0x4F00      CMP      R7,#+32768
   \   00000056   0xD0E1             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_1
    501                {
    502                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD005             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_7
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000064   0x4287             CMP      R7,R0
   \   00000066   0xD2D9             BCS.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_1
    503                  {
    504                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_7: (+1)
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0xF884 0x0035      STRB     R0,[R4, #+53]
    505          
    506                    /* Process Unlocked */
    507                    __HAL_UNLOCK(hi2c);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF884 0x0034      STRB     R0,[R4, #+52]
    508          
    509                    return HAL_TIMEOUT;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE02E             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_8
    510                  }
    511                }
    512              }
    513            }
    514            else
    515            {
    516              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_0: (+1)
   \   00000078   0x0C28             LSRS     R0,R5,#+16
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD10A             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_9
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6940             LDR      R0,[R0, #+20]
   \   00000084   0x4028             ANDS     R0,R5,R0
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_10
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE00B             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_10: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE009             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_9: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0x4028             ANDS     R0,R5,R0
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0xB2A9             UXTH     R1,R5            ;; ZeroExt  R1,R5,#+16,#+16
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD101             BNE.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_12
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_11
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_12: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_11: (+1)
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD012             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_6
    517              {
    518                /* Check for the Timeout */
    519                if(Timeout != HAL_MAX_DELAY)
   \   000000AE   0xF5B7 0x4F00      CMP      R7,#+32768
   \   000000B2   0xD0E1             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    520                {
    521                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD005             BEQ.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_13
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000C0   0x4287             CMP      R7,R0
   \   000000C2   0xD2D9             BCS.N    ??RdBrdI2C_WaitOnFlagUntilTimeout_0
    522                  {
    523                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_13: (+1)
   \   000000C4   0x2020             MOVS     R0,#+32
   \   000000C6   0xF884 0x0035      STRB     R0,[R4, #+53]
    524          
    525                    /* Process Unlocked */
    526                    __HAL_UNLOCK(hi2c);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0034      STRB     R0,[R4, #+52]
    527          
    528                    return HAL_TIMEOUT;
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0xE000             B.N      ??RdBrdI2C_WaitOnFlagUntilTimeout_8
    529                  }
    530                }
    531              }
    532            }
    533            return HAL_OK;
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_6: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??RdBrdI2C_WaitOnFlagUntilTimeout_8: (+1)
   \   000000D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    534          }
    535          
    536          /**
    537            * @brief  Tests I2C channel and sets error codes if failed.
    538            * @param None.
    539            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    540            *                                HAL_ERROR:    Error found in Tasking or data passed.
    541            *                                HAL_BUSY:     UART is busy.
    542            *                                HAL_TIMEOUT:  UART timed out.
    543            */

   \                                 In section .text, align 2, keep-with-next
    544          HAL_StatusTypeDef RoadBrd_TestI2C( void )
    545          {
   \                     RoadBrd_TestI2C: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    546            GPIO_InitTypeDef GPIO_InitStruct;
    547            HAL_StatusTypeDef Status;
    548            
    549            GPIO_InitStruct.Pin = I2C_SCL_Pin|I2C_SDA_Pin;
   \   00000004   0x20C0             MOVS     R0,#+192
   \   00000006   0x9000             STR      R0,[SP, #+0]
    550            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    551            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9002             STR      R0,[SP, #+8]
    552            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000014   0x.... 0x....      BL       HAL_GPIO_Init
    553            
    554            // Wait for Hardware to stabilize....10ms
    555            RoadBrd_Delay( 10 );
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       RoadBrd_Delay
    556            
    557            // Test I2C Clock
    558            if ( HAL_GPIO_ReadPin( GPIOB, I2C_SCL_Pin) == GPIO_PIN_RESET )
   \   0000001E   0x2140             MOVS     R1,#+64
   \   00000020   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000022   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD114             BNE.N    ??RoadBrd_TestI2C_0
    559            {
    560              // If low....Then SCLK has failed...Record Error.
    561              RdBrd_ErrCdLogErrCd( ERROR_I2C_SCLK, MODULE_i2c );
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x200B             MOVS     R0,#+11
   \   0000002E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    562              Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x2007             MOVS     R0,#+7
   \   00000036   0x.... 0x....      BL       Set_DriverStates
    563              Status = HAL_ERROR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0004             MOVS     R4,R0
    564              
    565              // Time to test SDAT
    566              if ( HAL_GPIO_ReadPin( GPIOB, I2C_SDA_Pin) == GPIO_PIN_RESET)
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000042   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD11B             BNE.N    ??RoadBrd_TestI2C_1
    567              {
    568                // If low....Then SDAT has failed...Record Error.
    569                RdBrd_ErrCdLogErrCd( ERROR_I2C_SDAT, MODULE_i2c );
   \   0000004A   0x2103             MOVS     R1,#+3
   \   0000004C   0x200C             MOVS     R0,#+12
   \   0000004E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
   \   00000052   0xE016             B.N      ??RoadBrd_TestI2C_1
    570              }
    571            }
    572            else
    573            {
    574              // Passed, Time to test SDAT
    575              if ( HAL_GPIO_ReadPin( GPIOB, I2C_SDA_Pin) == GPIO_PIN_RESET)
   \                     ??RoadBrd_TestI2C_0: (+1)
   \   00000054   0x2180             MOVS     R1,#+128
   \   00000056   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000058   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD10A             BNE.N    ??RoadBrd_TestI2C_2
    576              {
    577                // If low....Then SDAT has failed...Record Error.
    578                RdBrd_ErrCdLogErrCd( ERROR_I2C_SDAT, MODULE_i2c );
   \   00000060   0x2103             MOVS     R1,#+3
   \   00000062   0x200C             MOVS     R0,#+12
   \   00000064   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    579                Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x2007             MOVS     R0,#+7
   \   0000006C   0x.... 0x....      BL       Set_DriverStates
    580                Status = HAL_ERROR;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x0004             MOVS     R4,R0
   \   00000074   0xE005             B.N      ??RoadBrd_TestI2C_1
    581              }
    582              else
    583              {
    584                Set_DriverStates( I2C_STATE, DRIVER_ON );
   \                     ??RoadBrd_TestI2C_2: (+1)
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x2007             MOVS     R0,#+7
   \   0000007A   0x.... 0x....      BL       Set_DriverStates
    585                Status = HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0004             MOVS     R4,R0
    586              }
    587            }
    588            
    589            return Status;
   \                     ??RoadBrd_TestI2C_1: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0xB006             ADD      SP,SP,#+24
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
    590          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40023824         DC32     0x40023824
    591          /* USER CODE END 1 */
    592          
    593          /**
    594            * @}
    595            */
    596          
    597          /**
    598            * @}
    599            */
    600          
    601          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_MspDeInit
         8   -> HAL_GPIO_DeInit
      32   HAL_I2C_MspInit
        32   -> HAL_GPIO_Init
       8   I2C_WaitBusyFlag
         8   -> RdBrdI2C_WaitOnFlagUntilTimeout
       8   MX_I2C1_Init
         8   -> Error_Handler
         8   -> HAL_I2C_Init
       8   MX_I2C1_Reset
         8   -> MX_I2C1_Init
         8   -> RoadBrd_Delay
      24   RdBrdI2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
       8   RoadBrd_Delay
         8   -> HAL_Delay
       8   RoadBrd_I2C_GetError
         8   -> HAL_I2C_GetError
       8   RoadBrd_I2C_GetState
         8   -> HAL_I2C_GetState
      40   RoadBrd_I2C_Master_CmdReceive
        40   -> HAL_I2C_Master_Receive
        40   -> RoadBrd_I2C_Master_Transmit
        40   -> RoadBrd_gpio_On
      32   RoadBrd_I2C_Master_Receive
        32   -> HAL_I2C_Master_Receive
        32   -> RoadBrd_gpio_Off
        32   -> RoadBrd_gpio_On
      24   RoadBrd_I2C_Master_Receive_IT
        24   -> HAL_I2C_Master_Receive_IT
        24   -> RoadBrd_gpio_Off
        24   -> RoadBrd_gpio_On
      32   RoadBrd_I2C_Master_Transmit
        32   -> HAL_I2C_Master_Transmit
        32   -> RoadBrd_gpio_Off
        32   -> RoadBrd_gpio_On
     152   RoadBrd_I2C_Master_Transmit_CMDData
       152   -> RoadBrd_I2C_Master_Transmit
     152   RoadBrd_I2C_Master_Transmit_CMDData_IT
       152   -> RoadBrd_I2C_Master_Transmit_IT
      24   RoadBrd_I2C_Master_Transmit_IT
        24   -> HAL_I2C_Master_Transmit_IT
        24   -> RoadBrd_gpio_Off
        24   -> RoadBrd_gpio_On
      32   RoadBrd_TestI2C
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_ReadPin
        32   -> RdBrd_ErrCdLogErrCd
        32   -> RoadBrd_Delay
        32   -> Set_DriverStates
      16   RoadBrd_WaitForState
        16   -> RoadBrd_Delay
        16   -> RoadBrd_I2C_GetState
        16   -> RoadBrd_WWDG_Refresh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
      42  HAL_I2C_MspDeInit
      80  HAL_I2C_MspInit
      18  I2C_WaitBusyFlag
      98  MX_I2C1_Init
      80  MX_I2C1_Reset
     218  RdBrdI2C_WaitOnFlagUntilTimeout
      10  RoadBrd_Delay
      10  RoadBrd_I2C_GetError
      10  RoadBrd_I2C_GetState
      96  RoadBrd_I2C_Master_CmdReceive
      54  RoadBrd_I2C_Master_Receive
      44  RoadBrd_I2C_Master_Receive_IT
      54  RoadBrd_I2C_Master_Transmit
     110  RoadBrd_I2C_Master_Transmit_CMDData
     104  RoadBrd_I2C_Master_Transmit_CMDData_IT
      44  RoadBrd_I2C_Master_Transmit_IT
     138  RoadBrd_TestI2C
      62  RoadBrd_WaitForState
      60  hi2c1

 
    60 bytes in section .bss
 1 288 bytes in section .text
 
 1 288 bytes of CODE memory
    60 bytes of DATA memory

Errors: none
Warnings: none
