###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       07/Dec/2017  20:12:27
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_uart.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_uart.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The UART HAL driver can be used as follows:
     20              
     21              (#) Declare a UART_HandleTypeDef handle structure.
     22          
     23              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     24                  (##) Enable the USARTx interface clock.
     25                  (##) UART pins configuration:
     26                      (+++) Enable the clock for the UART GPIOs.
     27                      (+++) Configure the UART pins as alternate function pull-up.
     28                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     29                       and HAL_UART_Receive_IT() APIs):
     30                      (+++) Configure the USARTx interrupt priority.
     31                      (+++) Enable the NVIC USART IRQ handle.
     32                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     33                       and HAL_UART_Receive_DMA() APIs):
     34                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     35                      (+++) Enable the DMAx interface clock.
     36                      (+++) Configure the declared DMA handle structure with the required 
     37                            Tx/Rx parameters.                
     38                      (+++) Configure the DMA Tx/Rx channel.
     39                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     40                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     41                            interrupt on the DMA Tx/Rx channel.
     42                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     43                            (used for last byte sending completion detection in DMA non circular mode)
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     85                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     86                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     87                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     88                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     90          
     91               *** DMA mode IO operation ***
     92               ==============================
     93               [..] 
     94                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     95                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     96                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     97                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     99                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    100                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    101                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    102                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    103                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    104                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    106                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    107                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    108                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    109          
    110               *** UART HAL driver macros list ***
    111               =============================================
    112               [..]
    113                 Below the list of most used macros in UART HAL driver.
    114          
    115                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    116                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    117                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    118                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    119                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    120                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    121                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    122          
    123               [..]
    124                 (@) You can refer to the UART HAL driver header file for more useful macros 
    125                
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32l1xx_hal.h"
    159          #include "wwdg.h"
    160          
    161          /** @addtogroup STM32L1xx_HAL_Driver
    162            * @{
    163            */
    164          
    165          /** @defgroup UART UART
    166            * @brief HAL UART module driver
    167            * @{
    168            */
    169          #ifdef HAL_UART_MODULE_ENABLED
    170              
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private define ------------------------------------------------------------*/
    173          /* Private macros ------------------------------------------------------------*/
    174          /* Private variables ---------------------------------------------------------*/
    175          /* Private function prototypes -----------------------------------------------*/
    176          /** @addtogroup UART_Private_Functions   UART Private Functions
    177            * @{
    178            */
    179          static void UART_SetConfig (UART_HandleTypeDef *huart);
    180          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    181          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    182          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    183          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    187          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    188          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    189          /**
    190            * @}
    191            */
    192          
    193          /* Exported functions ---------------------------------------------------------*/
    194          
    195          /** @defgroup UART_Exported_Functions UART Exported Functions
    196            * @{
    197            */
    198          
    199          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    200            *  @brief    Initialization and Configuration functions 
    201            *
    202          @verbatim
    203          ===============================================================================
    204                      ##### Initialization and Configuration functions #####
    205           ===============================================================================  
    206              [..]
    207              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    208              in asynchronous mode.
    209                (+) For the asynchronous mode only these parameters can be configured: 
    210                  (++) Baud Rate
    211                  (++) Word Length 
    212                  (++) Stop Bit
    213                  (++) Parity
    214                  (++) Hardware flow control
    215                  (++) Receiver/transmitter modes
    216                  (++) Over Sampling Methode
    217              [..]
    218              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    219              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    220              configuration procedures (details for the procedures are available in reference manual (RM0038)).
    221          
    222          @endverbatim
    223            * @{
    224            */
    225          
    226          /*
    227            Additionnal remark: If the parity is enabled, then the MSB bit of the data written
    228                                in the data register is transmitted but is changed by the parity bit.
    229                                Depending on the frame length defined by the M bit (8-bits or 9-bits),
    230                                the possible UART frame formats are as listed in the following table:
    231              +-------------------------------------------------------------+
    232              |   M bit |  PCE bit  |            UART frame                 |
    233              |---------------------|---------------------------------------|
    234              |    0    |    0      |    | SB | 8 bit data | STB |          |
    235              |---------|-----------|---------------------------------------|
    236              |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    237              |---------|-----------|---------------------------------------|
    238              |    1    |    0      |    | SB | 9 bit data | STB |          |
    239              |---------|-----------|---------------------------------------|
    240              |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    241              +-------------------------------------------------------------+
    242          */
    243          
    244          /**
    245            * @brief  Initializes the UART mode according to the specified parameters in
    246            *         the UART_InitTypeDef and create the associated handle.
    247            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    248            *                the configuration information for the specified UART module.
    249            * @retval HAL status
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    252          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    253            /* Check the UART handle allocation */
    254            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_Init_0
    255            {
    256              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE031             B.N      ??HAL_UART_Init_1
    257            }
    258          
    259            /* Check the parameters */
    260            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FF             BNE.N    ??HAL_UART_Init_2
    261            {
    262              /* The hardware flow control is available only for USART1, USART2, USART3 */
    263              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    264              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    265            }
    266            else
    267            {
    268              assert_param(IS_UART_INSTANCE(huart->Instance));
    269            }
    270            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    271            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    272            
    273            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??HAL_UART_Init_4
    274            {  
    275              /* Allocate lock resource and initialize it */
    276              huart->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
    277          
    278              /* Init the low level hardware */
    279              HAL_UART_MspInit(huart);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    280            }
    281          
    282            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    283          
    284            /* Disable the peripheral */
    285            __HAL_UART_DISABLE(huart);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x60C8             STR      R0,[R1, #+12]
    286            
    287            /* Set the UART Communication parameters */
    288            UART_SetConfig(huart);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_SetConfig
    289            
    290            /* In asynchronous mode, the following bits must be kept cleared: 
    291               - LINEN and CLKEN bits in the USART_CR2 register,
    292               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    293            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6900             LDR      R0,[R0, #+16]
   \   00000042   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6108             STR      R0,[R1, #+16]
    294            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6940             LDR      R0,[R0, #+20]
   \   0000004E   0xF07F 0x012A      MVNS     R1,#+42
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6148             STR      R0,[R1, #+20]
    295            
    296            /* Enable the peripheral */
    297            __HAL_UART_ENABLE(huart);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x60C8             STR      R0,[R1, #+12]
    298            
    299            /* Initialize the UART state */
    300            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x63E0             STR      R0,[R4, #+60]
    301            huart->State= HAL_UART_STATE_READY;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF884 0x0039      STRB     R0,[R4, #+57]
    302            
    303            return HAL_OK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Init_1: (+1)
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    304          }
    305          
    306          /**
    307            * @brief  Initializes the half-duplex mode according to the specified
    308            *         parameters in the UART_InitTypeDef and create the associated handle.
    309            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    310            *                the configuration information for the specified UART module.
    311            * @retval HAL status
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    314          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    315            /* Check the UART handle allocation */
    316            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    317            {
    318              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE034             B.N      ??HAL_HalfDuplex_Init_1
    319            }
    320            
    321            /* Check UART instance */
    322            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    323            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    324            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    325          
    326            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    327            {   
    328              /* Allocate lock resource and initialize it */
    329              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    330          
    331              /* Init the low level hardware */
    332              HAL_UART_MspInit(huart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    333            }
    334          
    335            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    336          
    337            /* Disable the peripheral */
    338            __HAL_UART_DISABLE(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    339            
    340            /* Set the UART Communication parameters */
    341            UART_SetConfig(huart);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    342            
    343            /* In half-duplex mode, the following bits must be kept cleared: 
    344               - LINEN and CLKEN bits in the USART_CR2 register,
    345               - SCEN and IREN bits in the USART_CR3 register.*/
    346            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6108             STR      R0,[R1, #+16]
    347            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0xF07F 0x0122      MVNS     R1,#+34
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6148             STR      R0,[R1, #+20]
    348            
    349            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    350            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6940             LDR      R0,[R0, #+20]
   \   00000056   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6148             STR      R0,[R1, #+20]
    351           
    352            /* Enable the peripheral */
    353            __HAL_UART_ENABLE(huart);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
    354            
    355            /* Initialize the UART state*/
    356            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x63E0             STR      R0,[R4, #+60]
    357            huart->State= HAL_UART_STATE_READY;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xF884 0x0039      STRB     R0,[R4, #+57]
    358            
    359            return HAL_OK;
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    360          }
    361          
    362          /**
    363            * @brief  Initializes the LIN mode according to the specified
    364            *         parameters in the UART_InitTypeDef and create the associated handle.
    365            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    366            *                the configuration information for the specified UART module.
    367            * @param  BreakDetectLength: Specifies the LIN break detection length.
    368            *         This parameter can be one of the following values:
    369            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    370            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    371            * @retval HAL status
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    374          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    375            /* Check the UART handle allocation */
    376            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    377            {
    378              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE03C             B.N      ??HAL_LIN_Init_1
    379            }
    380            
    381            /* Check the LIN UART instance */  
    382            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    383            /* Check the Break detection length parameter */
    384            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    385            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    386            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    387            
    388            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_2
    389            {   
    390              /* Allocate lock resource and initialize it */
    391              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    392          
    393              /* Init the low level hardware */
    394              HAL_UART_MspInit(huart);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    395            }
    396          
    397            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    398          
    399            /* Disable the peripheral */
    400            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    401            
    402            /* Set the UART Communication parameters */
    403            UART_SetConfig(huart);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    404            
    405            /* In LIN mode, the following bits must be kept cleared: 
    406               - CLKEN bits in the USART_CR2 register,
    407               - SCEN and IREN bits in the USART_CR3 register.*/
    408            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6108             STR      R0,[R1, #+16]
    409            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0xF07F 0x012A      MVNS     R1,#+42
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6148             STR      R0,[R1, #+20]
    410            
    411            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    412            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6108             STR      R0,[R1, #+16]
    413            
    414            /* Set the USART LIN Break detection length. */
    415            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6900             LDR      R0,[R0, #+16]
   \   00000064   0xF07F 0x0120      MVNS     R1,#+32
   \   00000068   0x4008             ANDS     R0,R1,R0
   \   0000006A   0x4328             ORRS     R0,R5,R0
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x6108             STR      R0,[R1, #+16]
    416            
    417            /* Enable the peripheral */
    418            __HAL_UART_ENABLE(huart);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x60C8             STR      R0,[R1, #+12]
    419            
    420            /* Initialize the UART state*/
    421            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x63E0             STR      R0,[R4, #+60]
    422            huart->State= HAL_UART_STATE_READY;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xF884 0x0039      STRB     R0,[R4, #+57]
    423            
    424            return HAL_OK;
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000088   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    425          }
    426          
    427          /**
    428            * @brief  Initializes the Multi-Processor mode according to the specified
    429            *         parameters in the UART_InitTypeDef and create the associated handle.
    430            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    431            *                the configuration information for the specified UART module.
    432            * @param  Address: UART node address
    433            * @param  WakeUpMethod: specifies the UART wakeup method.
    434            *         This parameter can be one of the following values:
    435            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
    436            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
    437            * @retval HAL status
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    440          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    441            /* Check the UART handle allocation */
    442            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    443            {
    444              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE03D             B.N      ??HAL_MultiProcessor_Init_1
    445            }
    446          
    447            /* Check UART instance capabilities */  
    448            assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
    449          
    450            /* Check the Address & wake up method parameters */
    451            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    452            assert_param(IS_UART_ADDRESS(Address));
    453            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    454            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    455          
    456            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    457            {   
    458              /* Allocate lock resource and initialize it */
    459              huart->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0038      STRB     R0,[R4, #+56]
    460          
    461              /* Init the low level hardware */
    462              HAL_UART_MspInit(huart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    463            }
    464          
    465            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    466          
    467            /* Disable the peripheral */
    468            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x60C8             STR      R0,[R1, #+12]
    469            
    470            /* Set the UART Communication parameters */
    471            UART_SetConfig(huart);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UART_SetConfig
    472            
    473            /* In Multi-Processor mode, the following bits must be kept cleared: 
    474               - LINEN and CLKEN bits in the USART_CR2 register,
    475               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    476            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6108             STR      R0,[R1, #+16]
    477            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF07F 0x012A      MVNS     R1,#+42
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    478            
    479            /* Set the USART address node */
    480            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6900             LDR      R0,[R0, #+16]
   \   0000005A   0x0900             LSRS     R0,R0,#+4
   \   0000005C   0x0100             LSLS     R0,R0,#+4
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x4328             ORRS     R0,R5,R0
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6108             STR      R0,[R1, #+16]
    481            
    482            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    483            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000006E   0x4330             ORRS     R0,R6,R0
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x60C8             STR      R0,[R1, #+12]
    484            
    485            /* Enable the peripheral */
    486            __HAL_UART_ENABLE(huart);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
    487            
    488            /* Initialize the UART state */
    489            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x63E0             STR      R0,[R4, #+60]
    490            huart->State= HAL_UART_STATE_READY;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0039      STRB     R0,[R4, #+57]
    491            
    492            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
    493          }
    494          
    495          /**
    496            * @brief  DeInitializes the UART peripheral. 
    497            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    498            *                the configuration information for the specified UART module.
    499            * @retval HAL status
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    502          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    503            /* Check the UART handle allocation */
    504            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_DeInit_0
    505            {
    506              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE01D             B.N      ??HAL_UART_DeInit_1
    507            }
    508            
    509            /* Check the parameters */
    510            assert_param(IS_UART_INSTANCE(huart->Instance));
    511          
    512            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0039      STRB     R0,[R4, #+57]
    513            
    514            /* Disable the Peripheral */
    515            __HAL_UART_DISABLE(huart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
    516            
    517            huart->Instance->CR1 = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x60C8             STR      R0,[R1, #+12]
    518            huart->Instance->CR2 = 0x0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6108             STR      R0,[R1, #+16]
    519            huart->Instance->CR3 = 0x0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6148             STR      R0,[R1, #+20]
    520            
    521            /* DeInit the low level hardware */
    522            HAL_UART_MspDeInit(huart);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       HAL_UART_MspDeInit
    523          
    524            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    525            huart->State = HAL_UART_STATE_RESET;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
    526          
    527            /* Process Unlock */
    528            __HAL_UNLOCK(huart);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0038      STRB     R0,[R4, #+56]
    529          
    530            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    531          }
    532          
    533          /**
    534            * @brief  UART MSP Init.
    535            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    536            *                the configuration information for the specified UART module.
    537            * @retval None
    538            */

   \                                 In section .text, align 2, keep-with-next
    539           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    540          {
    541            /* Prevent unused argument(s) compilation warning */
    542            UNUSED(huart);
    543          
    544            /* NOTE: This function should not be modified, when the callback is needed,
    545                     the HAL_UART_MspInit can be implemented in the user file
    546             */ 
    547          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    548          
    549          /**
    550            * @brief  UART MSP DeInit.
    551            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    552            *                the configuration information for the specified UART module.
    553            * @retval None
    554            */

   \                                 In section .text, align 2, keep-with-next
    555           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    556          {
    557            /* Prevent unused argument(s) compilation warning */
    558            UNUSED(huart);
    559          
    560            /* NOTE: This function should not be modified, when the callback is needed,
    561                     the HAL_UART_MspDeInit can be implemented in the user file
    562             */ 
    563          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    564          
    565          /**
    566            * @}
    567            */
    568          
    569          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    570            *  @brief UART Transmit and Receive functions 
    571            *
    572          @verbatim
    573            ==============================================================================
    574                                ##### IO operation functions #####
    575            ==============================================================================  
    576            [..]
    577              This subsection provides a set of functions allowing to manage the UART asynchronous
    578              and Half duplex data transfers.
    579          
    580              (#) There are two modes of transfer:
    581                 (++) Blocking mode: The communication is performed in polling mode. 
    582                      The HAL status of all data processing is returned by the same function 
    583                      after finishing transfer.  
    584                 (++) Non blocking mode: The communication is performed using Interrupts 
    585                      or DMA, these APIs return the HAL status.
    586                      The end of the data processing will be indicated through the 
    587                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    588                      using DMA mode.
    589                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    590                      will be executed respectively at the end of the transmit or receive process.
    591                      The HAL_UART_ErrorCallback() user callback will be executed when 
    592                      a communication error is detected.
    593          
    594              (#) Blocking mode APIs are:
    595                  (++) HAL_UART_Transmit()
    596                  (++) HAL_UART_Receive() 
    597          
    598              (#) Non Blocking mode APIs with Interrupt are:
    599                  (++) HAL_UART_Transmit_IT()
    600                  (++) HAL_UART_Receive_IT()
    601                  (++) HAL_UART_IRQHandler()
    602          
    603              (#) Non Blocking mode functions with DMA are:
    604                  (++) HAL_UART_Transmit_DMA()
    605                  (++) HAL_UART_Receive_DMA()
    606                  (++) HAL_UART_DMAPause()
    607                  (++) HAL_UART_DMAResume()
    608                  (++) HAL_UART_DMAStop()
    609          
    610              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    611                  (++) HAL_UART_TxHalfCpltCallback()
    612                  (++) HAL_UART_TxCpltCallback()
    613                  (++) HAL_UART_RxHalfCpltCallback()
    614                  (++) HAL_UART_RxCpltCallback()
    615                  (++) HAL_UART_ErrorCallback()
    616          
    617              [..] 
    618                (@) In the Half duplex communication, it is forbidden to run the transmit 
    619                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    620                    can't be useful.
    621                
    622          @endverbatim
    623            * @{
    624            */
    625          
    626          /**
    627            * @brief  Sends an amount of data in blocking mode. 
    628            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    629            *                the configuration information for the specified UART module.
    630            * @param  pData: Pointer to data buffer
    631            * @param  Size: Amount of data to be sent
    632            * @param  Timeout: Timeout duration  
    633            * @retval HAL status
    634            */

   \                                 In section .text, align 2, keep-with-next
    635          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    636          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    637            uint16_t* tmp;
    638            uint32_t tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    639            
    640            tmp_state = huart->State;
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x4681             MOV      R9,R0
    641            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_0
   \   0000001C   0xF1B9 0x0F22      CMP      R9,#+34
   \   00000020   0xD169             BNE.N    ??HAL_UART_Transmit_1
    642            {
    643              if((pData == NULL) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Transmit_2
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Transmit_3
    644              {
    645                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE063             B.N      ??HAL_UART_Transmit_4
    646              }
    647          
    648              /* Process Locked */
    649              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000030   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Transmit_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE05D             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
    650          
    651              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63E0             STR      R0,[R4, #+60]
    652              /* Check if a non-blocking receive process is ongoing or not */
    653              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000046   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000004A   0x2822             CMP      R0,#+34
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Transmit_6
    654              {
    655                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Transmit_7
    656              }
    657              else
    658              {
    659                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000056   0x2012             MOVS     R0,#+18
   \   00000058   0xF884 0x0039      STRB     R0,[R4, #+57]
    660              }
    661          
    662              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   0000005C   0x84A6             STRH     R6,[R4, #+36]
    663              huart->TxXferCount = Size;
   \   0000005E   0x84E6             STRH     R6,[R4, #+38]
    664              while(huart->TxXferCount > 0)
   \                     ??HAL_UART_Transmit_8: (+1)
   \   00000060   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD02D             BEQ.N    ??HAL_UART_Transmit_9
    665              {
    666                huart->TxXferCount--;
   \   00000066   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x84E0             STRH     R0,[R4, #+38]
    667                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD117             BNE.N    ??HAL_UART_Transmit_10
    668                {
    669                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Transmit_11
    670                  {
    671                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE037             B.N      ??HAL_UART_Transmit_4
    672                  }
    673                  tmp = (uint16_t*) pData;
   \                     ??HAL_UART_Transmit_11: (+1)
   \   00000088   0x46A8             MOV      R8,R5
    674                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
   \   0000008A   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000008E   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000090   0x0DC0             LSRS     R0,R0,#+23
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6048             STR      R0,[R1, #+4]
    675                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD101             BNE.N    ??HAL_UART_Transmit_12
    676                  {
    677                    pData +=2;
   \   0000009C   0x1CAD             ADDS     R5,R5,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Transmit_8
    678                  }
    679                  else
    680                  { 
    681                    pData +=1;
   \                     ??HAL_UART_Transmit_12: (+1)
   \   000000A0   0x1C6D             ADDS     R5,R5,#+1
   \   000000A2   0xE7DD             B.N      ??HAL_UART_Transmit_8
    682                  }
    683                } 
    684                else
    685                {
    686                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_10: (+1)
   \   000000A4   0x003B             MOVS     R3,R7
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x2180             MOVS     R1,#+128
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??HAL_UART_Transmit_13
    687                  {
    688                    return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE01F             B.N      ??HAL_UART_Transmit_4
    689                  }
    690                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_13: (+1)
   \   000000B8   0x7828             LDRB     R0,[R5, #+0]
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \   000000C0   0xE7CE             B.N      ??HAL_UART_Transmit_8
    691                }
    692              }
    693          
    694              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000C2   0x003B             MOVS     R3,R7
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0x2140             MOVS     R1,#+64
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD001             BEQ.N    ??HAL_UART_Transmit_14
    695              { 
    696                return HAL_TIMEOUT;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xE010             B.N      ??HAL_UART_Transmit_4
    697              }
    698          
    699              /* Check if a non-blocking receive process is ongoing or not */
    700              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_14: (+1)
   \   000000D6   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000DA   0x2832             CMP      R0,#+50
   \   000000DC   0xD103             BNE.N    ??HAL_UART_Transmit_15
    701              {
    702                huart->State = HAL_UART_STATE_BUSY_RX;
   \   000000DE   0x2022             MOVS     R0,#+34
   \   000000E0   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000E4   0xE002             B.N      ??HAL_UART_Transmit_16
    703              }
    704              else
    705              {
    706                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_15: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xF884 0x0039      STRB     R0,[R4, #+57]
    707              }
    708          
    709              /* Process Unlocked */
    710              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_16: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF884 0x0038      STRB     R0,[R4, #+56]
    711          
    712              return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE000             B.N      ??HAL_UART_Transmit_4
    713            }
    714            else
    715            {
    716              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000F6   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000F8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    717            }
    718          }
    719          
    720          /**
    721            * @brief  Receives an amount of data in blocking mode. 
    722            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    723            *                the configuration information for the specified UART module.
    724            * @param  pData: Pointer to data buffer
    725            * @param  Size: Amount of data to be received
    726            * @param  Timeout: Timeout duration
    727            * @retval HAL status
    728            */

   \                                 In section .text, align 2, keep-with-next
    729          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    730          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    731            uint16_t* tmp;
    732            uint32_t  tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    733          
    734            tmp_state = huart->State;
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x4681             MOV      R9,R0
    735            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_0
   \   0000001C   0xF1B9 0x0F12      CMP      R9,#+18
   \   00000020   0xD16F             BNE.N    ??HAL_UART_Receive_1
    736            {
    737              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Receive_2
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Receive_3
    738              {
    739                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE069             B.N      ??HAL_UART_Receive_4
    740              }
    741          
    742              /* Process Locked */
    743              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000030   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Receive_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE063             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
    744          
    745              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63E0             STR      R0,[R4, #+60]
    746              /* Check if a non-blocking transmit process is ongoing or not */
    747              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000046   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000004A   0x2812             CMP      R0,#+18
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Receive_6
    748              {
    749                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Receive_7
    750              }
    751              else
    752              {
    753                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0xF884 0x0039      STRB     R0,[R4, #+57]
    754              }
    755          
    756              huart->RxXferSize = Size;
   \                     ??HAL_UART_Receive_7: (+1)
   \   0000005C   0x85A6             STRH     R6,[R4, #+44]
    757              huart->RxXferCount = Size;
   \   0000005E   0x85E6             STRH     R6,[R4, #+46]
    758          
    759              /* Check the remain data to be received */
    760              while(huart->RxXferCount > 0)
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000060   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD03D             BEQ.N    ??HAL_UART_Receive_9
    761              {
    762                huart->RxXferCount--;
   \   00000066   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x85E0             STRH     R0,[R4, #+46]
    763                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD11D             BNE.N    ??HAL_UART_Receive_10
    764                {
    765                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2120             MOVS     R1,#+32
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Receive_11
    766                  {
    767                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE03D             B.N      ??HAL_UART_Receive_4
    768                  }
    769                  tmp = (uint16_t*) pData ;
   \                     ??HAL_UART_Receive_11: (+1)
   \   00000088   0x46A8             MOV      R8,R5
    770                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD107             BNE.N    ??HAL_UART_Receive_12
    771                  {
    772                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000096   0x0DC0             LSRS     R0,R0,#+23
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    773                    pData +=2;
   \   0000009C   0x1CAD             ADDS     R5,R5,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Receive_8
    774                  }
    775                  else
    776                  {
    777                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_UART_Receive_12: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000A8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    778                    pData +=1;
   \   000000AC   0x1C6D             ADDS     R5,R5,#+1
   \   000000AE   0xE7D7             B.N      ??HAL_UART_Receive_8
    779                  }
    780          
    781                }
    782                else
    783                {
    784                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000B0   0x003B             MOVS     R3,R7
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2120             MOVS     R1,#+32
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??HAL_UART_Receive_13
    785                  {
    786                    return HAL_TIMEOUT;
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0xE01F             B.N      ??HAL_UART_Receive_4
    787                  }
    788                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000C4   0x6920             LDR      R0,[R4, #+16]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD104             BNE.N    ??HAL_UART_Receive_14
    789                  {
    790                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6840             LDR      R0,[R0, #+4]
   \   000000CE   0x7028             STRB     R0,[R5, #+0]
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \   000000D2   0xE7C5             B.N      ??HAL_UART_Receive_8
    791                  }
    792                  else
    793                  {
    794                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6840             LDR      R0,[R0, #+4]
   \   000000D8   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000DC   0x7028             STRB     R0,[R5, #+0]
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
   \   000000E0   0xE7BE             B.N      ??HAL_UART_Receive_8
    795                  }
    796          
    797                }
    798              }
    799          
    800              /* Check if a non-blocking transmit process is ongoing or not */
    801              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_9: (+1)
   \   000000E2   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000E6   0x2832             CMP      R0,#+50
   \   000000E8   0xD103             BNE.N    ??HAL_UART_Receive_15
    802              {
    803                huart->State = HAL_UART_STATE_BUSY_TX;
   \   000000EA   0x2012             MOVS     R0,#+18
   \   000000EC   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000F0   0xE002             B.N      ??HAL_UART_Receive_16
    804              }
    805              else
    806              {
    807                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_15: (+1)
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xF884 0x0039      STRB     R0,[R4, #+57]
    808              }
    809              /* Process Unlocked */
    810              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_16: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF884 0x0038      STRB     R0,[R4, #+56]
    811          
    812              return HAL_OK;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xE000             B.N      ??HAL_UART_Receive_4
    813            }
    814            else
    815            {
    816              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   00000102   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000104   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    817            }
    818          }
    819          
    820          /**
    821            * @brief  Sends an amount of data in non blocking mode.
    822            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    823            *                the configuration information for the specified UART module.
    824            * @param  pData: Pointer to data buffer
    825            * @param  Size: Amount of data to be sent
    826            * @retval HAL status
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    829          {
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    830            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    831          
    832            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    833            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   00000010   0x2C22             CMP      R4,#+34
   \   00000012   0xD12A             BNE.N    ??HAL_UART_Transmit_IT_1
    834            {
    835              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    836              {
    837                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE024             B.N      ??HAL_UART_Transmit_IT_4
    838              }
    839              
    840              /* Process Locked */
    841              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Transmit_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE01E             B.N      ??HAL_UART_Transmit_IT_4
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    842              
    843              huart->pTxBuffPtr = pData;
   \   00000034   0x6219             STR      R1,[R3, #+32]
    844              huart->TxXferSize = Size;
   \   00000036   0x849A             STRH     R2,[R3, #+36]
    845              huart->TxXferCount = Size;
   \   00000038   0x84DA             STRH     R2,[R3, #+38]
    846          
    847              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    848              /* Check if a receive process is ongoing or not */
    849              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2822             CMP      R0,#+34
   \   00000044   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
    850              {
    851                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Transmit_IT_7
    852              }
    853              else
    854              {
    855                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \   0000004E   0x2012             MOVS     R0,#+18
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    856              }
    857          
    858              /* Process Unlocked */
    859              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    860          
    861              /* Enable the UART Transmit data register empty Interrupt */
    862              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x60E8             STR      R0,[R5, #+12]
    863              
    864              return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE000             B.N      ??HAL_UART_Transmit_IT_4
    865            }
    866            else
    867            {
    868              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   0000006A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   0000006C   0xBC30             POP      {R4,R5}
   \   0000006E   0x4770             BX       LR               ;; return
    869            }
    870          }
    871          
    872          /**
    873            * @brief  Receives an amount of data in non blocking mode 
    874            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    875            *                the configuration information for the specified UART module.
    876            * @param  pData: Pointer to data buffer
    877            * @param  Size: Amount of data to be received
    878            * @retval HAL status
    879            */

   \                                 In section .text, align 2, keep-with-next
    880          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    881          {
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    882            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    883            
    884            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    885            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_IT_0
   \   00000010   0x2C12             CMP      R4,#+18
   \   00000012   0xD136             BNE.N    ??HAL_UART_Receive_IT_1
    886            {
    887              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    888              {
    889                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE030             B.N      ??HAL_UART_Receive_IT_4
    890              }
    891          
    892              /* Process Locked */
    893              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Receive_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE02A             B.N      ??HAL_UART_Receive_IT_4
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    894          
    895              huart->pRxBuffPtr = pData;
   \   00000034   0x6299             STR      R1,[R3, #+40]
    896              huart->RxXferSize = Size;
   \   00000036   0x859A             STRH     R2,[R3, #+44]
    897              huart->RxXferCount = Size;
   \   00000038   0x85DA             STRH     R2,[R3, #+46]
    898          
    899              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    900              /* Check if a transmit process is ongoing or not */
    901              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xD103             BNE.N    ??HAL_UART_Receive_IT_6
    902              {
    903                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Receive_IT_7
    904              }
    905              else
    906              {
    907                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    908              }
    909          
    910              /* Process Unlocked */
    911              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    912          
    913              /* Enable the UART Parity Error Interrupt */
    914              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x60E8             STR      R0,[R5, #+12]
    915          
    916              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    917              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000066   0x6818             LDR      R0,[R3, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006E   0x681D             LDR      R5,[R3, #+0]
   \   00000070   0x6168             STR      R0,[R5, #+20]
    918          
    919              /* Enable the UART Data Register not empty Interrupt */
    920              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   00000072   0x6818             LDR      R0,[R3, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007A   0x681D             LDR      R5,[R3, #+0]
   \   0000007C   0x60E8             STR      R0,[R5, #+12]
    921          
    922              return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??HAL_UART_Receive_IT_4
    923            }
    924            else
    925            {
    926              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   00000084   0xBC30             POP      {R4,R5}
   \   00000086   0x4770             BX       LR               ;; return
    927            }
    928          }
    929          
    930          /**
    931            * @brief  Sends an amount of data in non blocking mode. 
    932            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    933            *                the configuration information for the specified UART module.
    934            * @param  pData: Pointer to data buffer
    935            * @param  Size: Amount of data to be sent
    936            * @retval HAL status
    937            */

   \                                 In section .text, align 2, keep-with-next
    938          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    939          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    940            uint32_t *tmp;
    941            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    942          
    943            tmp_state = huart->State;
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
    944            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   00000012   0x2F22             CMP      R7,#+34
   \   00000014   0xD146             BNE.N    ??HAL_UART_Transmit_DMA_1
    945            {
    946              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
    947              {
    948                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03F             B.N      ??HAL_UART_Transmit_DMA_4
    949              }
    950          
    951              /* Process Locked */
    952              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000026   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE039             B.N      ??HAL_UART_Transmit_DMA_4
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    953          
    954              huart->pTxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6220             STR      R0,[R4, #+32]
    955              huart->TxXferSize = Size;
   \   0000003C   0x84A5             STRH     R5,[R4, #+36]
    956              huart->TxXferCount = Size;
   \   0000003E   0x84E5             STRH     R5,[R4, #+38]
    957          
    958              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x63E0             STR      R0,[R4, #+60]
    959              /* Check if a receive process is ongoing or not */
    960              if(huart->State == HAL_UART_STATE_BUSY_RX)
   \   00000044   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000048   0x2822             CMP      R0,#+34
   \   0000004A   0xD103             BNE.N    ??HAL_UART_Transmit_DMA_6
    961              {
    962                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004C   0x2032             MOVS     R0,#+50
   \   0000004E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000052   0xE002             B.N      ??HAL_UART_Transmit_DMA_7
    963              }
    964              else
    965              {
    966                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \   00000054   0x2012             MOVS     R0,#+18
   \   00000056   0xF884 0x0039      STRB     R0,[R4, #+57]
    967              }
    968          
    969              /* Set the UART DMA transfer complete callback */
    970              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \                     ??HAL_UART_Transmit_DMA_7: (+1)
   \   0000005A   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000005E   0x6B21             LDR      R1,[R4, #+48]
   \   00000060   0x6288             STR      R0,[R1, #+40]
    971          
    972              /* Set the UART DMA Half transfer complete callback */
    973              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000062   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000066   0x6B21             LDR      R1,[R4, #+48]
   \   00000068   0x62C8             STR      R0,[R1, #+44]
    974          
    975              /* Set the DMA error callback */
    976              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000006A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006E   0x6B21             LDR      R1,[R4, #+48]
   \   00000070   0x6308             STR      R0,[R1, #+48]
    977          
    978              /* Enable the UART transmit DMA channel */
    979              tmp = (uint32_t*)&pData;
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x0006             MOVS     R6,R0
    980              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000076   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   0x002B             MOVS     R3,R5
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x1D02             ADDS     R2,R0,#+4
   \   0000007E   0x6831             LDR      R1,[R6, #+0]
   \   00000080   0x6B20             LDR      R0,[R4, #+48]
   \   00000082   0x.... 0x....      BL       HAL_DMA_Start_IT
    981          
    982              /* Clear the TC flag in the SR register by writing 0 to it */
    983              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000086   0xF07F 0x0040      MVNS     R0,#+64
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    984          
    985              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    986                 in the UART CR3 register */
    987              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6940             LDR      R0,[R0, #+20]
   \   00000092   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6148             STR      R0,[R1, #+20]
    988          
    989              /* Process Unlocked */
    990              __HAL_UNLOCK(huart);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x0038      STRB     R0,[R4, #+56]
    991          
    992              return HAL_OK;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE000             B.N      ??HAL_UART_Transmit_DMA_4
    993            }
    994            else
    995            {
    996              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   000000A4   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    997            }
    998          }
    999          
   1000          /**
   1001            * @brief  Receives an amount of data in non blocking mode. 
   1002            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1003            *                the configuration information for the specified UART module.
   1004            * @param  pData: Pointer to data buffer
   1005            * @param  Size: Amount of data to be received
   1006            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
   1007            *         the parity bit (MSB position)     
   1008            * @retval HAL status
   1009            */

   \                                 In section .text, align 2, keep-with-next
   1010          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1011          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1012            uint32_t *tmp;
   1013            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   1014          
   1015            tmp_state = huart->State;
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
   1016            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   00000012   0x2F12             CMP      R7,#+18
   \   00000014   0xD141             BNE.N    ??HAL_UART_Receive_DMA_1
   1017            {
   1018              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   1019              {
   1020                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03A             B.N      ??HAL_UART_Receive_DMA_4
   1021              }
   1022          
   1023              /* Process Locked */
   1024              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000026   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Receive_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE034             B.N      ??HAL_UART_Receive_DMA_4
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1025          
   1026              huart->pRxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x62A0             STR      R0,[R4, #+40]
   1027              huart->RxXferSize = Size;
   \   0000003C   0x85A5             STRH     R5,[R4, #+44]
   1028          
   1029              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x63E0             STR      R0,[R4, #+60]
   1030              /* Check if a transmit process is ongoing or not */
   1031              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000042   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD103             BNE.N    ??HAL_UART_Receive_DMA_6
   1032              {
   1033                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000050   0xE002             B.N      ??HAL_UART_Receive_DMA_7
   1034              }
   1035              else
   1036              {
   1037                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \   00000052   0x2022             MOVS     R0,#+34
   \   00000054   0xF884 0x0039      STRB     R0,[R4, #+57]
   1038              }
   1039          
   1040              /* Set the UART DMA transfer complete callback */
   1041              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_7: (+1)
   \   00000058   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000005C   0x6B61             LDR      R1,[R4, #+52]
   \   0000005E   0x6288             STR      R0,[R1, #+40]
   1042          
   1043              /* Set the UART DMA Half transfer complete callback */
   1044              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000060   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000064   0x6B61             LDR      R1,[R4, #+52]
   \   00000066   0x62C8             STR      R0,[R1, #+44]
   1045          
   1046              /* Set the DMA error callback */
   1047              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000068   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006C   0x6B61             LDR      R1,[R4, #+52]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   1048          
   1049              /* Enable the DMA channel */
   1050              tmp = (uint32_t*)&pData;
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x0006             MOVS     R6,R0
   1051              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x002B             MOVS     R3,R5
   \   00000078   0x6832             LDR      R2,[R6, #+0]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x1D01             ADDS     R1,R0,#+4
   \   0000007E   0x6B60             LDR      R0,[R4, #+52]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   1052          
   1053              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1054                 in the UART CR3 register */
   1055              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6940             LDR      R0,[R0, #+20]
   \   00000088   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6148             STR      R0,[R1, #+20]
   1056          
   1057              /* Process Unlocked */
   1058              __HAL_UNLOCK(huart);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF884 0x0038      STRB     R0,[R4, #+56]
   1059          
   1060              return HAL_OK;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE000             B.N      ??HAL_UART_Receive_DMA_4
   1061            }
   1062            else
   1063            {
   1064              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1065            }
   1066          }
   1067              
   1068          /**
   1069            * @brief Pauses the DMA Transfer.
   1070            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1071            *                the configuration information for the specified UART module.
   1072            * @retval HAL status
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1075          {
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1076            /* Process Locked */
   1077            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02F             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1078            
   1079            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xD107             BNE.N    ??HAL_UART_DMAPause_2
   1080            {
   1081              /* Disable the UART DMA Tx request */
   1082              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0xF07F 0x0280      MVNS     R2,#+128
   \   00000024   0x4010             ANDS     R0,R2,R0
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x6150             STR      R0,[R2, #+20]
   \   0000002A   0xE01C             B.N      ??HAL_UART_DMAPause_3
   1083            }
   1084            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   0000002C   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000030   0x2822             CMP      R0,#+34
   \   00000032   0xD107             BNE.N    ??HAL_UART_DMAPause_4
   1085            {
   1086              /* Disable the UART DMA Rx request */
   1087              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000034   0x6808             LDR      R0,[R1, #+0]
   \   00000036   0x6940             LDR      R0,[R0, #+20]
   \   00000038   0xF07F 0x0240      MVNS     R2,#+64
   \   0000003C   0x4010             ANDS     R0,R2,R0
   \   0000003E   0x680A             LDR      R2,[R1, #+0]
   \   00000040   0x6150             STR      R0,[R2, #+20]
   \   00000042   0xE010             B.N      ??HAL_UART_DMAPause_3
   1088            }
   1089            else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000044   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000048   0x2832             CMP      R0,#+50
   \   0000004A   0xD107             BNE.N    ??HAL_UART_DMAPause_5
   1090            {
   1091              /* Disable the UART DMA Tx & Rx requests */
   1092              CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   0000004C   0x6808             LDR      R0,[R1, #+0]
   \   0000004E   0x6940             LDR      R0,[R0, #+20]
   \   00000050   0xF07F 0x02C0      MVNS     R2,#+192
   \   00000054   0x4010             ANDS     R0,R2,R0
   \   00000056   0x680A             LDR      R2,[R1, #+0]
   \   00000058   0x6150             STR      R0,[R2, #+20]
   \   0000005A   0xE004             B.N      ??HAL_UART_DMAPause_3
   1093            }
   1094            else
   1095            {
   1096              /* Process Unlocked */
   1097              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1098            
   1099              return HAL_ERROR; 
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE003             B.N      ??HAL_UART_DMAPause_1
   1100            }
   1101            
   1102            /* Process Unlocked */
   1103            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF881 0x0038      STRB     R0,[R1, #+56]
   1104          
   1105            return HAL_OK; 
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   0000006E   0x4770             BX       LR               ;; return
   1106          }
   1107          
   1108          /**
   1109            * @brief Resumes the DMA Transfer.
   1110            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1111            *                the configuration information for the specified UART module.
   1112            * @retval HAL status
   1113            */

   \                                 In section .text, align 2, keep-with-next
   1114          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1115          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
   1116            /* Process Locked */
   1117            __HAL_LOCK(huart);
   \   00000004   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE03A             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF881 0x0038      STRB     R0,[R1, #+56]
   1118          
   1119            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000016   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000001A   0x2812             CMP      R0,#+18
   \   0000001C   0xD106             BNE.N    ??HAL_UART_DMAResume_2
   1120            {
   1121              /* Enable the UART DMA Tx request */
   1122              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x6940             LDR      R0,[R0, #+20]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x6150             STR      R0,[R2, #+20]
   \   0000002A   0xE028             B.N      ??HAL_UART_DMAResume_3
   1123            }
   1124            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   0000002C   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000030   0x2822             CMP      R0,#+34
   \   00000032   0xD10D             BNE.N    ??HAL_UART_DMAResume_4
   1125            {
   1126              /* Clear the Overrun flag before resumming the Rx transfer*/
   1127              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000034   0x6808             LDR      R0,[R1, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   1128              /* Enable the UART DMA Rx request */
   1129              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000042   0x6808             LDR      R0,[R1, #+0]
   \   00000044   0x6940             LDR      R0,[R0, #+20]
   \   00000046   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0x6150             STR      R0,[R2, #+20]
   \   0000004E   0xE016             B.N      ??HAL_UART_DMAResume_3
   1130            }
   1131            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000050   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000054   0x2832             CMP      R0,#+50
   \   00000056   0xD10D             BNE.N    ??HAL_UART_DMAResume_5
   1132            {
   1133              /* Clear the Overrun flag before resumming the Rx transfer*/
   1134              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x6808             LDR      R0,[R1, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   1135              /* Enable the UART DMA Tx & Rx request */
   1136              SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000066   0x6808             LDR      R0,[R1, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   0000006E   0x680A             LDR      R2,[R1, #+0]
   \   00000070   0x6150             STR      R0,[R2, #+20]
   \   00000072   0xE004             B.N      ??HAL_UART_DMAResume_3
   1137            }
   1138            else
   1139            {
   1140              /* Process Unlocked */
   1141              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF881 0x0038      STRB     R0,[R1, #+56]
   1142          
   1143              return HAL_ERROR; 
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xE003             B.N      ??HAL_UART_DMAResume_1
   1144            }
   1145          
   1146            /* Process Unlocked */
   1147            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF881 0x0038      STRB     R0,[R1, #+56]
   1148          
   1149            return HAL_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0x4770             BX       LR               ;; return
   1150          }
   1151          
   1152          /**
   1153            * @brief Stops the DMA Transfer.
   1154            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1155            *                the configuration information for the specified UART module.
   1156            * @retval HAL status
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1159          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1160            /* The Lock is not implemented on this API to allow the user application
   1161               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1162               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1163               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1164               */
   1165            
   1166            /* Disable the UART Tx/Rx DMA requests */
   1167            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0xF07F 0x01C0      MVNS     R1,#+192
   \   0000000C   0x4008             ANDS     R0,R1,R0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x6148             STR      R0,[R1, #+20]
   1168            
   1169            /* Abort the UART DMA tx channel */
   1170            if(huart->hdmatx != NULL)
   \   00000012   0x6B20             LDR      R0,[R4, #+48]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_DMAStop_0
   1171            {
   1172              HAL_DMA_Abort(huart->hdmatx);
   \   00000018   0x6B20             LDR      R0,[R4, #+48]
   \   0000001A   0x.... 0x....      BL       HAL_DMA_Abort
   1173            }
   1174            /* Abort the UART DMA rx channel */
   1175            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   0000001E   0x6B60             LDR      R0,[R4, #+52]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1176            {
   1177              HAL_DMA_Abort(huart->hdmarx);
   \   00000024   0x6B60             LDR      R0,[R4, #+52]
   \   00000026   0x.... 0x....      BL       HAL_DMA_Abort
   1178            }
   1179            
   1180            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1181            
   1182            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1183          }
   1184          
   1185          /**
   1186            * @brief  This function handles UART interrupt request.
   1187            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1188            *                the configuration information for the specified UART module.
   1189            * @retval None
   1190            */

   \                                 In section .text, align 2, keep-with-next
   1191          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1192          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1193            uint32_t tmp_flag = 0, tmp_it_source = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   1194          
   1195            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x0005             MOVS     R5,R0
   1196            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000001C   0x0006             MOVS     R6,R0
   1197            /* UART parity error interrupt occurred ------------------------------------*/
   1198            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD005             BEQ.N    ??HAL_UART_IRQHandler_0
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD003             BEQ.N    ??HAL_UART_IRQHandler_0
   1199            { 
   1200              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000026   0x6BE0             LDR      R0,[R4, #+60]
   \   00000028   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002C   0x63E0             STR      R0,[R4, #+60]
   1201            }
   1202            
   1203            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000038   0x0005             MOVS     R5,R0
   1204            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6940             LDR      R0,[R0, #+20]
   \   0000003E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000042   0x0006             MOVS     R6,R0
   1205            /* UART frame error interrupt occurred -------------------------------------*/
   1206            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD005             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD003             BEQ.N    ??HAL_UART_IRQHandler_1
   1207            {
   1208              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   0000004C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000004E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000052   0x63E0             STR      R0,[R4, #+60]
   1209            }
   1210            
   1211            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0880             LSRS     R0,R0,#+2
   \   0000005A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000005E   0x0005             MOVS     R5,R0
   1212            /* UART noise error interrupt occurred -------------------------------------*/
   1213            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD005             BEQ.N    ??HAL_UART_IRQHandler_2
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_UART_IRQHandler_2
   1214            {
   1215              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000068   0x6BE0             LDR      R0,[R4, #+60]
   \   0000006A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006E   0x63E0             STR      R0,[R4, #+60]
   1216            }
   1217            
   1218            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x08C0             LSRS     R0,R0,#+3
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0x0005             MOVS     R5,R0
   1219            /* UART Over-Run interrupt occurred ----------------------------------------*/
   1220            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD005             BEQ.N    ??HAL_UART_IRQHandler_3
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD003             BEQ.N    ??HAL_UART_IRQHandler_3
   1221            {
   1222              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   00000084   0x6BE0             LDR      R0,[R4, #+60]
   \   00000086   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000008A   0x63E0             STR      R0,[R4, #+60]
   1223            }
   1224            
   1225            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x0940             LSRS     R0,R0,#+5
   \   00000092   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000096   0x0005             MOVS     R5,R0
   1226            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   000000A0   0x0006             MOVS     R6,R0
   1227            /* UART in mode Receiver ---------------------------------------------------*/
   1228            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000A2   0x2D00             CMP      R5,#+0
   \   000000A4   0xD004             BEQ.N    ??HAL_UART_IRQHandler_4
   \   000000A6   0x2E00             CMP      R6,#+0
   \   000000A8   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1229            { 
   1230              UART_Receive_IT(huart);
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       UART_Receive_IT
   1231            }
   1232            
   1233            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x09C0             LSRS     R0,R0,#+7
   \   000000B6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000BA   0x0005             MOVS     R5,R0
   1234            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x68C0             LDR      R0,[R0, #+12]
   \   000000C0   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000C4   0x0006             MOVS     R6,R0
   1235            /* UART in mode Transmitter ------------------------------------------------*/
   1236            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xD004             BEQ.N    ??HAL_UART_IRQHandler_5
   \   000000CA   0x2E00             CMP      R6,#+0
   \   000000CC   0xD002             BEQ.N    ??HAL_UART_IRQHandler_5
   1237            {
   1238              UART_Transmit_IT(huart);
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       UART_Transmit_IT
   1239            }
   1240          
   1241            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x0980             LSRS     R0,R0,#+6
   \   000000DA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000DE   0x0005             MOVS     R5,R0
   1242            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   000000E8   0x0006             MOVS     R6,R0
   1243            /* UART in mode Transmitter end --------------------------------------------*/
   1244            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD004             BEQ.N    ??HAL_UART_IRQHandler_6
   \   000000EE   0x2E00             CMP      R6,#+0
   \   000000F0   0xD002             BEQ.N    ??HAL_UART_IRQHandler_6
   1245            {
   1246              UART_EndTransmit_IT(huart);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       UART_EndTransmit_IT
   1247            }  
   1248          
   1249            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   000000F8   0x6BE0             LDR      R0,[R4, #+60]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_7
   1250            {
   1251              /* Clear all the error flag at once */
   1252              __HAL_UART_CLEAR_PEFLAG(huart);
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6840             LDR      R0,[R0, #+4]
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   1253              
   1254              /* Set the UART state ready to be able to start again the process */
   1255              huart->State = HAL_UART_STATE_READY;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1256              
   1257              HAL_UART_ErrorCallback(huart);
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1258            }  
   1259          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000118   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1260          
   1261          /**
   1262            * @brief  Tx Transfer completed callbacks.
   1263            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1264            *                the configuration information for the specified UART module.
   1265            * @retval None
   1266            */

   \                                 In section .text, align 2, keep-with-next
   1267           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1268          {
   1269            /* Prevent unused argument(s) compilation warning */
   1270            UNUSED(huart);
   1271          
   1272            /* NOTE: This function should not be modified, when the callback is needed,
   1273                     the HAL_UART_TxCpltCallback can be implemented in the user file
   1274             */ 
   1275          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1276          
   1277          /**
   1278            * @brief  Tx Half Transfer completed callbacks.
   1279            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1280            *                the configuration information for the specified UART module.
   1281            * @retval None
   1282            */

   \                                 In section .text, align 2, keep-with-next
   1283           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1284          {
   1285            /* Prevent unused argument(s) compilation warning */
   1286            UNUSED(huart);
   1287          
   1288            /* NOTE: This function should not be modified, when the callback is needed,
   1289                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1290             */ 
   1291          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1292          
   1293          /**
   1294            * @brief  Rx Transfer completed callbacks.
   1295            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1296            *                the configuration information for the specified UART module.
   1297            * @retval None
   1298            */

   \                                 In section .text, align 2, keep-with-next
   1299          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1300          {
   1301            /* Prevent unused argument(s) compilation warning */
   1302            UNUSED(huart);
   1303          
   1304            /* NOTE: This function should not be modified, when the callback is needed,
   1305                     the HAL_UART_RxCpltCallback can be implemented in the user file
   1306             */
   1307          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1308          
   1309          /**
   1310            * @brief  Rx Half Transfer completed callbacks.
   1311            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1312            *                the configuration information for the specified UART module.
   1313            * @retval None
   1314            */

   \                                 In section .text, align 2, keep-with-next
   1315          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1316          {
   1317            /* Prevent unused argument(s) compilation warning */
   1318            UNUSED(huart);
   1319          
   1320            /* NOTE: This function should not be modified, when the callback is needed,
   1321                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1322             */
   1323          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1324          
   1325          /**
   1326            * @brief  UART error callbacks.
   1327            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1328            *                the configuration information for the specified UART module.
   1329            * @retval None
   1330            */

   \                                 In section .text, align 2, keep-with-next
   1331           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1332          {
   1333            /* Prevent unused argument(s) compilation warning */
   1334            UNUSED(huart);
   1335          
   1336            /* NOTE: This function should not be modified, when the callback is needed,
   1337                     the HAL_UART_ErrorCallback can be implemented in the user file
   1338             */ 
   1339          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1340          
   1341          /**
   1342            * @}
   1343            */
   1344          
   1345          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1346            *  @brief   UART control functions 
   1347            *
   1348          @verbatim   
   1349            ==============================================================================
   1350                                ##### Peripheral Control functions #####
   1351            ==============================================================================  
   1352            [..]
   1353              This subsection provides a set of functions allowing to control the UART:
   1354              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1355              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1356              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1357              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   1358              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   1359              
   1360          @endverbatim
   1361            * @{
   1362            */
   1363          
   1364          /**
   1365            * @brief  Transmits break characters.
   1366            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1367            *                the configuration information for the specified UART module.
   1368            * @retval HAL status
   1369            */

   \                                 In section .text, align 2, keep-with-next
   1370          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1371          {
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1372            /* Check the parameters */
   1373            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
   1374            
   1375            /* Process Locked */
   1376            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1377            
   1378            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1379            
   1380            /* Send break characters */
   1381            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1382           
   1383            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1384            
   1385            /* Process Unlocked */
   1386            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1387            
   1388            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1389          }
   1390          
   1391          /**
   1392            * @brief  Enters the UART in mute mode. 
   1393            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1394            *                the configuration information for the specified UART module.
   1395            * @retval HAL status
   1396            */

   \                                 In section .text, align 2, keep-with-next
   1397          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1398          {
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1399            /* Check the parameters */
   1400            assert_param(IS_UART_INSTANCE(huart->Instance));
   1401            
   1402            /* Process Locked */
   1403            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_MultiProcessor_EnterMuteMode_1
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1404            
   1405            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1406            
   1407            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1408            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1409            
   1410            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1411            
   1412            /* Process Unlocked */
   1413            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1414            
   1415            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_EnterMuteMode_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1416          }
   1417          
   1418          /**
   1419            * @brief  Exits the UART mute mode: wake up software. 
   1420            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1421            *                the configuration information for the specified UART module.
   1422            * @retval HAL status
   1423            */

   \                                 In section .text, align 2, keep-with-next
   1424          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1425          {
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1426            /* Check the parameters */
   1427            assert_param(IS_UART_INSTANCE(huart->Instance));
   1428            
   1429            /* Process Locked */
   1430            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE013             B.N      ??HAL_MultiProcessor_ExitMuteMode_1
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1431            
   1432            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1433            
   1434            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1435            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF07F 0x0202      MVNS     R2,#+2
   \   00000022   0x4010             ANDS     R0,R2,R0
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x60D0             STR      R0,[R2, #+12]
   1436            
   1437            huart->State = HAL_UART_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF881 0x0039      STRB     R0,[R1, #+57]
   1438            
   1439            /* Process Unlocked */
   1440            __HAL_UNLOCK(huart);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF881 0x0038      STRB     R0,[R1, #+56]
   1441            
   1442            return HAL_OK; 
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_ExitMuteMode_1: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1443          }
   1444          
   1445          /**
   1446            * @brief  Enables the UART transmitter and disables the UART receiver.
   1447            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1448            *                the configuration information for the specified UART module.
   1449            * @retval HAL status
   1450            */

   \                                 In section .text, align 2, keep-with-next
   1451          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1452          {
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1453            /* Process Locked */
   1454            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE015             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1455            
   1456            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1457          
   1458            /*-------------------------- USART CR1 Configuration -----------------------*/
   1459            /* Clear TE and RE bits */
   1460            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1461            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF07F 0x020C      MVNS     R2,#+12
   \   00000022   0x4010             ANDS     R0,R2,R0
   \   00000024   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x60D0             STR      R0,[R2, #+12]
   1462           
   1463            huart->State = HAL_UART_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF881 0x0039      STRB     R0,[R1, #+57]
   1464            
   1465            /* Process Unlocked */
   1466            __HAL_UNLOCK(huart);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF881 0x0038      STRB     R0,[R1, #+56]
   1467            
   1468            return HAL_OK; 
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
   1469          }
   1470          
   1471          /**
   1472            * @brief  Enables the UART receiver and disables the UART transmitter.
   1473            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1474            *                the configuration information for the specified UART module.
   1475            * @retval HAL status
   1476            */

   \                                 In section .text, align 2, keep-with-next
   1477          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1478          {
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1479            /* Process Locked */
   1480            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE015             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1481            
   1482            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1483          
   1484            /*-------------------------- USART CR1 Configuration -----------------------*/
   1485            /* Clear TE and RE bits */
   1486            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1487            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF07F 0x020C      MVNS     R2,#+12
   \   00000022   0x4010             ANDS     R0,R2,R0
   \   00000024   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x60D0             STR      R0,[R2, #+12]
   1488            
   1489            huart->State = HAL_UART_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF881 0x0039      STRB     R0,[R1, #+57]
   1490            
   1491            /* Process Unlocked */
   1492            __HAL_UNLOCK(huart);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF881 0x0038      STRB     R0,[R1, #+56]
   1493            
   1494            return HAL_OK; 
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
   1495          }
   1496          
   1497          /**
   1498            * @}
   1499            */
   1500          
   1501          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1502            *  @brief   UART State and Errors functions 
   1503            *
   1504          @verbatim   
   1505            ==============================================================================
   1506                           ##### Peripheral State and Errors functions #####
   1507            ==============================================================================  
   1508           [..]
   1509             This subsection provides a set of functions allowing to return the State of 
   1510             UART communication process, return Peripheral Errors occurred during communication 
   1511             process
   1512             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1513             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1514          
   1515          @endverbatim
   1516            * @{
   1517            */
   1518            
   1519          /**
   1520            * @brief  Returns the UART state.
   1521            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1522            *                the configuration information for the specified UART module.
   1523            * @retval HAL state
   1524            */

   \                                 In section .text, align 2, keep-with-next
   1525          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1526          {
   1527            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1528          }
   1529          
   1530          /**
   1531          * @brief  Return the UART error code
   1532          * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1533            *              the configuration information for the specified UART.
   1534          * @retval UART Error Code
   1535          */

   \                                 In section .text, align 2, keep-with-next
   1536          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1537          {
   1538            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1539          }
   1540          
   1541          /**
   1542            * @}
   1543            */
   1544          
   1545          /**
   1546            * @}
   1547            */
   1548          
   1549          /** @defgroup UART_Private_Functions   UART Private Functions
   1550            *  @brief   UART Private functions 
   1551            * @{
   1552            */
   1553          /**
   1554            * @brief  DMA UART transmit process complete callback. 
   1555            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1556            *               the configuration information for the specified DMA module.
   1557            * @retval None
   1558            */

   \                                 In section .text, align 4, keep-with-next
   1559          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1560          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1561            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1562            /* DMA Normal mode*/
   1563            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD40F             BMI.N    ??UART_DMATransmitCplt_0
   1564            {
   1565              huart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x84E8             STRH     R0,[R5, #+38]
   1566          
   1567              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1568                 in the UART CR3 register */
   1569              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF07F 0x0180      MVNS     R1,#+128
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0x6148             STR      R0,[R1, #+20]
   1570          
   1571              /* Enable the UART Transmit Complete Interrupt */    
   1572              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x68C0             LDR      R0,[R0, #+12]
   \   00000024   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x60C8             STR      R0,[R1, #+12]
   \   0000002C   0xE002             B.N      ??UART_DMATransmitCplt_1
   1573            }
   1574            /* DMA Circular mode */
   1575            else
   1576            {
   1577              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1578            }
   1579          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1580          
   1581          /**
   1582            * @brief DMA UART transmit process half complete callback 
   1583            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1584            *               the configuration information for the specified DMA module.
   1585            * @retval None
   1586            */

   \                                 In section .text, align 4, keep-with-next
   1587          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1588          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1589            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1590          
   1591            HAL_UART_TxHalfCpltCallback(huart);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1592          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1593          
   1594          /**
   1595            * @brief  DMA UART receive process complete callback. 
   1596            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1597            *               the configuration information for the specified DMA module.
   1598            * @retval None
   1599            */

   \                                 In section .text, align 4, keep-with-next
   1600          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1601          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1602            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1603            /* DMA Normal mode*/
   1604            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD413             BMI.N    ??UART_DMAReceiveCplt_0
   1605            {
   1606              huart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x85E8             STRH     R0,[R5, #+46]
   1607            
   1608              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1609                 in the UART CR3 register */
   1610              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF07F 0x0140      MVNS     R1,#+64
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0x6148             STR      R0,[R1, #+20]
   1611          
   1612              /* Check if a transmit process is ongoing or not */
   1613              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000020   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000024   0x2832             CMP      R0,#+50
   \   00000026   0xD103             BNE.N    ??UART_DMAReceiveCplt_1
   1614              {
   1615                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000028   0x2012             MOVS     R0,#+18
   \   0000002A   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   0000002E   0xE002             B.N      ??UART_DMAReceiveCplt_0
   1616              }
   1617              else
   1618              {
   1619                huart->State = HAL_UART_STATE_READY;
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF885 0x0039      STRB     R0,[R5, #+57]
   1620              }
   1621            }
   1622            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1623          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1624          
   1625          /**
   1626            * @brief DMA UART receive process half complete callback 
   1627            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1628            *               the configuration information for the specified DMA module.
   1629            * @retval None
   1630            */

   \                                 In section .text, align 4, keep-with-next
   1631          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1632          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1633            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1634          
   1635            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1636          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1637          
   1638          /**
   1639            * @brief  DMA UART communication error callback.
   1640            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1641            *               the configuration information for the specified DMA module.
   1642            * @retval None
   1643            */

   \                                 In section .text, align 4, keep-with-next
   1644          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1645          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1646            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1647            huart->RxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x85E8             STRH     R0,[R5, #+46]
   1648            huart->TxXferCount = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x84E8             STRH     R0,[R5, #+38]
   1649            huart->State= HAL_UART_STATE_READY;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF885 0x0039      STRB     R0,[R5, #+57]
   1650            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000014   0x6BE8             LDR      R0,[R5, #+60]
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001A   0x63E8             STR      R0,[R5, #+60]
   1651            HAL_UART_ErrorCallback(huart);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1652          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1653          
   1654          /**
   1655            * @brief  This function handles UART Communication Timeout.
   1656            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1657            *                the configuration information for the specified UART module.
   1658            * @param  Flag: specifies the UART flag to check.
   1659            * @param  Status: The new Flag status (SET or RESET).
   1660            * @param  Timeout: Timeout duration
   1661            * @retval HAL status
   1662            */

   \                                 In section .text, align 2, keep-with-next
   1663          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1664          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1665            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1666          
   1667            /* Get tick */ 
   1668            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   1669          
   1670            /* Wait until flag is set */
   1671            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD133             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1672            {
   1673              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4028             ANDS     R0,R5,R0
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD060             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1674              {
   1675                // Need to Service Watch Dog or we die here....
   1676                RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   00000026   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   1677                /* Check for the Timeout */
   1678                if(Timeout != HAL_MAX_DELAY)
   \   0000002A   0xF5B7 0x4F00      CMP      R7,#+32768
   \   0000002E   0xD0F5             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1679                {
   1680                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   00000034   0x.... 0x....      BL       HAL_GetTick
   \   00000038   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000003C   0x4287             CMP      R7,R0
   \   0000003E   0xD2ED             BCS.N    ??UART_WaitOnFlagUntilTimeout_1
   1681                  {
   1682                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1683                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x68C0             LDR      R0,[R0, #+12]
   \   00000044   0xF07F 0x0180      MVNS     R1,#+128
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x60C8             STR      R0,[R1, #+12]
   1684                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68C0             LDR      R0,[R0, #+12]
   \   00000052   0xF07F 0x0120      MVNS     R1,#+32
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x60C8             STR      R0,[R1, #+12]
   1685                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   1686                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6940             LDR      R0,[R0, #+20]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6148             STR      R0,[R1, #+20]
   1687          
   1688                    huart->State= HAL_UART_STATE_READY;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x0039      STRB     R0,[R4, #+57]
   1689          
   1690                    /* Process Unlocked */
   1691                    __HAL_UNLOCK(huart);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0038      STRB     R0,[R4, #+56]
   1692          
   1693                    return HAL_TIMEOUT;
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0xE032             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1694                  }
   1695                }
   1696              }
   1697            }
   1698            else
   1699            {
   1700              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x4028             ANDS     R0,R5,R0
   \   0000008A   0x42A8             CMP      R0,R5
   \   0000008C   0xD12C             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1701              {
   1702                /* Check for the Timeout */
   1703                if(Timeout != HAL_MAX_DELAY)
   \   0000008E   0xF5B7 0x4F00      CMP      R7,#+32768
   \   00000092   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1704                {
   1705                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   \   00000098   0x.... 0x....      BL       HAL_GetTick
   \   0000009C   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000A0   0x4287             CMP      R7,R0
   \   000000A2   0xD2EF             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1706                  {
   1707                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1708                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x68C0             LDR      R0,[R0, #+12]
   \   000000A8   0xF07F 0x0180      MVNS     R1,#+128
   \   000000AC   0x4008             ANDS     R0,R1,R0
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x60C8             STR      R0,[R1, #+12]
   1709                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x68C0             LDR      R0,[R0, #+12]
   \   000000B6   0xF07F 0x0120      MVNS     R1,#+32
   \   000000BA   0x4008             ANDS     R0,R1,R0
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x60C8             STR      R0,[R1, #+12]
   1710                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x68C0             LDR      R0,[R0, #+12]
   \   000000C4   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x60C8             STR      R0,[R1, #+12]
   1711                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x6940             LDR      R0,[R0, #+20]
   \   000000D0   0x0840             LSRS     R0,R0,#+1
   \   000000D2   0x0040             LSLS     R0,R0,#+1
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x6148             STR      R0,[R1, #+20]
   1712          
   1713                    huart->State= HAL_UART_STATE_READY;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0039      STRB     R0,[R4, #+57]
   1714          
   1715                    /* Process Unlocked */
   1716                    __HAL_UNLOCK(huart);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x0038      STRB     R0,[R4, #+56]
   1717          
   1718                    return HAL_TIMEOUT;
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1719                  }
   1720                }
   1721              }
   1722            }
   1723            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000EA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1724          }
   1725          
   1726          /**
   1727            * @brief  Sends an amount of data in non blocking mode.
   1728            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1729            *                the configuration information for the specified UART module.
   1730            * @retval HAL status
   1731            */

   \                                 In section .text, align 2, keep-with-next
   1732          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1733          {
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1734            uint16_t* tmp;
   1735            uint32_t tmp_state = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   1736            
   1737            tmp_state = huart->State;
   \   00000006   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000000A   0x0003             MOVS     R3,R0
   1738            if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2B12             CMP      R3,#+18
   \   0000000E   0xD001             BEQ.N    ??UART_Transmit_IT_0
   \   00000010   0x2B32             CMP      R3,#+50
   \   00000012   0xD130             BNE.N    ??UART_Transmit_IT_1
   1739            {
   1740              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Transmit_IT_0: (+1)
   \   00000014   0x6888             LDR      R0,[R1, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD111             BNE.N    ??UART_Transmit_IT_2
   1741              {
   1742                tmp = (uint16_t*) huart->pTxBuffPtr;
   \   0000001C   0x6A08             LDR      R0,[R1, #+32]
   \   0000001E   0x0002             MOVS     R2,R0
   1743                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \   00000020   0x8810             LDRH     R0,[R2, #+0]
   \   00000022   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000024   0x0DC0             LSRS     R0,R0,#+23
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   \   00000028   0x6060             STR      R0,[R4, #+4]
   1744                if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000002A   0x6908             LDR      R0,[R1, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??UART_Transmit_IT_3
   1745                {
   1746                  huart->pTxBuffPtr += 2;
   \   00000030   0x6A08             LDR      R0,[R1, #+32]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x6208             STR      R0,[R1, #+32]
   \   00000036   0xE009             B.N      ??UART_Transmit_IT_4
   1747                }
   1748                else
   1749                {
   1750                  huart->pTxBuffPtr += 1;
   \                     ??UART_Transmit_IT_3: (+1)
   \   00000038   0x6A08             LDR      R0,[R1, #+32]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x6208             STR      R0,[R1, #+32]
   \   0000003E   0xE005             B.N      ??UART_Transmit_IT_4
   1751                }
   1752              } 
   1753              else
   1754              {
   1755                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_2: (+1)
   \   00000040   0x6A08             LDR      R0,[R1, #+32]
   \   00000042   0x1C44             ADDS     R4,R0,#+1
   \   00000044   0x620C             STR      R4,[R1, #+32]
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x680C             LDR      R4,[R1, #+0]
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   1756              }
   1757          
   1758              if(--huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000004C   0x8CC8             LDRH     R0,[R1, #+38]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x84C8             STRH     R0,[R1, #+38]
   \   00000052   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10C             BNE.N    ??UART_Transmit_IT_5
   1759              {
   1760                /* Disable the UART Transmit Complete Interrupt */
   1761                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF07F 0x0480      MVNS     R4,#+128
   \   00000060   0x4020             ANDS     R0,R4,R0
   \   00000062   0x680C             LDR      R4,[R1, #+0]
   \   00000064   0x60E0             STR      R0,[R4, #+12]
   1762          
   1763                /* Enable the UART Transmit Complete Interrupt */    
   1764                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000066   0x6808             LDR      R0,[R1, #+0]
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000006E   0x680C             LDR      R4,[R1, #+0]
   \   00000070   0x60E0             STR      R0,[R4, #+12]
   1765              }
   1766              return HAL_OK;
   \                     ??UART_Transmit_IT_5: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE000             B.N      ??UART_Transmit_IT_6
   1767            }
   1768            else
   1769            {
   1770              return HAL_BUSY;
   \                     ??UART_Transmit_IT_1: (+1)
   \   00000076   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_6: (+1)
   \   00000078   0xBC10             POP      {R4}
   \   0000007A   0x4770             BX       LR               ;; return
   1771            }
   1772          }
   1773          
   1774          
   1775          /**
   1776            * @brief  Wraps up transmission in non blocking mode.
   1777            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1778            *                the configuration information for the specified UART module.
   1779            * @retval HAL status
   1780            */

   \                                 In section .text, align 2, keep-with-next
   1781          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1782          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1783            /* Disable the UART Transmit Complete Interrupt */    
   1784            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF07F 0x0140      MVNS     R1,#+64
   \   0000000C   0x4008             ANDS     R0,R1,R0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   1785            
   1786            /* Check if a receive process is ongoing or not */
   1787            if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2832             CMP      R0,#+50
   \   00000018   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1788            {
   1789              huart->State = HAL_UART_STATE_BUSY_RX;
   \   0000001A   0x2022             MOVS     R0,#+34
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000020   0xE002             B.N      ??UART_EndTransmit_IT_1
   1790            }
   1791            else
   1792            {
   1793              huart->State = HAL_UART_STATE_READY;
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   1794            }
   1795            
   1796            HAL_UART_TxCpltCallback(huart);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1797            
   1798            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1799          }
   1800          
   1801          /**
   1802            * @brief  Receives an amount of data in non blocking mode 
   1803            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1804            *                the configuration information for the specified UART module.
   1805            * @retval HAL status
   1806            */

   \                                 In section .text, align 2, keep-with-next
   1807          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1808          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1809            uint16_t* tmp;
   1810            uint32_t tmp_state = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   1811            
   1812            tmp_state = huart->State; 
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000A   0x0006             MOVS     R6,R0
   1813            if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2E22             CMP      R6,#+34
   \   0000000E   0xD001             BEQ.N    ??UART_Receive_IT_0
   \   00000010   0x2E32             CMP      R6,#+50
   \   00000012   0xD157             BNE.N    ??UART_Receive_IT_1
   1814            {
   1815              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Receive_IT_0: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD116             BNE.N    ??UART_Receive_IT_2
   1816              {
   1817                tmp = (uint16_t*) huart->pRxBuffPtr;
   \   0000001C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001E   0x0005             MOVS     R5,R0
   1818                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD108             BNE.N    ??UART_Receive_IT_3
   1819                {
   1820                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000002C   0x0DC0             LSRS     R0,R0,#+23
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
   1821                  huart->pRxBuffPtr += 2;
   \   00000030   0x6AA0             LDR      R0,[R4, #+40]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x62A0             STR      R0,[R4, #+40]
   \   00000036   0xE01A             B.N      ??UART_Receive_IT_4
   1822                }
   1823                else
   1824                {
   1825                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   1826                  huart->pRxBuffPtr += 1;
   \   00000042   0x6AA0             LDR      R0,[R4, #+40]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x62A0             STR      R0,[R4, #+40]
   \   00000048   0xE011             B.N      ??UART_Receive_IT_4
   1827                }
   1828              }
   1829              else
   1830              {
   1831                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_2: (+1)
   \   0000004A   0x6920             LDR      R0,[R4, #+16]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD106             BNE.N    ??UART_Receive_IT_5
   1832                {
   1833                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   00000050   0x6AA0             LDR      R0,[R4, #+40]
   \   00000052   0x1C41             ADDS     R1,R0,#+1
   \   00000054   0x62A1             STR      R1,[R4, #+40]
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
   \   0000005C   0xE007             B.N      ??UART_Receive_IT_4
   1834                }
   1835                else
   1836                {
   1837                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   0000005E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000060   0x1C41             ADDS     R1,R0,#+1
   \   00000062   0x62A1             STR      R1,[R4, #+40]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6849             LDR      R1,[R1, #+4]
   \   00000068   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   1838                }
   1839              }
   1840          
   1841              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_4: (+1)
   \   0000006E   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x85E0             STRH     R0,[R4, #+46]
   \   00000074   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD122             BNE.N    ??UART_Receive_IT_6
   1842              {
   1843                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0xF07F 0x0120      MVNS     R1,#+32
   \   00000082   0x4008             ANDS     R0,R1,R0
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x60C8             STR      R0,[R1, #+12]
   1844          
   1845                /* Check if a transmit process is ongoing or not */
   1846                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000088   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000008C   0x2832             CMP      R0,#+50
   \   0000008E   0xD103             BNE.N    ??UART_Receive_IT_7
   1847                {
   1848                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000090   0x2012             MOVS     R0,#+18
   \   00000092   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000096   0xE00E             B.N      ??UART_Receive_IT_8
   1849                }
   1850                else
   1851                {
   1852                  /* Disable the UART Parity Error Interrupt */
   1853                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_7: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
   1854          
   1855                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1856                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6940             LDR      R0,[R0, #+20]
   \   000000A8   0x0840             LSRS     R0,R0,#+1
   \   000000AA   0x0040             LSLS     R0,R0,#+1
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6148             STR      R0,[R1, #+20]
   1857          
   1858                  huart->State = HAL_UART_STATE_READY;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF884 0x0039      STRB     R0,[R4, #+57]
   1859                }
   1860                HAL_UART_RxCpltCallback(huart);
   \                     ??UART_Receive_IT_8: (+1)
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1861          
   1862                return HAL_OK;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE002             B.N      ??UART_Receive_IT_9
   1863              }
   1864              return HAL_OK;
   \                     ??UART_Receive_IT_6: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??UART_Receive_IT_9
   1865            }
   1866            else
   1867            {
   1868              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000C4   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_9: (+1)
   \   000000C6   0xBD70             POP      {R4-R6,PC}       ;; return
   1869            }
   1870          }
   1871          
   1872          /**
   1873            * @brief  Configures the UART peripheral. 
   1874            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1875            *                the configuration information for the specified UART module.
   1876            * @retval None
   1877            */

   \                                 In section .text, align 2, keep-with-next
   1878          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1879          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1880            uint32_t tmpreg = 0x00;
   \   00000006   0x2500             MOVS     R5,#+0
   1881            
   1882            /* Check the parameters */
   1883            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1884            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1885            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1886            assert_param(IS_UART_MODE(huart->Init.Mode));
   1887          
   1888            /*------- UART-associated USART registers setting : CR2 Configuration ------*/
   1889            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1890             * to huart->Init.StopBits value */
   1891            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   \   0000000C   0xF430 0x5040      BICS     R0,R0,#0x3000
   \   00000010   0x68E1             LDR      R1,[R4, #+12]
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6108             STR      R0,[R1, #+16]
   1892          
   1893            /*------- UART-associated USART registers setting : CR1 Configuration ------*/
   1894            /* Configure the UART Word Length, Parity and mode: 
   1895               Set the M bits according to huart->Init.WordLength value 
   1896               Set PCE and PS bits according to huart->Init.Parity value
   1897               Set TE and RE bits according to huart->Init.Mode value
   1898               Set OVER8 bit according to huart->Init.OverSampling value */
   1899            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x6921             LDR      R1,[R4, #+16]
   \   0000001C   0x4308             ORRS     R0,R1,R0
   \   0000001E   0x6961             LDR      R1,[R4, #+20]
   \   00000020   0x4308             ORRS     R0,R1,R0
   \   00000022   0x69E1             LDR      R1,[R4, #+28]
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0x0005             MOVS     R5,R0
   1900            MODIFY_REG(huart->Instance->CR1, 
   1901                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
   1902                       tmpreg);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x....             LDR.N    R1,??DataTable0  ;; 0xffff69f3
   \   0000002E   0x4008             ANDS     R0,R1,R0
   \   00000030   0x4328             ORRS     R0,R5,R0
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x60C8             STR      R0,[R1, #+12]
   1903            
   1904            /*------- UART-associated USART registers setting : CR3 Configuration ------*/
   1905            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1906            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6940             LDR      R0,[R0, #+20]
   \   0000003A   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000003E   0x69A1             LDR      R1,[R4, #+24]
   \   00000040   0x4308             ORRS     R0,R1,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6148             STR      R0,[R1, #+20]
   1907            
   1908            /* Check the Over Sampling */
   1909            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \   00000046   0x69E0             LDR      R0,[R4, #+28]
   \   00000048   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004C   0xF040 0x80AC      BNE.W    ??UART_SetConfig_0
   1910            {
   1911              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1912              if((huart->Instance == USART1))
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD153             BNE.N    ??UART_SetConfig_1
   1913              {
   1914                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000058   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005C   0x4681             MOV      R9,R0
   \   0000005E   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000068   0x0007             MOVS     R7,R0
   \   0000006A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000006E   0x0006             MOVS     R6,R0
   \   00000070   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000074   0x2119             MOVS     R1,#+25
   \   00000076   0xFB01 0xF109      MUL      R1,R1,R9
   \   0000007A   0x6862             LDR      R2,[R4, #+4]
   \   0000007C   0x0052             LSLS     R2,R2,#+1
   \   0000007E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000082   0x2264             MOVS     R2,#+100
   \   00000084   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000088   0x2219             MOVS     R2,#+25
   \   0000008A   0xFB02 0xF208      MUL      R2,R2,R8
   \   0000008E   0x6863             LDR      R3,[R4, #+4]
   \   00000090   0x005B             LSLS     R3,R3,#+1
   \   00000092   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000096   0x2319             MOVS     R3,#+25
   \   00000098   0xFB03 0xF307      MUL      R3,R3,R7
   \   0000009C   0x6867             LDR      R7,[R4, #+4]
   \   0000009E   0x007F             LSLS     R7,R7,#+1
   \   000000A0   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000000A4   0x2764             MOVS     R7,#+100
   \   000000A6   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000000AA   0x2764             MOVS     R7,#+100
   \   000000AC   0xFB07 0x2213      MLS      R2,R7,R3,R2
   \   000000B0   0x00D2             LSLS     R2,R2,#+3
   \   000000B2   0x3232             ADDS     R2,R2,#+50
   \   000000B4   0x2364             MOVS     R3,#+100
   \   000000B6   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000BA   0x0052             LSLS     R2,R2,#+1
   \   000000BC   0xF412 0x72F8      ANDS     R2,R2,#0x1F0
   \   000000C0   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   000000C4   0x2219             MOVS     R2,#+25
   \   000000C6   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000CA   0x6863             LDR      R3,[R4, #+4]
   \   000000CC   0x005B             LSLS     R3,R3,#+1
   \   000000CE   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000D2   0x2319             MOVS     R3,#+25
   \   000000D4   0x4358             MULS     R0,R3,R0
   \   000000D6   0x6863             LDR      R3,[R4, #+4]
   \   000000D8   0x005B             LSLS     R3,R3,#+1
   \   000000DA   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000DE   0x2364             MOVS     R3,#+100
   \   000000E0   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000E4   0x2364             MOVS     R3,#+100
   \   000000E6   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000000EA   0x00C0             LSLS     R0,R0,#+3
   \   000000EC   0x3032             ADDS     R0,R0,#+50
   \   000000EE   0x2264             MOVS     R2,#+100
   \   000000F0   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000000F4   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000F8   0x1840             ADDS     R0,R0,R1
   \   000000FA   0x6821             LDR      R1,[R4, #+0]
   \   000000FC   0x6088             STR      R0,[R1, #+8]
   \   000000FE   0xE0FC             B.N      ??UART_SetConfig_2
   1915              }
   1916              else
   1917              {
   1918                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_1: (+1)
   \   00000100   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000104   0x4681             MOV      R9,R0
   \   00000106   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000010A   0x4680             MOV      R8,R0
   \   0000010C   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000110   0x0007             MOVS     R7,R0
   \   00000112   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000116   0x0006             MOVS     R6,R0
   \   00000118   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000011C   0x2119             MOVS     R1,#+25
   \   0000011E   0xFB01 0xF109      MUL      R1,R1,R9
   \   00000122   0x6862             LDR      R2,[R4, #+4]
   \   00000124   0x0052             LSLS     R2,R2,#+1
   \   00000126   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000012A   0x2264             MOVS     R2,#+100
   \   0000012C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000130   0x2219             MOVS     R2,#+25
   \   00000132   0xFB02 0xF208      MUL      R2,R2,R8
   \   00000136   0x6863             LDR      R3,[R4, #+4]
   \   00000138   0x005B             LSLS     R3,R3,#+1
   \   0000013A   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000013E   0x2319             MOVS     R3,#+25
   \   00000140   0xFB03 0xF307      MUL      R3,R3,R7
   \   00000144   0x6867             LDR      R7,[R4, #+4]
   \   00000146   0x007F             LSLS     R7,R7,#+1
   \   00000148   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   0000014C   0x2764             MOVS     R7,#+100
   \   0000014E   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   00000152   0x2764             MOVS     R7,#+100
   \   00000154   0xFB07 0x2213      MLS      R2,R7,R3,R2
   \   00000158   0x00D2             LSLS     R2,R2,#+3
   \   0000015A   0x3232             ADDS     R2,R2,#+50
   \   0000015C   0x2364             MOVS     R3,#+100
   \   0000015E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000162   0x0052             LSLS     R2,R2,#+1
   \   00000164   0xF412 0x72F8      ANDS     R2,R2,#0x1F0
   \   00000168   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000016C   0x2219             MOVS     R2,#+25
   \   0000016E   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000172   0x6863             LDR      R3,[R4, #+4]
   \   00000174   0x005B             LSLS     R3,R3,#+1
   \   00000176   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000017A   0x2319             MOVS     R3,#+25
   \   0000017C   0x4358             MULS     R0,R3,R0
   \   0000017E   0x6863             LDR      R3,[R4, #+4]
   \   00000180   0x005B             LSLS     R3,R3,#+1
   \   00000182   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000186   0x2364             MOVS     R3,#+100
   \   00000188   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000018C   0x2364             MOVS     R3,#+100
   \   0000018E   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   00000192   0x00C0             LSLS     R0,R0,#+3
   \   00000194   0x3032             ADDS     R0,R0,#+50
   \   00000196   0x2264             MOVS     R2,#+100
   \   00000198   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   0000019C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000001A0   0x1840             ADDS     R0,R0,R1
   \   000001A2   0x6821             LDR      R1,[R4, #+0]
   \   000001A4   0x6088             STR      R0,[R1, #+8]
   \   000001A6   0xE0A8             B.N      ??UART_SetConfig_2
   1919              }
   1920            }
   1921            else
   1922            {
   1923              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1924              if((huart->Instance == USART1))
   \                     ??UART_SetConfig_0: (+1)
   \   000001A8   0x6820             LDR      R0,[R4, #+0]
   \   000001AA   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   000001AC   0x4288             CMP      R0,R1
   \   000001AE   0xD152             BNE.N    ??UART_SetConfig_3
   1925              {
   1926                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   000001B0   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001B4   0x4681             MOV      R9,R0
   \   000001B6   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001BA   0x4680             MOV      R8,R0
   \   000001BC   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001C0   0x0007             MOVS     R7,R0
   \   000001C2   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001C6   0x0006             MOVS     R6,R0
   \   000001C8   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001CC   0x2119             MOVS     R1,#+25
   \   000001CE   0xFB01 0xF109      MUL      R1,R1,R9
   \   000001D2   0x6862             LDR      R2,[R4, #+4]
   \   000001D4   0x0092             LSLS     R2,R2,#+2
   \   000001D6   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001DA   0x2264             MOVS     R2,#+100
   \   000001DC   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001E0   0x2219             MOVS     R2,#+25
   \   000001E2   0xFB02 0xF208      MUL      R2,R2,R8
   \   000001E6   0x6863             LDR      R3,[R4, #+4]
   \   000001E8   0x009B             LSLS     R3,R3,#+2
   \   000001EA   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000001EE   0x2319             MOVS     R3,#+25
   \   000001F0   0xFB03 0xF307      MUL      R3,R3,R7
   \   000001F4   0x6867             LDR      R7,[R4, #+4]
   \   000001F6   0x00BF             LSLS     R7,R7,#+2
   \   000001F8   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000001FC   0x2764             MOVS     R7,#+100
   \   000001FE   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   00000202   0x2764             MOVS     R7,#+100
   \   00000204   0xFB07 0x2213      MLS      R2,R7,R3,R2
   \   00000208   0x0112             LSLS     R2,R2,#+4
   \   0000020A   0x3232             ADDS     R2,R2,#+50
   \   0000020C   0x2364             MOVS     R3,#+100
   \   0000020E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000212   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000216   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000021A   0x2219             MOVS     R2,#+25
   \   0000021C   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000220   0x6863             LDR      R3,[R4, #+4]
   \   00000222   0x009B             LSLS     R3,R3,#+2
   \   00000224   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000228   0x2319             MOVS     R3,#+25
   \   0000022A   0x4358             MULS     R0,R3,R0
   \   0000022C   0x6863             LDR      R3,[R4, #+4]
   \   0000022E   0x009B             LSLS     R3,R3,#+2
   \   00000230   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000234   0x2364             MOVS     R3,#+100
   \   00000236   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000023A   0x2364             MOVS     R3,#+100
   \   0000023C   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   00000240   0x0100             LSLS     R0,R0,#+4
   \   00000242   0x3032             ADDS     R0,R0,#+50
   \   00000244   0x2264             MOVS     R2,#+100
   \   00000246   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   0000024A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000024E   0x1840             ADDS     R0,R0,R1
   \   00000250   0x6821             LDR      R1,[R4, #+0]
   \   00000252   0x6088             STR      R0,[R1, #+8]
   \   00000254   0xE051             B.N      ??UART_SetConfig_2
   1927              }
   1928              else
   1929              {
   1930                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_3: (+1)
   \   00000256   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000025A   0x4681             MOV      R9,R0
   \   0000025C   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000260   0x4680             MOV      R8,R0
   \   00000262   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000266   0x0007             MOVS     R7,R0
   \   00000268   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000026C   0x0006             MOVS     R6,R0
   \   0000026E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000272   0x2119             MOVS     R1,#+25
   \   00000274   0xFB01 0xF109      MUL      R1,R1,R9
   \   00000278   0x6862             LDR      R2,[R4, #+4]
   \   0000027A   0x0092             LSLS     R2,R2,#+2
   \   0000027C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000280   0x2264             MOVS     R2,#+100
   \   00000282   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000286   0x2219             MOVS     R2,#+25
   \   00000288   0xFB02 0xF208      MUL      R2,R2,R8
   \   0000028C   0x6863             LDR      R3,[R4, #+4]
   \   0000028E   0x009B             LSLS     R3,R3,#+2
   \   00000290   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000294   0x2319             MOVS     R3,#+25
   \   00000296   0xFB03 0xF307      MUL      R3,R3,R7
   \   0000029A   0x6867             LDR      R7,[R4, #+4]
   \   0000029C   0x00BF             LSLS     R7,R7,#+2
   \   0000029E   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000002A2   0x2764             MOVS     R7,#+100
   \   000002A4   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000002A8   0x2764             MOVS     R7,#+100
   \   000002AA   0xFB07 0x2213      MLS      R2,R7,R3,R2
   \   000002AE   0x0112             LSLS     R2,R2,#+4
   \   000002B0   0x3232             ADDS     R2,R2,#+50
   \   000002B2   0x2364             MOVS     R3,#+100
   \   000002B4   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000002B8   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   000002BC   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   000002C0   0x2219             MOVS     R2,#+25
   \   000002C2   0xFB02 0xF206      MUL      R2,R2,R6
   \   000002C6   0x6863             LDR      R3,[R4, #+4]
   \   000002C8   0x009B             LSLS     R3,R3,#+2
   \   000002CA   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000002CE   0x2319             MOVS     R3,#+25
   \   000002D0   0x4358             MULS     R0,R3,R0
   \   000002D2   0x6863             LDR      R3,[R4, #+4]
   \   000002D4   0x009B             LSLS     R3,R3,#+2
   \   000002D6   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000002DA   0x2364             MOVS     R3,#+100
   \   000002DC   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000002E0   0x2364             MOVS     R3,#+100
   \   000002E2   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000002E6   0x0100             LSLS     R0,R0,#+4
   \   000002E8   0x3032             ADDS     R0,R0,#+50
   \   000002EA   0x2264             MOVS     R2,#+100
   \   000002EC   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000002F0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000002F4   0x1840             ADDS     R0,R0,R1
   \   000002F6   0x6821             LDR      R1,[R4, #+0]
   \   000002F8   0x6088             STR      R0,[R1, #+8]
   1931              }
   1932            }
   1933          }
   \                     ??UART_SetConfig_2: (+1)
   \   000002FA   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40013800         DC32     0x40013800
   1934          /**
   1935            * @}
   1936            */
   1937          
   1938          #endif /* HAL_UART_MODULE_ENABLED */
   1939          /**
   1940            * @}
   1941            */
   1942          
   1943          /**
   1944            * @}
   1945            */
   1946          
   1947          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      24   HAL_UART_IRQHandler
        24   -> HAL_UART_ErrorCallback
        24   -> UART_EndTransmit_IT
        24   -> UART_Receive_IT
        24   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
      16   UART_DMAError
        16   -> HAL_UART_ErrorCallback
      16   UART_DMAReceiveCplt
        16   -> HAL_UART_RxCpltCallback
      16   UART_DMARxHalfCplt
        16   -> HAL_UART_RxHalfCpltCallback
      16   UART_DMATransmitCplt
        16   -> HAL_UART_TxCpltCallback
      16   UART_DMATxHalfCplt
        16   -> HAL_UART_TxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
      16   UART_Receive_IT
        16   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
       4   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
        24   -> RoadBrd_WWDG_Refresh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      60  HAL_HalfDuplex_EnableReceiver
      60  HAL_HalfDuplex_EnableTransmitter
     120  HAL_HalfDuplex_Init
     138  HAL_LIN_Init
      54  HAL_LIN_SendBreak
      54  HAL_MultiProcessor_EnterMuteMode
      56  HAL_MultiProcessor_ExitMuteMode
     142  HAL_MultiProcessor_Init
     112  HAL_UART_DMAPause
     138  HAL_UART_DMAResume
      52  HAL_UART_DMAStop
      74  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     282  HAL_UART_IRQHandler
     114  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     264  HAL_UART_Receive
     158  HAL_UART_Receive_DMA
     136  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     252  HAL_UART_Transmit
     168  HAL_UART_Transmit_DMA
     112  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      36  UART_DMAError
      62  UART_DMAReceiveCplt
      14  UART_DMARxHalfCplt
      54  UART_DMATransmitCplt
      14  UART_DMATxHalfCplt
      50  UART_EndTransmit_IT
     200  UART_Receive_IT
     766  UART_SetConfig
     124  UART_Transmit_IT
     238  UART_WaitOnFlagUntilTimeout

 
 4 136 bytes in section .text
 
 4 136 bytes of CODE memory

Errors: none
Warnings: none
