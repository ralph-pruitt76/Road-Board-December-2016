###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       03/Jan/2018  15:19:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\main.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\main.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\main.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : main.c
      4            * Description        : Main program body
      5            ******************************************************************************
      6            *
      7            * COPYRIGHT(c) 2016 STMicroelectronics
      8            *
      9            * Redistribution and use in source and binary forms, with or without modification,
     10            * are permitted provided that the following conditions are met:
     11            *   1. Redistributions of source code must retain the above copyright notice,
     12            *      this list of conditions and the following disclaimer.
     13            *   2. Redistributions in binary form must reproduce the above copyright notice,
     14            *      this list of conditions and the following disclaimer in the documentation
     15            *      and/or other materials provided with the distribution.
     16            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     17            *      may be used to endorse or promote products derived from this software
     18            *      without specific prior written permission.
     19            *
     20            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     21            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     22            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     24            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     25            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     26            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     27            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     28            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     29            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30            *
     31            ******************************************************************************
     32            */
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "stm32l1xx_hal.h"
     35          #include "cmsis_os.h"
     36          #include "adc.h"
     37          #include "dma.h"
     38          #include "i2c.h"
     39          #include "tim.h"
     40          #include "usart.h"
     41          #include "usb_device.h"
     42          #include "wwdg.h"
     43          #include "Flash.h"
     44          
     45          /* USER CODE BEGIN Includes */
     46          #include "stm32l1xx_nucleo.h"
     47          #ifdef REV_L
     48            #include "bgm111.h"
     49            #include "app_data.h"
     50          #endif
     51          #include "gpio.h"
     52          #include "main.h"
     53          #include "parser.h"
     54          #include "BootMonitor.h"
     55          #include "stdbool.h"
     56          #include "ErrorCodes.h"
     57              
     58          /* USER CODE END Includes */
     59          
     60          /* Private variables ---------------------------------------------------------*/
     61          
     62          /* USER CODE BEGIN PV */
     63          /* Private variables ---------------------------------------------------------*/
     64          
     65          /* USER CODE END PV */
     66          
     67          /* Private function prototypes -----------------------------------------------*/
     68          void SystemClock_Config(void);
     69          void Error_Handler(void);
     70          void MX_FREERTOS_Init(void);
     71          
     72          /* USER CODE BEGIN PFP */
     73          /* Private function prototypes -----------------------------------------------*/
     74          
     75          /* USER CODE END PFP */
     76          
     77          /* USER CODE BEGIN 0 */
     78          
     79          /* USER CODE END 0 */

   \                                 In section .text, align 2, keep-with-next
     80          int main(void)
     81          {
   \                     main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0BA             SUB      SP,SP,#+232
     82            /* USER CODE BEGIN 1 */
     83          #ifdef TEST2
     84            #define RECEIVE_SZ      5
     85            uint8_t tempBffr[RECEIVE_SZ];
     86            char tempBffr2[5];
     87            HAL_StatusTypeDef Status;
     88          #else
     89            #ifdef TEST
     90              #define RECEIVE_SZ      5
     91            #else
     92          //HERE
     93              #define RECEIVE_SZ      125
     94              uint8_t tempBffr[RECEIVE_SZ];
     95              uint8_t tempBffr2[80];
     96              HAL_StatusTypeDef Status;
     97            #endif
     98          #endif
     99          
    100          #ifdef REV_L
    101            //N uint16_t tmpSize = RECEIVE_SZ;
    102            //N uint8_t tmpData[2];
    103          //  uint8_t tmpData[RECEIVE_SZ];
    104            Temperature   Temp;
    105          #ifndef PATCH_UART
    106            bool firstTime = true;
   \   00000004   0x2501             MOVS     R5,#+1
    107          #endif
    108            //N uint8_t *pData = tempBffr;
    109          #endif
    110          
    111          //ITStatus PStatus;
    112          
    113            /* USER CODE END 1 */
    114          
    115            /* MCU Configuration----------------------------------------------------------*/
    116          
    117          #ifdef REV_L
    118            // Turn Off Power Supplies
    119            //RoadBrd_gpio_Off(gTAM_PWR);    // Turn Off 5V Power
    120            //RoadBrd_gpio_Off(gVDD_PWR);    // Turn Off 3.3V Power
    121          #endif
    122          
    123            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    124            HAL_Init();
   \   00000006   0x.... 0x....      BL       HAL_Init
    125          
    126            /* Configure the system clock */
    127            SystemClock_Config();
   \   0000000A   0x.... 0x....      BL       SystemClock_Config
    128          
    129            /* Initialize all configured peripherals */
    130            MX_GPIO_Init();
   \   0000000E   0x.... 0x....      BL       MX_GPIO_Init
    131            MX_DMA_Init();
   \   00000012   0x.... 0x....      BL       MX_DMA_Init
    132            MX_ADC_Init();
   \   00000016   0x.... 0x....      BL       MX_ADC_Init
    133            ADC_Config();
   \   0000001A   0x.... 0x....      BL       ADC_Config
    134            MX_USART2_UART_Init();
   \   0000001E   0x.... 0x....      BL       MX_USART2_UART_Init
    135            MX_USART3_UART_Init();
   \   00000022   0x.... 0x....      BL       MX_USART3_UART_Init
    136            MX_TIM2_Init();
   \   00000026   0x.... 0x....      BL       MX_TIM2_Init
    137            MX_TIM3_Init();
   \   0000002A   0x.... 0x....      BL       MX_TIM3_Init
    138          
    139            /* USER CODE BEGIN 2 */
    140          #ifdef REV_L
    141            // Wait for power to stabilize off...200msec
    142            //RoadBrd_Delay( 200 );
    143            // Turn on Power Supplies.
    144            RoadBrd_gpio_On(gTAM_PWR);    // Turn on 5V Power
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      BL       RoadBrd_gpio_On
    145            RoadBrd_gpio_On(gVDD_PWR);    // Turn on 3.3V Power
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0x.... 0x....      BL       RoadBrd_gpio_On
    146            // Wait for power to stabilize...200msec
    147            RoadBrd_Delay( 200 );
   \   0000003A   0x20C8             MOVS     R0,#+200
   \   0000003C   0x.... 0x....      BL       RoadBrd_Delay
    148            // Reset all Drivers to Off before starting init process.
    149            Reset_DriverStates();
   \   00000040   0x.... 0x....      BL       Reset_DriverStates
    150          
    151            // Enable Interrupts
    152            //---UART
    153            HAL_NVIC_EnableIRQ(USART2_IRQn);
   \   00000044   0x2026             MOVS     R0,#+38
   \   00000046   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    154            HAL_NVIC_EnableIRQ(USART3_IRQn);
   \   0000004A   0x2027             MOVS     R0,#+39
   \   0000004C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    155          
    156            // Flush I2C Channel before testing...
    157            RoadBrd_I2CRepair();
   \   00000050   0x.... 0x....      BL       RoadBrd_I2CRepair
    158            
    159            // Test I2C Channel and see if we even have a working I2C.
    160            RoadBrd_TestI2C();
   \   00000054   0x.... 0x....      BL       RoadBrd_TestI2C
    161            
    162            // Test for I2C Failure then attempt a repair.
    163            if ( !(Get_DriverStates( I2C_STATE )) )
   \   00000058   0x2007             MOVS     R0,#+7
   \   0000005A   0x.... 0x....      BL       Get_DriverStates
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD117             BNE.N    ??main_0
    164            {
    165              if ((RoadBrd_I2CRepair()) == HAL_OK)
   \   00000062   0x.... 0x....      BL       RoadBrd_I2CRepair
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD10A             BNE.N    ??main_1
    166              {
    167                RdBrd_ErrCdLogErrCd( REPAIR_I2C, MODULE_main );
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x2014             MOVS     R0,#+20
   \   0000006E   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    168                Set_DriverStates( I2C_STATE, DRIVER_ON );
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x2007             MOVS     R0,#+7
   \   00000076   0x.... 0x....      BL       Set_DriverStates
    169                // Now..Initialize I2C and test Drivers.
    170                MX_I2C1_Init();
   \   0000007A   0x.... 0x....      BL       MX_I2C1_Init
   \   0000007E   0xE00A             B.N      ??main_2
    171              }
    172              else
    173              {
    174                // OK...It is hung.
    175                Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \                     ??main_1: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x2007             MOVS     R0,#+7
   \   00000084   0x.... 0x....      BL       Set_DriverStates
    176                RdBrd_ErrCdLogErrCd( ERROR_I2CBUSY, MODULE_main );
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
   \   00000090   0xE001             B.N      ??main_2
    177              }
    178            }
    179            else
    180            {
    181              // Now..Initialize I2C and test Drivers.
    182              MX_I2C1_Init();
   \                     ??main_0: (+1)
   \   00000092   0x.... 0x....      BL       MX_I2C1_Init
    183            }
    184            
    185            //---I2C1
    186            HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
   \                     ??main_2: (+1)
   \   00000096   0x201F             MOVS     R0,#+31
   \   00000098   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    187            HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
   \   0000009C   0x2020             MOVS     R0,#+32
   \   0000009E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    188            //---TIM
    189          #ifndef PATCH_UART
    190            HAL_TIM_StartTimer2();
   \   000000A2   0x.... 0x....      BL       HAL_TIM_StartTimer2
    191            HAL_TIM_StartTimer3();
   \   000000A6   0x.... 0x....      BL       HAL_TIM_StartTimer3
    192            HAL_NVIC_EnableIRQ(TIM2_IRQn);
   \   000000AA   0x201C             MOVS     R0,#+28
   \   000000AC   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    193            HAL_NVIC_EnableIRQ(TIM3_IRQn);
   \   000000B0   0x201D             MOVS     R0,#+29
   \   000000B2   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    194          #endif
    195            // Test I2C State.
    196          
    197            // Test I2C Status and Task init I2C if Active driver.
    198            if ( !(Get_DriverStates( I2C_STATE )) )
   \   000000B6   0x2007             MOVS     R0,#+7
   \   000000B8   0x.... 0x....      BL       Get_DriverStates
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD11A             BNE.N    ??main_3
    199            {
    200              // Wait 35  ms. For Busy flag to drop.
    201              if(I2C_WaitBusyFlag() != HAL_OK)
   \   000000C0   0x.... 0x....      BL       I2C_WaitBusyFlag
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD016             BEQ.N    ??main_3
    202              {
    203                // One More try at repairing hung I2C Channel.
    204                if ((RoadBrd_I2CRepair()) == HAL_OK)
   \   000000C8   0x.... 0x....      BL       RoadBrd_I2CRepair
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD10A             BNE.N    ??main_4
    205                {
    206                  Set_DriverStates( I2C_STATE, DRIVER_ON );
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x2007             MOVS     R0,#+7
   \   000000D4   0x.... 0x....      BL       Set_DriverStates
    207                  RdBrd_ErrCdLogErrCd( REPAIR_I2C, MODULE_main );
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x2014             MOVS     R0,#+20
   \   000000DC   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    208                  // Now..Initialize I2C and test Drivers.
    209                  MX_I2C1_Init();
   \   000000E0   0x.... 0x....      BL       MX_I2C1_Init
   \   000000E4   0xE007             B.N      ??main_3
    210                }
    211                else
    212                {
    213                  // OK...It is hung.
    214                  Set_DriverStates( I2C_STATE, DRIVER_OFF );
   \                     ??main_4: (+1)
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0x.... 0x....      BL       Set_DriverStates
    215                  RdBrd_ErrCdLogErrCd( ERROR_I2CBUSY, MODULE_main );
   \   000000EE   0x2101             MOVS     R1,#+1
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    216                }
    217              }
    218            }
    219          
    220            //BGM Initialization
    221          #ifndef TEST2
    222          #ifndef PATCH_UART
    223            BGM111_Init();
   \                     ??main_3: (+1)
   \   000000F6   0x.... 0x....      BL       BGM111_Init
    224          #else
    225            RoadBrd_gpio_Off(gRESET_BGM111);
    226          #endif
    227          #endif
    228            
    229            // Test I2C Status and Task init I2C if Active driver.
    230            if ( Get_DriverStates( I2C_STATE ) )
   \   000000FA   0x2007             MOVS     R0,#+7
   \   000000FC   0x.... 0x....      BL       Get_DriverStates
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xF000 0x8086      BEQ.W    ??main_5
    231            {
    232              Status = RoadBrd_RGBInit();
   \   00000106   0x.... 0x....      BL       RoadBrd_RGBInit
   \   0000010A   0x0004             MOVS     R4,R0
    233              if (Status == HAL_OK)
   \   0000010C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010E   0x2C00             CMP      R4,#+0
   \   00000110   0xD104             BNE.N    ??main_6
    234              {
    235                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_ON );
   \   00000112   0x2101             MOVS     R1,#+1
   \   00000114   0x2002             MOVS     R0,#+2
   \   00000116   0x.... 0x....      BL       Set_DriverStates
   \   0000011A   0xE007             B.N      ??main_7
    236              }
    237              else
    238              {
    239                RdBrd_ErrCdLogErrCd( ERROR_RGB_INIT, MODULE_main );
   \                     ??main_6: (+1)
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0x2008             MOVS     R0,#+8
   \   00000120   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    240                Set_DriverStates( IRRADIANCE_MNTR_TASK, DRIVER_OFF );
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0x2002             MOVS     R0,#+2
   \   00000128   0x.... 0x....      BL       Set_DriverStates
    241              }
    242          
    243              // Initialize Voltage Monitor Hardware
    244              Status = RoadBrd_Init_VMonitor();
   \                     ??main_7: (+1)
   \   0000012C   0x.... 0x....      BL       RoadBrd_Init_VMonitor
   \   00000130   0x0004             MOVS     R4,R0
    245              if (Status == HAL_OK)
   \   00000132   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000134   0x2C00             CMP      R4,#+0
   \   00000136   0xD104             BNE.N    ??main_8
    246              {
    247                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_ON );
   \   00000138   0x2101             MOVS     R1,#+1
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x.... 0x....      BL       Set_DriverStates
   \   00000140   0xE007             B.N      ??main_9
    248              }
    249              else
    250              {
    251                RdBrd_ErrCdLogErrCd( ERROR_VMNTR_INIT, MODULE_main );
   \                     ??main_8: (+1)
   \   00000142   0x2101             MOVS     R1,#+1
   \   00000144   0x2002             MOVS     R0,#+2
   \   00000146   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    252                Set_DriverStates( VOLTAGE_MNTR_TASK, DRIVER_OFF );
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x.... 0x....      BL       Set_DriverStates
    253              }
    254          
    255              // Initialize Grid Eye Hardware
    256              Status = RoadBrd_GridEyeInit();
   \                     ??main_9: (+1)
   \   00000152   0x.... 0x....      BL       RoadBrd_GridEyeInit
   \   00000156   0x0004             MOVS     R4,R0
    257              if (Status == HAL_OK)
   \   00000158   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015A   0x2C00             CMP      R4,#+0
   \   0000015C   0xD104             BNE.N    ??main_10
    258              {
    259                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_ON );
   \   0000015E   0x2101             MOVS     R1,#+1
   \   00000160   0x2005             MOVS     R0,#+5
   \   00000162   0x.... 0x....      BL       Set_DriverStates
   \   00000166   0xE01A             B.N      ??main_11
    260              }
    261              else
    262              {
    263                RdBrd_ErrCdLogErrCd( ERROR_GDEYE_INIT, MODULE_main );
   \                     ??main_10: (+1)
   \   00000168   0x2101             MOVS     R1,#+1
   \   0000016A   0x2004             MOVS     R0,#+4
   \   0000016C   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    264                Set_DriverStates( GRIDEYE_MNTR_TASK, DRIVER_OFF );
   \   00000170   0x2100             MOVS     R1,#+0
   \   00000172   0x2005             MOVS     R0,#+5
   \   00000174   0x.... 0x....      BL       Set_DriverStates
    265                // OK, We have no Grid Eye...Do we have a Cool Eye?
    266                Status = RoadBrd_CoolEyeInit();
   \   00000178   0x.... 0x....      BL       RoadBrd_CoolEyeInit
   \   0000017C   0x0004             MOVS     R4,R0
    267                if (Status == HAL_OK)
   \   0000017E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000180   0x2C00             CMP      R4,#+0
   \   00000182   0xD104             BNE.N    ??main_12
    268                {
    269                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_ON );
   \   00000184   0x2101             MOVS     R1,#+1
   \   00000186   0x2006             MOVS     R0,#+6
   \   00000188   0x.... 0x....      BL       Set_DriverStates
   \   0000018C   0xE007             B.N      ??main_11
    270                }
    271                else
    272                {
    273                  RdBrd_ErrCdLogErrCd( ERROR_CLEYE_INIT, MODULE_main );
   \                     ??main_12: (+1)
   \   0000018E   0x2101             MOVS     R1,#+1
   \   00000190   0x200A             MOVS     R0,#+10
   \   00000192   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    274                  Set_DriverStates( COOLEYE_MNTR_TASK, DRIVER_OFF );
   \   00000196   0x2100             MOVS     R1,#+0
   \   00000198   0x2006             MOVS     R0,#+6
   \   0000019A   0x.... 0x....      BL       Set_DriverStates
    275                }
    276            }
    277          
    278              // Initialize Pressure Sensor Hardware
    279              Status = RoadBrd_Init_Barometer();
   \                     ??main_11: (+1)
   \   0000019E   0x.... 0x....      BL       RoadBrd_Init_Barometer
   \   000001A2   0x0004             MOVS     R4,R0
    280              if (Status == HAL_OK)
   \   000001A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A6   0x2C00             CMP      R4,#+0
   \   000001A8   0xD104             BNE.N    ??main_13
    281              {
    282                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_ON );
   \   000001AA   0x2101             MOVS     R1,#+1
   \   000001AC   0x2003             MOVS     R0,#+3
   \   000001AE   0x.... 0x....      BL       Set_DriverStates
   \   000001B2   0xE007             B.N      ??main_14
    283              }
    284              else
    285              {
    286                RdBrd_ErrCdLogErrCd( ERROR_PRESSURE_INIT, MODULE_main );
   \                     ??main_13: (+1)
   \   000001B4   0x2101             MOVS     R1,#+1
   \   000001B6   0x2005             MOVS     R0,#+5
   \   000001B8   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    287                Set_DriverStates( PRESSURE_MNTR_TASK, DRIVER_OFF );
   \   000001BC   0x2100             MOVS     R1,#+0
   \   000001BE   0x2003             MOVS     R0,#+3
   \   000001C0   0x.... 0x....      BL       Set_DriverStates
    288              }
    289          
    290              // Initialize Humidity Sensor Hardware
    291              Status = RoadBrd_HumidityInit();
   \                     ??main_14: (+1)
   \   000001C4   0x.... 0x....      BL       RoadBrd_HumidityInit
   \   000001C8   0x0004             MOVS     R4,R0
    292              if (Status == HAL_OK)
   \   000001CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001CC   0x2C00             CMP      R4,#+0
   \   000001CE   0xD104             BNE.N    ??main_15
    293              {
    294                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_ON );
   \   000001D0   0x2101             MOVS     R1,#+1
   \   000001D2   0x2004             MOVS     R0,#+4
   \   000001D4   0x.... 0x....      BL       Set_DriverStates
   \   000001D8   0xE007             B.N      ??main_16
    295              }
    296              else
    297              {
    298                RdBrd_ErrCdLogErrCd( ERROR_HUMIDITY_INIT, MODULE_main );
   \                     ??main_15: (+1)
   \   000001DA   0x2101             MOVS     R1,#+1
   \   000001DC   0x2007             MOVS     R0,#+7
   \   000001DE   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    299                Set_DriverStates( HUMIDITY_MNTR_TASK, DRIVER_OFF );
   \   000001E2   0x2100             MOVS     R1,#+0
   \   000001E4   0x2004             MOVS     R0,#+4
   \   000001E6   0x.... 0x....      BL       Set_DriverStates
    300              }
    301            
    302              // Test Temperature Sensor Hardware
    303              Status = RoadBrd_ReadTemp( &Temp );
   \                     ??main_16: (+1)
   \   000001EA   0xA814             ADD      R0,SP,#+80
   \   000001EC   0x.... 0x....      BL       RoadBrd_ReadTemp
   \   000001F0   0x0004             MOVS     R4,R0
    304              if (Status == HAL_OK)
   \   000001F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F4   0x2C00             CMP      R4,#+0
   \   000001F6   0xD104             BNE.N    ??main_17
    305              {
    306                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_ON );
   \   000001F8   0x2101             MOVS     R1,#+1
   \   000001FA   0x2001             MOVS     R0,#+1
   \   000001FC   0x.... 0x....      BL       Set_DriverStates
   \   00000200   0xE007             B.N      ??main_5
    307              }
    308              else
    309              {
    310                RdBrd_ErrCdLogErrCd( ERROR_TEMP_INIT, MODULE_main );
   \                     ??main_17: (+1)
   \   00000202   0x2101             MOVS     R1,#+1
   \   00000204   0x2009             MOVS     R0,#+9
   \   00000206   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    311                Set_DriverStates( TEMPERATURE_MNTR_TASK, DRIVER_OFF );
   \   0000020A   0x2100             MOVS     R1,#+0
   \   0000020C   0x2001             MOVS     R0,#+1
   \   0000020E   0x.... 0x....      BL       Set_DriverStates
    312              }
    313            } //EndIf ( Get_DriverStates( I2C_STATE )
    314            
    315            // Initialize key app vars.
    316            InitSensors();
   \                     ??main_5: (+1)
   \   00000212   0x.... 0x....      BL       InitSensors
    317            RoadBrd_ParserInit();                         // This initializes the Parse Tasking Structure.
   \   00000216   0x.... 0x....      BL       RoadBrd_ParserInit
    318            RoadBrd_WWDG_InitializeDateString();          // Initialize Date Tag From Server as NULL.
   \   0000021A   0x.... 0x....      BL       RoadBrd_WWDG_InitializeDateString
    319            RoadBrd_WWDG_InitializeTickString();          // Initialize Tick Tag From as NULL.
   \   0000021E   0x.... 0x....      BL       RoadBrd_WWDG_InitializeTickString
    320            //**
    321            //**
    322            //** Initialize all Flash Structures.
    323            //**
    324            //**
    325            //*******1. Initializ WWDG Flash Structure
    326            // 1a. Is WWDG Flash Frame Initialized?
    327            if (RoadBrd_WWDG_VerifyFrame())
   \   00000222   0x.... 0x....      BL       RoadBrd_WWDG_VerifyFrame
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD004             BEQ.N    ??main_18
    328            {
    329              //Yes....Set FRAME_TASK Bit in Driver State Variable.
    330              Set_DriverStates( FRAME_TASK, DRIVER_ON );
   \   0000022A   0x2101             MOVS     R1,#+1
   \   0000022C   0x2008             MOVS     R0,#+8
   \   0000022E   0x.... 0x....      BL       Set_DriverStates
   \   00000232   0xE010             B.N      ??main_19
    331            } // EndIf (RoadBrd_WWDG_VerifyFrame())
    332            else
    333            {
    334              //No....1b. Attempt to Initialize WWDG Flash Frame.
    335              if (RoadBrd_WWDG_InitializeFrmFlash() != HAL_OK)
   \                     ??main_18: (+1)
   \   00000234   0x.... 0x....      BL       RoadBrd_WWDG_InitializeFrmFlash
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0xD008             BEQ.N    ??main_20
    336              {
    337                //FAILED....Indicate Error Code and Fail Driver State.
    338                RdBrd_ErrCdLogErrCd( ERROR_FRAME_INIT, MODULE_main );
   \   0000023C   0x2101             MOVS     R1,#+1
   \   0000023E   0x2010             MOVS     R0,#+16
   \   00000240   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    339                Set_DriverStates( FRAME_TASK, DRIVER_OFF );
   \   00000244   0x2100             MOVS     R1,#+0
   \   00000246   0x2008             MOVS     R0,#+8
   \   00000248   0x.... 0x....      BL       Set_DriverStates
   \   0000024C   0xE003             B.N      ??main_19
    340              }
    341              else
    342              {
    343                //SUCCESS....Set FRAME_TASK Bit in Driver State Variable.
    344                Set_DriverStates( FRAME_TASK, DRIVER_ON );
   \                     ??main_20: (+1)
   \   0000024E   0x2101             MOVS     R1,#+1
   \   00000250   0x2008             MOVS     R0,#+8
   \   00000252   0x.... 0x....      BL       Set_DriverStates
    345              }
    346            } // EndElse (RoadBrd_WWDG_VerifyFrame())
    347            
    348            //*******2. Initializ Calibration Flash Structure
    349            // 2a. Is Calibration Flash Frame Initialized?
    350            if (RoadBrd_CAL_VerifyFrame())
   \                     ??main_19: (+1)
   \   00000256   0x.... 0x....      BL       RoadBrd_CAL_VerifyFrame
   \   0000025A   0x2800             CMP      R0,#+0
   \   0000025C   0xD004             BEQ.N    ??main_21
    351            {
    352              //Yes....Set CAL_TASK Bit in Driver State Variable.
    353              Set_DriverStates( CAL_TASK, DRIVER_ON );
   \   0000025E   0x2101             MOVS     R1,#+1
   \   00000260   0x2009             MOVS     R0,#+9
   \   00000262   0x.... 0x....      BL       Set_DriverStates
   \   00000266   0xE010             B.N      ??main_22
    354            } // EndIf (RoadBrd_WWDG_VerifyFrame())
    355            else
    356            {
    357              //No....2b. Attempt to Initialize Structure Flash Structure.
    358              if (RoadBrd_CAL_InitializeFrmFlash() != HAL_OK)
   \                     ??main_21: (+1)
   \   00000268   0x.... 0x....      BL       RoadBrd_CAL_InitializeFrmFlash
   \   0000026C   0x2800             CMP      R0,#+0
   \   0000026E   0xD008             BEQ.N    ??main_23
    359              {
    360                //FAILED....Indicate Error Code and Fail Driver State.
    361                RdBrd_ErrCdLogErrCd( ERROR_CAL_INIT, MODULE_main );
   \   00000270   0x2101             MOVS     R1,#+1
   \   00000272   0x2013             MOVS     R0,#+19
   \   00000274   0x.... 0x....      BL       RdBrd_ErrCdLogErrCd
    362                Set_DriverStates( CAL_TASK, DRIVER_OFF );
   \   00000278   0x2100             MOVS     R1,#+0
   \   0000027A   0x2009             MOVS     R0,#+9
   \   0000027C   0x.... 0x....      BL       Set_DriverStates
   \   00000280   0xE003             B.N      ??main_22
    363              }
    364              else
    365              {
    366                //SUCCESS....Set FRAME_TASK Bit in Driver State Variable.
    367                Set_DriverStates( CAL_TASK, DRIVER_ON );
   \                     ??main_23: (+1)
   \   00000282   0x2101             MOVS     R1,#+1
   \   00000284   0x2009             MOVS     R0,#+9
   \   00000286   0x.... 0x....      BL       Set_DriverStates
    368              }
    369            } // EndElse (RoadBrd_WWDG_VerifyFrame())
    370            
    371            
    372          // Initialize Key Vars once Flash has been validated.
    373            // Initialize Key Timer Sampling Vars.
    374            Set_TickCounts( RoadBrd_Get_RdSndTickCnt(), RoadBrd_Get_SnsrTickCnt() );
   \                     ??main_22: (+1)
   \   0000028A   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   0000028E   0x0006             MOVS     R6,R0
   \   00000290   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   00000294   0x0031             MOVS     R1,R6
   \   00000296   0x.... 0x....      BL       Set_TickCounts
    375              
    376            // Time to start WWDG..
    377            HAL_NVIC_EnableIRQ(WWDG_IRQn);
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    378            MX_WWDG_Init();
   \   000002A0   0x.... 0x....      BL       MX_WWDG_Init
    379            RoadBrd_WWDG_Start();
   \   000002A4   0x.... 0x....      BL       RoadBrd_WWDG_Start
    380          
    381          #endif
    382          
    383          #ifdef TASKING
    384            /* USER CODE END 2 */
    385          
    386            /* Call init function for freertos objects (in freertos.c) */
    387            MX_FREERTOS_Init();
    388          
    389            /* Start scheduler */
    390            osKernelStart();
    391            
    392            /* We should never get here as control is now taken by the scheduler */
    393          
    394            /* Infinite loop */
    395            /* USER CODE BEGIN WHILE */
    396          #else
    397            
    398            #ifdef TEST
    399                // Turn On Bluetooth Interface for Debug.
    400                RoadBrd_gpio_On( gRESET_BGM111 );
    401            #else
    402          //    #ifndef TEST2
    403                #ifdef ASCII
    404                  // Send Opening Banner for Monitor Code.
    405                  #ifdef NUCLEO
    406          //        strcpy( (char *)tempBffr2, "*********************  WEATHERCLOUD *********************\r\n\r\n");
    407                    strcpy( (char *)tempBffr2, "\r\n\r\n");
    408                    // Send string to UART..
    409          #ifdef REV_L
    410                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    411                    // Wait for msg to be completed.
    412                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    413                    {
    414                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    415                    }
    416                    // Clear State for Next Transfer.
    417                    clrUsartState( NUCLEO_USART );
    418          #else
    419                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    420                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    421          #endif
    422                    if (Status != HAL_OK)
    423                      Error_Handler();
    424                    sprintf( (char *)tempBffr2, "     Road Board Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
    425                    //strcpy( (char *)tempBffr2, "     Road Board Monitor Rev K Hardware Version 1.0 \r\n");
    426                    // Send string to UART..
    427          #ifdef REV_L
    428                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    429                    // Wait for msg to be completed.
    430                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    431                    {
    432                    }
    433                    // Clear State for Next Transfer.
    434                    clrUsartState( NUCLEO_USART );
    435          #else
    436                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    437          #endif
    438                    if (Status != HAL_OK)
    439                      Error_Handler();
    440                    sprintf( (char *)tempBffr2, "                  Copyright %s. \r\n\r\n", REL_DATE);
    441                    //strcpy( (char *)tempBffr2, "                  Copyright August 9, 2016. \r\n\r\n\r\n> ");
    442                    // Send string to UART..
    443                    // *******Time to Build Extra Information...
    444          #ifdef REV_L
    445                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    446                    // Wait for msg to be completed.
    447                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    448                    {
    449                    }
    450                    // Clear State for Next Transfer.
    451                    clrUsartState( NUCLEO_USART );
    452          #else
    453                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    454          #endif
    455                    if (Status != HAL_OK)
    456                      Error_Handler();
    457                    sprintf( (char *)tempBffr2, "RdSnd Sample Rate:  %3.1f Seconds.\r\n", ((float)RoadBrd_Get_RdSndTickCnt()/10));
    458          #ifdef REV_L
    459                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    460                    // Wait for msg to be completed.
    461                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    462                    {
    463                    }
    464                    // Clear State for Next Transfer.
    465                    clrUsartState( NUCLEO_USART );
    466          #else
    467                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    468          #endif
    469                    if (Status != HAL_OK)
    470                      Error_Handler();
    471                    sprintf( (char *)tempBffr2, "Sensor Sample Rate: %3.1f Seconds.\r\n\r\n> ", ((float)RoadBrd_Get_SnsrTickCnt()/10));
    472          #ifdef REV_L
    473                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    474                    // Wait for msg to be completed.
    475                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    476                    {
    477                    }
    478                    // Clear State for Next Transfer.
    479                    clrUsartState( NUCLEO_USART );
    480          #else
    481                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    482          #endif
    483                    if (Status != HAL_OK)
    484                      Error_Handler();
    485                  #else
    486                    strcpy( (char *)tempBffr2, "*********************  WEATHERCLOUD *********************\r\n\r\n");
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable1_1
   \   000002AC   0x4668             MOV      R0,SP
   \   000002AE   0x.... 0x....      BL       strcpy
    487                    // Send string to UART..
    488          #ifdef REV_L
    489                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000002B2   0x4669             MOV      R1,SP
   \   000002B4   0x2000             MOVS     R0,#+0
   \   000002B6   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000002BA   0x0004             MOVS     R4,R0
    490                    // Wait for msg to be completed.
    491                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_24: (+1)
   \   000002BC   0x2000             MOVS     R0,#+0
   \   000002BE   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000002C2   0x2801             CMP      R0,#+1
   \   000002C4   0xD002             BEQ.N    ??main_25
    492                    {
    493                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   000002C6   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   000002CA   0xE7F7             B.N      ??main_24
    494                    }
    495                    // Clear State for Next Transfer.
    496                    clrUsartState( MONITOR_UART );
   \                     ??main_25: (+1)
   \   000002CC   0x2000             MOVS     R0,#+0
   \   000002CE   0x.... 0x....      BL       clrUsartState
    497          #else
    498                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    499                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    500          #endif
    501                    if (Status != HAL_OK)
   \   000002D2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D4   0x2C00             CMP      R4,#+0
   \   000002D6   0xD001             BEQ.N    ??main_26
    502                      Error_Handler();
   \   000002D8   0x.... 0x....      BL       Error_Handler
    503                    sprintf( (char *)tempBffr2, "     Road Board Monitor %s Hardware Version %s \r\n", VERSION_NUM, BRD_REV);
   \                     ??main_26: (+1)
   \   000002DC   0x.... 0x....      LDR.W    R3,??DataTable1_2
   \   000002E0   0x.... 0x....      LDR.W    R2,??DataTable1_3
   \   000002E4   0x.... 0x....      LDR.W    R1,??DataTable1_4
   \   000002E8   0x4668             MOV      R0,SP
   \   000002EA   0x.... 0x....      BL       sprintf
    504                    //strcpy( (char *)tempBffr2, "     Road Board Monitor Rev K Hardware Version 1.0 \r\n");
    505                    // Send string to UART..
    506          #ifdef REV_L
    507                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000002EE   0x4669             MOV      R1,SP
   \   000002F0   0x2000             MOVS     R0,#+0
   \   000002F2   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000002F6   0x0004             MOVS     R4,R0
    508                    // Wait for msg to be completed.
    509                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_27: (+1)
   \   000002F8   0x2000             MOVS     R0,#+0
   \   000002FA   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000002FE   0x2801             CMP      R0,#+1
   \   00000300   0xD002             BEQ.N    ??main_28
    510                    {
    511                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   00000302   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   00000306   0xE7F7             B.N      ??main_27
    512                    }
    513                    // Clear State for Next Transfer.
    514                    clrUsartState( MONITOR_UART );
   \                     ??main_28: (+1)
   \   00000308   0x2000             MOVS     R0,#+0
   \   0000030A   0x.... 0x....      BL       clrUsartState
    515          #else
    516                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    517                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    518          #endif
    519                    if (Status != HAL_OK)
   \   0000030E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000310   0x2C00             CMP      R4,#+0
   \   00000312   0xD001             BEQ.N    ??main_29
    520                      Error_Handler();
   \   00000314   0x.... 0x....      BL       Error_Handler
    521                    sprintf( (char *)tempBffr2, "                  Copyright %s. \r\n\r\n", REL_DATE);
   \                     ??main_29: (+1)
   \   00000318   0x.... 0x....      LDR.W    R2,??DataTable1_5
   \   0000031C   0x.... 0x....      LDR.W    R1,??DataTable1_6
   \   00000320   0x4668             MOV      R0,SP
   \   00000322   0x.... 0x....      BL       sprintf
    522                    //strcpy( (char *)tempBffr2, "                  Copyright August 9, 2016. \r\n\r\n\r\n> ");
    523                    // Send string to UART..
    524          #ifdef REV_L
    525                    Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   00000326   0x4669             MOV      R1,SP
   \   00000328   0x2000             MOVS     R0,#+0
   \   0000032A   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   0000032E   0x0004             MOVS     R4,R0
    526                    // Wait for msg to be completed.
    527                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_30: (+1)
   \   00000330   0x2000             MOVS     R0,#+0
   \   00000332   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000336   0x2801             CMP      R0,#+1
   \   00000338   0xD002             BEQ.N    ??main_31
    528                    {
    529                      RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   0000033A   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   \   0000033E   0xE7F7             B.N      ??main_30
    530                    }
    531                    // Clear State for Next Transfer.
    532                    clrUsartState( MONITOR_UART );
   \                     ??main_31: (+1)
   \   00000340   0x2000             MOVS     R0,#+0
   \   00000342   0x.... 0x....      BL       clrUsartState
    533          #else
    534                    Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    535                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
    536          #endif
    537                    if (Status != HAL_OK)
   \   00000346   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000348   0x2C00             CMP      R4,#+0
   \   0000034A   0xD001             BEQ.N    ??main_32
    538                      Error_Handler();
   \   0000034C   0x.... 0x....      BL       Error_Handler
    539                    // *******Time to Build Extra Information...
    540                    sprintf( (char *)tempBffr2, "RdSnd Sample Rate:  %3.1f Seconds.\r\n", ((float)RoadBrd_Get_RdSndTickCnt()/10));
   \                     ??main_32: (+1)
   \   00000350   0x.... 0x....      BL       RoadBrd_Get_RdSndTickCnt
   \   00000354   0x.... 0x....      BL       __aeabi_ui2f
   \   00000358   0x.... 0x....      LDR.W    R1,??DataTable1_7  ;; 0x41200000
   \   0000035C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000360   0x.... 0x....      BL       __aeabi_f2d
   \   00000364   0x0002             MOVS     R2,R0
   \   00000366   0x000B             MOVS     R3,R1
   \   00000368   0x.... 0x....      LDR.W    R1,??DataTable1_8
   \   0000036C   0x4668             MOV      R0,SP
   \   0000036E   0x.... 0x....      BL       sprintf
    541          #ifdef REV_L
    542                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   00000372   0x4669             MOV      R1,SP
   \   00000374   0x2000             MOVS     R0,#+0
   \   00000376   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   0000037A   0x0004             MOVS     R4,R0
    543                    // Wait for msg to be completed.
    544                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_33: (+1)
   \   0000037C   0x2000             MOVS     R0,#+0
   \   0000037E   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000382   0x2801             CMP      R0,#+1
   \   00000384   0xD1FA             BNE.N    ??main_33
    545                    {
    546                    }
    547                    // Clear State for Next Transfer.
    548                    clrUsartState( NUCLEO_USART );
   \   00000386   0x2000             MOVS     R0,#+0
   \   00000388   0x.... 0x....      BL       clrUsartState
    549          #else
    550                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    551          #endif
    552                    if (Status != HAL_OK)
   \   0000038C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000038E   0x2C00             CMP      R4,#+0
   \   00000390   0xD001             BEQ.N    ??main_34
    553                      Error_Handler();
   \   00000392   0x.... 0x....      BL       Error_Handler
    554                    sprintf( (char *)tempBffr2, "Sensor Sample Rate: %3.1f Seconds.\r\n", ((float)RoadBrd_Get_SnsrTickCnt()/10));
   \                     ??main_34: (+1)
   \   00000396   0x.... 0x....      BL       RoadBrd_Get_SnsrTickCnt
   \   0000039A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000039E   0x....             LDR.N    R1,??DataTable1_7  ;; 0x41200000
   \   000003A0   0x.... 0x....      BL       __aeabi_fdiv
   \   000003A4   0x.... 0x....      BL       __aeabi_f2d
   \   000003A8   0x0002             MOVS     R2,R0
   \   000003AA   0x000B             MOVS     R3,R1
   \   000003AC   0x....             LDR.N    R1,??DataTable1_9
   \   000003AE   0x4668             MOV      R0,SP
   \   000003B0   0x.... 0x....      BL       sprintf
    555          #ifdef REV_L
    556                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   000003B4   0x4669             MOV      R1,SP
   \   000003B6   0x2000             MOVS     R0,#+0
   \   000003B8   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000003BC   0x0004             MOVS     R4,R0
    557                    // Wait for msg to be completed.
    558                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_35: (+1)
   \   000003BE   0x2000             MOVS     R0,#+0
   \   000003C0   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000003C4   0x2801             CMP      R0,#+1
   \   000003C6   0xD1FA             BNE.N    ??main_35
    559                    {
    560                    }
    561                    // Clear State for Next Transfer.
    562                    clrUsartState( NUCLEO_USART );
   \   000003C8   0x2000             MOVS     R0,#+0
   \   000003CA   0x.... 0x....      BL       clrUsartState
    563          #else
    564                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    565          #endif
    566                    if (Status != HAL_OK)
   \   000003CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003D0   0x2C00             CMP      R4,#+0
   \   000003D2   0xD001             BEQ.N    ??main_36
    567                      Error_Handler();
   \   000003D4   0x.... 0x....      BL       Error_Handler
    568                    sprintf( (char *)tempBffr2, "TACK Limit: %d.\r\n", RoadBrd_Get_TackLimit() );
   \                     ??main_36: (+1)
   \   000003D8   0x.... 0x....      BL       RoadBrd_Get_TackLimit
   \   000003DC   0x0002             MOVS     R2,R0
   \   000003DE   0x....             LDR.N    R1,??DataTable1_10
   \   000003E0   0x4668             MOV      R0,SP
   \   000003E2   0x.... 0x....      BL       sprintf
    569          #ifdef REV_L
    570                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   000003E6   0x4669             MOV      R1,SP
   \   000003E8   0x2000             MOVS     R0,#+0
   \   000003EA   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000003EE   0x0004             MOVS     R4,R0
    571                    // Wait for msg to be completed.
    572                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_37: (+1)
   \   000003F0   0x2000             MOVS     R0,#+0
   \   000003F2   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000003F6   0x2801             CMP      R0,#+1
   \   000003F8   0xD1FA             BNE.N    ??main_37
    573                    {
    574                    }
    575                    // Clear State for Next Transfer.
    576                    clrUsartState( NUCLEO_USART );
   \   000003FA   0x2000             MOVS     R0,#+0
   \   000003FC   0x.... 0x....      BL       clrUsartState
    577          #else
    578                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    579          #endif
    580                    if (Status != HAL_OK)
   \   00000400   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000402   0x2C00             CMP      R4,#+0
   \   00000404   0xD001             BEQ.N    ??main_38
    581                      Error_Handler();
   \   00000406   0x.... 0x....      BL       Error_Handler
    582                    sprintf( (char *)tempBffr2, "Boot Delay: %d Seconds.\r\n", RoadBrd_Get_BootDelay() );
   \                     ??main_38: (+1)
   \   0000040A   0x.... 0x....      BL       RoadBrd_Get_BootDelay
   \   0000040E   0x0002             MOVS     R2,R0
   \   00000410   0x....             LDR.N    R1,??DataTable1_11
   \   00000412   0x4668             MOV      R0,SP
   \   00000414   0x.... 0x....      BL       sprintf
    583          #ifdef REV_L
    584                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \   00000418   0x4669             MOV      R1,SP
   \   0000041A   0x2000             MOVS     R0,#+0
   \   0000041C   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   00000420   0x0004             MOVS     R4,R0
    585                    // Wait for msg to be completed.
    586                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_39: (+1)
   \   00000422   0x2000             MOVS     R0,#+0
   \   00000424   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000428   0x2801             CMP      R0,#+1
   \   0000042A   0xD1FA             BNE.N    ??main_39
    587                    {
    588                    }
    589                    // Clear State for Next Transfer.
    590                    clrUsartState( NUCLEO_USART );
   \   0000042C   0x2000             MOVS     R0,#+0
   \   0000042E   0x.... 0x....      BL       clrUsartState
    591          #else
    592                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    593          #endif
    594                    if (Status != HAL_OK)
   \   00000432   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000434   0x2C00             CMP      R4,#+0
   \   00000436   0xD001             BEQ.N    ??main_40
    595                      Error_Handler();
   \   00000438   0x.... 0x....      BL       Error_Handler
    596                    // Now Display the Units Enabled State.
    597                    if (RoadBrd_Get_UnitsFlag())
   \                     ??main_40: (+1)
   \   0000043C   0x.... 0x....      BL       RoadBrd_Get_UnitsFlag
   \   00000440   0x2800             CMP      R0,#+0
   \   00000442   0xD004             BEQ.N    ??main_41
    598                    {
    599                      sprintf( (char *)tempBffr2, "Units XML State: ENABLED\r\n\r\n> ");
   \   00000444   0x....             LDR.N    R1,??DataTable1_12
   \   00000446   0x4668             MOV      R0,SP
   \   00000448   0x.... 0x....      BL       sprintf
   \   0000044C   0xE003             B.N      ??main_42
    600                    }
    601                    else
    602                    {
    603                      sprintf( (char *)tempBffr2, "Units XML State: DISABLED\r\n\r\n> ");
   \                     ??main_41: (+1)
   \   0000044E   0x....             LDR.N    R1,??DataTable1_13
   \   00000450   0x4668             MOV      R0,SP
   \   00000452   0x.... 0x....      BL       sprintf
    604                    }
    605          #ifdef REV_L
    606                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
   \                     ??main_42: (+1)
   \   00000456   0x4669             MOV      R1,SP
   \   00000458   0x2000             MOVS     R0,#+0
   \   0000045A   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   0000045E   0x0004             MOVS     R4,R0
    607                    // Wait for msg to be completed.
    608                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
   \                     ??main_43: (+1)
   \   00000460   0x2000             MOVS     R0,#+0
   \   00000462   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000466   0x2801             CMP      R0,#+1
   \   00000468   0xD1FA             BNE.N    ??main_43
    609                    {
    610                    }
    611                    // Clear State for Next Transfer.
    612                    clrUsartState( NUCLEO_USART );
   \   0000046A   0x2000             MOVS     R0,#+0
   \   0000046C   0x.... 0x....      BL       clrUsartState
    613          #else
    614                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    615          #endif
    616                    if (Status != HAL_OK)
   \   00000470   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000472   0x2C00             CMP      R4,#+0
   \   00000474   0xD001             BEQ.N    ??main_44
    617                      Error_Handler();
   \   00000476   0x.... 0x....      BL       Error_Handler
    618          #ifdef BUG_ENABLE
    619                    SCB->CCR |= 0x10;
    620                    int a = 10;
    621                    int b = 0;
    622                    int c;
    623                    c = a/b;
    624                    sprintf( (char *)tempBffr2, "Bug Value Dump: %d\r\n\r\n> ",c);
    625            #ifdef REV_L
    626                    Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    627                    // Wait for msg to be completed.
    628                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    629                    {
    630                    }
    631                    // Clear State for Next Transfer.
    632                    clrUsartState( NUCLEO_USART );
    633            #else
    634                    Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    635            #endif
    636          #endif          
    637                 #endif
    638          //      #endif
    639              #endif
    640            #endif
    641            while (1)
    642            {
    643            /* USER CODE END WHILE */
    644          
    645            /* USER CODE BEGIN 3 */
    646            /****************************************************************************
    647              * TEST CODE....Blinks LEDs for both Road Board and Nucleo Board.
    648              **************************************************************************/
    649            #ifdef TEST
    650              #ifdef NUCLEO
    651                // Turn On NUCLEO_LED_GREEN LED.
    652                RoadBrd_gpio_On( NUCLEO_LED_GREEN );
    653                // Wait 500msec.
    654                RoadBrd_Delay( 500 );
    655                // Turn Off NUCLEO_LED_GREEN LED.
    656                RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    657              #else
    658                // Turn On Blue LED and turn off Yellow LED.
    659                RoadBrd_gpio_On( BLUE_LED );
    660                RoadBrd_gpio_Off( YELLOW_LED );
    661                // Wait 500msec.
    662                RoadBrd_Delay( 500 );
    663                // Turn On Green LED and turn off Blue LED.
    664                RoadBrd_gpio_On( GREEN_LED );
    665                RoadBrd_gpio_Off( BLUE_LED );
    666                // Wait 500msec.
    667                RoadBrd_Delay( 500 );
    668                // Turn On Yellow LED and turn off Green LED.
    669                RoadBrd_gpio_On( YELLOW_LED );
    670                RoadBrd_gpio_Off( GREEN_LED );
    671              #endif
    672              // Wait 500msec.
    673              RoadBrd_Delay( 500 );
    674            //******************Endif TEST
    675            #else
    676            //******************Else TEST
    677          
    678            /****************************************************************************
    679             * TEST2 CODE....Reads COM port and translates back to sender. Simple COMM test.
    680             **************************************************************************/
    681              #ifdef TEST2
    682                #ifdef NUCLEO
    683                  // Turn Off NUCLEO_LED_GREEN LED.
    684                  RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    685                  // Wait on a character from Nucleo COM Port.
    686          #ifdef REV_L
    687                  Status = RoadBrd_UART_Receive_IT(NUCLEO_USART, tempBffr, 1);
    688                  // Wait for msg to be completed.
    689                  while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    690                  {
    691                  }
    692                  // Clear State for Next Transfer.
    693                  clrUsartState( NUCLEO_USART );
    694          #else
    695                  Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, 1);
    696          #endif
    697                  // Turn On NUCLEO_LED_GREEN LED.
    698                  RoadBrd_gpio_On( NUCLEO_LED_GREEN );
    699                  switch(  Status)
    700                  {
    701                    case HAL_OK:
    702                      // We have a good character. Time to build a response string.
    703                      tempBffr2[0] = '(';
    704                      tempBffr2[1] = tempBffr[0];
    705                      tempBffr2[2] = ')';
    706                      tempBffr2[3] = 0x00;
    707                      // Send string to UART..
    708          #ifdef REV_L
    709                      Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    710                      // Wait for msg to be completed.
    711                      while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    712                      {
    713                      }
    714                      // Clear State for Next Transfer.
    715                      clrUsartState( NUCLEO_USART );
    716          #else
    717                      Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    718          #endif
    719                      if (Status != HAL_OK)
    720                        Error_Handler();
    721                      /*Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    722                      if (Status != HAL_OK)
    723                        Error_Handler();
    724                      // Now wait for completion of Transmit
    725                      PStatus = RESET;
    726                      while (PStatus == RESET)
    727                      {
    728                        PStatus = RoadBrd_Uart_Status(NUCLEO_USART);
    729                      } */
    730                      break;
    731                    case HAL_ERROR:
    732                      // ERROR. We are done.
    733                      Error_Handler();
    734                      break;
    735                    case HAL_BUSY:
    736                      // ERROR. We are done.
    737                      Error_Handler();
    738                      break;
    739                    case HAL_TIMEOUT:
    740                      // Nothing to do. Try again.
    741                      break;
    742                    default:
    743                      // ERROR. We are done.
    744                      Error_Handler();
    745                      break;
    746                    
    747                  }
    748                // Wait 500msec.
    749                RoadBrd_Delay( 50 );
    750                #else
    751                  // Turn Off BGM_LED LED.
    752                  RoadBrd_gpio_Off( BGM_LED );
    753                  // Wait on a character from Nucleo COM Port.
    754           #ifdef REV_L
    755                  Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, 1);
    756                  // Wait for msg to be completed.
    757                  while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    758                  {
    759                  }
    760                  // Clear State for Next Transfer.
    761                  clrUsartState( MONITOR_UART );
    762          #else
    763                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, 1);
    764          #endif
    765                  // Turn On BGM_LED LED.
    766                  RoadBrd_gpio_On( BGM_LED );
    767                  switch(  Status)
    768                  {
    769                    case HAL_OK:
    770                      // We have a good character. Time to build a response string.
    771                      tempBffr2[0] = '(';
    772                      tempBffr2[1] = tempBffr[0];
    773                      tempBffr2[2] = ')';
    774                      tempBffr2[3] = 0x00;
    775                      // Send string to UART..
    776          #ifdef REV_L
    777                      Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
    778                      // Wait for msg to be completed.
    779                      while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    780                      {
    781                      }
    782                      // Clear State for Next Transfer.
    783                      clrUsartState( MONITOR_UART );
    784          #else
    785                      Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    786          #endif
    787                      if (Status != HAL_OK)
    788                        Error_Handler();
    789                      /*Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    790                      if (Status != HAL_OK)
    791                        Error_Handler();
    792                      // Now wait for completion of Transmit
    793                      PStatus = RESET;
    794                      while (PStatus == RESET)
    795                      {
    796                        PStatus = RoadBrd_Uart_Status(NUCLEO_USART);
    797                      } */
    798                      break;
    799                    case HAL_ERROR:
    800                      // ERROR. We are done.
    801                      Error_Handler();
    802                      break;
    803                    case HAL_BUSY:
    804                      // ERROR. We are done.
    805                      Error_Handler();
    806                      break;
    807                    case HAL_TIMEOUT:
    808                      // Nothing to do. Try again.
    809                      break;
    810                    default:
    811                      // ERROR. We are done.
    812                      Error_Handler();
    813                      break;
    814                    
    815                  }
    816                // Wait 500msec.
    817                RoadBrd_Delay( 50 );
    818                #endif
    819              //******************Endif TEST2
    820              #else
    821              //******************Else TEST2
    822            /*****************************************************************************
    823             *    NORMAL FLOW HERE
    824             ****************************************************************************/
    825          //         RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    826          //         Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, 1);
    827                #ifdef NUCLEO
    828                
    829                //************************* NUCLEO VERSION *************************************   
    830                   // Turn Off NUCLEO_LED_GREEN LED.
    831                  RoadBrd_gpio_Off( NUCLEO_LED_GREEN );
    832                  // Wait on a character from Nucleo COM Port.
    833          #ifdef REV_L
    834                  tmpSize = Size;
    835                  pData = tempBffr;
    836                  while ( tmpSize>0 )
    837                  {
    838                    Status = RoadBrd_UART_Receive_IT(NUCLEO_USART, tempBffr, RECEIVE_SZ);
    839                    // Wait for msg to be completed.
    840                    while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    841                    {
    842                    }
    843                    // Clear State for Next Transfer.
    844                    clrUsartState( NUCLEO_USART );
    845                    if(Status == HAL_OK)
    846                    {
    847                      // Watch for termination characters.
    848                      if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
    849                      {
    850                        *pData = 0x00;
    851                        // Yes..We are done.
    852                        return Status;
    853                      }
    854                      else
    855                      {
    856                        // Move new character into passed buffer.
    857                        *pData = tmpData[0];
    858                        tmpSize--;                          // Decrement Count
    859                        pData++;                            // Move pointer to next buffer location.
    860                      }
    861                    }
    862                    else
    863                      Error_Handler();
    864                  } // EndWhile ( tmpSize>0 )
    865          #else
    866                  Status = RoadBrd_UART_Receive(NUCLEO_USART, tempBffr, RECEIVE_SZ);
    867          #endif
    868                  // Turn On NUCLEO_LED_GREEN LED.
    869          #ifndef LED_OFF
    870                  RoadBrd_gpio_On( NUCLEO_LED_GREEN );
    871          #endif
    872          #ifdef ASCII
    873                  // Send <CR><LF> to UART..
    874                  strcpy( (char *)tempBffr2, "\r\n");
    875          #ifdef REV_L
    876                      Status = RoadBrd_UART_Transmit_IT(NUCLEO_USART, (uint8_t *)tempBffr2);
    877                      // Wait for msg to be completed.
    878                      while (RoadBrd_Uart_Status(NUCLEO_USART) != SET)
    879                      {
    880                      }
    881                      // Clear State for Next Transfer.
    882                      clrUsartState( NUCLEO_USART );
    883          #else
    884                  Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
    885          #endif
    886                  if (Status != HAL_OK)
    887                    Error_Handler();
    888          #endif
    889                  switch(  Status )
    890                  {
    891                    case HAL_OK:
    892                      Status = RoadBrd_ParseString((char *)tempBffr);
    893                      // We have a good Tasking String. Time to determine action.
    894                      if (Status != HAL_OK)
    895                        Error_Handler();
    896                      
    897                      break;
    898                    case HAL_ERROR:
    899                      // ERROR. We are done.
    900                      Error_Handler();
    901                      break;
    902                    case HAL_BUSY:
    903                      // ERROR. We are done.
    904                      Error_Handler();
    905                      break;
    906                    case HAL_TIMEOUT:
    907                      // Nothing to do. Try again.
    908                      break;
    909                    default:
    910                      // ERROR. We are done.
    911                      Error_Handler();
    912                      break;
    913                  }
    914                // Wait 500msec.
    915                RoadBrd_Delay( 50 );
    916                //************************* END NUCLEO VERSION *************************************   
    917                
    918                #else
    919          
    920                //************************* ROAD BRD VERSION *************************************   
    921                  // Wait on a character from Nucleo COM Port.
    922          //********************PATCH_UART ACTIVE*******************************************
    923          #ifdef PATCH_UART
    924          #ifdef REV_L
    925                  // Turn Off MICRO_LED LED.
    926                  RoadBrd_gpio_Off( MICRO_LED );
    927                  tmpSize = RECEIVE_SZ;
    928                  pData = tempBffr;
    929                  while ( tmpSize>0 )
    930                  {
    931                    Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
    932                    // Wait for msg to be completed.
    933                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
    934                    {
    935                     }
    936                    // Clear State for Next Transfer.
    937                    clrUsartState( MONITOR_UART );
    938                    if(Status == HAL_OK)
    939                    {
    940                      // Watch for termination characters.
    941                      if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
    942                      {
    943                        *pData = 0x00;
    944                        // Yes..We are done.
    945                        break;
    946                      }
    947                      else
    948                      {
    949                        // Move new character into passed buffer.
    950                        *pData = tmpData[0];
    951                        tmpSize--;                          // Decrement Count
    952                        pData++;                            // Move pointer to next buffer location.
    953                      }
    954                    }
    955                    else
    956                      Error_Handler();
    957                  } // EndWhile ( tmpSize>0 )
    958          #ifndef LED_OFF
    959                  RoadBrd_gpio_On( MICRO_LED );
    960          #endif
    961                  // Send <CR><LF> to UART..
    962                  strcpy( (char *)tempBffr2, "\r\n");
    963                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
    964                  if (Status != HAL_OK)
    965                    Error_Handler();
    966                  switch(  Status )
    967                  {
    968                    case HAL_OK:
    969                      // We have a good Tasking String. Time to determine action.
    970                      Status = RoadBrd_ParseString((char *)tempBffr);
    971                      // We have a good Tasking String. Time to determine action.
    972                      if (Status != HAL_OK)
    973                        Error_Handler();
    974                      break;
    975                    case HAL_ERROR:
    976                      // ERROR. We are done.
    977                      Error_Handler();
    978                      break;
    979                    case HAL_BUSY:
    980                      // ERROR. We are done.
    981                      Error_Handler();
    982                      break;
    983                    case HAL_TIMEOUT:
    984                      // Nothing to do. Try again.
    985                      break;
    986                    default:
    987                      // ERROR. We are done.
    988                      Error_Handler();
    989                      break;
    990                    
    991                  } // EndSwitch (  Status )
    992          #else
    993                  // Turn Off BGM_LED LED.
    994                  RoadBrd_gpio_Off( MICRO_LED );
    995                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, RECEIVE_SZ);
    996                  // Process Buffer Now.
    997                  // Turn On BGM_LED LED.
    998          #ifndef LED_OFF
    999                  RoadBrd_gpio_On( MICRO_LED );
   1000          #endif
   1001                  // Send <CR><LF> to UART..
   1002                  strcpy( (char *)tempBffr2, "\r\n");
   1003          #ifdef REV_L
   1004                      Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   1005                      // Wait for msg to be completed.
   1006                      while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   1007                      {
   1008                      }
   1009                      // Clear State for Next Transfer.
   1010                      clrUsartState( MONITOR_UART );
   1011          #else
   1012                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   1013          #endif
   1014                  if (Status != HAL_OK)
   1015                    Error_Handler();
   1016                  switch(  Status )
   1017                  {
   1018                    case HAL_OK:
   1019                      // We have a good Tasking String. Time to determine action.
   1020                      Status = RoadBrd_ParseString((char *)tempBffr, false);
   1021                      // We have a good Tasking String. Time to determine action.
   1022                      if (Status != HAL_OK)
   1023                        Error_Handler();
   1024                      break;
   1025                    case HAL_ERROR:
   1026                      // ERROR. We are done.
   1027                      Error_Handler();
   1028                      break;
   1029                    case HAL_BUSY:
   1030                      // ERROR. We are done.
   1031                      Error_Handler();
   1032                      break;
   1033                    case HAL_TIMEOUT:
   1034                      // Nothing to do. Try again.
   1035                      break;
   1036                    default:
   1037                      // ERROR. We are done.
   1038                      Error_Handler();
   1039                      break;
   1040                    
   1041                  } // EndSwitch (  Status )
   1042          #endif
   1043          //********************END PATCH_UART ACTIVE*******************************************
   1044          #else
   1045          //********************PATCH_UART NOT ACTIVE*******************************************
   1046          #ifdef REV_L
   1047                    /* Process BLE input */
   1048                    BGM111_ProcessInput();
   \                     ??main_44: (+1)
   \   0000047A   0x.... 0x....      BL       BGM111_ProcessInput
   1049                  
   1050                    // Process Timer Stimulus for Timer 2.
   1051                    Status = Proc_Timer2();
   \   0000047E   0x.... 0x....      BL       Proc_Timer2
   \   00000482   0x0004             MOVS     R4,R0
   1052                    if(Status != HAL_OK)
   \   00000484   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000486   0x2C00             CMP      R4,#+0
   \   00000488   0xD00D             BEQ.N    ??main_45
   1053                    {
   1054                      strcpy( (char *)tempBffr2, "BGM111_ProcessInput ERROR: Sensors reported Background error.\r\n");
   \   0000048A   0x....             LDR.N    R1,??DataTable1_14
   \   0000048C   0x4668             MOV      R0,SP
   \   0000048E   0x.... 0x....      BL       strcpy
   1055          #ifdef NUCLEO
   1056                      Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
   1057          #else
   1058                      Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);                   
   \   00000492   0x4669             MOV      R1,SP
   \   00000494   0x2000             MOVS     R0,#+0
   \   00000496   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   0000049A   0x0004             MOVS     R4,R0
   1059          #endif
   1060                      if (Status != HAL_OK)
   \   0000049C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000049E   0x2C00             CMP      R4,#+0
   \   000004A0   0xD001             BEQ.N    ??main_45
   1061                        Error_Handler();
   \   000004A2   0x.... 0x....      BL       Error_Handler
   1062                    }
   1063                    // Process any Outstanding Parse Tasks.
   1064                    RoadBrd_ProcessParserTsk();
   \                     ??main_45: (+1)
   \   000004A6   0x.... 0x....      BL       RoadBrd_ProcessParserTsk
   1065                    
   1066                    // Test to process CMD mode.
   1067                    Process_CmdMode();
   \   000004AA   0x.... 0x....      BL       Process_CmdMode
   1068                    
   1069                    /* Process the sensor state machine if the BLE module is ready */
   1070                      if ((BGM111_Ready()) &&
   1071                          (BGM111_Connected()) &&
   1072                          (BGM111_DataConnected()) &&
   1073                          (BGM111_SyncModeTest()) )
   \   000004AE   0x.... 0x....      BL       BGM111_Ready
   \   000004B2   0x2800             CMP      R0,#+0
   \   000004B4   0xD00F             BEQ.N    ??main_46
   \   000004B6   0x.... 0x....      BL       BGM111_Connected
   \   000004BA   0x2800             CMP      R0,#+0
   \   000004BC   0xD00B             BEQ.N    ??main_46
   \   000004BE   0x.... 0x....      BL       BGM111_DataConnected
   \   000004C2   0x2800             CMP      R0,#+0
   \   000004C4   0xD007             BEQ.N    ??main_46
   \   000004C6   0x.... 0x....      BL       BGM111_SyncModeTest
   \   000004CA   0x2800             CMP      R0,#+0
   \   000004CC   0xD003             BEQ.N    ??main_46
   1074                    {
   1075                      ProcessSensorState();
   \   000004CE   0x.... 0x....      BL       ProcessSensorState
   1076                      Process_RdSound();
   \   000004D2   0x.... 0x....      BL       Process_RdSound
   1077                    }
   1078                    /* Sleep when we have nothing to process */
   1079                    //PWR_EnterSleepMode(PWR_Regulator_ON, PWR_SLEEPEntry_WFI);
   1080                    // Only Process the first Time
   1081                    if (firstTime)
   \                     ??main_46: (+1)
   \   000004D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004D8   0x2D00             CMP      R5,#+0
   \   000004DA   0xD00E             BEQ.N    ??main_47
   1082                    {
   1083                      firstTime = false;
   \   000004DC   0x2000             MOVS     R0,#+0
   \   000004DE   0x0005             MOVS     R5,R0
   1084                      Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
   \   000004E0   0x227D             MOVS     R2,#+125
   \   000004E2   0xA91A             ADD      R1,SP,#+104
   \   000004E4   0x2000             MOVS     R0,#+0
   \   000004E6   0x.... 0x....      BL       RoadBrd_UART_Receive_IT
   \   000004EA   0x0004             MOVS     R4,R0
   1085                      // Enable BGM Serial Traffic.
   1086                      HAL_UART_EnableBGM_RX();
   \   000004EC   0x.... 0x....      BL       HAL_UART_EnableBGM_RX
   1087                      RoadBrd_SetBffrFlg();
   \   000004F0   0x.... 0x....      BL       RoadBrd_SetBffrFlg
   1088                      // Clear bffrFlag..Only Processing one character.
   1089          //            bffrFlag = false;
   1090                      // Turn Off BGM_LED and MICRO_LED.
   1091                      RoadBrd_gpio_Off( MICRO_LED );
   \   000004F4   0x2002             MOVS     R0,#+2
   \   000004F6   0x.... 0x....      BL       RoadBrd_gpio_Off
   1092                    }
   1093                    // Service Watchdog
   1094                    RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \                     ??main_47: (+1)
   \   000004FA   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   1095                    // Wait for msg to be completed.
   1096                    while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_48: (+1)
   \   000004FE   0x2000             MOVS     R0,#+0
   \   00000500   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   00000504   0x2801             CMP      R0,#+1
   \   00000506   0xD02E             BEQ.N    ??main_49
   1097                    {
   1098                      // Process Timer Stimulus for Timer 2.
   1099                      Status = Proc_Timer2();
   \   00000508   0x.... 0x....      BL       Proc_Timer2
   \   0000050C   0x0004             MOVS     R4,R0
   1100                      if(Status != HAL_OK)
   \   0000050E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000510   0x2C00             CMP      R4,#+0
   \   00000512   0xD00D             BEQ.N    ??main_50
   1101                      {
   1102                        strcpy( (char *)tempBffr2, "BGM111_ProcessInput ERROR: Sensors reported Background error.\r\n");
   \   00000514   0x....             LDR.N    R1,??DataTable1_14
   \   00000516   0x4668             MOV      R0,SP
   \   00000518   0x.... 0x....      BL       strcpy
   1103          #ifdef NUCLEO
   1104                        Status = RoadBrd_UART_Transmit(NUCLEO_USART, (uint8_t *)tempBffr2);
   1105          #else
   1106                        Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);                   
   \   0000051C   0x4669             MOV      R1,SP
   \   0000051E   0x2000             MOVS     R0,#+0
   \   00000520   0x.... 0x....      BL       RoadBrd_UART_Transmit
   \   00000524   0x0004             MOVS     R4,R0
   1107          #endif
   1108                        if (Status != HAL_OK)
   \   00000526   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000528   0x2C00             CMP      R4,#+0
   \   0000052A   0xD001             BEQ.N    ??main_50
   1109                          Error_Handler();
   \   0000052C   0x.... 0x....      BL       Error_Handler
   1110                      }
   1111                      // Process any Outstanding Parse Tasks.
   1112                      RoadBrd_ProcessParserTsk();
   \                     ??main_50: (+1)
   \   00000530   0x.... 0x....      BL       RoadBrd_ProcessParserTsk
   1113                      
   1114                      // Test to process CMD mode.
   1115                      Process_CmdMode();
   \   00000534   0x.... 0x....      BL       Process_CmdMode
   1116                      
   1117                      /* Process the sensor state machine if the BLE module is ready */
   1118                      if ((BGM111_Ready()) &&
   1119                          (BGM111_Connected()) &&
   1120                          (BGM111_DataConnected()) &&
   1121                          (BGM111_SyncModeTest()) )
   \   00000538   0x.... 0x....      BL       BGM111_Ready
   \   0000053C   0x2800             CMP      R0,#+0
   \   0000053E   0xD0DE             BEQ.N    ??main_48
   \   00000540   0x.... 0x....      BL       BGM111_Connected
   \   00000544   0x2800             CMP      R0,#+0
   \   00000546   0xD0DA             BEQ.N    ??main_48
   \   00000548   0x.... 0x....      BL       BGM111_DataConnected
   \   0000054C   0x2800             CMP      R0,#+0
   \   0000054E   0xD0D6             BEQ.N    ??main_48
   \   00000550   0x.... 0x....      BL       BGM111_SyncModeTest
   \   00000554   0x2800             CMP      R0,#+0
   \   00000556   0xD0D2             BEQ.N    ??main_48
   1122                      {
   1123                        // Service Watchdog
   1124                        RoadBrd_WWDG_Refresh();     // Refresh WatchDog
   \   00000558   0x.... 0x....      BL       RoadBrd_WWDG_Refresh
   1125                        ProcessSensorState();
   \   0000055C   0x.... 0x....      BL       ProcessSensorState
   1126                        Process_RdSound();
   \   00000560   0x.... 0x....      BL       Process_RdSound
   \   00000564   0xE7CB             B.N      ??main_48
   1127                      }
   1128                      // Test to see if we have any BGM Traffic to process.
   1129                      //BGM111_ProcessInput();
   1130                    }
   1131                    // Test if BGM or Monitor Character received.
   1132                    if (RoadBrd_Uart_Status(MONITOR_UART) == SET)
   \                     ??main_49: (+1)
   \   00000566   0x2000             MOVS     R0,#+0
   \   00000568   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   0000056C   0x2801             CMP      R0,#+1
   \   0000056E   0xD15E             BNE.N    ??main_51
   1133                    {
   1134                      // Clear State for Next Transfer.
   1135                      clrUsartState( MONITOR_UART );
   \   00000570   0x2000             MOVS     R0,#+0
   \   00000572   0x.... 0x....      BL       clrUsartState
   1136                      if(Status == HAL_OK)
   \   00000576   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000578   0x2C00             CMP      R4,#+0
   \   0000057A   0xD14D             BNE.N    ??main_52
   1137                      {
   1138          //***** START HERE
   1139                        // Test Boot Monitor Flag...If Set, we ae in special Boot monitor mode.
   1140                        if (Tst_Boot_Bypass())
   \   0000057C   0x.... 0x....      BL       Tst_Boot_Bypass
   \   00000580   0x2800             CMP      R0,#+0
   \   00000582   0xD00D             BEQ.N    ??main_53
   1141                        {
   1142                          // We have a good Tasking String. Time to determine action.
   1143                          // Turn On BGM_LED LED.
   1144            #ifndef LED_OFF
   1145                          RoadBrd_gpio_On( GREEN_LED );
   \   00000584   0x2002             MOVS     R0,#+2
   \   00000586   0x.... 0x....      BL       RoadBrd_gpio_On
   1146            #endif
   1147                          Status = Parse_BootString((char *)tempBffr, false);
   \   0000058A   0x2100             MOVS     R1,#+0
   \   0000058C   0xA81A             ADD      R0,SP,#+104
   \   0000058E   0x.... 0x....      BL       Parse_BootString
   \   00000592   0x0004             MOVS     R4,R0
   1148                          // We have a good Tasking String. Time to determine action.
   1149                          if (Status != HAL_OK)
   \   00000594   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000596   0x2C00             CMP      R4,#+0
   \   00000598   0xD040             BEQ.N    ??main_54
   1150                            Error_Handler();
   \   0000059A   0x.... 0x....      BL       Error_Handler
   \   0000059E   0xE03D             B.N      ??main_54
   1151                        } // EndIf (Tst_Bypass())
   1152                        // Test Bypass Flag...If Set, we ae in special monitor mode.
   1153                        else if (Tst_Bypass())
   \                     ??main_53: (+1)
   \   000005A0   0x.... 0x....      BL       Tst_Bypass
   \   000005A4   0x2800             CMP      R0,#+0
   \   000005A6   0xD00D             BEQ.N    ??main_55
   1154                        {
   1155                          // We have a good Tasking String. Time to determine action.
   1156                          // Turn On BGM_LED LED.
   1157            #ifndef LED_OFF
   1158                          RoadBrd_gpio_On( GREEN_LED );
   \   000005A8   0x2002             MOVS     R0,#+2
   \   000005AA   0x.... 0x....      BL       RoadBrd_gpio_On
   1159            #endif
   1160                          Status = RoadBrd_ParseString((char *)tempBffr, false);
   \   000005AE   0x2100             MOVS     R1,#+0
   \   000005B0   0xA81A             ADD      R0,SP,#+104
   \   000005B2   0x.... 0x....      BL       RoadBrd_ParseString
   \   000005B6   0x0004             MOVS     R4,R0
   1161                          // We have a good Tasking String. Time to determine action.
   1162                          if (Status != HAL_OK)
   \   000005B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005BA   0x2C00             CMP      R4,#+0
   \   000005BC   0xD02E             BEQ.N    ??main_54
   1163                            Error_Handler();
   \   000005BE   0x.... 0x....      BL       Error_Handler
   \   000005C2   0xE02B             B.N      ??main_54
   1164                        } // EndIf (Tst_Bypass())
   1165                        else {
   1166                          // Yes..We are done.
   1167                          // Process Buffer NOW.
   1168                          // Send <CR><LF> to UART..
   1169                          strcpy( (char *)tempBffr2, "\r\n");
   \                     ??main_55: (+1)
   \   000005C4   0x....             ADR.N    R1,??DataTable1  ;; 0x0D, 0x0A, 0x00, 0x00
   \   000005C6   0x4668             MOV      R0,SP
   \   000005C8   0x.... 0x....      BL       strcpy
   1170                          Status = RoadBrd_UART_Transmit_IT(MONITOR_UART, (uint8_t *)tempBffr2);
   \   000005CC   0x4669             MOV      R1,SP
   \   000005CE   0x2000             MOVS     R0,#+0
   \   000005D0   0x.... 0x....      BL       RoadBrd_UART_Transmit_IT
   \   000005D4   0x0004             MOVS     R4,R0
   1171                          // Wait for msg to be completed.
   1172                          while (RoadBrd_Uart_Status(MONITOR_UART) != SET)
   \                     ??main_56: (+1)
   \   000005D6   0x2000             MOVS     R0,#+0
   \   000005D8   0x.... 0x....      BL       RoadBrd_Uart_Status
   \   000005DC   0x2801             CMP      R0,#+1
   \   000005DE   0xD1FA             BNE.N    ??main_56
   1173                          {
   1174                          }
   1175                          // Clear State for Next Transfer.
   1176                          clrUsartState( MONITOR_UART );
   \   000005E0   0x2000             MOVS     R0,#+0
   \   000005E2   0x.... 0x....      BL       clrUsartState
   1177                          if (Status != HAL_OK)
   \   000005E6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005E8   0x2C00             CMP      R4,#+0
   \   000005EA   0xD001             BEQ.N    ??main_57
   1178                            Error_Handler();
   \   000005EC   0x.... 0x....      BL       Error_Handler
   1179                          if(Status == HAL_OK)
   \                     ??main_57: (+1)
   \   000005F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005F2   0x2C00             CMP      R4,#+0
   \   000005F4   0xD10D             BNE.N    ??main_58
   1180                          {
   1181                            // We have a good Tasking String. Time to determine action.
   1182                            // Turn On BGM_LED LED.
   1183            #ifndef LED_OFF
   1184                            RoadBrd_gpio_On( GREEN_LED );
   \   000005F6   0x2002             MOVS     R0,#+2
   \   000005F8   0x.... 0x....      BL       RoadBrd_gpio_On
   1185            #endif
   1186                            Status = RoadBrd_ParseString((char *)tempBffr, false);
   \   000005FC   0x2100             MOVS     R1,#+0
   \   000005FE   0xA81A             ADD      R0,SP,#+104
   \   00000600   0x.... 0x....      BL       RoadBrd_ParseString
   \   00000604   0x0004             MOVS     R4,R0
   1187                            // We have a good Tasking String. Time to determine action.
   1188                            if (Status != HAL_OK)
   \   00000606   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000608   0x2C00             CMP      R4,#+0
   \   0000060A   0xD007             BEQ.N    ??main_54
   1189                              Error_Handler();
   \   0000060C   0x.... 0x....      BL       Error_Handler
   \   00000610   0xE004             B.N      ??main_54
   1190                          }
   1191                          else
   1192                            Error_Handler();
   \                     ??main_58: (+1)
   \   00000612   0x.... 0x....      BL       Error_Handler
   \   00000616   0xE001             B.N      ??main_54
   1193                        } // EndElse (Tst_Bypass())
   1194                      }
   1195          //***** END HERE
   1196                      else
   1197                        Error_Handler();
   \                     ??main_52: (+1)
   \   00000618   0x.... 0x....      BL       Error_Handler
   1198                    Status = RoadBrd_UART_Receive_IT(MONITOR_UART, tempBffr, RECEIVE_SZ);
   \                     ??main_54: (+1)
   \   0000061C   0x227D             MOVS     R2,#+125
   \   0000061E   0xA91A             ADD      R1,SP,#+104
   \   00000620   0x2000             MOVS     R0,#+0
   \   00000622   0x.... 0x....      BL       RoadBrd_UART_Receive_IT
   \   00000626   0x0004             MOVS     R4,R0
   1199                    // Turn Off MICRO_LED.
   1200                    RoadBrd_gpio_Off( MICRO_LED );
   \   00000628   0x2002             MOVS     R0,#+2
   \   0000062A   0x.... 0x....      BL       RoadBrd_gpio_Off
   1201                  } // EndIf (RoadBrd_Uart_Status(MONITOR_UART) == SET)
   1202          
   1203          #else
   1204                  // Turn Off BGM_LED LED.
   1205                  RoadBrd_gpio_Off( MICRO_LED );
   1206                  Status = RoadBrd_UART_Receive(MONITOR_UART, tempBffr, RECEIVE_SZ);
   1207                  // Turn On BGM_LED LED.
   1208          #ifndef LED_OFF
   1209                  RoadBrd_gpio_On( MICRO_LED );
   1210          #endif
   1211                  // Send <CR><LF> to UART..
   1212                  strcpy( (char *)tempBffr2, "\r\n");
   1213                  Status = RoadBrd_UART_Transmit(MONITOR_UART, (uint8_t *)tempBffr2);
   1214                  if (Status != HAL_OK)
   1215                    Error_Handler();
   1216                  switch(  Status )
   1217                  {
   1218                    case HAL_OK:
   1219                      // We have a good Tasking String. Time to determine action.
   1220                      Status = RoadBrd_ParseString((char *)tempBffr, false);
   1221                      // We have a good Tasking String. Time to determine action.
   1222                      if (Status != HAL_OK)
   1223                        Error_Handler();
   1224                      break;
   1225                    case HAL_ERROR:
   1226                      // ERROR. We are done.
   1227                      Error_Handler();
   1228                      break;
   1229                    case HAL_BUSY:
   1230                      // ERROR. We are done.
   1231                      Error_Handler();
   1232                      break;
   1233                    case HAL_TIMEOUT:
   1234                      // Nothing to do. Try again.
   1235                      break;
   1236                    default:
   1237                      // ERROR. We are done.
   1238                      Error_Handler();
   1239                      break;
   1240                    
   1241                  } // EndSwitch (  Status )
   1242          #endif
   1243          //********************END PATCH_UART NOT ACTIVE*******************************************
   1244          #endif
   1245                // Wait 50msec.
   1246                RoadBrd_Delay( 50 );
   \                     ??main_51: (+1)
   \   0000062E   0x2032             MOVS     R0,#+50
   \   00000630   0x.... 0x....      BL       RoadBrd_Delay
   \   00000634   0xE721             B.N      ??main_44
   1247                //************************* END Road BRD VERSION *************************************   
   1248                #endif
   1249            /*****************************************************************************
   1250             *    END NORMAL FLOW HERE
   1251             ****************************************************************************/
   1252              //******************EndElse TEST2
   1253              #endif
   1254          
   1255            //******************EndElse TEST
   1256            #endif
   1257            } // EndWhile (1)
   1258          //********************ENDIF TASKING
   1259          #endif
   1260            /* USER CODE END 3 */
   1261          
   1262          }
   1263          
   1264          /** System Clock Configuration
   1265          */

   \                                 In section .text, align 2, keep-with-next
   1266          void SystemClock_Config(void)
   1267          {
   \                     SystemClock_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   1268          
   1269            RCC_OscInitTypeDef RCC_OscInitStruct;
   1270            RCC_ClkInitTypeDef RCC_ClkInitStruct;
   1271          
   1272            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000004   0x....             LDR.N    R0,??DataTable1_15  ;; 0x40023824
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000C   0x....             LDR.N    R1,??DataTable1_15  ;; 0x40023824
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x....             LDR.N    R0,??DataTable1_15  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   1273          
   1274            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   \   0000001C   0x....             LDR.N    R0,??DataTable1_16  ;; 0x40007000
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x50C0      BICS     R0,R0,#0x1800
   \   00000024   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000028   0x....             LDR.N    R1,??DataTable1_16  ;; 0x40007000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1275          
   1276            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   1277            RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x9007             STR      R0,[SP, #+28]
   1278            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9009             STR      R0,[SP, #+36]
   1279            RCC_OscInitStruct.HSICalibrationValue = 16;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x900A             STR      R0,[SP, #+40]
   1280            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x900F             STR      R0,[SP, #+60]
   1281            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   \   00000040   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000044   0x9010             STR      R0,[SP, #+64]
   1282            RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
   \   00000046   0xF45F 0x1080      MOVS     R0,#+1048576
   \   0000004A   0x9011             STR      R0,[SP, #+68]
   1283            RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3;
   \   0000004C   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000050   0x9012             STR      R0,[SP, #+72]
   1284            if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \   00000052   0xA806             ADD      R0,SP,#+24
   \   00000054   0x.... 0x....      BL       HAL_RCC_OscConfig
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??SystemClock_Config_0
   1285            {
   1286              Error_Handler();
   \   0000005C   0x.... 0x....      BL       Error_Handler
   1287            }
   1288          
   1289            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1290                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   \                     ??SystemClock_Config_0: (+1)
   \   00000060   0x200F             MOVS     R0,#+15
   \   00000062   0x9001             STR      R0,[SP, #+4]
   1291            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x9002             STR      R0,[SP, #+8]
   1292            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9003             STR      R0,[SP, #+12]
   1293            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x9004             STR      R0,[SP, #+16]
   1294            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9005             STR      R0,[SP, #+20]
   1295            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x.... 0x....      BL       HAL_RCC_ClockConfig
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ.N    ??SystemClock_Config_1
   1296            {
   1297              Error_Handler();
   \   00000080   0x.... 0x....      BL       Error_Handler
   1298            }
   1299          
   1300            HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
   \                     ??SystemClock_Config_1: (+1)
   \   00000084   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000088   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000090   0x.... 0x....      BL       HAL_SYSTICK_Config
   1301          
   1302            HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x.... 0x....      BL       HAL_SYSTICK_CLKSourceConfig
   1303          
   1304            /* SysTick_IRQn interrupt configuration */
   1305            HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
   \   0000009A   0x2200             MOVS     R2,#+0
   \   0000009C   0x210F             MOVS     R1,#+15
   \   0000009E   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000A2   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1306          }
   \   000000A6   0xB013             ADD      SP,SP,#+76
   \   000000A8   0xBD00             POP      {PC}             ;; return
   1307          
   1308          /* USER CODE BEGIN 4 */
   1309          
   1310          /* USER CODE END 4 */
   1311          
   1312          /**
   1313            * @brief  This function is executed in case of error occurrence.
   1314            * @param  None
   1315            * @retval None
   1316            */

   \                                 In section .text, align 2, keep-with-next
   1317          void Error_Handler(void)
   1318          {
   \                     Error_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1319            /* USER CODE BEGIN Error_Handler */
   1320            /* User can add his own implementation to report the HAL error return state */
   1321            // Turn LED2 on
   1322          #ifdef NUCLEO
   1323            BSP_LED_On(LED2);
   1324          #else
   1325            RoadBrd_LED_On(BLUE_LED);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       RoadBrd_LED_On
   1326            RoadBrd_LED_On(GREEN_LED);
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       RoadBrd_LED_On
   1327            RoadBrd_LED_On(YELLOW_LED);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       RoadBrd_LED_On
   1328          #endif
   1329            while(1) 
   1330            {
   1331              // Error if LED2 is slowly blinking (1 sec. period)
   1332          #ifdef NUCLEO
   1333              BSP_LED_Toggle(LED2); 
   1334          #else
   1335              RoadBrd_LED_Toggle(BLUE_LED); 
   \                     ??Error_Handler_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1336              RoadBrd_LED_Toggle(GREEN_LED); 
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1337              RoadBrd_LED_Toggle(YELLOW_LED); 
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       RoadBrd_LED_Toggle
   1338          #endif
   1339              HAL_Delay(50); 
   \   00000026   0x2032             MOVS     R0,#+50
   \   00000028   0x.... 0x....      BL       HAL_Delay
   \   0000002C   0xE7F2             B.N      ??Error_Handler_0
   1340            }
   1341            /* USER CODE END Error_Handler */ 
   1342          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_12:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_13:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_14:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_15:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_16:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000008   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000010   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 20H, 20H, 57H
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x20 0x57    
   \   00000018   0x45 0x41          DC8 45H, 41H, 54H, 48H, 45H, 52H, 43H, 4CH
   \              0x54 0x48    
   \              0x45 0x52    
   \              0x43 0x4C    
   \   00000020   0x4F 0x55          DC8 4FH, 55H, 44H, 20H, 2AH, 2AH, 2AH, 2AH
   \              0x44 0x20    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000028   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000038   0x2A 0x0D          DC8 2AH, 0DH, 0AH, 0DH, 0AH, 0
   \              0x0A 0x0D    
   \              0x0A 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x20 0x20          DC8 "     Road Board Monitor %s Hardware Version %s \015\012"
   \              0x20 0x20    
   \              0x20 0x52    
   \              0x6F 0x61    
   \              0x64 0x20    
   \              0x42 0x6F    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x4D 0x6F    
   \              0x6E 0x69    
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x25 0x73    
   \              0x20 0x48    
   \              0x61 0x72    
   \              0x64 0x77    
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x56 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x25 0x73    
   \              0x20 0x0D    
   \              0x0A 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x4E 0x2E          DC8 "N.9.0"
   \              0x39 0x2E    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x52 0x65          DC8 "Rev M"
   \              0x76 0x20    
   \              0x4D 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x20 0x20          DC8 "                  Copyright %s. \015\012\015\012"
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x43 0x6F    
   \              0x70 0x79    
   \              0x72 0x69    
   \              0x67 0x68    
   \              0x74 0x20    
   \              0x25 0x73    
   \              0x2E 0x20    
   \              0x0D 0x0A    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x4A 0x61          DC8 "Jan 3, 2018"
   \              0x6E 0x20    
   \              0x33 0x2C    
   \              0x20 0x32    
   \              0x30 0x31    
   \              0x38 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x52 0x64          DC8 "RdSnd Sample Rate:  %3.1f Seconds.\015\012"
   \              0x53 0x6E    
   \              0x64 0x20    
   \              0x53 0x61    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x20 0x52    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x20    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x20    
   \              0x53 0x65    
   \              0x63 0x6F    
   \              0x6E 0x64    
   \              0x73 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x53 0x65          DC8 "Sensor Sample Rate: %3.1f Seconds.\015\012"
   \              0x6E 0x73    
   \              0x6F 0x72    
   \              0x20 0x53    
   \              0x61 0x6D    
   \              0x70 0x6C    
   \              0x65 0x20    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x25 0x33    
   \              0x2E 0x31    
   \              0x66 0x20    
   \              0x53 0x65    
   \              0x63 0x6F    
   \              0x6E 0x64    
   \              0x73 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x54 0x41          DC8 "TACK Limit: %d.\015\012"
   \              0x43 0x4B    
   \              0x20 0x4C    
   \              0x69 0x6D    
   \              0x69 0x74    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x42 0x6F          DC8 "Boot Delay: %d Seconds.\015\012"
   \              0x6F 0x74    
   \              0x20 0x44    
   \              0x65 0x6C    
   \              0x61 0x79    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x53    
   \              0x65 0x63    
   \              0x6F 0x6E    
   \              0x64 0x73    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x55 0x6E          DC8 "Units XML State: ENABLED\015\012\015\012> "
   \              0x69 0x74    
   \              0x73 0x20    
   \              0x58 0x4D    
   \              0x4C 0x20    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x45    
   \              0x4E 0x41    
   \              0x42 0x4C    
   \              0x45 0x44    
   \              0x0D 0x0A    
   \              0x0D 0x0A    
   \              0x3E 0x20    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x55 0x6E          DC8 "Units XML State: DISABLED\015\012\015\012> "
   \              0x69 0x74    
   \              0x73 0x20    
   \              0x58 0x4D    
   \              0x4C 0x20    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x44    
   \              0x49 0x53    
   \              0x41 0x42    
   \              0x4C 0x45    
   \              0x44 0x0D    
   \              0x0A 0x0D    
   \              0x0A 0x3E    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x42 0x47          DC8 42H, 47H, 4DH, 31H, 31H, 31H, 5FH, 50H
   \              0x4D 0x31    
   \              0x31 0x31    
   \              0x5F 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 63H, 65H, 73H, 73H, 49H, 6EH
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x49 0x6E    
   \   00000010   0x70 0x75          DC8 70H, 75H, 74H, 20H, 45H, 52H, 52H, 4FH
   \              0x74 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \   00000018   0x52 0x3A          DC8 52H, 3AH, 20H, 53H, 65H, 6EH, 73H, 6FH
   \              0x20 0x53    
   \              0x65 0x6E    
   \              0x73 0x6F    
   \   00000020   0x72 0x73          DC8 72H, 73H, 20H, 72H, 65H, 70H, 6FH, 72H
   \              0x20 0x72    
   \              0x65 0x70    
   \              0x6F 0x72    
   \   00000028   0x74 0x65          DC8 74H, 65H, 64H, 20H, 42H, 61H, 63H, 6BH
   \              0x64 0x20    
   \              0x42 0x61    
   \              0x63 0x6B    
   \   00000030   0x67 0x72          DC8 67H, 72H, 6FH, 75H, 6EH, 64H, 20H, 65H
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x20 0x65    
   \   00000038   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 2EH, 0DH, 0AH, 0
   \              0x6F 0x72    
   \              0x2E 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0
   1343          
   1344          #ifdef USE_FULL_ASSERT
   1345          
   1346          /**
   1347             * @brief Reports the name of the source file and the source line number
   1348             * where the assert_param error has occurred.
   1349             * @param file: pointer to the source file name
   1350             * @param line: assert_param error line source number
   1351             * @retval None
   1352             */
   1353          void assert_failed(uint8_t* file, uint32_t line)
   1354          {
   1355            /* USER CODE BEGIN 6 */
   1356            /* User can add his own implementation to report the file name and line number,
   1357              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1358            /* USER CODE END 6 */
   1359          
   1360          }
   1361          #endif
   1362          
   1363          /**
   1364            * @}
   1365            */ 
   1366          
   1367          /**
   1368            * @}
   1369          */ 
   1370          
   1371          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Error_Handler
         8   -> HAL_Delay
         8   -> RoadBrd_LED_On
         8   -> RoadBrd_LED_Toggle
      80   SystemClock_Config
        80   -> Error_Handler
        80   -> HAL_NVIC_SetPriority
        80   -> HAL_RCC_ClockConfig
        80   -> HAL_RCC_GetHCLKFreq
        80   -> HAL_RCC_OscConfig
        80   -> HAL_SYSTICK_CLKSourceConfig
        80   -> HAL_SYSTICK_Config
     248   main
       248   -> ADC_Config
       248   -> BGM111_Connected
       248   -> BGM111_DataConnected
       248   -> BGM111_Init
       248   -> BGM111_ProcessInput
       248   -> BGM111_Ready
       248   -> BGM111_SyncModeTest
       248   -> Error_Handler
       248   -> Get_DriverStates
       248   -> HAL_Init
       248   -> HAL_NVIC_EnableIRQ
       248   -> HAL_TIM_StartTimer2
       248   -> HAL_TIM_StartTimer3
       248   -> HAL_UART_EnableBGM_RX
       248   -> I2C_WaitBusyFlag
       248   -> InitSensors
       248   -> MX_ADC_Init
       248   -> MX_DMA_Init
       248   -> MX_GPIO_Init
       248   -> MX_I2C1_Init
       248   -> MX_TIM2_Init
       248   -> MX_TIM3_Init
       248   -> MX_USART2_UART_Init
       248   -> MX_USART3_UART_Init
       248   -> MX_WWDG_Init
       248   -> Parse_BootString
       248   -> Proc_Timer2
       248   -> ProcessSensorState
       248   -> Process_CmdMode
       248   -> Process_RdSound
       248   -> RdBrd_ErrCdLogErrCd
       248   -> Reset_DriverStates
       248   -> RoadBrd_CAL_InitializeFrmFlash
       248   -> RoadBrd_CAL_VerifyFrame
       248   -> RoadBrd_CoolEyeInit
       248   -> RoadBrd_Delay
       248   -> RoadBrd_Get_BootDelay
       248   -> RoadBrd_Get_RdSndTickCnt
       248   -> RoadBrd_Get_SnsrTickCnt
       248   -> RoadBrd_Get_TackLimit
       248   -> RoadBrd_Get_UnitsFlag
       248   -> RoadBrd_GridEyeInit
       248   -> RoadBrd_HumidityInit
       248   -> RoadBrd_I2CRepair
       248   -> RoadBrd_Init_Barometer
       248   -> RoadBrd_Init_VMonitor
       248   -> RoadBrd_ParseString
       248   -> RoadBrd_ParserInit
       248   -> RoadBrd_ProcessParserTsk
       248   -> RoadBrd_RGBInit
       248   -> RoadBrd_ReadTemp
       248   -> RoadBrd_SetBffrFlg
       248   -> RoadBrd_TestI2C
       248   -> RoadBrd_UART_Receive_IT
       248   -> RoadBrd_UART_Transmit
       248   -> RoadBrd_UART_Transmit_IT
       248   -> RoadBrd_Uart_Status
       248   -> RoadBrd_WWDG_InitializeDateString
       248   -> RoadBrd_WWDG_InitializeFrmFlash
       248   -> RoadBrd_WWDG_InitializeTickString
       248   -> RoadBrd_WWDG_Refresh
       248   -> RoadBrd_WWDG_Start
       248   -> RoadBrd_WWDG_VerifyFrame
       248   -> RoadBrd_gpio_Off
       248   -> RoadBrd_gpio_On
       248   -> Set_DriverStates
       248   -> Set_TickCounts
       248   -> SystemClock_Config
       248   -> Tst_Boot_Bypass
       248   -> Tst_Bypass
       248   -> __aeabi_f2d
       248   -> __aeabi_fdiv
       248   -> __aeabi_ui2f
       248   -> clrUsartState
       248   -> sprintf
       248   -> strcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_14
       4  ??DataTable1_15
       4  ??DataTable1_16
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      64  ?_0
      52  ?_1
      32  ?_10
      32  ?_11
      64  ?_12
       4  ?_13
       8  ?_2
       8  ?_3
      40  ?_4
      12  ?_5
      40  ?_6
      40  ?_7
      20  ?_8
      28  ?_9
      46  Error_Handler
     170  SystemClock_Config
    1590  main

 
   444 bytes in section .rodata
 1 874 bytes in section .text
 
 1 874 bytes of CODE  memory
   444 bytes of CONST memory

Errors: none
Warnings: none
