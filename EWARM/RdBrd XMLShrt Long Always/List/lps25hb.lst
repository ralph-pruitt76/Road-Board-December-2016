###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       25/Oct/2017  15:17:27
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\lps25hb.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\lps25hb.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\lps25hb.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\lps25hb.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\lps25hb.c
      1          /**
      2           ******************************************************************************
      3           * @file    lps25hb.c
      4           * @author  MEMS Application Team
      5           * @version V1.0.0
      6           * @date    11-February-2015
      7           * @brief   This file provides a set of functions needed to manage the lps25hb.
      8           ******************************************************************************
      9           * @attention
     10           *
     11           * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     12           *
     13           * Redistribution and use in source and binary forms, with or without modification,
     14           * are permitted provided that the following conditions are met:
     15           *   1. Redistributions of source code must retain the above copyright notice,
     16           *      this list of conditions and the following disclaimer.
     17           *   2. Redistributions in binary form must reproduce the above copyright notice,
     18           *      this list of conditions and the following disclaimer in the documentation
     19           *      and/or other materials provided with the distribution.
     20           *   3. Neither the name of STMicroelectronics nor the names of its contributors
     21           *      may be used to endorse or promote products derived from this software
     22           *      without specific prior written permission.
     23           *
     24           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     25           * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     26           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     27           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     28           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     29           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     30           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     31           * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     32           * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     33           * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     34           *
     35           ******************************************************************************
     36           */
     37          /* Includes ------------------------------------------------------------------*/
     38          #include "lps25hb.h"
     39          
     40          /** @addtogroup BSP
     41           * @{
     42           */
     43          
     44          /** @addtogroup Components
     45           * @{
     46           */
     47          
     48          /** @addtogroup LPS25HB
     49           * @{
     50           */
     51          
     52          /** @defgroup LPS25HB_Private_Variables LPS25HB_Private_Variables
     53           * @{
     54           */
     55          

   \                                 In section .data, align 1
     56          uint8_t LPS25HB_SlaveAddress = LPS25HB_ADDRESS_HIGH;
   \                     LPS25HB_SlaveAddress:
   \   00000000   0xBA               DC8 186
     57          
     58          /**
     59           * @}
     60           */
     61          
     62          static PRESSURE_StatusTypeDef LPS25HB_I2C_ReadRawPressure(int32_t *raw_press);
     63          static PRESSURE_StatusTypeDef LPS25HB_I2C_ReadRawTemperature(int16_t *raw_data);
     64          
     65          /** @defgroup LPS25HB_Private_Functions LPS25HB_Private_Functions
     66           * @{
     67           */
     68          
     69          /**
     70           * @brief  Set LPS25HB Initialization
     71           * @param  LPS25HB_Init the configuration setting for the LPS25HB
     72           * @retval PRESSURE_OK in case of success, an error code otherwise
     73           */

   \                                 In section .text, align 2, keep-with-next
     74          PRESSURE_StatusTypeDef LPS25HB_Init(PRESSURE_InitTypeDef *LPS25HB_Init)
     75          {
   \                     LPS25HB_Init: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     76            uint8_t tmp1 = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
     77            
     78            /* Configure the low level interface ---------------------------------------*/
     79            if(LPS25HB_IO_Init() != PRESSURE_OK)
     80            {
     81              return PRESSURE_ERROR;
     82            }
     83            
     84            if(LPS25HB_PowerOn() != PRESSURE_OK)
   \   0000000A   0x.... 0x....      BL       LPS25HB_PowerOn
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??LPS25HB_Init_0
     85            {
     86              return PRESSURE_ERROR;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE07C             B.N      ??LPS25HB_Init_1
     87            }
     88          
     89            if(LPS25HB_IO_Read(&tmp1, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG1_ADDR, 1) != PRESSURE_OK)
   \                     ??LPS25HB_Init_0: (+1)
   \   00000016   0xF44F 0x70FA      MOV      R0,#+500
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xAA01             ADD      R2,SP,#+4
   \   00000020   0x2120             MOVS     R1,#+32
   \   00000022   0x20BA             MOVS     R0,#+186
   \   00000024   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??LPS25HB_Init_2
     90            {
     91              return PRESSURE_ERROR;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE06F             B.N      ??LPS25HB_Init_1
     92            }
     93            
     94            /* Output Data Rate selection */
     95            tmp1 &= ~(LPS25HB_ODR_MASK);
   \                     ??LPS25HB_Init_2: (+1)
   \   00000030   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000034   0xF010 0x008F      ANDS     R0,R0,#0x8F
   \   00000038   0xF88D 0x0004      STRB     R0,[SP, #+4]
     96            tmp1 |= LPS25HB_Init->OutputDataRate;
   \   0000003C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000040   0x7821             LDRB     R1,[R4, #+0]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0xF88D 0x0004      STRB     R0,[SP, #+4]
     97            
     98            /* Interrupt circuit selection */
     99            tmp1 &= ~(LPS25HB_DIFF_EN_MASK);
   \   00000048   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000004C   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000050   0xF88D 0x0004      STRB     R0,[SP, #+4]
    100            tmp1 |= LPS25HB_Init->DiffEnable;
   \   00000054   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000058   0x78E1             LDRB     R1,[R4, #+3]
   \   0000005A   0x4308             ORRS     R0,R1,R0
   \   0000005C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    101            
    102            /* Block Data Update selection */
    103            tmp1 &= ~(LPS25HB_BDU_MASK);
   \   00000060   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000064   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   00000068   0xF88D 0x0004      STRB     R0,[SP, #+4]
    104            tmp1 |= LPS25HB_Init->BlockDataUpdate;
   \   0000006C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000070   0x7921             LDRB     R1,[R4, #+4]
   \   00000072   0x4308             ORRS     R0,R1,R0
   \   00000074   0xF88D 0x0004      STRB     R0,[SP, #+4]
    105            
    106            /* Serial Interface Mode selection */
    107            tmp1 &= ~(LPS25HB_SPI_SIM_MASK);
   \   00000078   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000007C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000080   0xF88D 0x0004      STRB     R0,[SP, #+4]
    108            tmp1 |= LPS25HB_Init->SPIMode;
   \   00000084   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000088   0x7961             LDRB     R1,[R4, #+5]
   \   0000008A   0x4308             ORRS     R0,R1,R0
   \   0000008C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    109            
    110            if(LPS25HB_IO_Write(&tmp1, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG1_ADDR, 1) != PRESSURE_OK)
   \   00000090   0xF44F 0x70FA      MOV      R0,#+500
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x2301             MOVS     R3,#+1
   \   00000098   0xAA01             ADD      R2,SP,#+4
   \   0000009A   0x2120             MOVS     R1,#+32
   \   0000009C   0x20BA             MOVS     R0,#+186
   \   0000009E   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD001             BEQ.N    ??LPS25HB_Init_3
    111            {
    112              return PRESSURE_ERROR;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xE032             B.N      ??LPS25HB_Init_1
    113            }
    114            
    115            if(LPS25HB_IO_Read(&tmp1, LPS25HB_ADDRESS_HIGH, LPS25HB_RES_CONF_ADDR, 1) != PRESSURE_OK)
   \                     ??LPS25HB_Init_3: (+1)
   \   000000AA   0xF44F 0x70FA      MOV      R0,#+500
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0x2301             MOVS     R3,#+1
   \   000000B2   0xAA01             ADD      R2,SP,#+4
   \   000000B4   0x2110             MOVS     R1,#+16
   \   000000B6   0x20BA             MOVS     R0,#+186
   \   000000B8   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??LPS25HB_Init_4
    116            {
    117              return PRESSURE_ERROR;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xE025             B.N      ??LPS25HB_Init_1
    118            }
    119            
    120            /* Serial Interface Mode selection */
    121            tmp1 &= ~(LPS25HB_P_RES_MASK);
   \                     ??LPS25HB_Init_4: (+1)
   \   000000C4   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000C8   0xF010 0x00FC      ANDS     R0,R0,#0xFC
   \   000000CC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    122            tmp1 |= LPS25HB_Init->PressureResolution;
   \   000000D0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000D4   0x7861             LDRB     R1,[R4, #+1]
   \   000000D6   0x4308             ORRS     R0,R1,R0
   \   000000D8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    123            
    124            /* Serial Interface Mode selection */
    125            tmp1 &= ~(LPS25HB_T_RES_MASK);
   \   000000DC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000E0   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   000000E4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    126            tmp1 |= LPS25HB_Init->TemperatureResolution;
   \   000000E8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000EC   0x78A1             LDRB     R1,[R4, #+2]
   \   000000EE   0x4308             ORRS     R0,R1,R0
   \   000000F0   0xF88D 0x0004      STRB     R0,[SP, #+4]
    127            
    128            if(LPS25HB_IO_Write(&tmp1, LPS25HB_ADDRESS_HIGH, LPS25HB_RES_CONF_ADDR, 1) != PRESSURE_OK)
   \   000000F4   0xF44F 0x70FA      MOV      R0,#+500
   \   000000F8   0x9000             STR      R0,[SP, #+0]
   \   000000FA   0x2301             MOVS     R3,#+1
   \   000000FC   0xAA01             ADD      R2,SP,#+4
   \   000000FE   0x2110             MOVS     R1,#+16
   \   00000100   0x20BA             MOVS     R0,#+186
   \   00000102   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD001             BEQ.N    ??LPS25HB_Init_5
    129            {
    130              return PRESSURE_ERROR;
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE000             B.N      ??LPS25HB_Init_1
    131            }
    132            
    133            //LPS25HB_IO_ITConfig();
    134            
    135            return PRESSURE_OK;
   \                     ??LPS25HB_Init_5: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_Init_1: (+1)
   \   00000110   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    136          }
    137          
    138          /**
    139           * @brief  Read ID address of LPS25HB
    140           * @param  ht_id the pointer where the ID of the device is stored
    141           * @retval PRESSURE_OK in case of success, an error code otherwise
    142           */

   \                                 In section .text, align 2, keep-with-next
    143          PRESSURE_StatusTypeDef LPS25HB_ReadID(uint8_t *p_id)
    144          {
   \                     LPS25HB_ReadID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    145            if(!p_id)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??LPS25HB_ReadID_0
    146            {
    147              return PRESSURE_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE00E             B.N      ??LPS25HB_ReadID_1
    148            }
    149            
    150            return LPS25HB_IO_Read(p_id, LPS25HB_ADDRESS_HIGH, LPS25HB_WHO_AM_I_ADDR, 1);
   \                     ??LPS25HB_ReadID_0: (+1)
   \   0000000E   0xF44F 0x70FA      MOV      R0,#+500
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x0022             MOVS     R2,R4
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x20BA             MOVS     R0,#+186
   \   0000001C   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??LPS25HB_ReadID_2
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE000             B.N      ??LPS25HB_ReadID_3
   \                     ??LPS25HB_ReadID_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \                     ??LPS25HB_ReadID_3: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPS25HB_ReadID_1: (+1)
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    151          }
    152          
    153          /**
    154           * @brief  Reboot memory content of LPS25HB
    155           * @retval PRESSURE_OK in case of success, an error code otherwise
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          PRESSURE_StatusTypeDef LPS25HB_RebootCmd(void)
    158          {
   \                     LPS25HB_RebootCmd: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    159            uint8_t tmpreg;
    160            
    161            /* Read CTRL_REG5 register */
    162            if(LPS25HB_IO_Read(&tmpreg, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG2_ADDR, 1) != PRESSURE_OK)
   \   00000004   0xF44F 0x70FA      MOV      R0,#+500
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xAA01             ADD      R2,SP,#+4
   \   0000000E   0x2121             MOVS     R1,#+33
   \   00000010   0x20BA             MOVS     R0,#+186
   \   00000012   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??LPS25HB_RebootCmd_0
    163            {
    164              return PRESSURE_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE013             B.N      ??LPS25HB_RebootCmd_1
    165            }
    166            
    167            /* Enable or Disable the reboot memory */
    168            tmpreg |= LPS25HB_RESET_MEMORY;
   \                     ??LPS25HB_RebootCmd_0: (+1)
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0xF88D 0x0004      STRB     R0,[SP, #+4]
    169            
    170            /* Write value to MEMS CTRL_REG5 regsister */
    171            if(LPS25HB_IO_Write(&tmpreg, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG2_ADDR, 1) != PRESSURE_OK)
   \   0000002A   0xF44F 0x70FA      MOV      R0,#+500
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0xAA01             ADD      R2,SP,#+4
   \   00000034   0x2121             MOVS     R1,#+33
   \   00000036   0x20BA             MOVS     R0,#+186
   \   00000038   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??LPS25HB_RebootCmd_2
    172            {
    173              return PRESSURE_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??LPS25HB_RebootCmd_1
    174            }
    175            
    176            return PRESSURE_OK;
   \                     ??LPS25HB_RebootCmd_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_RebootCmd_1: (+1)
   \   00000046   0xBD0E             POP      {R1-R3,PC}       ;; return
    177          }
    178          
    179          
    180          /**
    181           * @brief  Read LPS25HB output register, and calculate the raw pressure
    182           * @param  raw_press the pressure raw value
    183           * @retval PRESSURE_OK in case of success, an error code otherwise
    184           */

   \                                 In section .text, align 2, keep-with-next
    185          static PRESSURE_StatusTypeDef LPS25HB_I2C_ReadRawPressure(int32_t *raw_press)
    186          {
   \                     LPS25HB_I2C_ReadRawPressure: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    187            uint8_t buffer[3], i;
    188            uint32_t tempVal = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    189            
    190            /* Read the register content */
    191            
    192            if(LPS25HB_IO_Read(buffer, LPS25HB_ADDRESS_HIGH, (LPS25HB_PRESS_POUT_XL_ADDR | LPS25HB_I2C_MULTIPLEBYTE_CMD),
    193                               3) != PRESSURE_OK)
   \   00000006   0xF44F 0x70FA      MOV      R0,#+500
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2303             MOVS     R3,#+3
   \   0000000E   0xAA01             ADD      R2,SP,#+4
   \   00000010   0x21A8             MOVS     R1,#+168
   \   00000012   0x20BA             MOVS     R0,#+186
   \   00000014   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??LPS25HB_I2C_ReadRawPressure_0
    194            {
    195              return PRESSURE_ERROR;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE013             B.N      ??LPS25HB_I2C_ReadRawPressure_1
    196            }
    197            
    198            /* Build the raw data */
    199            for (i = 0 ; i < 3 ; i++)
   \                     ??LPS25HB_I2C_ReadRawPressure_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0005             MOVS     R5,R0
   \                     ??LPS25HB_I2C_ReadRawPressure_2: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D03             CMP      R5,#+3
   \   00000028   0xDA08             BGE.N    ??LPS25HB_I2C_ReadRawPressure_3
    200              tempVal |= (((uint32_t) buffer[i]) << (8 * i));
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x5D40             LDRB     R0,[R0, R5]
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x00E9             LSLS     R1,R5,#+3
   \   00000034   0x4088             LSLS     R0,R0,R1
   \   00000036   0x4306             ORRS     R6,R0,R6
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0xE7F3             B.N      ??LPS25HB_I2C_ReadRawPressure_2
    201              
    202            /* convert the 2's complement 24 bit to 2's complement 32 bit */
    203            if (tempVal & 0x00800000)
   \                     ??LPS25HB_I2C_ReadRawPressure_3: (+1)
   \   0000003C   0x0230             LSLS     R0,R6,#+8
   \   0000003E   0xD501             BPL.N    ??LPS25HB_I2C_ReadRawPressure_4
    204              tempVal |= 0xFF000000;
   \   00000040   0xF056 0x467F      ORRS     R6,R6,#0xFF000000
    205              
    206            /* return the built value */
    207            *raw_press = ((int32_t) tempVal);
   \                     ??LPS25HB_I2C_ReadRawPressure_4: (+1)
   \   00000044   0x6026             STR      R6,[R4, #+0]
    208            
    209            return PRESSURE_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_I2C_ReadRawPressure_1: (+1)
   \   00000048   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    210          }
    211          
    212          
    213          /**
    214           * @brief  Read LPS25HB output register, and calculate the raw pressure
    215           * @param  raw_press the pressure raw value
    216           * @retval PRESSURE_OK in case of success, an error code otherwise
    217           */

   \                                 In section .text, align 2, keep-with-next
    218          PRESSURE_StatusTypeDef LPS25HB_I2C_GetRawPressure(int32_t *raw_press)
    219          {
   \                     LPS25HB_I2C_GetRawPressure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    220            return( LPS25HB_I2C_ReadRawPressure( raw_press ) );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       LPS25HB_I2C_ReadRawPressure
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    221          }
    222          
    223          /**
    224           * @brief  Read LPS25HB output register, and calculate the pressure in mbar
    225           * @param  pfData the pressure value in mbar
    226           * @retval PRESSURE_OK in case of success, an error code otherwise
    227           */

   \                                 In section .text, align 2, keep-with-next
    228          PRESSURE_StatusTypeDef LPS25HB_GetPressure(float* pfData)
    229          {
   \                     LPS25HB_GetPressure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    230            int32_t raw_press = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    231            
    232            if(LPS25HB_I2C_ReadRawPressure(&raw_press) != PRESSURE_OK)
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       LPS25HB_I2C_ReadRawPressure
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??LPS25HB_GetPressure_0
    233            {
    234              return PRESSURE_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE008             B.N      ??LPS25HB_GetPressure_1
    235            }
    236            
    237            *pfData = (float)raw_press / 4096.0f;
   \                     ??LPS25HB_GetPressure_0: (+1)
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_i2f
   \   0000001E   0xF05F 0x418B      MOVS     R1,#+1166016512
   \   00000022   0x.... 0x....      BL       __aeabi_fdiv
   \   00000026   0x6020             STR      R0,[R4, #+0]
    238            
    239            return PRESSURE_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_GetPressure_1: (+1)
   \   0000002A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    240          }
    241          
    242          /**
    243           * @brief  Read LPS25HB output register, and calculate the raw temperature
    244           * @param  raw_data the temperature raw value
    245           * @retval PRESSURE_OK in case of success, an error code otherwise
    246           */

   \                                 In section .text, align 2, keep-with-next
    247          PRESSURE_StatusTypeDef LPS25HB_I2C_GetRawTemperature(int16_t *raw_data)
    248          {
   \                     LPS25HB_I2C_GetRawTemperature: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    249            return( LPS25HB_I2C_ReadRawTemperature( raw_data ) );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       LPS25HB_I2C_ReadRawTemperature
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    250          }
    251          
    252          /**
    253           * @brief  Read LPS25HB output register, and calculate the raw temperature
    254           * @param  raw_data the temperature raw value
    255           * @retval PRESSURE_OK in case of success, an error code otherwise
    256           */

   \                                 In section .text, align 2, keep-with-next
    257          static PRESSURE_StatusTypeDef LPS25HB_I2C_ReadRawTemperature(int16_t *raw_data)
    258          {
   \                     LPS25HB_I2C_ReadRawTemperature: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    259            uint8_t buffer[2];
    260            uint16_t tempVal = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    261            
    262            /* Read the register content */
    263            if(LPS25HB_IO_Read(buffer, LPS25HB_ADDRESS_HIGH, (LPS25HB_TEMP_OUT_L_ADDR | LPS25HB_I2C_MULTIPLEBYTE_CMD),
    264                               2) != PRESSURE_OK)
   \   00000008   0xF44F 0x70FA      MOV      R0,#+500
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2302             MOVS     R3,#+2
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0x21AB             MOVS     R1,#+171
   \   00000014   0x20BA             MOVS     R0,#+186
   \   00000016   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??LPS25HB_I2C_ReadRawTemperature_0
    265            {
    266              return PRESSURE_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE008             B.N      ??LPS25HB_I2C_ReadRawTemperature_1
    267            }
    268            
    269            /* Build the raw value */
    270            tempVal = (((uint16_t)buffer[1]) << 8) + (uint16_t)buffer[0];
   \                     ??LPS25HB_I2C_ReadRawTemperature_0: (+1)
   \   00000022   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000026   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000002A   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000002E   0x0005             MOVS     R5,R0
    271            
    272            /* Return it */
    273            *raw_data = ((int16_t)tempVal);
   \   00000030   0x8025             STRH     R5,[R4, #+0]
    274            
    275            return PRESSURE_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_I2C_ReadRawTemperature_1: (+1)
   \   00000034   0xBD3E             POP      {R1-R5,PC}       ;; return
    276          }
    277          
    278          /**
    279           * @brief  Read LPS25HB output register, and calculate the temperature
    280           * @param  pfData the temperature value
    281           * @retval PRESSURE_OK in case of success, an error code otherwise
    282           */

   \                                 In section .text, align 2, keep-with-next
    283          PRESSURE_StatusTypeDef LPS25HB_GetTemperature(float *pfData)
    284          {
   \                     LPS25HB_GetTemperature: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    285            int16_t raw_data;
    286            
    287            if(LPS25HB_I2C_ReadRawTemperature(&raw_data) != PRESSURE_OK)
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       LPS25HB_I2C_ReadRawTemperature
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??LPS25HB_GetTemperature_0
    288            {
    289              return PRESSURE_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE00B             B.N      ??LPS25HB_GetTemperature_1
    290            }
    291            
    292            *pfData = (float)((((float)raw_data / 480.0f) + 42.5f));
   \                     ??LPS25HB_GetTemperature_0: (+1)
   \   00000014   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       __aeabi_i2f
   \   0000001C   0x....             LDR.N    R1,??DataTable1  ;; 0x43f00000
   \   0000001E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000022   0x....             LDR.N    R1,??DataTable1_1  ;; 0x422a0000
   \   00000024   0x.... 0x....      BL       __aeabi_fadd
   \   00000028   0x6020             STR      R0,[R4, #+0]
    293            
    294            return PRESSURE_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_GetTemperature_1: (+1)
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    295          }
    296          /**
    297           * @brief  Exit the shutdown mode for LPS25HB
    298           * @retval PRESSURE_OK in case of success, an error code otherwise
    299           */

   \                                 In section .text, align 2, keep-with-next
    300          static PRESSURE_StatusTypeDef LPS25HB_PowerOn(void)
    301          {
   \                     LPS25HB_PowerOn: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    302            uint8_t tmpreg;
    303            
    304            /* Read the register content */
    305            if(LPS25HB_IO_Read(&tmpreg, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG1_ADDR, 1) != PRESSURE_OK)
   \   00000004   0xF44F 0x70FA      MOV      R0,#+500
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xAA01             ADD      R2,SP,#+4
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x20BA             MOVS     R0,#+186
   \   00000012   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??LPS25HB_PowerOn_0
    306            {
    307              return PRESSURE_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE013             B.N      ??LPS25HB_PowerOn_1
    308            }
    309            
    310            /* Set the power down bit */
    311            tmpreg |= LPS25HB_MODE_ACTIVE;
   \                     ??LPS25HB_PowerOn_0: (+1)
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0xF88D 0x0004      STRB     R0,[SP, #+4]
    312            
    313            /* Write register */
    314            if(LPS25HB_IO_Write(&tmpreg, LPS25HB_ADDRESS_HIGH, LPS25HB_CTRL_REG1_ADDR, 1) != PRESSURE_OK)
   \   0000002A   0xF44F 0x70FA      MOV      R0,#+500
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0xAA01             ADD      R2,SP,#+4
   \   00000034   0x2120             MOVS     R1,#+32
   \   00000036   0x20BA             MOVS     R0,#+186
   \   00000038   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??LPS25HB_PowerOn_2
    315            {
    316              return PRESSURE_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??LPS25HB_PowerOn_1
    317            }
    318            
    319            return PRESSURE_OK;
   \                     ??LPS25HB_PowerOn_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_PowerOn_1: (+1)
   \   00000046   0xBD0E             POP      {R1-R3,PC}       ;; return
    320          }
    321          
    322          
    323          /**
    324           * @brief  Enter the shutdown mode for LPS25HB
    325           * @retval PRESSURE_OK in case of success, an error code otherwise
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          PRESSURE_StatusTypeDef LPS25HB_PowerOff(void)
    328          {
   \                     LPS25HB_PowerOff: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    329            uint8_t tmpreg;
    330            
    331            /* Read the register content */
    332            if(LPS25HB_IO_Read(&tmpreg, (uint16_t)LPS25HB_ADDRESS_HIGH, (uint8_t)LPS25HB_CTRL_REG1_ADDR, (uint16_t)1) != PRESSURE_OK)
   \   00000004   0xF44F 0x70FA      MOV      R0,#+500
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xAA01             ADD      R2,SP,#+4
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x20BA             MOVS     R0,#+186
   \   00000012   0x.... 0x....      BL       RoadBrd_I2C_Master_CmdReceive
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??LPS25HB_PowerOff_0
    333            {
    334              return PRESSURE_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE013             B.N      ??LPS25HB_PowerOff_1
    335            }
    336            
    337            /* Reset the power down bit */
    338            tmpreg &= ~(LPS25HB_MODE_ACTIVE);
   \                     ??LPS25HB_PowerOff_0: (+1)
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000026   0xF88D 0x0004      STRB     R0,[SP, #+4]
    339            
    340            /* Write register */
    341            if(LPS25HB_IO_Write(&tmpreg, (uint16_t)LPS25HB_ADDRESS_HIGH, (uint8_t)LPS25HB_CTRL_REG1_ADDR, (uint16_t)1) != PRESSURE_OK)
   \   0000002A   0xF44F 0x70FA      MOV      R0,#+500
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0xAA01             ADD      R2,SP,#+4
   \   00000034   0x2120             MOVS     R1,#+32
   \   00000036   0x20BA             MOVS     R0,#+186
   \   00000038   0x.... 0x....      BL       RoadBrd_I2C_Master_Transmit_CMDData
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??LPS25HB_PowerOff_2
    342            {
    343              return PRESSURE_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??LPS25HB_PowerOff_1
    344            }
    345            
    346            return PRESSURE_OK;
   \                     ??LPS25HB_PowerOff_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??LPS25HB_PowerOff_1: (+1)
   \   00000046   0xBD0E             POP      {R1-R3,PC}       ;; return
    347          }
    348          
    349          /**
    350           * @brief  Set the slave address according to SA0 bit
    351           * @param  SA0_Bit_Status LPS25HB_SA0_LOW or LPS25HB_SA0_HIGH
    352           * @retval None
    353           */

   \                                 In section .text, align 2, keep-with-next
    354          void LPS25HB_SlaveAddrRemap(uint8_t SA0_Bit_Status)
    355          {
    356            LPS25HB_SlaveAddress = LPS25HB_ADDRESS_HIGH;
   \                     LPS25HB_SlaveAddrRemap: (+1)
   \   00000000   0x21BA             MOVS     R1,#+186
   \   00000002   0x....             LDR.N    R2,??DataTable1_2
   \   00000004   0x7011             STRB     R1,[R2, #+0]
    357            //LPS25HB_SlaveAddress = (SA0_Bit_Status == LPS25HB_SA0_LOW ? LPS25HB_ADDRESS_LOW : LPS25HB_ADDRESS_HIGH);
    358          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x43F00000         DC32     0x43f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x422A0000         DC32     0x422a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     LPS25HB_SlaveAddress
    359          
    360          /**
    361           * @}
    362           */
    363          
    364          /**
    365           * @}
    366           */
    367          
    368          /**
    369           * @}
    370           */
    371          
    372          /**
    373           * @}
    374           */
    375          
    376          
    377          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LPS25HB_GetPressure
        16   -> LPS25HB_I2C_ReadRawPressure
        16   -> __aeabi_fdiv
        16   -> __aeabi_i2f
      16   LPS25HB_GetTemperature
        16   -> LPS25HB_I2C_ReadRawTemperature
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
        16   -> __aeabi_i2f
       8   LPS25HB_I2C_GetRawPressure
         8   -> LPS25HB_I2C_ReadRawPressure
       8   LPS25HB_I2C_GetRawTemperature
         8   -> LPS25HB_I2C_ReadRawTemperature
      24   LPS25HB_I2C_ReadRawPressure
        24   -> RoadBrd_I2C_Master_CmdReceive
      24   LPS25HB_I2C_ReadRawTemperature
        24   -> RoadBrd_I2C_Master_CmdReceive
      16   LPS25HB_Init
        16   -> LPS25HB_PowerOn
        16   -> RoadBrd_I2C_Master_CmdReceive
        16   -> RoadBrd_I2C_Master_Transmit_CMDData
      16   LPS25HB_PowerOff
        16   -> RoadBrd_I2C_Master_CmdReceive
        16   -> RoadBrd_I2C_Master_Transmit_CMDData
      16   LPS25HB_PowerOn
        16   -> RoadBrd_I2C_Master_CmdReceive
        16   -> RoadBrd_I2C_Master_Transmit_CMDData
      16   LPS25HB_ReadID
        16   -> RoadBrd_I2C_Master_CmdReceive
      16   LPS25HB_RebootCmd
        16   -> RoadBrd_I2C_Master_CmdReceive
        16   -> RoadBrd_I2C_Master_Transmit_CMDData
       0   LPS25HB_SlaveAddrRemap


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      44  LPS25HB_GetPressure
      46  LPS25HB_GetTemperature
      12  LPS25HB_I2C_GetRawPressure
      12  LPS25HB_I2C_GetRawTemperature
      74  LPS25HB_I2C_ReadRawPressure
      54  LPS25HB_I2C_ReadRawTemperature
     274  LPS25HB_Init
      72  LPS25HB_PowerOff
      72  LPS25HB_PowerOn
      46  LPS25HB_ReadID
      72  LPS25HB_RebootCmd
       8  LPS25HB_SlaveAddrRemap
       1  LPS25HB_SlaveAddress

 
   1 byte  in section .data
 798 bytes in section .text
 
 798 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
