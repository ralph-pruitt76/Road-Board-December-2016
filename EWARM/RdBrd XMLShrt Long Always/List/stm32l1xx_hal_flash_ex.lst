###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       20/Sep/2017  10:11:16
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_flash_ex.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_flash_ex.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_flash_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   Extended FLASH HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the internal FLASH memory:
     11            *            + FLASH Interface configuration
     12            *            + FLASH Memory Erasing
     13            *            + DATA EEPROM Programming/Erasing
     14            *            + Option Bytes Programming
     15            *            + Interrupts management
     16            *    
     17            @verbatim
     18            ==============================================================================
     19                         ##### Flash peripheral Extended features  #####
     20            ==============================================================================
     21                     
     22            [..] Comparing to other products, the FLASH interface for STM32L1xx
     23                 devices contains the following additional features        
     24                 (+) Erase functions
     25                 (+) DATA_EEPROM memory management
     26                 (+) BOOT option bit configuration       
     27                 (+) PCROP protection for all sectors
     28             
     29                                ##### How to use this driver #####
     30            ==============================================================================
     31            [..] This driver provides functions to configure and program the FLASH memory 
     32                 of all STM32L1xx. It includes:
     33                 (+) Full DATA_EEPROM erase and program management
     34                 (+) Boot activation
     35                 (+) PCROP protection configuration and control for all pages
     36            
     37            @endverbatim
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     42            *
     43            * Redistribution and use in source and binary forms, with or without modification,
     44            * are permitted provided that the following conditions are met:
     45            *   1. Redistributions of source code must retain the above copyright notice,
     46            *      this list of conditions and the following disclaimer.
     47            *   2. Redistributions in binary form must reproduce the above copyright notice,
     48            *      this list of conditions and the following disclaimer in the documentation
     49            *      and/or other materials provided with the distribution.
     50            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     51            *      may be used to endorse or promote products derived from this software
     52            *      without specific prior written permission.
     53            *
     54            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     55            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     56            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     57            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     58            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     59            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     60            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     61            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     62            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     63            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     64            *
     65            ******************************************************************************  
     66            */ 
     67          
     68          /* Includes ------------------------------------------------------------------*/
     69          #include "stm32l1xx_hal.h"
     70          
     71          /** @addtogroup STM32L1xx_HAL_Driver
     72            * @{
     73            */
     74          #ifdef HAL_FLASH_MODULE_ENABLED
     75          
     76          /** @addtogroup FLASH
     77            * @{
     78            */
     79          /** @addtogroup FLASH_Private_Variables
     80           * @{
     81           */
     82          /* Variables used for Erase pages under interruption*/
     83          extern FLASH_ProcessTypeDef pFlash;
     84          /**
     85            * @}
     86            */
     87          
     88          /**
     89            * @}
     90            */
     91            
     92          /** @defgroup FLASHEx FLASHEx
     93            * @brief FLASH HAL Extension module driver
     94            * @{
     95            */
     96          
     97          /* Private typedef -----------------------------------------------------------*/
     98          /* Private define ------------------------------------------------------------*/
     99          /** @defgroup FLASHEx_Private_Constants FLASHEx Private Constants
    100           * @{
    101           */
    102          /**
    103            * @}
    104            */
    105          
    106          /* Private macro -------------------------------------------------------------*/
    107          /** @defgroup FLASHEx_Private_Macros FLASHEx Private Macros
    108            * @{
    109            */
    110          /**
    111            * @}
    112            */ 
    113          
    114          /* Private variables ---------------------------------------------------------*/
    115          /* Private function prototypes -----------------------------------------------*/
    116          /** @defgroup FLASHEx_Private_Functions FLASHEx Private Functions
    117           * @{
    118           */
    119          static HAL_StatusTypeDef  FLASH_OB_WRPConfig(FLASH_OBProgramInitTypeDef *pOBInit, FunctionalState NewState);
    120          static void               FLASH_OB_WRPConfigWRP1OrPCROP1(uint32_t WRP1OrPCROP1, FunctionalState NewState);
    121          #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)    \
    122           || defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xCA) \
    123           || defined(STM32L152xD) || defined(STM32L152xDX) || defined(STM32L162xCA) || defined(STM32L162xD)  \
    124           || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE)
    125          static void               FLASH_OB_WRPConfigWRP2OrPCROP2(uint32_t WRP2OrPCROP2, FunctionalState NewState);
    126          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    127          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
    128           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)   \
    129           || defined(STM32L162xE)
    130          static void               FLASH_OB_WRPConfigWRP3(uint32_t WRP3, FunctionalState NewState);
    131          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    132          #if defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE) || defined(STM32L151xDX) \
    133           || defined(STM32L152xDX) || defined(STM32L162xDX)
    134          static void               FLASH_OB_WRPConfigWRP4(uint32_t WRP4, FunctionalState NewState);
    135          #endif /* STM32L151xE || STM32L152xE || STM32L151xDX || ... */
    136          static HAL_StatusTypeDef  FLASH_OB_RDPConfig(uint8_t OB_RDP);
    137          static HAL_StatusTypeDef  FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
    138          static HAL_StatusTypeDef  FLASH_OB_BORConfig(uint8_t OB_BOR);
    139          static uint8_t            FLASH_OB_GetRDP(void);
    140          static uint8_t            FLASH_OB_GetUser(void);
    141          static uint8_t            FLASH_OB_GetBOR(void);
    142          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
    143           || defined(STM32L162xC)
    144          static HAL_StatusTypeDef  FLASH_OB_PCROPConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit, FunctionalState NewState);
    145          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    146          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
    147           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
    148           || defined(STM32L162xE)
    149          static HAL_StatusTypeDef  FLASH_OB_BootConfig(uint8_t OB_BOOT);
    150          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    151          
    152          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramByte(uint32_t Address, uint8_t Data);
    153          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data);
    154          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramWord(uint32_t Address, uint32_t Data);
    155          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramWord(uint32_t Address, uint32_t Data);
    156          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data);
    157          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramByte(uint32_t Address, uint8_t Data);
    158          /**
    159            * @}
    160            */
    161          
    162          /* Exported functions ---------------------------------------------------------*/
    163          /** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
    164            * @{
    165            */
    166          
    167          /** @defgroup FLASHEx_Exported_Functions_Group1 FLASHEx Memory Erasing functions
    168           *  @brief   FLASH Memory Erasing functions
    169           *
    170          @verbatim   
    171            ==============================================================================
    172                          ##### FLASH Erasing Programming functions ##### 
    173            ==============================================================================
    174          
    175              [..] The FLASH Memory Erasing functions, includes the following functions:
    176              (+) @ref HAL_FLASHEx_Erase: return only when erase has been done
    177              (+) @ref HAL_FLASHEx_Erase_IT: end of erase is done when @ref HAL_FLASH_EndOfOperationCallback 
    178                  is called with parameter 0xFFFFFFFF
    179          
    180              [..] Any operation of erase should follow these steps:
    181              (#) Call the @ref HAL_FLASH_Unlock() function to enable the flash control register and 
    182                  program memory access.
    183              (#) Call the desired function to erase page.
    184              (#) Call the @ref HAL_FLASH_Lock() to disable the flash program memory access 
    185                 (recommended to protect the FLASH memory against possible unwanted operation).
    186          
    187          @endverbatim
    188            * @{
    189            */
    190            
    191          /**
    192            * @brief  Erase the specified FLASH memory Pages 
    193            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    194            *         must be called before.
    195            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    196            *         (recommended to protect the FLASH memory against possible unwanted operation)
    197            * @note   For STM32L151xDX/STM32L152xDX/STM32L162xDX, as memory is not continuous between
    198            *         2 banks, user should perform pages erase by bank only.
    199            * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    200            *         contains the configuration information for the erasing.
    201            * 
    202            * @param[out]  PageError pointer to variable  that
    203            *         contains the configuration information on faulty page in case of error
    204            *         (0xFFFFFFFF means that all the pages have been correctly erased)
    205            * 
    206            * @retval HAL_StatusTypeDef HAL Status
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
    209          {
   \                     HAL_FLASHEx_Erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    210            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000006   0x2601             MOVS     R6,#+1
    211            uint32_t address = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    212            
    213            /* Process Locked */
    214            __HAL_LOCK(&pFlash);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000000E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_FLASHEx_Erase_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE03F             B.N      ??HAL_FLASHEx_Erase_1
   \                     ??HAL_FLASHEx_Erase_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000001E   0x7408             STRB     R0,[R1, #+16]
    215          
    216            /* Wait for last operation to be completed */
    217            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0006             MOVS     R6,R0
    218          
    219            if (status == HAL_OK)
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD12D             BNE.N    ??HAL_FLASHEx_Erase_2
    220            {
    221              /*Initialization of PageError variable*/
    222              *PageError = 0xFFFFFFFF;
   \   00000030   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000034   0x6028             STR      R0,[R5, #+0]
    223          
    224              /* Check the parameters */
    225              assert_param(IS_NBPAGES(pEraseInit->NbPages));
    226              assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    227              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    228              assert_param(IS_FLASH_PROGRAM_ADDRESS((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1));
    229          
    230          #if defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    231              /* Check on which bank belongs the 1st address to erase */
    232              if (pEraseInit->PageAddress < FLASH_BANK2_BASE)
    233              {
    234                /* BANK1 */
    235                /* Check that last page to erase still belongs to BANK1 */
    236                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK1_END)
    237                {
    238                  /*  Last page does not belong to BANK1, erase procedure cannot be performed because memory is not
    239                      continuous */
    240                  /* Process Unlocked */
    241                  __HAL_UNLOCK(&pFlash);
    242                  return HAL_ERROR;
    243                }
    244              }
    245              else
    246              {
    247                /* BANK2 */
    248                /* Check that last page to erase still belongs to BANK2 */
    249                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK2_END)
    250                {
    251                  /*  Last page does not belong to BANK2, erase procedure cannot be performed because memory is not
    252                      continuous */
    253                  /* Process Unlocked */
    254                  __HAL_UNLOCK(&pFlash);
    255                  return HAL_ERROR;
    256                }
    257              }
    258          #endif /* STM32L151xDX || STM32L152xDX || STM32L162xDX */
    259          
    260              /* Erase page by page to be done*/
    261              for(address = pEraseInit->PageAddress; 
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x0007             MOVS     R7,R0
    262                  address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
   \                     ??HAL_FLASHEx_Erase_3: (+1)
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0xF44F 0x7180      MOV      R1,#+256
   \   00000040   0x6862             LDR      R2,[R4, #+4]
   \   00000042   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000046   0x4287             CMP      R7,R0
   \   00000048   0xD220             BCS.N    ??HAL_FLASHEx_Erase_2
    263                  address += FLASH_PAGE_SIZE)
    264              {
    265                FLASH_PageErase(address);
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x.... 0x....      BL       FLASH_PageErase
    266          
    267                /* Wait for last operation to be completed */
    268                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000050   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000054   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000058   0x0006             MOVS     R6,R0
    269          
    270                /* If the erase operation is completed, disable the ERASE Bit */
    271                CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF07F 0x0108      MVNS     R1,#+8
   \   00000064   0x4008             ANDS     R0,R1,R0
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    272                CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    273          
    274                if (status != HAL_OK) 
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x2E00             CMP      R6,#+0
   \   00000080   0xD001             BEQ.N    ??HAL_FLASHEx_Erase_4
    275                {
    276                      /* In case of error, stop erase procedure and return the faulty address */
    277                  *PageError = address;
   \   00000082   0x602F             STR      R7,[R5, #+0]
    278                  break;
   \   00000084   0xE002             B.N      ??HAL_FLASHEx_Erase_2
    279                }
    280              }
   \                     ??HAL_FLASHEx_Erase_4: (+1)
   \   00000086   0xF517 0x7780      ADDS     R7,R7,#+256
   \   0000008A   0xE7D6             B.N      ??HAL_FLASHEx_Erase_3
    281            }
    282          
    283            /* Process Unlocked */
    284            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_Erase_2: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000092   0x7408             STRB     R0,[R1, #+16]
    285          
    286            return status;
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_1: (+1)
   \   00000098   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    287          }
    288          
    289          /**
    290            * @brief  Perform a page erase of the specified FLASH memory pages  with interrupt enabled
    291            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    292            *         must be called before.
    293            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    294            *         (recommended to protect the FLASH memory against possible unwanted operation)
    295            * @note   For STM32L151xDX/STM32L152xDX/STM32L162xDX, as memory is not continuous between
    296            *         2 banks, user should perform pages erase by bank only.
    297            * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    298            *         contains the configuration information for the erasing.
    299            * 
    300            * @retval HAL_StatusTypeDef HAL Status
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
    303          {
   \                     HAL_FLASHEx_Erase_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    304            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    305          
    306            /* If procedure already ongoing, reject the next one */
    307            if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_FLASHEx_Erase_IT_0
    308            {
    309              return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE023             B.N      ??HAL_FLASHEx_Erase_IT_1
    310            }
    311          
    312            /* Check the parameters */
    313            assert_param(IS_NBPAGES(pEraseInit->NbPages));
    314            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    315            assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    316            assert_param(IS_FLASH_PROGRAM_ADDRESS((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1));
    317          
    318            /* Process Locked */
    319            __HAL_LOCK(&pFlash);
   \                     ??HAL_FLASHEx_Erase_IT_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000018   0x7C00             LDRB     R0,[R0, #+16]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD101             BNE.N    ??HAL_FLASHEx_Erase_IT_2
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE01C             B.N      ??HAL_FLASHEx_Erase_IT_1
   \                     ??HAL_FLASHEx_Erase_IT_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000028   0x7408             STRB     R0,[R1, #+16]
    320          
    321          #if defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    322              /* Check on which bank belongs the 1st address to erase */
    323              if (pEraseInit->PageAddress < FLASH_BANK2_BASE)
    324              {
    325                /* BANK1 */
    326                /* Check that last page to erase still belongs to BANK1 */
    327                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK1_END)
    328                {
    329                  /*  Last page does not belong to BANK1, erase procedure cannot be performed because memory is not
    330                      continuous */
    331                  /* Process Unlocked */
    332                  __HAL_UNLOCK(&pFlash);
    333                  return HAL_ERROR;
    334                }
    335              }
    336              else
    337              {
    338                /* BANK2 */
    339                /* Check that last page to erase still belongs to BANK2 */
    340                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK2_END)
    341                {
    342                  /*  Last page does not belong to BANK2, erase procedure cannot be performed because memory is not
    343                      continuous */
    344                  /* Process Unlocked */
    345                  __HAL_UNLOCK(&pFlash);
    346                  return HAL_ERROR;
    347                }
    348              }
    349          #endif /* STM32L151xDX || STM32L152xDX || STM32L162xDX */
    350          
    351            /* Enable End of FLASH Operation and Error source interrupts */
    352            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF450 0x3040      ORRS     R0,R0,#0x30000
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   00000038   0x6008             STR      R0,[R1, #+0]
    353            
    354            pFlash.ProcedureOnGoing = FLASH_PROC_PAGEERASE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    355            pFlash.NbPagesToErase = pEraseInit->NbPages;
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000048   0x6048             STR      R0,[R1, #+4]
    356            pFlash.Page = pEraseInit->PageAddress;
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000050   0x60C8             STR      R0,[R1, #+12]
    357          
    358            /*Erase 1st page and wait for IT*/
    359            FLASH_PageErase(pEraseInit->PageAddress);
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x.... 0x....      BL       FLASH_PageErase
    360          
    361            return status;
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_IT_1: (+1)
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    362          }
    363          
    364          /**
    365            * @}
    366            */
    367          
    368          /** @defgroup FLASHEx_Exported_Functions_Group2 Option Bytes Programming functions
    369           *  @brief   Option Bytes Programming functions
    370           *
    371          @verbatim   
    372            ==============================================================================
    373                          ##### Option Bytes Programming functions ##### 
    374            ==============================================================================  
    375          
    376              [..] Any operation of erase or program should follow these steps:
    377              (#) Call the @ref HAL_FLASH_OB_Unlock() function to enable the Flash option control 
    378                  register access.
    379              (#) Call following function to program the desired option bytes.
    380                  (++) @ref HAL_FLASHEx_OBProgram:
    381                   - To Enable/Disable the desired sector write protection.
    382                   - To set the desired read Protection Level.
    383                   - To configure the user option Bytes: IWDG, STOP and the Standby.
    384                   - To Set the BOR level.
    385              (#) Once all needed option bytes to be programmed are correctly written, call the
    386                  @ref HAL_FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    387              (#) Call the @ref HAL_FLASH_OB_Lock() to disable the Flash option control register access (recommended
    388                  to protect the option Bytes against possible unwanted operations).
    389          
    390              [..] Proprietary code Read Out Protection (PcROP):
    391              (#) The PcROP sector is selected by using the same option bytes as the Write
    392                  protection (nWRPi bits). As a result, these 2 options are exclusive each other.
    393              (#) In order to activate the PcROP (change the function of the nWRPi option bits), 
    394                  the SPRMOD option bit must be activated.
    395              (#) The active value of nWRPi bits is inverted when PCROP mode is active, this
    396                  means: if SPRMOD = 1 and nWRPi = 1 (default value), then the user sector "i"
    397                  is read/write protected.
    398              (#) To activate PCROP mode for Flash sector(s), you need to call the following function:
    399                  (++) @ref HAL_FLASHEx_AdvOBProgram in selecting sectors to be read/write protected
    400                  (++) @ref HAL_FLASHEx_OB_SelectPCROP to enable the read/write protection
    401              (#) PcROP is available only in STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices.
    402          
    403          @endverbatim
    404            * @{
    405            */
    406          
    407          /**
    408            * @brief  Program option bytes
    409            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    410            *         contains the configuration information for the programming.
    411            * 
    412            * @retval HAL_StatusTypeDef HAL Status
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
    415          {
   \                     HAL_FLASHEx_OBProgram: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    416            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000004   0x2501             MOVS     R5,#+1
    417            
    418            /* Process Locked */
    419            __HAL_LOCK(&pFlash);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000000A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_FLASHEx_OBProgram_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE05F             B.N      ??HAL_FLASHEx_OBProgram_1
   \                     ??HAL_FLASHEx_OBProgram_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000001A   0x7408             STRB     R0,[R1, #+16]
    420          
    421            /* Check the parameters */
    422            assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
    423          
    424            /*Write protection configuration*/
    425            if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD517             BPL.N    ??HAL_FLASHEx_OBProgram_2
    426            {
    427              assert_param(IS_WRPSTATE(pOBInit->WRPState));
    428              if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD105             BNE.N    ??HAL_FLASHEx_OBProgram_3
    429              {
    430                /* Enable of Write protection on the selected Sector*/
    431                status = FLASH_OB_WRPConfig(pOBInit, ENABLE);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       FLASH_OB_WRPConfig
   \   00000030   0x0005             MOVS     R5,R0
   \   00000032   0xE004             B.N      ??HAL_FLASHEx_OBProgram_4
    432              }
    433              else
    434              {
    435                /* Disable of Write protection on the selected Sector*/
    436                status = FLASH_OB_WRPConfig(pOBInit, DISABLE);
   \                     ??HAL_FLASHEx_OBProgram_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       FLASH_OB_WRPConfig
   \   0000003C   0x0005             MOVS     R5,R0
    437              }
    438              if (status != HAL_OK)
   \                     ??HAL_FLASHEx_OBProgram_4: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_2
    439              {
    440                /* Process Unlocked */
    441                __HAL_UNLOCK(&pFlash);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000004A   0x7408             STRB     R0,[R1, #+16]
    442                return status;
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE040             B.N      ??HAL_FLASHEx_OBProgram_1
    443              }
    444            }
    445            
    446            /* Read protection configuration*/
    447            if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
   \                     ??HAL_FLASHEx_OBProgram_2: (+1)
   \   00000052   0x7820             LDRB     R0,[R4, #+0]
   \   00000054   0x0780             LSLS     R0,R0,#+30
   \   00000056   0xD50D             BPL.N    ??HAL_FLASHEx_OBProgram_5
    448            {
    449              status = FLASH_OB_RDPConfig(pOBInit->RDPLevel);
   \   00000058   0x7E20             LDRB     R0,[R4, #+24]
   \   0000005A   0x.... 0x....      BL       FLASH_OB_RDPConfig
   \   0000005E   0x0005             MOVS     R5,R0
    450              if (status != HAL_OK)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_5
    451              {
    452                /* Process Unlocked */
    453                __HAL_UNLOCK(&pFlash);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000006C   0x7408             STRB     R0,[R1, #+16]
    454                return status;
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xE02F             B.N      ??HAL_FLASHEx_OBProgram_1
    455              }
    456            }
    457            
    458            /* USER  configuration*/
    459            if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
   \                     ??HAL_FLASHEx_OBProgram_5: (+1)
   \   00000074   0x7820             LDRB     R0,[R4, #+0]
   \   00000076   0x0740             LSLS     R0,R0,#+29
   \   00000078   0xD515             BPL.N    ??HAL_FLASHEx_OBProgram_6
    460            {
    461              status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_IWDG_SW, 
    462                                           pOBInit->USERConfig & OB_STOP_NORST,
    463                                           pOBInit->USERConfig & OB_STDBY_NORST);
   \   0000007A   0x7EA0             LDRB     R0,[R4, #+26]
   \   0000007C   0xF010 0x0240      ANDS     R2,R0,#0x40
   \   00000080   0x7EA0             LDRB     R0,[R4, #+26]
   \   00000082   0xF010 0x0120      ANDS     R1,R0,#0x20
   \   00000086   0x7EA0             LDRB     R0,[R4, #+26]
   \   00000088   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   0000008C   0x.... 0x....      BL       FLASH_OB_UserConfig
   \   00000090   0x0005             MOVS     R5,R0
    464              if (status != HAL_OK)
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x2D00             CMP      R5,#+0
   \   00000096   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_6
    465              {
    466                /* Process Unlocked */
    467                __HAL_UNLOCK(&pFlash);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000009E   0x7408             STRB     R0,[R1, #+16]
    468                return status;
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xE016             B.N      ??HAL_FLASHEx_OBProgram_1
    469              }
    470            }
    471          
    472            /* BOR Level  configuration*/
    473            if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
   \                     ??HAL_FLASHEx_OBProgram_6: (+1)
   \   000000A6   0x7820             LDRB     R0,[R4, #+0]
   \   000000A8   0x0700             LSLS     R0,R0,#+28
   \   000000AA   0xD50D             BPL.N    ??HAL_FLASHEx_OBProgram_7
    474            {
    475              status = FLASH_OB_BORConfig(pOBInit->BORLevel);
   \   000000AC   0x7E60             LDRB     R0,[R4, #+25]
   \   000000AE   0x.... 0x....      BL       FLASH_OB_BORConfig
   \   000000B2   0x0005             MOVS     R5,R0
    476              if (status != HAL_OK)
   \   000000B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B6   0x2D00             CMP      R5,#+0
   \   000000B8   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_7
    477              {
    478                /* Process Unlocked */
    479                __HAL_UNLOCK(&pFlash);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000C0   0x7408             STRB     R0,[R1, #+16]
    480                return status;
   \   000000C2   0x0028             MOVS     R0,R5
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C6   0xE005             B.N      ??HAL_FLASHEx_OBProgram_1
    481              }
    482            } 
    483            /* Process Unlocked */
    484            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_OBProgram_7: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000CE   0x7408             STRB     R0,[R1, #+16]
    485          
    486            return status;
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_OBProgram_1: (+1)
   \   000000D4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    487          }
    488          
    489          /**
    490            * @brief   Get the Option byte configuration
    491            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    492            *         contains the configuration information for the programming.
    493            * 
    494            * @retval None
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
    497          {
   \                     HAL_FLASHEx_OBGetConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    498            pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
   \   00000004   0x200F             MOVS     R0,#+15
   \   00000006   0x6020             STR      R0,[R4, #+0]
    499          
    500            /*Get WRP1*/
    501            pOBInit->WRPSector0To31 = (uint32_t)(FLASH->WRPR1);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26_2  ;; 0x40023c20
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
    502          
    503          #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)    \
    504           || defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xCA) \
    505           || defined(STM32L152xD) || defined(STM32L152xDX) || defined(STM32L162xCA) || defined(STM32L162xD)  \
    506           || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE)
    507              
    508            /*Get WRP2*/
    509            pOBInit->WRPSector32To63 = (uint32_t)(FLASH->WRPR2);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_3  ;; 0x40023c80
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x60E0             STR      R0,[R4, #+12]
    510          
    511          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    512            
    513          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
    514           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
    515           || defined(STM32L162xE)
    516              
    517            /*Get WRP3*/
    518            pOBInit->WRPSector64To95 = (uint32_t)(FLASH->WRPR3);
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_4  ;; 0x40023c84
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    519          
    520          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    521            
    522          #if defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE) || defined(STM32L151xDX) \
    523           || defined(STM32L152xDX) || defined(STM32L162xDX)
    524          
    525            /*Get WRP4*/
    526            pOBInit->WRPSector96To127 = (uint32_t)(FLASH->WRPR4);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x40023c88
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x6160             STR      R0,[R4, #+20]
    527          
    528          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
    529          
    530            /*Get RDP Level*/
    531            pOBInit->RDPLevel   = FLASH_OB_GetRDP();
   \   00000028   0x.... 0x....      BL       FLASH_OB_GetRDP
   \   0000002C   0x7620             STRB     R0,[R4, #+24]
    532          
    533            /*Get USER*/
    534            pOBInit->USERConfig = FLASH_OB_GetUser();
   \   0000002E   0x.... 0x....      BL       FLASH_OB_GetUser
   \   00000032   0x76A0             STRB     R0,[R4, #+26]
    535          
    536            /*Get BOR Level*/
    537            pOBInit->BORLevel   = FLASH_OB_GetBOR();
   \   00000034   0x.... 0x....      BL       FLASH_OB_GetBOR
   \   00000038   0x7660             STRB     R0,[R4, #+25]
    538            
    539          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    540          
    541          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
    542           || defined(STM32L162xC) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD)  \
    543           || defined(STM32L152xDX) || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) \
    544           || defined(STM32L152xE) || defined(STM32L162xE)
    545              
    546          /**
    547            * @brief  Program option bytes
    548            * @note   This function can be used only for Cat2 & Cat3 devices for PCROP and Cat4 & Cat5 for BFB2.
    549            * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    550            *         contains the configuration information for the programming.
    551            * 
    552            * @retval HAL_StatusTypeDef HAL Status
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          HAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    555          {
   \                     HAL_FLASHEx_AdvOBProgram: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    556            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000004   0x2501             MOVS     R5,#+1
    557            
    558            /* Check the parameters */
    559            assert_param(IS_OBEX(pAdvOBInit->OptionType));
    560          
    561          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
    562           || defined(STM32L162xC)
    563              
    564            /* Cat2 & Cat3 devices only */
    565            /*Program PCROP option byte*/
    566            if ((pAdvOBInit->OptionType & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)
    567            {
    568              /* Check the parameters */
    569              assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));
    570              if (pAdvOBInit->PCROPState == OB_PCROP_STATE_ENABLE)
    571              {
    572                /*Enable of Write protection on the selected Sector*/
    573                status = FLASH_OB_PCROPConfig(pAdvOBInit, ENABLE);
    574                if (status != HAL_OK)
    575                {
    576                  return status;
    577                }
    578              }
    579              else
    580              {
    581                /*Disable of Write protection on the selected Sector*/ 
    582                status = FLASH_OB_PCROPConfig(pAdvOBInit, DISABLE);
    583                if (status != HAL_OK)
    584                {
    585                  return status;
    586                }
    587              }
    588            }
    589            
    590          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    591          
    592          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
    593           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE) \
    594           || defined(STM32L162xE)
    595              
    596            /* Cat4 & Cat5 devices only */
    597            /*Program BOOT config option byte*/
    598            if ((pAdvOBInit->OptionType & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD504             BPL.N    ??HAL_FLASHEx_AdvOBProgram_0
    599            {
    600              status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);
   \   0000000C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       FLASH_OB_BootConfig
   \   00000014   0x0005             MOVS     R5,R0
    601            }
    602            
    603          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    604          
    605            return status;
   \                     ??HAL_FLASHEx_AdvOBProgram_0: (+1)
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    606          }
    607          
    608          /**
    609            * @brief   Get the OBEX byte configuration
    610            * @note   This function can be used only for Cat2  & Cat3 devices for PCROP and Cat4 & Cat5 for BFB2.
    611            * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    612            *         contains the configuration information for the programming.
    613            * 
    614            * @retval None
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          void HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    617          {
    618          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
    619           || defined(STM32L162xC)
    620                
    621            pAdvOBInit->OptionType = OPTIONBYTE_PCROP;
    622          
    623            /*Get PCROP state */
    624            pAdvOBInit->PCROPState = (FLASH->OBR & FLASH_OBR_SPRMOD) >> POSITION_VAL(FLASH_OBR_SPRMOD);
    625            
    626            /*Get PCROP protected sector from 0 to 31 */
    627            pAdvOBInit->PCROPSector0To31 = FLASH->WRPR1;
    628            
    629            #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)
    630          
    631            /*Get PCROP protected sector from 32 to 63 */
    632            pAdvOBInit->PCROPSector32To63 = FLASH->WRPR2;
    633          
    634            #endif /* STM32L100xC || STM32L151xC || STM32L152xC || STM32L162xC */
    635            
    636          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    637          
    638          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
    639           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
    640           || defined(STM32L162xE)
    641                
    642            pAdvOBInit->OptionType = OPTIONBYTE_BOOTCONFIG;
   \                     HAL_FLASHEx_AdvOBGetConfig: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x6001             STR      R1,[R0, #+0]
    643          
    644            /*Get Boot config OB*/
    645            pAdvOBInit->BootConfig = (FLASH->OBR & 0x80000000) >> 24;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable26_6  ;; 0x40023c1c
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x0E09             LSRS     R1,R1,#+24
   \   0000000C   0xF011 0x0180      ANDS     R1,R1,#0x80
   \   00000010   0x8081             STRH     R1,[R0, #+4]
    646          
    647          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    648          }
   \   00000012   0x4770             BX       LR               ;; return
    649          
    650          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    651          
    652          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
    653           || defined(STM32L162xC)
    654          
    655          /**
    656            * @brief  Select the Protection Mode (SPRMOD).
    657            * @note   This function can be used only for STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices
    658            * @note   Once SPRMOD bit is active, unprotection of a protected sector is not possible 
    659            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    660            * @retval HAL status
    661            */
    662          HAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)
    663          {
    664            HAL_StatusTypeDef status = HAL_OK;
    665            uint16_t tmp1 = 0;
    666            uint32_t tmp2 = 0;
    667            uint8_t optiontmp = 0;
    668            uint16_t optiontmp2 = 0;
    669            
    670            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    671            
    672            /* Mask RDP Byte */
    673            optiontmp =  (uint8_t)(*(__IO uint8_t *)(OB_BASE)); 
    674            
    675            /* Update Option Byte */
    676            optiontmp2 = (uint16_t)(OB_PCROP_SELECTED | optiontmp); 
    677            
    678            /* calculate the option byte to write */
    679            tmp1 = (uint16_t)(~(optiontmp2 ));
    680            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)optiontmp2));
    681            
    682            if(status == HAL_OK)
    683            {         
    684              /* Clean the error context */
    685              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    686          
    687              /* program PCRop */
    688              OB->RDP = tmp2;
    689            }
    690            
    691            /* Wait for last operation to be completed */
    692            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    693            
    694            /* Return the Read protection operation Status */
    695            return status;            
    696          }
    697          
    698          /**
    699            * @brief  Deselect the Protection Mode (SPRMOD).
    700            * @note   This function can be used only for STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices
    701            * @note   Once SPRMOD bit is active, unprotection of a protected sector is not possible 
    702            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    703            * @retval HAL status
    704            */
    705          HAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)
    706          {
    707            HAL_StatusTypeDef status = HAL_OK;
    708            uint16_t tmp1 = 0;
    709            uint32_t tmp2 = 0;
    710            uint8_t optiontmp = 0;
    711            uint16_t optiontmp2 = 0;
    712            
    713            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    714            
    715            /* Mask RDP Byte */
    716            optiontmp =  (uint8_t)(*(__IO uint8_t *)(OB_BASE)); 
    717            
    718            /* Update Option Byte */
    719            optiontmp2 = (uint16_t)(OB_PCROP_DESELECTED | optiontmp); 
    720            
    721            /* calculate the option byte to write */
    722            tmp1 = (uint16_t)(~(optiontmp2 ));
    723            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)optiontmp2));
    724            
    725            if(status == HAL_OK)
    726            {         
    727              /* Clean the error context */
    728              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    729          
    730              /* program PCRop */
    731              OB->RDP = tmp2;
    732            }
    733            
    734            /* Wait for last operation to be completed */
    735            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    736            
    737            /* Return the Read protection operation Status */
    738            return status;            
    739          }
    740          
    741          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    742          
    743          /**
    744            * @}
    745            */
    746          
    747          /** @defgroup FLASHEx_Exported_Functions_Group3 DATA EEPROM Programming functions
    748           *  @brief   DATA EEPROM Programming functions
    749           *
    750          @verbatim   
    751           ===============================================================================
    752                               ##### DATA EEPROM Programming functions ##### 
    753           ===============================================================================  
    754           
    755              [..] Any operation of erase or program should follow these steps:
    756              (#) Call the @ref HAL_FLASHEx_DATAEEPROM_Unlock() function to enable the data EEPROM access
    757                  and Flash program erase control register access.
    758              (#) Call the desired function to erase or program data.
    759              (#) Call the @ref HAL_FLASHEx_DATAEEPROM_Lock() to disable the data EEPROM access
    760                  and Flash program erase control register access(recommended
    761                  to protect the DATA_EEPROM against possible unwanted operation).
    762          
    763          @endverbatim
    764            * @{
    765            */
    766          
    767          /**
    768            * @brief  Unlocks the data memory and FLASH_PECR register access.
    769            * @retval HAL_StatusTypeDef HAL Status
    770            */

   \                                 In section .text, align 2, keep-with-next
    771          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Unlock(void)
    772          {
    773            if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
   \                     HAL_FLASHEx_DATAEEPROM_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD50B             BPL.N    ??HAL_FLASHEx_DATAEEPROM_Unlock_0
    774            {  
    775              /* Unlocking the Data memory and FLASH_PECR register access*/
    776              FLASH->PEKEYR = FLASH_PEKEY1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26_7  ;; 0x89abcdef
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable26_8  ;; 0x40023c0c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    777              FLASH->PEKEYR = FLASH_PEKEY2;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable26_9  ;; 0x2030405
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable26_8  ;; 0x40023c0c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    778            }
    779            else
    780            {
    781              return HAL_ERROR;
    782            }
    783            return HAL_OK;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??HAL_FLASHEx_DATAEEPROM_Unlock_1
   \                     ??HAL_FLASHEx_DATAEEPROM_Unlock_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASHEx_DATAEEPROM_Unlock_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    784          }
    785          
    786          /**
    787            * @brief  Locks the Data memory and FLASH_PECR register access.
    788            * @retval HAL_StatusTypeDef HAL Status
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Lock(void)
    791          {
    792            /* Set the PELOCK Bit to lock the data memory and FLASH_PECR register access */
    793            SET_BIT(FLASH->PECR, FLASH_PECR_PELOCK);
   \                     HAL_FLASHEx_DATAEEPROM_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    794            
    795            return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    796          }
    797          
    798          /**
    799            * @brief  Erase a word in data memory.
    800            * @param  Address specifies the address to be erased.
    801            * @param  TypeErase  Indicate the way to erase at a specified address.
    802            *         This parameter can be a value of @ref FLASH_Type_Program
    803            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    804            *         must be called before.
    805            *         Call the DATA_EEPROM_Lock() to the data EEPROM access
    806            *         and Flash program erase control register access(recommended to protect 
    807            *         the DATA_EEPROM against possible unwanted operation).
    808            * @retval HAL_StatusTypeDef HAL Status
    809            */

   \                                 In section .text, align 2, keep-with-next
    810          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Erase(uint32_t TypeErase, uint32_t Address)
    811          {
   \                     HAL_FLASHEx_DATAEEPROM_Erase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    812            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    813            
    814            /* Check the parameters */
    815            assert_param(IS_TYPEPROGRAMDATA(TypeErase));
    816            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    817            
    818            /* Wait for last operation to be completed */
    819            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
    820            
    821            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10F             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_0
    822            {
    823              /* Clean the error context */
    824              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000001E   0x6148             STR      R0,[R1, #+20]
    825          
    826              if(TypeErase == FLASH_TYPEERASEDATA_WORD)
   \   00000020   0x2C02             CMP      R4,#+2
   \   00000022   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_1
    827              {
    828                /* Write 00000000h to valid address in the data memory */
    829                *(__IO uint32_t *) Address = 0x00000000;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6028             STR      R0,[R5, #+0]
    830              }
    831          
    832              if(TypeErase == FLASH_TYPEERASEDATA_HALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_1: (+1)
   \   00000028   0x2C01             CMP      R4,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_2
    833              {
    834                /* Write 0000h to valid address in the data memory */
    835                *(__IO uint16_t *) Address = (uint16_t)0x0000;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    836              }
    837          
    838              if(TypeErase == FLASH_TYPEERASEDATA_BYTE)
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_0
    839              {
    840                /* Write 00h to valid address in the data memory */
    841                *(__IO uint8_t *) Address = (uint8_t)0x00;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7028             STRB     R0,[R5, #+0]
    842              }
    843            }
    844             
    845            /* Return the erase status */
    846            return status;
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_0: (+1)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    847          }  
    848          
    849          /**
    850            * @brief  Program word at a specified address
    851            * @note   To correctly run this function, the HAL_FLASH_EEPROM_Unlock() function
    852            *         must be called before.
    853            *         Call the HAL_FLASHEx_DATAEEPROM_Unlock() to he data EEPROM access
    854            *         and Flash program erase control register access(recommended to protect 
    855            *         the DATA_EEPROM against possible unwanted operation).
    856            * @note   The function  HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram() can be called before 
    857            *         this function to configure the Fixed Time Programming.
    858            * @param  TypeProgram  Indicate the way to program at a specified address.
    859            *         This parameter can be a value of @ref FLASHEx_Type_Program_Data
    860            * @param  Address  specifies the address to be programmed.
    861            * @param  Data specifies the data to be programmed
    862            * 
    863            * @retval HAL_StatusTypeDef HAL Status
    864            */
    865          

   \                                 In section .text, align 2, keep-with-next
    866          HAL_StatusTypeDef   HAL_FLASHEx_DATAEEPROM_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    867          {
   \                     HAL_FLASHEx_DATAEEPROM_Program: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    868            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000008   0x2701             MOVS     R7,#+1
    869            
    870            /* Process Locked */
    871            __HAL_LOCK(&pFlash);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000000E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE043             B.N      ??HAL_FLASHEx_DATAEEPROM_Program_1
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000001E   0x7408             STRB     R0,[R1, #+16]
    872          
    873            /* Check the parameters */
    874            assert_param(IS_TYPEPROGRAMDATA(TypeProgram));
    875          
    876            /* Wait for last operation to be completed */
    877            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0007             MOVS     R7,R0
    878            
    879            if(status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD131             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_2
    880            {
    881              /* Clean the error context */
    882              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000036   0x6148             STR      R0,[R1, #+20]
    883          
    884              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTBYTE)
   \   00000038   0x2C04             CMP      R4,#+4
   \   0000003A   0xD105             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_3
    885              {
    886                /*Program word (8-bit) at a specified address.*/
    887                status = FLASH_DATAEEPROM_FastProgramByte(Address, (uint8_t) Data);
   \   0000003C   0x0031             MOVS     R1,R6
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramByte
   \   00000046   0x0007             MOVS     R7,R0
    888              }
    889              
    890              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTHALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_3: (+1)
   \   00000048   0x2C08             CMP      R4,#+8
   \   0000004A   0xD105             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_4
    891              {
    892                /*Program word (16-bit) at a specified address.*/
    893                status = FLASH_DATAEEPROM_FastProgramHalfWord(Address, (uint16_t) Data);
   \   0000004C   0x0031             MOVS     R1,R6
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramHalfWord
   \   00000056   0x0007             MOVS     R7,R0
    894              }    
    895              
    896              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_4: (+1)
   \   00000058   0x2C10             CMP      R4,#+16
   \   0000005A   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_5
    897              {
    898                /*Program word (32-bit) at a specified address.*/
    899                status = FLASH_DATAEEPROM_FastProgramWord(Address, (uint32_t) Data);
   \   0000005C   0x0031             MOVS     R1,R6
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramWord
   \   00000064   0x0007             MOVS     R7,R0
    900              }
    901              
    902              if(TypeProgram == FLASH_TYPEPROGRAMDATA_WORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_5: (+1)
   \   00000066   0x2C02             CMP      R4,#+2
   \   00000068   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_6
    903              {
    904                /*Program word (32-bit) at a specified address.*/
    905                status = FLASH_DATAEEPROM_ProgramWord(Address, (uint32_t) Data);
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramWord
   \   00000072   0x0007             MOVS     R7,R0
    906              }
    907                 
    908              if(TypeProgram == FLASH_TYPEPROGRAMDATA_HALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_6: (+1)
   \   00000074   0x2C01             CMP      R4,#+1
   \   00000076   0xD105             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_7
    909              {
    910                /*Program word (16-bit) at a specified address.*/
    911                status = FLASH_DATAEEPROM_ProgramHalfWord(Address, (uint16_t) Data);
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramHalfWord
   \   00000082   0x0007             MOVS     R7,R0
    912              }
    913                  
    914              if(TypeProgram == FLASH_TYPEPROGRAMDATA_BYTE)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_7: (+1)
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD105             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_2
    915              {
    916                /*Program word (8-bit) at a specified address.*/
    917                status = FLASH_DATAEEPROM_ProgramByte(Address, (uint8_t) Data);
   \   00000088   0x0031             MOVS     R1,R6
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramByte
   \   00000092   0x0007             MOVS     R7,R0
    918              }
    919            }
    920            
    921            /* Process Unlocked */
    922            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_2: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000009A   0x7408             STRB     R0,[R1, #+16]
    923          
    924            return status;
   \   0000009C   0x0038             MOVS     R0,R7
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_1: (+1)
   \   000000A0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    925          }
    926          
    927          /**
    928            * @brief  Enable DATA EEPROM fixed Time programming (2*Tprog).
    929            * @retval None
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          void HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram(void)
    932          {
    933            SET_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \                     HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    934          }
   \   00000010   0x4770             BX       LR               ;; return
    935          
    936          /**
    937            * @brief  Disables DATA EEPROM fixed Time programming (2*Tprog).
    938            * @retval None
    939            */

   \                                 In section .text, align 2, keep-with-next
    940          void HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram(void)
    941          {
    942            CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \                     HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    943          }
   \   00000010   0x4770             BX       LR               ;; return
    944          
    945          /**
    946            * @}
    947            */
    948          
    949          /**
    950            * @}
    951            */
    952          
    953          /** @addtogroup FLASHEx_Private_Functions
    954           * @{
    955           */
    956          
    957          /*
    958          ==============================================================================
    959                        OPTIONS BYTES
    960          ==============================================================================
    961          */
    962          /**
    963            * @brief  Enables or disables the read out protection.
    964            * @note   To correctly run this function, the HAL_FLASH_OB_Unlock() function
    965            *         must be called before.
    966            * @param  OB_RDP specifies the read protection level. 
    967            *   This parameter can be:
    968            *     @arg @ref OB_RDP_LEVEL_0 No protection
    969            *     @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
    970            *     @arg @ref OB_RDP_LEVEL_2 Chip protection
    971            * 
    972            *  !!!Warning!!! When enabling OB_RDP_LEVEL_2 it's no more possible to go back to level 1 or 0
    973            *   
    974            * @retval HAL status
    975            */

   \                                 In section .text, align 2, keep-with-next
    976          static HAL_StatusTypeDef FLASH_OB_RDPConfig(uint8_t OB_RDP)
    977          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    978            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    979            uint32_t tmp1 = 0, tmp2 = 0, sprmod = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    980            
    981            /* Check the parameters */
    982            assert_param(IS_OB_RDP(OB_RDP));
    983            
    984            /* According to errata sheet, DocID022054 Rev 5, par2.1.5
    985            Before setting Level0 in the RDP register, check that the current level is not equal to Level0.
    986            If the current level is not equal to Level0, Level0 can be activated.
    987            If the current level is Level0 then the RDP register must not be written again with Level0. */
    988            tmp1 = (uint32_t)(OB->RDP & 0x000000FF);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_10  ;; 0x1ff80000
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000001A   0x0006             MOVS     R6,R0
    989            
    990            if ((tmp1 == OB_RDP_LEVEL_0) && (OB_RDP == OB_RDP_LEVEL_0))
   \   0000001C   0x2EAA             CMP      R6,#+170
   \   0000001E   0xD105             BNE.N    ??FLASH_OB_RDPConfig_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2CAA             CMP      R4,#+170
   \   00000024   0xD102             BNE.N    ??FLASH_OB_RDPConfig_0
    991            {
    992              /*current level is Level0 then the RDP register must not be written again with Level0. */
    993              status = HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE024             B.N      ??FLASH_OB_RDPConfig_1
    994            }
    995            else 
    996            {
    997              /* Clean the error context */
    998              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000032   0x6148             STR      R0,[R1, #+20]
    999          
   1000              /* Mask SPRMOD bit */
   1001              sprmod = (uint32_t)(OB->RDP & 0x00000100);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable26_10  ;; 0x1ff80000
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000003E   0x4680             MOV      R8,R0
   1002          
   1003              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000040   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000044   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000048   0x0005             MOVS     R5,R0
   1004              
   1005              /* calculate the option byte to write */
   1006              tmp1 = (~((uint32_t)(OB_RDP | sprmod)));
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0xEA58 0x0004      ORRS     R0,R8,R4
   \   00000050   0x43C0             MVNS     R0,R0
   \   00000052   0x0006             MOVS     R6,R0
   1007              tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)(OB_RDP | sprmod)));
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xEA54 0x4006      ORRS     R0,R4,R6, LSL #+16
   \   0000005A   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000005E   0x0007             MOVS     R7,R0
   1008              
   1009              if(status == HAL_OK)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD102             BNE.N    ??FLASH_OB_RDPConfig_2
   1010              {         
   1011               /* program read protection level */
   1012                OB->RDP = tmp2;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable26_10  ;; 0x1ff80000
   \   0000006A   0x6007             STR      R7,[R0, #+0]
   1013              }
   1014              
   1015              /* Wait for last operation to be completed */
   1016              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_RDPConfig_2: (+1)
   \   0000006C   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000070   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000074   0x0005             MOVS     R5,R0
   1017            }
   1018               
   1019            /* Return the Read protection operation Status */
   1020            return status;            
   \                     ??FLASH_OB_RDPConfig_1: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1021          }
   1022          
   1023          /**
   1024            * @brief  Programs the FLASH brownout reset threshold level Option Byte.
   1025            * @param  OB_BOR Selects the brownout reset threshold level.
   1026            *   This parameter can be one of the following values:
   1027            *     @arg @ref OB_BOR_OFF BOR is disabled at power down, the reset is asserted when the VDD 
   1028            *                      power supply reaches the PDR(Power Down Reset) threshold (1.5V)
   1029            *     @arg @ref OB_BOR_LEVEL1 BOR Reset threshold levels for 1.7V - 1.8V VDD power supply
   1030            *     @arg @ref OB_BOR_LEVEL2 BOR Reset threshold levels for 1.9V - 2.0V VDD power supply
   1031            *     @arg @ref OB_BOR_LEVEL3 BOR Reset threshold levels for 2.3V - 2.4V VDD power supply
   1032            *     @arg @ref OB_BOR_LEVEL4 BOR Reset threshold levels for 2.55V - 2.65V VDD power supply
   1033            *     @arg @ref OB_BOR_LEVEL5 BOR Reset threshold levels for 2.8V - 2.9V VDD power supply
   1034            * @retval HAL status
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          static HAL_StatusTypeDef FLASH_OB_BORConfig(uint8_t OB_BOR)
   1037          {
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1038            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1039            uint32_t tmp = 0, tmp1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1040          
   1041            /* Check the parameters */
   1042            assert_param(IS_OB_BOR_LEVEL(OB_BOR));
   1043          
   1044            /* Get the User Option byte register */
   1045            tmp1 = (FLASH->OBR & (FLASH_OBR_USER)) >> 16;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40023c1c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000016   0x0007             MOVS     R7,R0
   1046               
   1047            /* Calculate the option byte to write - [0xFF | nUSER | 0x00 | USER]*/
   1048            tmp = (uint32_t)~((OB_BOR | tmp1)) << 16;
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000001E   0x43C0             MVNS     R0,R0
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0x0006             MOVS     R6,R0
   1049            tmp |= (OB_BOR | tmp1);
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000002A   0x4306             ORRS     R6,R0,R6
   1050              
   1051            /* Wait for last operation to be completed */
   1052            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000002C   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0005             MOVS     R5,R0
   1053            
   1054            if(status == HAL_OK)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD106             BNE.N    ??FLASH_OB_BORConfig_0
   1055            {  
   1056              /* Clean the error context */
   1057              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000042   0x6148             STR      R0,[R1, #+20]
   1058          
   1059              /* Write the BOR Option Byte */            
   1060              OB->USER = tmp; 
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable26_11  ;; 0x1ff80004
   \   00000048   0x6006             STR      R6,[R0, #+0]
   1061            }
   1062            
   1063            /* Wait for last operation to be completed */
   1064            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_BORConfig_0: (+1)
   \   0000004A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000004E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000052   0x0005             MOVS     R5,R0
   1065                  
   1066            /* Return the Option Byte program Status */
   1067            return status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1068          }
   1069          
   1070          /**
   1071            * @brief  Returns the FLASH User Option Bytes values.
   1072            * @retval The FLASH User Option Bytes.
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          static uint8_t FLASH_OB_GetUser(void)
   1075          {
   1076            /* Return the User Option Byte */
   1077            return (uint8_t)((FLASH->OBR & FLASH_OBR_USER) >> POSITION_VAL(FLASH_OBR_USER));
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x0070      ANDS     R0,R0,#0xF00000
   \   0000000A   0xF44F 0x6170      MOV      R1,#+3840
   \   0000000E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
   1078          }
   1079          
   1080          /**
   1081            * @brief  Checks whether the FLASH Read out Protection Status is set or not.
   1082            * @retval FLASH ReadOut Protection Status:
   1083            *         This parameter can be one of the following values:
   1084            *            @arg @ref OB_RDP_LEVEL_0 No protection
   1085            *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
   1086            *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
   1087            */

   \                                 In section .text, align 2, keep-with-next
   1088          static uint8_t FLASH_OB_GetRDP(void)
   1089          {
   1090            return (uint8_t)(FLASH->OBR & FLASH_OBR_RDPRT);
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
   1091          }
   1092          
   1093          /**
   1094            * @brief  Returns the FLASH BOR level.
   1095            * @retval The FLASH User Option Bytes.
   1096            */

   \                                 In section .text, align 2, keep-with-next
   1097          static uint8_t FLASH_OB_GetBOR(void)
   1098          {
   1099            /* Return the BOR level */
   1100            return (uint8_t)((FLASH->OBR & (uint32_t)FLASH_OBR_BOR_LEV) >> POSITION_VAL(FLASH_OBR_BOR_LEV));
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_6  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x2070      ANDS     R0,R0,#0xF0000
   \   0000000A   0xF44F 0x4170      MOV      R1,#+61440
   \   0000000E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
   1101          }
   1102          
   1103          /**
   1104            * @brief  Write protects the desired pages of the first 64KB of the Flash.
   1105            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
   1106            *         contains WRP parameters.
   1107            * @param  NewState new state of the specified FLASH Pages Wtite protection.
   1108            *   This parameter can be: ENABLE or DISABLE.
   1109            * @retval HAL_StatusTypeDef
   1110            */

   \                                 In section .text, align 2, keep-with-next
   1111          static HAL_StatusTypeDef FLASH_OB_WRPConfig(FLASH_OBProgramInitTypeDef *pOBInit, FunctionalState NewState)
   1112          {
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1113            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1114            
   1115            /* Wait for last operation to be completed */
   1116            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1117           
   1118            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD128             BNE.N    ??FLASH_OB_WRPConfig_0
   1119            {
   1120              /* Clean the error context */
   1121              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000001E   0x6148             STR      R0,[R1, #+20]
   1122          
   1123              /* WRP for sector between 0 to 31 */
   1124              if (pOBInit->WRPSector0To31 != 0)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_1
   1125              {
   1126                FLASH_OB_WRPConfigWRP1OrPCROP1(pOBInit->WRPSector0To31, NewState);
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x.... 0x....      BL       FLASH_OB_WRPConfigWRP1OrPCROP1
   1127              }
   1128              
   1129          #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)    \
   1130           || defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xCA) \
   1131           || defined(STM32L152xD) || defined(STM32L152xDX) || defined(STM32L162xCA) || defined(STM32L162xD)  \
   1132           || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE)
   1133                
   1134              /* Pages for Cat3, Cat4 & Cat5 devices*/
   1135              /* WRP for sector between 32 to 63 */
   1136              if (pOBInit->WRPSector32To63 != 0)
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_2
   1137              {
   1138                FLASH_OB_WRPConfigWRP2OrPCROP2(pOBInit->WRPSector32To63, NewState);
   \   00000036   0x0029             MOVS     R1,R5
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x.... 0x....      BL       FLASH_OB_WRPConfigWRP2OrPCROP2
   1139              }
   1140              
   1141          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1142          
   1143          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
   1144           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
   1145           || defined(STM32L162xE)
   1146                
   1147              /* Pages for devices with FLASH >= 256KB*/
   1148              /* WRP for sector between 64 to 95 */
   1149              if (pOBInit->WRPSector64To95 != 0)
   \                     ??FLASH_OB_WRPConfig_2: (+1)
   \   00000040   0x6920             LDR      R0,[R4, #+16]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_3
   1150              {
   1151                FLASH_OB_WRPConfigWRP3(pOBInit->WRPSector64To95, NewState);
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004A   0x6920             LDR      R0,[R4, #+16]
   \   0000004C   0x.... 0x....      BL       FLASH_OB_WRPConfigWRP3
   1152              }
   1153              
   1154          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1155          
   1156          #if defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE) || defined(STM32L151xDX) \
   1157           || defined(STM32L152xDX) || defined(STM32L162xDX)
   1158          
   1159              /* Pages for Cat5 devices*/
   1160              /* WRP for sector between 96 to 127 */
   1161              if (pOBInit->WRPSector96To127 != 0)
   \                     ??FLASH_OB_WRPConfig_3: (+1)
   \   00000050   0x6960             LDR      R0,[R4, #+20]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_4
   1162              {
   1163                FLASH_OB_WRPConfigWRP4(pOBInit->WRPSector96To127, NewState);
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x6960             LDR      R0,[R4, #+20]
   \   0000005C   0x.... 0x....      BL       FLASH_OB_WRPConfigWRP4
   1164              }
   1165              
   1166          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
   1167          
   1168              /* Wait for last operation to be completed */
   1169              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_WRPConfig_4: (+1)
   \   00000060   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000064   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000068   0x0006             MOVS     R6,R0
   1170            }
   1171          
   1172            /* Return the write protection operation Status */
   1173            return status;      
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
   1174          }
   1175          
   1176          #if defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L151xC) || defined(STM32L152xC) \
   1177           || defined(STM32L162xC)
   1178          /**
   1179            * @brief  Enables the read/write protection (PCROP) of the desired 
   1180            *         sectors.
   1181            * @note   This function can be used only for Cat2 & Cat3 devices
   1182            * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
   1183            *         contains PCROP parameters.
   1184            * @param  NewState new state of the specified FLASH Pages read/Write protection.
   1185            *   This parameter can be: ENABLE or DISABLE.
   1186            * @retval HAL status
   1187            */
   1188          static HAL_StatusTypeDef FLASH_OB_PCROPConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit, FunctionalState NewState)
   1189          {
   1190            HAL_StatusTypeDef status = HAL_OK;
   1191            FunctionalState pcropstate = DISABLE;
   1192            
   1193            /* Wait for last operation to be completed */
   1194            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1195            
   1196            /* Invert state to use same function of WRP */
   1197            if (NewState == DISABLE)
   1198            {
   1199              pcropstate = ENABLE;
   1200            }
   1201                  
   1202            if(status == HAL_OK)
   1203            {
   1204              /* Clean the error context */
   1205              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   1206          
   1207              /* Pages for Cat2 devices*/
   1208              /* PCROP for sector between 0 to 31 */
   1209              if (pAdvOBInit->PCROPSector0To31 != 0)
   1210              {
   1211                FLASH_OB_WRPConfigWRP1OrPCROP1(pAdvOBInit->PCROPSector0To31, pcropstate);
   1212              }
   1213              
   1214          #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)
   1215          
   1216              /* Pages for Cat3 devices*/
   1217              /* WRP for sector between 32 to 63 */
   1218              if (pAdvOBInit->PCROPSector32To63 != 0)
   1219              {
   1220                FLASH_OB_WRPConfigWRP2OrPCROP2(pAdvOBInit->PCROPSector32To63, pcropstate);
   1221              }
   1222              
   1223          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || STM32L162xC  */
   1224              
   1225              /* Wait for last operation to be completed */
   1226              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1227            }
   1228          
   1229            /* Return the write protection operation Status */
   1230            return status;      
   1231          }
   1232          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
   1233          
   1234          /**
   1235            * @brief  Write protects the desired pages of the first 128KB of the Flash.
   1236            * @param  WRP1OrPCROP1 specifies the address of the pages to be write protected.
   1237            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection1
   1238            * @param  NewState new state of the specified FLASH Pages Write protection.
   1239            *   This parameter can be: ENABLE or DISABLE.
   1240            * @retval None
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          static void FLASH_OB_WRPConfigWRP1OrPCROP1(uint32_t WRP1OrPCROP1, FunctionalState NewState)
   1243          {
   \                     FLASH_OB_WRPConfigWRP1OrPCROP1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1244            uint32_t wrp01data = 0, wrp23data = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1245            
   1246            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1247            
   1248            if (NewState != DISABLE)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD01B             BEQ.N    ??FLASH_OB_WRPConfigWRP1OrPCROP1_0
   1249            {
   1250              wrp01data = (uint16_t)(((WRP1OrPCROP1 & WRP_MASK_LOW) | OB->WRP01));
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable26_12  ;; 0x1ff80008
   \   00000014   0x6836             LDR      R6,[R6, #+0]
   \   00000016   0x4306             ORRS     R6,R6,R0
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x0032             MOVS     R2,R6
   1251              wrp23data = (uint16_t)((((WRP1OrPCROP1 & WRP_MASK_HIGH)>>16 | OB->WRP23))); 
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable26_13  ;; 0x1ff8000c
   \   00000020   0x6836             LDR      R6,[R6, #+0]
   \   00000022   0xEA56 0x4610      ORRS     R6,R6,R0, LSR #+16
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x0033             MOVS     R3,R6
   1252              tmp1 = (uint32_t)(~(wrp01data) << 16)|(wrp01data);
   \   0000002A   0x43D6             MVNS     R6,R2
   \   0000002C   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000030   0x0034             MOVS     R4,R6
   1253              OB->WRP01 = tmp1;
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable26_12  ;; 0x1ff80008
   \   00000036   0x6034             STR      R4,[R6, #+0]
   1254          
   1255              tmp2 = (uint32_t)(~(wrp23data) << 16)|(wrp23data);
   \   00000038   0x43DE             MVNS     R6,R3
   \   0000003A   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   0000003E   0x0035             MOVS     R5,R6
   1256              OB->WRP23 = tmp2;      
   \   00000040   0x.... 0x....      LDR.W    R6,??DataTable26_13  ;; 0x1ff8000c
   \   00000044   0x6035             STR      R5,[R6, #+0]
   \   00000046   0xE01F             B.N      ??FLASH_OB_WRPConfigWRP1OrPCROP1_1
   1257            }
   1258            else
   1259            {
   1260              wrp01data = (uint16_t)(~WRP1OrPCROP1 & (WRP_MASK_LOW & OB->WRP01));
   \                     ??FLASH_OB_WRPConfigWRP1OrPCROP1_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R6,??DataTable26_12  ;; 0x1ff80008
   \   0000004C   0x6836             LDR      R6,[R6, #+0]
   \   0000004E   0x4386             BICS     R6,R6,R0
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x0032             MOVS     R2,R6
   1261              wrp23data = (uint16_t)((((~WRP1OrPCROP1 & WRP_MASK_HIGH)>>16 & OB->WRP23))); 
   \   00000054   0xF3C0 0x460F      UBFX     R6,R0,#+16,#+16
   \   00000058   0xF486 0x467F      EOR      R6,R6,#0xFF00
   \   0000005C   0xF096 0x06FF      EORS     R6,R6,#0xFF
   \   00000060   0x.... 0x....      LDR.W    R7,??DataTable26_13  ;; 0x1ff8000c
   \   00000064   0x683F             LDR      R7,[R7, #+0]
   \   00000066   0x403E             ANDS     R6,R7,R6
   \   00000068   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006A   0x0033             MOVS     R3,R6
   1262          
   1263              tmp1 = (uint32_t)((~wrp01data) << 16)|(wrp01data);
   \   0000006C   0x43D6             MVNS     R6,R2
   \   0000006E   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000072   0x0034             MOVS     R4,R6
   1264              OB->WRP01 = tmp1;
   \   00000074   0x.... 0x....      LDR.W    R6,??DataTable26_12  ;; 0x1ff80008
   \   00000078   0x6034             STR      R4,[R6, #+0]
   1265              
   1266              tmp2 = (uint32_t)((~wrp23data) << 16)|(wrp23data);
   \   0000007A   0x43DE             MVNS     R6,R3
   \   0000007C   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000080   0x0035             MOVS     R5,R6
   1267              OB->WRP23 = tmp2;
   \   00000082   0x.... 0x....      LDR.W    R6,??DataTable26_13  ;; 0x1ff8000c
   \   00000086   0x6035             STR      R5,[R6, #+0]
   1268            }
   1269          }
   \                     ??FLASH_OB_WRPConfigWRP1OrPCROP1_1: (+1)
   \   00000088   0xBCF0             POP      {R4-R7}
   \   0000008A   0x4770             BX       LR               ;; return
   1270          
   1271          #if defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC)    \
   1272           || defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xCA) \
   1273           || defined(STM32L152xD) || defined(STM32L152xDX) || defined(STM32L162xCA) || defined(STM32L162xD)  \
   1274           || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE)
   1275          /**
   1276            * @brief  Enable Write protects the desired pages of the second 128KB of the Flash.
   1277            * @note   This function can be used only for Cat3, Cat4  & Cat5 devices.
   1278            * @param  WRP2OrPCROP2 specifies the address of the pages to be write protected.
   1279            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection2
   1280            * @param  NewState new state of the specified FLASH Pages Wtite protection.
   1281            *   This parameter can be: ENABLE or DISABLE.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2, keep-with-next
   1284          static void FLASH_OB_WRPConfigWRP2OrPCROP2(uint32_t WRP2OrPCROP2, FunctionalState NewState)
   1285          {
   \                     FLASH_OB_WRPConfigWRP2OrPCROP2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1286            uint32_t wrp45data = 0, wrp67data = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1287            
   1288            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1289            
   1290            if (NewState != DISABLE)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD01B             BEQ.N    ??FLASH_OB_WRPConfigWRP2OrPCROP2_0
   1291            {
   1292              wrp45data = (uint16_t)(((WRP2OrPCROP2 & WRP_MASK_LOW) | OB->WRP45));
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable26_14  ;; 0x1ff80010
   \   00000014   0x6836             LDR      R6,[R6, #+0]
   \   00000016   0x4306             ORRS     R6,R6,R0
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x0032             MOVS     R2,R6
   1293              wrp67data = (uint16_t)((((WRP2OrPCROP2 & WRP_MASK_HIGH)>>16 | OB->WRP67))); 
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable26_15  ;; 0x1ff80014
   \   00000020   0x6836             LDR      R6,[R6, #+0]
   \   00000022   0xEA56 0x4610      ORRS     R6,R6,R0, LSR #+16
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x0033             MOVS     R3,R6
   1294              tmp1 = (uint32_t)(~(wrp45data) << 16)|(wrp45data);
   \   0000002A   0x43D6             MVNS     R6,R2
   \   0000002C   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000030   0x0034             MOVS     R4,R6
   1295              OB->WRP45 = tmp1;
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable26_14  ;; 0x1ff80010
   \   00000036   0x6034             STR      R4,[R6, #+0]
   1296              
   1297              tmp2 = (uint32_t)(~(wrp67data) << 16)|(wrp67data);
   \   00000038   0x43DE             MVNS     R6,R3
   \   0000003A   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   0000003E   0x0035             MOVS     R5,R6
   1298              OB->WRP67 = tmp2;
   \   00000040   0x.... 0x....      LDR.W    R6,??DataTable26_15  ;; 0x1ff80014
   \   00000044   0x6035             STR      R5,[R6, #+0]
   \   00000046   0xE01B             B.N      ??FLASH_OB_WRPConfigWRP2OrPCROP2_1
   1299            }
   1300            else
   1301            {
   1302              wrp45data = (uint16_t)(~WRP2OrPCROP2 & (WRP_MASK_LOW & OB->WRP45));
   \                     ??FLASH_OB_WRPConfigWRP2OrPCROP2_0: (+1)
   \   00000048   0x....             LDR.N    R6,??DataTable26_14  ;; 0x1ff80010
   \   0000004A   0x6836             LDR      R6,[R6, #+0]
   \   0000004C   0x4386             BICS     R6,R6,R0
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0x0032             MOVS     R2,R6
   1303              wrp67data = (uint16_t)((((~WRP2OrPCROP2 & WRP_MASK_HIGH)>>16 & OB->WRP67))); 
   \   00000052   0xF3C0 0x460F      UBFX     R6,R0,#+16,#+16
   \   00000056   0xF486 0x467F      EOR      R6,R6,#0xFF00
   \   0000005A   0xF096 0x06FF      EORS     R6,R6,#0xFF
   \   0000005E   0x....             LDR.N    R7,??DataTable26_15  ;; 0x1ff80014
   \   00000060   0x683F             LDR      R7,[R7, #+0]
   \   00000062   0x403E             ANDS     R6,R7,R6
   \   00000064   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   0x0033             MOVS     R3,R6
   1304              
   1305              tmp1 = (uint32_t)((~wrp45data) << 16)|(wrp45data);
   \   00000068   0x43D6             MVNS     R6,R2
   \   0000006A   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   0000006E   0x0034             MOVS     R4,R6
   1306              OB->WRP45 = tmp1;
   \   00000070   0x....             LDR.N    R6,??DataTable26_14  ;; 0x1ff80010
   \   00000072   0x6034             STR      R4,[R6, #+0]
   1307              
   1308              tmp2 = (uint32_t)((~wrp67data) << 16)|(wrp67data);
   \   00000074   0x43DE             MVNS     R6,R3
   \   00000076   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   0000007A   0x0035             MOVS     R5,R6
   1309              OB->WRP67 = tmp2;
   \   0000007C   0x....             LDR.N    R6,??DataTable26_15  ;; 0x1ff80014
   \   0000007E   0x6035             STR      R5,[R6, #+0]
   1310            }
   1311          }
   \                     ??FLASH_OB_WRPConfigWRP2OrPCROP2_1: (+1)
   \   00000080   0xBCF0             POP      {R4-R7}
   \   00000082   0x4770             BX       LR               ;; return
   1312          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1313          
   1314          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
   1315           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
   1316           || defined(STM32L162xE)
   1317          /**
   1318            * @brief  Enable Write protects the desired pages of the third 128KB of the Flash.
   1319            * @note   This function can be used only for STM32L151xD, STM32L152xD, STM32L162xD  & Cat5 devices.
   1320            * @param  WRP3 specifies the address of the pages to be write protected.
   1321            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection3
   1322            * @param  NewState new state of the specified FLASH Pages Wtite protection.
   1323            *   This parameter can be: ENABLE or DISABLE.
   1324            * @retval None
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          static void FLASH_OB_WRPConfigWRP3(uint32_t WRP3, FunctionalState NewState)
   1327          {
   \                     FLASH_OB_WRPConfigWRP3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1328            uint32_t wrp89data = 0, wrp1011data = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1329            
   1330            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1331            
   1332            if (NewState != DISABLE)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD017             BEQ.N    ??FLASH_OB_WRPConfigWRP3_0
   1333            {
   1334              wrp89data = (uint16_t)(((WRP3 & WRP_MASK_LOW) | OB->WRP89));
   \   00000010   0x....             LDR.N    R6,??DataTable26_16  ;; 0x1ff80018
   \   00000012   0x6836             LDR      R6,[R6, #+0]
   \   00000014   0x4306             ORRS     R6,R6,R0
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x0032             MOVS     R2,R6
   1335              wrp1011data = (uint16_t)((((WRP3 & WRP_MASK_HIGH)>>16 | OB->WRP1011))); 
   \   0000001A   0x....             LDR.N    R6,??DataTable26_17  ;; 0x1ff8001c
   \   0000001C   0x6836             LDR      R6,[R6, #+0]
   \   0000001E   0xEA56 0x4610      ORRS     R6,R6,R0, LSR #+16
   \   00000022   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000024   0x0033             MOVS     R3,R6
   1336              tmp1 = (uint32_t)(~(wrp89data) << 16)|(wrp89data);
   \   00000026   0x43D6             MVNS     R6,R2
   \   00000028   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   0000002C   0x0034             MOVS     R4,R6
   1337              OB->WRP89 = tmp1;
   \   0000002E   0x....             LDR.N    R6,??DataTable26_16  ;; 0x1ff80018
   \   00000030   0x6034             STR      R4,[R6, #+0]
   1338          
   1339              tmp2 = (uint32_t)(~(wrp1011data) << 16)|(wrp1011data);
   \   00000032   0x43DE             MVNS     R6,R3
   \   00000034   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000038   0x0035             MOVS     R5,R6
   1340              OB->WRP1011 = tmp2;      
   \   0000003A   0x....             LDR.N    R6,??DataTable26_17  ;; 0x1ff8001c
   \   0000003C   0x6035             STR      R5,[R6, #+0]
   \   0000003E   0xE01B             B.N      ??FLASH_OB_WRPConfigWRP3_1
   1341            }
   1342            else
   1343            {
   1344              wrp89data = (uint16_t)(~WRP3 & (WRP_MASK_LOW & OB->WRP89));
   \                     ??FLASH_OB_WRPConfigWRP3_0: (+1)
   \   00000040   0x....             LDR.N    R6,??DataTable26_16  ;; 0x1ff80018
   \   00000042   0x6836             LDR      R6,[R6, #+0]
   \   00000044   0x4386             BICS     R6,R6,R0
   \   00000046   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000048   0x0032             MOVS     R2,R6
   1345              wrp1011data = (uint16_t)((((~WRP3 & WRP_MASK_HIGH)>>16 & OB->WRP1011))); 
   \   0000004A   0xF3C0 0x460F      UBFX     R6,R0,#+16,#+16
   \   0000004E   0xF486 0x467F      EOR      R6,R6,#0xFF00
   \   00000052   0xF096 0x06FF      EORS     R6,R6,#0xFF
   \   00000056   0x....             LDR.N    R7,??DataTable26_17  ;; 0x1ff8001c
   \   00000058   0x683F             LDR      R7,[R7, #+0]
   \   0000005A   0x403E             ANDS     R6,R7,R6
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0x0033             MOVS     R3,R6
   1346          
   1347              tmp1 = (uint32_t)((~wrp89data) << 16)|(wrp89data);
   \   00000060   0x43D6             MVNS     R6,R2
   \   00000062   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000066   0x0034             MOVS     R4,R6
   1348              OB->WRP89 = tmp1;
   \   00000068   0x....             LDR.N    R6,??DataTable26_16  ;; 0x1ff80018
   \   0000006A   0x6034             STR      R4,[R6, #+0]
   1349          
   1350              tmp2 = (uint32_t)((~wrp1011data) << 16)|(wrp1011data);
   \   0000006C   0x43DE             MVNS     R6,R3
   \   0000006E   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000072   0x0035             MOVS     R5,R6
   1351              OB->WRP1011 = tmp2;
   \   00000074   0x....             LDR.N    R6,??DataTable26_17  ;; 0x1ff8001c
   \   00000076   0x6035             STR      R5,[R6, #+0]
   1352            }
   1353          }
   \                     ??FLASH_OB_WRPConfigWRP3_1: (+1)
   \   00000078   0xBCF0             POP      {R4-R7}
   \   0000007A   0x4770             BX       LR               ;; return
   1354          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1355          
   1356          #if defined(STM32L151xE) || defined(STM32L152xE) || defined(STM32L162xE) || defined(STM32L151xDX) \
   1357           || defined(STM32L152xDX) || defined(STM32L162xDX)
   1358          /**
   1359            * @brief  Enable Write protects the desired pages of the Fourth 128KB of the Flash.
   1360            * @note   This function can be used only for Cat5 & STM32L1xxDX devices.
   1361            * @param  WRP4 specifies the address of the pages to be write protected.
   1362            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection4
   1363            * @param  NewState new state of the specified FLASH Pages Wtite protection.
   1364            *   This parameter can be: ENABLE or DISABLE.
   1365            * @retval None
   1366            */

   \                                 In section .text, align 2, keep-with-next
   1367          static void FLASH_OB_WRPConfigWRP4(uint32_t WRP4, FunctionalState NewState)
   1368          {
   \                     FLASH_OB_WRPConfigWRP4: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1369            uint32_t wrp1213data = 0, wrp1415data = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1370            
   1371            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1372            
   1373            if (NewState != DISABLE)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD017             BEQ.N    ??FLASH_OB_WRPConfigWRP4_0
   1374            {
   1375              wrp1213data = (uint16_t)(((WRP4 & WRP_MASK_LOW) | OB->WRP1213));
   \   00000010   0x....             LDR.N    R6,??DataTable26_18  ;; 0x1ff80080
   \   00000012   0x6836             LDR      R6,[R6, #+0]
   \   00000014   0x4306             ORRS     R6,R6,R0
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x0032             MOVS     R2,R6
   1376              wrp1415data = (uint16_t)((((WRP4 & WRP_MASK_HIGH)>>16 | OB->WRP1415))); 
   \   0000001A   0x....             LDR.N    R6,??DataTable26_19  ;; 0x1ff80084
   \   0000001C   0x6836             LDR      R6,[R6, #+0]
   \   0000001E   0xEA56 0x4610      ORRS     R6,R6,R0, LSR #+16
   \   00000022   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000024   0x0033             MOVS     R3,R6
   1377              tmp1 = (uint32_t)(~(wrp1213data) << 16)|(wrp1213data);
   \   00000026   0x43D6             MVNS     R6,R2
   \   00000028   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   0000002C   0x0034             MOVS     R4,R6
   1378              OB->WRP1213 = tmp1;
   \   0000002E   0x....             LDR.N    R6,??DataTable26_18  ;; 0x1ff80080
   \   00000030   0x6034             STR      R4,[R6, #+0]
   1379          
   1380              tmp2 = (uint32_t)(~(wrp1415data) << 16)|(wrp1415data);
   \   00000032   0x43DE             MVNS     R6,R3
   \   00000034   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000038   0x0035             MOVS     R5,R6
   1381              OB->WRP1415 = tmp2;      
   \   0000003A   0x....             LDR.N    R6,??DataTable26_19  ;; 0x1ff80084
   \   0000003C   0x6035             STR      R5,[R6, #+0]
   \   0000003E   0xE01B             B.N      ??FLASH_OB_WRPConfigWRP4_1
   1382            }
   1383            else
   1384            {
   1385              wrp1213data = (uint16_t)(~WRP4 & (WRP_MASK_LOW & OB->WRP1213));
   \                     ??FLASH_OB_WRPConfigWRP4_0: (+1)
   \   00000040   0x....             LDR.N    R6,??DataTable26_18  ;; 0x1ff80080
   \   00000042   0x6836             LDR      R6,[R6, #+0]
   \   00000044   0x4386             BICS     R6,R6,R0
   \   00000046   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000048   0x0032             MOVS     R2,R6
   1386              wrp1415data = (uint16_t)((((~WRP4 & WRP_MASK_HIGH)>>16 & OB->WRP1415))); 
   \   0000004A   0xF3C0 0x460F      UBFX     R6,R0,#+16,#+16
   \   0000004E   0xF486 0x467F      EOR      R6,R6,#0xFF00
   \   00000052   0xF096 0x06FF      EORS     R6,R6,#0xFF
   \   00000056   0x....             LDR.N    R7,??DataTable26_19  ;; 0x1ff80084
   \   00000058   0x683F             LDR      R7,[R7, #+0]
   \   0000005A   0x403E             ANDS     R6,R7,R6
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0x0033             MOVS     R3,R6
   1387          
   1388              tmp1 = (uint32_t)((~wrp1213data) << 16)|(wrp1213data);
   \   00000060   0x43D6             MVNS     R6,R2
   \   00000062   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000066   0x0034             MOVS     R4,R6
   1389              OB->WRP1213 = tmp1;
   \   00000068   0x....             LDR.N    R6,??DataTable26_18  ;; 0x1ff80080
   \   0000006A   0x6034             STR      R4,[R6, #+0]
   1390          
   1391              tmp2 = (uint32_t)((~wrp1415data) << 16)|(wrp1415data);
   \   0000006C   0x43DE             MVNS     R6,R3
   \   0000006E   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000072   0x0035             MOVS     R5,R6
   1392              OB->WRP1415 = tmp2;
   \   00000074   0x....             LDR.N    R6,??DataTable26_19  ;; 0x1ff80084
   \   00000076   0x6035             STR      R5,[R6, #+0]
   1393            }
   1394          }
   \                     ??FLASH_OB_WRPConfigWRP4_1: (+1)
   \   00000078   0xBCF0             POP      {R4-R7}
   \   0000007A   0x4770             BX       LR               ;; return
   1395          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
   1396          
   1397          /**
   1398            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1399            * @param  OB_IWDG Selects the WDG mode.
   1400            *   This parameter can be one of the following values:
   1401            *     @arg @ref OB_IWDG_SW Software WDG selected
   1402            *     @arg @ref OB_IWDG_HW Hardware WDG selected
   1403            * @param  OB_STOP Reset event when entering STOP mode.
   1404            *   This parameter can be one of the following values:
   1405            *     @arg @ref OB_STOP_NORST No reset generated when entering in STOP
   1406            *     @arg @ref OB_STOP_RST Reset generated when entering in STOP
   1407            * @param  OB_STDBY Reset event when entering Standby mode.
   1408            *   This parameter can be one of the following values:
   1409            *     @arg @ref OB_STDBY_NORST No reset generated when entering in STANDBY
   1410            *     @arg @ref OB_STDBY_RST Reset generated when entering in STANDBY
   1411            * @retval HAL status
   1412            */

   \                                 In section .text, align 2, keep-with-next
   1413          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1414          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1415            HAL_StatusTypeDef status = HAL_OK; 
   \   0000000A   0x2700             MOVS     R7,#+0
   1416            uint32_t tmp = 0, tmp1 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1417          
   1418            /* Check the parameters */
   1419            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1420            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1421            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1422          
   1423            /* Get the User Option byte register */
   1424            tmp1 = (FLASH->OBR & FLASH_OBR_BOR_LEV) >> 16;
   \   00000014   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40023c1c
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF3C0 0x4003      UBFX     R0,R0,#+16,#+4
   \   0000001C   0x4681             MOV      R9,R0
   1425            
   1426            /* Calculate the user option byte to write */ 
   1427            tmp = (uint32_t)(((uint32_t)~((uint32_t)((uint32_t)(OB_IWDG) | (uint32_t)(OB_STOP) | (uint32_t)(OB_STDBY) | tmp1))) << 16);
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x4330             ORRS     R0,R6,R0
   \   0000002A   0xEA59 0x0000      ORRS     R0,R9,R0
   \   0000002E   0x43C0             MVNS     R0,R0
   \   00000030   0x0400             LSLS     R0,R0,#+16
   \   00000032   0x4680             MOV      R8,R0
   1428            tmp |= ((uint32_t)(OB_IWDG) | ((uint32_t)OB_STOP) | (uint32_t)(OB_STDBY) | tmp1);
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0xEA55 0x0004      ORRS     R0,R5,R4
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x4330             ORRS     R0,R6,R0
   \   00000040   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000044   0xEA50 0x0808      ORRS     R8,R0,R8
   1429            
   1430            /* Wait for last operation to be completed */
   1431            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000048   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000004C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000050   0x0007             MOVS     R7,R0
   1432            
   1433            if(status == HAL_OK)
   \   00000052   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD105             BNE.N    ??FLASH_OB_UserConfig_0
   1434            {  
   1435              /* Clean the error context */
   1436              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable26
   \   0000005C   0x6148             STR      R0,[R1, #+20]
   1437          
   1438              /* Write the User Option Byte */
   1439              OB->USER = tmp; 
   \   0000005E   0x....             LDR.N    R0,??DataTable26_11  ;; 0x1ff80004
   \   00000060   0xF8C0 0x8000      STR      R8,[R0, #+0]
   1440            }
   1441            
   1442            /* Wait for last operation to be completed */
   1443              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   00000064   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000068   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000006C   0x0007             MOVS     R7,R0
   1444                 
   1445            /* Return the Option Byte program Status */
   1446            return status;
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1447          }
   1448          
   1449          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) \
   1450           || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined(STM32L152xE)  \
   1451           || defined(STM32L162xE)
   1452          /**
   1453            * @brief  Configures to boot from Bank1 or Bank2.
   1454            * @param  OB_BOOT select the FLASH Bank to boot from.
   1455            *   This parameter can be one of the following values:
   1456            *     @arg @ref OB_BOOT_BANK2 At startup, if boot pins are set in boot from user Flash
   1457            *        position and this parameter is selected the device will boot from Bank2 or Bank1,
   1458            *        depending on the activation of the bank. The active banks are checked in
   1459            *        the following order: Bank2, followed by Bank1.
   1460            *        The active bank is recognized by the value programmed at the base address
   1461            *        of the respective bank (corresponding to the initial stack pointer value
   1462            *        in the interrupt vector table).
   1463            *     @arg @ref OB_BOOT_BANK1 At startup, if boot pins are set in boot from user Flash
   1464            *        position and this parameter is selected the device will boot from Bank1(Default).
   1465            *        For more information, please refer to AN2606 from www.st.com. 
   1466            * @retval HAL status
   1467            */

   \                                 In section .text, align 2, keep-with-next
   1468          static HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1469          {
   \                     FLASH_OB_BootConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1470            HAL_StatusTypeDef status = HAL_OK; 
   \   00000004   0x2500             MOVS     R5,#+0
   1471            uint32_t tmp = 0, tmp1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1472          
   1473            /* Check the parameters */
   1474            assert_param(IS_OB_BOOT_BANK(OB_BOOT));
   1475          
   1476            /* Get the User Option byte register  and BOR Level*/
   1477            tmp1 = (FLASH->OBR & (FLASH_OBR_nRST_STDBY | FLASH_OBR_nRST_STOP | FLASH_OBR_IWDG_SW | FLASH_OBR_BOR_LEV)) >> 16;
   \   0000000A   0x....             LDR.N    R0,??DataTable26_6  ;; 0x40023c1c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF3C0 0x4006      UBFX     R0,R0,#+16,#+7
   \   00000012   0x0007             MOVS     R7,R0
   1478               
   1479            /* Calculate the option byte to write */
   1480            tmp = (uint32_t)~(OB_BOOT | tmp1) << 16;
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000001A   0x43C0             MVNS     R0,R0
   \   0000001C   0x0400             LSLS     R0,R0,#+16
   \   0000001E   0x0006             MOVS     R6,R0
   1481            tmp |= (OB_BOOT | tmp1);
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0xEA57 0x0004      ORRS     R0,R7,R4
   \   00000026   0x4306             ORRS     R6,R0,R6
   1482              
   1483            /* Wait for last operation to be completed */
   1484            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000028   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000030   0x0005             MOVS     R5,R0
   1485            
   1486            if(status == HAL_OK)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD104             BNE.N    ??FLASH_OB_BootConfig_0
   1487            {  
   1488              /* Clean the error context */
   1489              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable26
   \   0000003C   0x6148             STR      R0,[R1, #+20]
   1490          
   1491              /* Write the BOOT Option Byte */
   1492              OB->USER = tmp; 
   \   0000003E   0x....             LDR.N    R0,??DataTable26_11  ;; 0x1ff80004
   \   00000040   0x6006             STR      R6,[R0, #+0]
   1493            }
   1494            
   1495            /* Wait for last operation to be completed */
   1496            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_BootConfig_0: (+1)
   \   00000042   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000046   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004A   0x0005             MOVS     R5,R0
   1497                 
   1498            /* Return the Option Byte program Status */
   1499            return status;
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1500          }
   1501          
   1502          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1503          
   1504          /*
   1505          ==============================================================================
   1506                        DATA
   1507          ==============================================================================
   1508          */
   1509          
   1510          /**
   1511            * @brief  Write a Byte at a specified address in data memory.
   1512            * @param  Address specifies the address to be written.
   1513            * @param  Data specifies the data to be written.
   1514            * @note   This function assumes that the is data word is already erased.
   1515            * @retval HAL status
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramByte(uint32_t Address, uint8_t Data)
   1518          {
   \                     FLASH_DATAEEPROM_FastProgramByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1519            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1520          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1521            uint32_t tmp = 0, tmpaddr = 0;
   1522          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1523            
   1524            /* Check the parameters */
   1525            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   1526          
   1527            /* Wait for last operation to be completed */
   1528            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1529              
   1530            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10B             BNE.N    ??FLASH_DATAEEPROM_FastProgramByte_0
   1531            {
   1532              /* Clear the FTDW bit */
   1533              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000018   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000020   0x....             LDR.N    R1,??DataTable26_1  ;; 0x40023c04
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1534          
   1535          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1536              /* Possible only on Cat1 devices */
   1537              if(Data != (uint8_t)0x00) 
   1538              {
   1539                /* If the previous operation is completed, proceed to write the new Data */
   1540                *(__IO uint8_t *)Address = Data;
   1541                      
   1542                /* Wait for last operation to be completed */
   1543                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1544              }
   1545              else
   1546              {
   1547                tmpaddr = Address & 0xFFFFFFFC;
   1548                tmp = * (__IO uint32_t *) tmpaddr;
   1549                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   1550                tmp &= ~tmpaddr;
   1551                status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   1552                /* Process Unlocked */
   1553                __HAL_UNLOCK(&pFlash);
   1554                status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   1555                /* Process Locked */
   1556                __HAL_LOCK(&pFlash);
   1557              }
   1558          #else /*!Cat1*/ 
   1559              /* If the previous operation is completed, proceed to write the new Data */
   1560              *(__IO uint8_t *)Address = Data;
   \   00000024   0x7025             STRB     R5,[R4, #+0]
   1561                      
   1562              /* Wait for last operation to be completed */
   1563              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
   1564          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1565            }
   1566            /* Return the Write Status */
   1567            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramByte_0: (+1)
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   1568          }
   1569          
   1570          /**
   1571            * @brief  Writes a half word at a specified address in data memory.
   1572            * @param  Address specifies the address to be written.
   1573            * @param  Data specifies the data to be written.
   1574            * @note   This function assumes that the is data word is already erased.
   1575            * @retval HAL status
   1576            */

   \                                 In section .text, align 2, keep-with-next
   1577          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data)
   1578          {
   \                     FLASH_DATAEEPROM_FastProgramHalfWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1579            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1580          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1581            uint32_t tmp = 0, tmpaddr = 0;
   1582          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1583            
   1584            /* Check the parameters */
   1585            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1586          
   1587            /* Wait for last operation to be completed */
   1588            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1589              
   1590            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10B             BNE.N    ??FLASH_DATAEEPROM_FastProgramHalfWord_0
   1591            {
   1592              /* Clear the FTDW bit */
   1593              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000018   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000020   0x....             LDR.N    R1,??DataTable26_1  ;; 0x40023c04
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1594          
   1595          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1596              /* Possible only on Cat1 devices */
   1597              if(Data != (uint16_t)0x0000) 
   1598              {
   1599                /* If the previous operation is completed, proceed to write the new data */
   1600                *(__IO uint16_t *)Address = Data;
   1601            
   1602                /* Wait for last operation to be completed */
   1603                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1604              }
   1605              else
   1606              {
   1607                /* Process Unlocked */
   1608                __HAL_UNLOCK(&pFlash);
   1609                if((Address & 0x3) != 0x3)
   1610                {
   1611                  tmpaddr = Address & 0xFFFFFFFC;
   1612                  tmp = * (__IO uint32_t *) tmpaddr;
   1613                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   1614                  tmp &= ~tmpaddr;        
   1615                  status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   1616                  status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   1617                }
   1618                else
   1619                {
   1620                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address, 0x00);
   1621                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address + 1, 0x00);
   1622                }
   1623                /* Process Locked */
   1624                __HAL_LOCK(&pFlash);
   1625              }
   1626          #else /* !Cat1 */
   1627              /* If the previous operation is completed, proceed to write the new data */
   1628              *(__IO uint16_t *)Address = Data;
   \   00000024   0x8025             STRH     R5,[R4, #+0]
   1629            
   1630              /* Wait for last operation to be completed */
   1631              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
   1632          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1633            }
   1634            /* Return the Write Status */
   1635            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramHalfWord_0: (+1)
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   1636          }
   1637          
   1638          /**
   1639            * @brief  Programs a word at a specified address in data memory.
   1640            * @param  Address specifies the address to be written.
   1641            * @param  Data specifies the data to be written.
   1642            * @note   This function assumes that the is data word is already erased.
   1643            * @retval HAL status
   1644            */

   \                                 In section .text, align 2, keep-with-next
   1645          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramWord(uint32_t Address, uint32_t Data)
   1646          {
   \                     FLASH_DATAEEPROM_FastProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1647            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1648          
   1649            /* Check the parameters */
   1650            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1651            
   1652            /* Wait for last operation to be completed */
   1653            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1654            
   1655            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10B             BNE.N    ??FLASH_DATAEEPROM_FastProgramWord_0
   1656            {
   1657              /* Clear the FTDW bit */
   1658              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000018   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000020   0x....             LDR.N    R1,??DataTable26_1  ;; 0x40023c04
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1659            
   1660              /* If the previous operation is completed, proceed to program the new data */    
   1661              *(__IO uint32_t *)Address = Data;
   \   00000024   0x6025             STR      R5,[R4, #+0]
   1662              
   1663              /* Wait for last operation to be completed */
   1664              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);       
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
   1665            }
   1666            /* Return the Write Status */
   1667            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramWord_0: (+1)
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   1668          }
   1669          
   1670          /**
   1671            * @brief  Write a Byte at a specified address in data memory without erase.
   1672            * @param  Address specifies the address to be written.
   1673            * @param  Data specifies the data to be written.
   1674            * @retval HAL status
   1675            */

   \                                 In section .text, align 2, keep-with-next
   1676          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramByte(uint32_t Address, uint8_t Data)
   1677          {
   \                     FLASH_DATAEEPROM_ProgramByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1678            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1679          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1680            uint32_t tmp = 0, tmpaddr = 0;
   1681          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1682            
   1683            /* Check the parameters */
   1684            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   1685          
   1686            /* Wait for last operation to be completed */
   1687            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1688            
   1689            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD105             BNE.N    ??FLASH_DATAEEPROM_ProgramByte_0
   1690            {
   1691          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1692              if(Data != (uint8_t) 0x00)
   1693              {  
   1694                *(__IO uint8_t *)Address = Data;
   1695              
   1696                /* Wait for last operation to be completed */
   1697                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1698          
   1699              }
   1700              else
   1701              {
   1702                tmpaddr = Address & 0xFFFFFFFC;
   1703                tmp = * (__IO uint32_t *) tmpaddr;
   1704                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   1705                tmp &= ~tmpaddr;        
   1706                status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   1707                /* Process Unlocked */
   1708                __HAL_UNLOCK(&pFlash);
   1709                status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   1710                /* Process Locked */
   1711                __HAL_LOCK(&pFlash);
   1712              }
   1713          #else /* Not Cat1*/
   1714              *(__IO uint8_t *)Address = Data;
   \   00000018   0x7025             STRB     R5,[R4, #+0]
   1715              
   1716              /* Wait for last operation to be completed */
   1717              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000001A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000022   0x0006             MOVS     R6,R0
   1718          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1719            }
   1720            /* Return the Write Status */
   1721            return status;
   \                     ??FLASH_DATAEEPROM_ProgramByte_0: (+1)
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1722          }
   1723          
   1724          /**
   1725            * @brief  Writes a half word at a specified address in data memory without erase.
   1726            * @param  Address specifies the address to be written.
   1727            * @param  Data specifies the data to be written.
   1728            * @retval HAL status
   1729            */

   \                                 In section .text, align 2, keep-with-next
   1730          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data)
   1731          {
   \                     FLASH_DATAEEPROM_ProgramHalfWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1732            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1733          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1734            uint32_t tmp = 0, tmpaddr = 0;
   1735          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1736            
   1737            /* Check the parameters */
   1738            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1739          
   1740            /* Wait for last operation to be completed */
   1741            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1742            
   1743            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD105             BNE.N    ??FLASH_DATAEEPROM_ProgramHalfWord_0
   1744            {
   1745          #if defined(STM32L100xB) || defined(STM32L151xB) || defined(STM32L152xB)
   1746              if(Data != (uint16_t)0x0000)
   1747              {
   1748                *(__IO uint16_t *)Address = Data;
   1749             
   1750                /* Wait for last operation to be completed */
   1751                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1752              }
   1753              else
   1754              {
   1755                /* Process Unlocked */
   1756                __HAL_UNLOCK(&pFlash);
   1757                if((Address & 0x3) != 0x3)
   1758                {
   1759                  tmpaddr = Address & 0xFFFFFFFC;
   1760                  tmp = * (__IO uint32_t *) tmpaddr;
   1761                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   1762                  tmp &= ~tmpaddr;          
   1763                  status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   1764                  status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   1765                }
   1766                else
   1767                {
   1768                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address, 0x00);
   1769                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address + 1, 0x00);
   1770                }
   1771                /* Process Locked */
   1772                __HAL_LOCK(&pFlash);
   1773              }
   1774          #else /* Not Cat1*/
   1775              *(__IO uint16_t *)Address = Data;
   \   00000018   0x8025             STRH     R5,[R4, #+0]
   1776             
   1777              /* Wait for last operation to be completed */
   1778              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000001A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000022   0x0006             MOVS     R6,R0
   1779          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1780            }
   1781            /* Return the Write Status */
   1782            return status;
   \                     ??FLASH_DATAEEPROM_ProgramHalfWord_0: (+1)
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1783          }
   1784          
   1785          /**
   1786            * @brief  Programs a word at a specified address in data memory without erase.
   1787            * @param  Address specifies the address to be written.
   1788            * @param  Data specifies the data to be written.
   1789            * @retval HAL status
   1790            */

   \                                 In section .text, align 2, keep-with-next
   1791          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramWord(uint32_t Address, uint32_t Data)
   1792          {
   \                     FLASH_DATAEEPROM_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1793            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1794            
   1795            /* Check the parameters */
   1796            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1797            
   1798            /* Wait for last operation to be completed */
   1799            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1800            
   1801            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD105             BNE.N    ??FLASH_DATAEEPROM_ProgramWord_0
   1802            {
   1803              *(__IO uint32_t *)Address = Data;
   \   00000018   0x6025             STR      R5,[R4, #+0]
   1804          
   1805              /* Wait for last operation to be completed */
   1806              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000001A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000022   0x0006             MOVS     R6,R0
   1807            }
   1808            /* Return the Write Status */
   1809            return status;
   \                     ??FLASH_DATAEEPROM_ProgramWord_0: (+1)
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1810          }
   1811          
   1812          /**
   1813            * @}
   1814            */
   1815          
   1816          /**
   1817            * @}
   1818            */
   1819          
   1820          /** @addtogroup FLASH
   1821            * @{
   1822            */
   1823          
   1824          
   1825          /** @addtogroup FLASH_Private_Functions
   1826           * @{
   1827           */
   1828          
   1829          /**
   1830            * @brief  Erases a specified page in program memory.
   1831            * @param  PageAddress The page address in program memory to be erased.
   1832            * @note   A Page is erased in the Program memory only if the address to load 
   1833            *         is the start address of a page (multiple of 256 bytes).
   1834            * @retval None
   1835            */

   \                                 In section .text, align 2, keep-with-next
   1836          void FLASH_PageErase(uint32_t PageAddress)
   1837          {
   1838            /* Clean the error context */
   1839            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_PageErase: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable26
   \   00000004   0x6151             STR      R1,[R2, #+20]
   1840          
   1841            /* Set the ERASE bit */
   1842            SET_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   00000006   0x....             LDR.N    R1,??DataTable26_1  ;; 0x40023c04
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF451 0x7100      ORRS     R1,R1,#0x200
   \   0000000E   0x....             LDR.N    R2,??DataTable26_1  ;; 0x40023c04
   \   00000010   0x6011             STR      R1,[R2, #+0]
   1843          
   1844            /* Set PROG bit */
   1845            SET_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \   00000012   0x....             LDR.N    R1,??DataTable26_1  ;; 0x40023c04
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   0000001A   0x....             LDR.N    R2,??DataTable26_1  ;; 0x40023c04
   \   0000001C   0x6011             STR      R1,[R2, #+0]
   1846          
   1847            /* Write 00000000h to the first word of the program page to erase */
   1848            *(__IO uint32_t *)(uint32_t)(PageAddress & ~(FLASH_PAGE_SIZE - 1)) = 0x00000000;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0A02             LSRS     R2,R0,#+8
   \   00000022   0x0212             LSLS     R2,R2,#+8
   \   00000024   0x6011             STR      R1,[R2, #+0]
   1849          }
   \   00000026   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x40023C20         DC32     0x40023c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x40023C80         DC32     0x40023c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x40023C84         DC32     0x40023c84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x40023C88         DC32     0x40023c88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x40023C1C         DC32     0x40023c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x89ABCDEF         DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x02030405         DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x1FF80004         DC32     0x1ff80004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \   00000000   0x1FF80008         DC32     0x1ff80008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_13:
   \   00000000   0x1FF8000C         DC32     0x1ff8000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_14:
   \   00000000   0x1FF80010         DC32     0x1ff80010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_15:
   \   00000000   0x1FF80014         DC32     0x1ff80014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_16:
   \   00000000   0x1FF80018         DC32     0x1ff80018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_17:
   \   00000000   0x1FF8001C         DC32     0x1ff8001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_18:
   \   00000000   0x1FF80080         DC32     0x1ff80080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_19:
   \   00000000   0x1FF80084         DC32     0x1ff80084
   1850            
   1851          /**
   1852            * @}
   1853            */
   1854          
   1855          /**
   1856            * @}
   1857            */
   1858          
   1859          #endif /* HAL_FLASH_MODULE_ENABLED */
   1860          /**
   1861            * @}
   1862            */
   1863          
   1864          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FLASH_DATAEEPROM_FastProgramByte
        16   -> FLASH_WaitForLastOperation
      16   FLASH_DATAEEPROM_FastProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_DATAEEPROM_FastProgramWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_DATAEEPROM_ProgramByte
        16   -> FLASH_WaitForLastOperation
      16   FLASH_DATAEEPROM_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_DATAEEPROM_ProgramWord
        16   -> FLASH_WaitForLastOperation
      24   FLASH_OB_BORConfig
        24   -> FLASH_WaitForLastOperation
      24   FLASH_OB_BootConfig
        24   -> FLASH_WaitForLastOperation
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
      24   FLASH_OB_RDPConfig
        24   -> FLASH_WaitForLastOperation
      32   FLASH_OB_UserConfig
        32   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_OB_WRPConfigWRP1OrPCROP1
        16   -> FLASH_OB_WRPConfigWRP2OrPCROP2
        16   -> FLASH_OB_WRPConfigWRP3
        16   -> FLASH_OB_WRPConfigWRP4
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfigWRP1OrPCROP1
      16   FLASH_OB_WRPConfigWRP2OrPCROP2
      16   FLASH_OB_WRPConfigWRP3
      16   FLASH_OB_WRPConfigWRP4
       0   FLASH_PageErase
       0   HAL_FLASHEx_AdvOBGetConfig
      16   HAL_FLASHEx_AdvOBProgram
        16   -> FLASH_OB_BootConfig
       0   HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram
       0   HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram
      16   HAL_FLASHEx_DATAEEPROM_Erase
        16   -> FLASH_WaitForLastOperation
       0   HAL_FLASHEx_DATAEEPROM_Lock
      24   HAL_FLASHEx_DATAEEPROM_Program
        24   -> FLASH_DATAEEPROM_FastProgramByte
        24   -> FLASH_DATAEEPROM_FastProgramHalfWord
        24   -> FLASH_DATAEEPROM_FastProgramWord
        24   -> FLASH_DATAEEPROM_ProgramByte
        24   -> FLASH_DATAEEPROM_ProgramHalfWord
        24   -> FLASH_DATAEEPROM_ProgramWord
        24   -> FLASH_WaitForLastOperation
       0   HAL_FLASHEx_DATAEEPROM_Unlock
      24   HAL_FLASHEx_Erase
        24   -> FLASH_PageErase
        24   -> FLASH_WaitForLastOperation
      16   HAL_FLASHEx_Erase_IT
        16   -> FLASH_PageErase
       8   HAL_FLASHEx_OBGetConfig
         8   -> FLASH_OB_GetBOR
         8   -> FLASH_OB_GetRDP
         8   -> FLASH_OB_GetUser
      16   HAL_FLASHEx_OBProgram
        16   -> FLASH_OB_BORConfig
        16   -> FLASH_OB_RDPConfig
        16   -> FLASH_OB_UserConfig
        16   -> FLASH_OB_WRPConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_18
       4  ??DataTable26_19
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
      54  FLASH_DATAEEPROM_FastProgramByte
      54  FLASH_DATAEEPROM_FastProgramHalfWord
      54  FLASH_DATAEEPROM_FastProgramWord
      42  FLASH_DATAEEPROM_ProgramByte
      42  FLASH_DATAEEPROM_ProgramHalfWord
      42  FLASH_DATAEEPROM_ProgramWord
      90  FLASH_OB_BORConfig
      82  FLASH_OB_BootConfig
      24  FLASH_OB_GetBOR
      10  FLASH_OB_GetRDP
      24  FLASH_OB_GetUser
     126  FLASH_OB_RDPConfig
     118  FLASH_OB_UserConfig
     112  FLASH_OB_WRPConfig
     140  FLASH_OB_WRPConfigWRP1OrPCROP1
     132  FLASH_OB_WRPConfigWRP2OrPCROP2
     124  FLASH_OB_WRPConfigWRP3
     124  FLASH_OB_WRPConfigWRP4
      40  FLASH_PageErase
      20  HAL_FLASHEx_AdvOBGetConfig
      28  HAL_FLASHEx_AdvOBProgram
      18  HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram
      18  HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram
      62  HAL_FLASHEx_DATAEEPROM_Erase
      20  HAL_FLASHEx_DATAEEPROM_Lock
     162  HAL_FLASHEx_DATAEEPROM_Program
      38  HAL_FLASHEx_DATAEEPROM_Unlock
     154  HAL_FLASHEx_Erase
      94  HAL_FLASHEx_Erase_IT
      60  HAL_FLASHEx_OBGetConfig
     214  HAL_FLASHEx_OBProgram

 
 2 402 bytes in section .text
 
 2 402 bytes of CODE memory

Errors: none
Warnings: none
