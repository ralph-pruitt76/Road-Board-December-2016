###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       26/Oct/2017  12:54:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_gpio.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_gpio.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_gpio.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   GPIO HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *         
     13            @verbatim
     14            ==============================================================================
     15                              ##### GPIO Peripheral features #####
     16            ==============================================================================         
     17            [..] 
     18            Each port bit of the general-purpose I/O (GPIO) ports can be individually 
     19            configured by software in several modes:
     20            (+) Input mode 
     21            (+) Analog mode
     22            (+) Output mode
     23            (+) Alternate function mode
     24            (+) External interrupt/event lines
     25           
     26            [..]  
     27            During and just after reset, the alternate functions and external interrupt  
     28            lines are not active and the I/O ports are configured in input floating mode.
     29            
     30            [..]   
     31            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     32            activated or not.
     33          
     34            [..]
     35            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     36            type and the IO speed can be selected depending on the VDD value.
     37            
     38            [..]
     39            The microcontroller IO pins are connected to onboard peripherals/modules through a 
     40            multiplexer that allows only one peripheral s alternate function (AF) connected 
     41            to an IO pin at a time. In this way, there can be no conflict between peripherals 
     42            sharing the same IO pin. 
     43            
     44            [..]  
     45            All ports have external interrupt/event capability. To use external interrupt 
     46            lines, the port must be configured in input mode. All available GPIO pins are 
     47            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     48            
     49            [..]  
     50            The external interrupt/event controller consists of up to 28 edge detectors 
     51            (depending on products 16 lines are connected to GPIO) for generating event/interrupt
     52            requests (each input line can be independently configured to select the type 
     53            (interrupt or event) and the corresponding trigger event (rising or falling or both). 
     54            Each line can also be masked independently. 
     55             
     56                      ##### How to use this driver #####
     57            ==============================================================================  
     58            [..]
     59             (#) Enable the GPIO AHB clock using the following function : __GPIOx_CLK_ENABLE(). 
     60                                              
     61             (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     62                 (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     63                 (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     64                      structure.
     65                 (++) In case of Output or alternate function mode selection: the speed is 
     66                      configured through "Speed" member from GPIO_InitTypeDef structure, 
     67                      the speed is configurable: Low, Medium and High.
     68                 (++) If alternate mode is selected, the alternate function connected to the IO
     69                      is configured through "Alternate" member from GPIO_InitTypeDef structure
     70                 (++) Analog mode is required when a pin is to be used as ADC channel 
     71                      or DAC output.
     72                 (++) In case of external interrupt/event selection the "Mode" member from 
     73                      GPIO_InitTypeDef structure select the type (interrupt or event) and 
     74                      the corresponding trigger event (rising or falling or both).
     75            
     76             (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     77                 mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     78                 HAL_NVIC_EnableIRQ().
     79            
     80             (#) HAL_GPIO_DeInit allows to set register values to their reset value. It's also 
     81                 recommended to use it to unconfigure pin which was used as an external interrupt 
     82                 or in event mode. That's the only way to reset corresponding bit in EXTI & SYSCFG 
     83                 registers.
     84            
     85             (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     86            
     87             (#) To set/reset the level of a pin configured in output mode use 
     88                 HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     89            
     90             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     91            
     92             (#) During and just after reset, the alternate functions are not 
     93                 active and the GPIO pins are configured in input floating mode (except JTAG
     94                 pins).
     95            
     96             (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     97                 (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     98                 priority over the GPIO function.
     99            
    100             (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
    101                 general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
    102                 The HSE has priority over the GPIO function.
    103            
    104            @endverbatim
    105            ******************************************************************************
    106            * @attention
    107            *
    108            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    109            *
    110            * Redistribution and use in source and binary forms, with or without modification,
    111            * are permitted provided that the following conditions are met:
    112            *   1. Redistributions of source code must retain the above copyright notice,
    113            *      this list of conditions and the following disclaimer.
    114            *   2. Redistributions in binary form must reproduce the above copyright notice,
    115            *      this list of conditions and the following disclaimer in the documentation
    116            *      and/or other materials provided with the distribution.
    117            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    118            *      may be used to endorse or promote products derived from this software
    119            *      without specific prior written permission.
    120            *
    121            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    122            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    123            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    124            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    125            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    126            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    127            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    128            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    129            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    130            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    131            *
    132            ******************************************************************************  
    133            */
    134          
    135          /* Includes ------------------------------------------------------------------*/
    136          #include "stm32l1xx_hal.h"
    137          
    138          /** @addtogroup STM32L1xx_HAL_Driver
    139            * @{
    140            */
    141          
    142          /** @addtogroup GPIO
    143            * @brief GPIO HAL module driver
    144            * @{
    145            */
    146          
    147          #ifdef HAL_GPIO_MODULE_ENABLED
    148          
    149          /* Private typedef -----------------------------------------------------------*/
    150          /* Private define ------------------------------------------------------------*/
    151          /** @addtogroup GPIO_Private_Constants
    152            * @{
    153            */
    154          #define GPIO_MODE             ((uint32_t)0x00000003)
    155          #define EXTI_MODE             ((uint32_t)0x10000000)
    156          #define GPIO_MODE_IT          ((uint32_t)0x00010000)
    157          #define GPIO_MODE_EVT         ((uint32_t)0x00020000)
    158          #define RISING_EDGE           ((uint32_t)0x00100000)
    159          #define FALLING_EDGE          ((uint32_t)0x00200000)
    160          #define GPIO_OUTPUT_TYPE      ((uint32_t)0x00000010)
    161          
    162          #define GPIO_NUMBER           ((uint32_t)16)
    163           
    164          /**
    165            * @}
    166            */
    167            
    168          /* Private macro -------------------------------------------------------------*/
    169          /* Private variables ---------------------------------------------------------*/
    170          /* Private function prototypes -----------------------------------------------*/
    171          /* Exported functions ---------------------------------------------------------*/
    172          
    173          /** @addtogroup GPIO_Exported_Functions
    174            * @{
    175            */
    176          
    177          /** @addtogroup GPIO_Exported_Functions_Group1
    178           *  @brief    Initialization and Configuration functions 
    179           *
    180          @verbatim    
    181           ===============================================================================
    182                        ##### Initialization and Configuration functions #####
    183           ===============================================================================
    184           
    185          @endverbatim
    186            * @{
    187            */
    188          
    189          /**
    190            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    191            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices
    192            * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
    193            *         the configuration information for the specified GPIO peripheral.
    194            * @retval None
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    197          { 
   \                     HAL_GPIO_Init: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
    198            uint32_t position = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    199            uint32_t iocurrent = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
    200            uint32_t temp = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    201          
    202            /* Check the parameters */
    203            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    204            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    205            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    206            assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 
    207          
    208            /* Configure the port pins */
    209            while (((GPIO_Init->Pin) >> position) != 0)
   \                     ??HAL_GPIO_Init_0: (+1)
   \   00000008   0x680D             LDR      R5,[R1, #+0]
   \   0000000A   0x40D5             LSRS     R5,R5,R2
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xF000 0x80DE      BEQ.W    ??HAL_GPIO_Init_1
    210            {
    211              /* Get current io position */
    212              iocurrent = (GPIO_Init->Pin) & ((uint32_t)1 << position);
   \   00000012   0x680D             LDR      R5,[R1, #+0]
   \   00000014   0x2601             MOVS     R6,#+1
   \   00000016   0x4096             LSLS     R6,R6,R2
   \   00000018   0x4035             ANDS     R5,R6,R5
   \   0000001A   0x002B             MOVS     R3,R5
    213              
    214              if(iocurrent)
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xF000 0x80D4      BEQ.W    ??HAL_GPIO_Init_2
    215              {
    216                /*--------------------- GPIO Mode Configuration ------------------------*/
    217                /* In case of Alternate function mode selection */
    218                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
   \   00000022   0x684D             LDR      R5,[R1, #+4]
   \   00000024   0x2D02             CMP      R5,#+2
   \   00000026   0xD002             BEQ.N    ??HAL_GPIO_Init_3
   \   00000028   0x684D             LDR      R5,[R1, #+4]
   \   0000002A   0x2D12             CMP      R5,#+18
   \   0000002C   0xD116             BNE.N    ??HAL_GPIO_Init_4
    219                {
    220                  /* Check the Alternate function parameters */
    221                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    222                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    223                  
    224                  /* Configure Alternate function mapped with the current IO */ 
    225                  /* Identify AFRL or AFRH register based on IO position*/
    226                  temp = GPIOx->AFR[position >> 3];
   \                     ??HAL_GPIO_Init_3: (+1)
   \   0000002E   0x08D5             LSRS     R5,R2,#+3
   \   00000030   0xEB00 0x0585      ADD      R5,R0,R5, LSL #+2
   \   00000034   0x6A2D             LDR      R5,[R5, #+32]
   \   00000036   0x002C             MOVS     R4,R5
    227                  CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
   \   00000038   0x250F             MOVS     R5,#+15
   \   0000003A   0xF012 0x0607      ANDS     R6,R2,#0x7
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x00B6             LSLS     R6,R6,#+2
   \   00000042   0x40B5             LSLS     R5,R5,R6
   \   00000044   0x43AC             BICS     R4,R4,R5
    228                  SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
   \   00000046   0x690D             LDR      R5,[R1, #+16]
   \   00000048   0xF012 0x0607      ANDS     R6,R2,#0x7
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x00B6             LSLS     R6,R6,#+2
   \   00000050   0x40B5             LSLS     R5,R5,R6
   \   00000052   0x432C             ORRS     R4,R5,R4
    229                  GPIOx->AFR[position >> 3] = temp;
   \   00000054   0x08D5             LSRS     R5,R2,#+3
   \   00000056   0xEB00 0x0585      ADD      R5,R0,R5, LSL #+2
   \   0000005A   0x622C             STR      R4,[R5, #+32]
    230                }
    231          
    232                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    233                temp = GPIOx->MODER;
   \                     ??HAL_GPIO_Init_4: (+1)
   \   0000005C   0x6805             LDR      R5,[R0, #+0]
   \   0000005E   0x002C             MOVS     R4,R5
    234                CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
   \   00000060   0x2503             MOVS     R5,#+3
   \   00000062   0x0016             MOVS     R6,R2
   \   00000064   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000066   0x0076             LSLS     R6,R6,#+1
   \   00000068   0x40B5             LSLS     R5,R5,R6
   \   0000006A   0x43AC             BICS     R4,R4,R5
    235                SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
   \   0000006C   0x790D             LDRB     R5,[R1, #+4]
   \   0000006E   0xF015 0x0503      ANDS     R5,R5,#0x3
   \   00000072   0x0016             MOVS     R6,R2
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x0076             LSLS     R6,R6,#+1
   \   00000078   0x40B5             LSLS     R5,R5,R6
   \   0000007A   0x432C             ORRS     R4,R5,R4
    236                GPIOx->MODER = temp;
   \   0000007C   0x6004             STR      R4,[R0, #+0]
    237          
    238                /* In case of Output or Alternate function mode selection */
    239                if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    240                    (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \   0000007E   0x684D             LDR      R5,[R1, #+4]
   \   00000080   0x2D01             CMP      R5,#+1
   \   00000082   0xD008             BEQ.N    ??HAL_GPIO_Init_5
   \   00000084   0x684D             LDR      R5,[R1, #+4]
   \   00000086   0x2D02             CMP      R5,#+2
   \   00000088   0xD005             BEQ.N    ??HAL_GPIO_Init_5
   \   0000008A   0x684D             LDR      R5,[R1, #+4]
   \   0000008C   0x2D11             CMP      R5,#+17
   \   0000008E   0xD002             BEQ.N    ??HAL_GPIO_Init_5
   \   00000090   0x684D             LDR      R5,[R1, #+4]
   \   00000092   0x2D12             CMP      R5,#+18
   \   00000094   0xD119             BNE.N    ??HAL_GPIO_Init_6
    241                {
    242                  /* Check the Speed parameter */
    243                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    244                  /* Configure the IO Speed */
    245                  temp = GPIOx->OSPEEDR; 
   \                     ??HAL_GPIO_Init_5: (+1)
   \   00000096   0x6885             LDR      R5,[R0, #+8]
   \   00000098   0x002C             MOVS     R4,R5
    246                  CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
   \   0000009A   0x2503             MOVS     R5,#+3
   \   0000009C   0x0016             MOVS     R6,R2
   \   0000009E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A0   0x0076             LSLS     R6,R6,#+1
   \   000000A2   0x40B5             LSLS     R5,R5,R6
   \   000000A4   0x43AC             BICS     R4,R4,R5
    247                  SET_BIT(temp, GPIO_Init->Speed << (position * 2));
   \   000000A6   0x68CD             LDR      R5,[R1, #+12]
   \   000000A8   0x0016             MOVS     R6,R2
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0x0076             LSLS     R6,R6,#+1
   \   000000AE   0x40B5             LSLS     R5,R5,R6
   \   000000B0   0x432C             ORRS     R4,R5,R4
    248                  GPIOx->OSPEEDR = temp;
   \   000000B2   0x6084             STR      R4,[R0, #+8]
    249          
    250                  /* Configure the IO Output Type */
    251                  temp = GPIOx->OTYPER;
   \   000000B4   0x6845             LDR      R5,[R0, #+4]
   \   000000B6   0x002C             MOVS     R4,R5
    252                  CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
   \   000000B8   0x2501             MOVS     R5,#+1
   \   000000BA   0x4095             LSLS     R5,R5,R2
   \   000000BC   0x43AC             BICS     R4,R4,R5
    253                  SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
   \   000000BE   0x684D             LDR      R5,[R1, #+4]
   \   000000C0   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \   000000C4   0x4095             LSLS     R5,R5,R2
   \   000000C6   0x432C             ORRS     R4,R5,R4
    254                  GPIOx->OTYPER = temp;
   \   000000C8   0x6044             STR      R4,[R0, #+4]
    255                }
    256          
    257                /* Activate the Pull-up or Pull down resistor for the current IO */
    258                temp = GPIOx->PUPDR;
   \                     ??HAL_GPIO_Init_6: (+1)
   \   000000CA   0x68C5             LDR      R5,[R0, #+12]
   \   000000CC   0x002C             MOVS     R4,R5
    259                CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2));
   \   000000CE   0x2503             MOVS     R5,#+3
   \   000000D0   0x0016             MOVS     R6,R2
   \   000000D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D4   0x0076             LSLS     R6,R6,#+1
   \   000000D6   0x40B5             LSLS     R5,R5,R6
   \   000000D8   0x43AC             BICS     R4,R4,R5
    260                SET_BIT(temp, (GPIO_Init->Pull) << (position * 2));
   \   000000DA   0x688D             LDR      R5,[R1, #+8]
   \   000000DC   0x0016             MOVS     R6,R2
   \   000000DE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E0   0x0076             LSLS     R6,R6,#+1
   \   000000E2   0x40B5             LSLS     R5,R5,R6
   \   000000E4   0x432C             ORRS     R4,R5,R4
    261                GPIOx->PUPDR = temp;
   \   000000E6   0x60C4             STR      R4,[R0, #+12]
    262          
    263                /*--------------------- EXTI Mode Configuration ------------------------*/
    264                /* Configure the External Interrupt or event for the current IO */
    265                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
   \   000000E8   0x684D             LDR      R5,[R1, #+4]
   \   000000EA   0x00ED             LSLS     R5,R5,#+3
   \   000000EC   0xD56D             BPL.N    ??HAL_GPIO_Init_2
    266                {
    267                  /* Enable SYSCFG Clock */
    268                  __HAL_RCC_SYSCFG_CLK_ENABLE();
   \   000000EE   0x....             LDR.N    R5,??DataTable2  ;; 0x40023820
   \   000000F0   0x682D             LDR      R5,[R5, #+0]
   \   000000F2   0xF055 0x0501      ORRS     R5,R5,#0x1
   \   000000F6   0x....             LDR.N    R6,??DataTable2  ;; 0x40023820
   \   000000F8   0x6035             STR      R5,[R6, #+0]
   \   000000FA   0x....             LDR.N    R5,??DataTable2  ;; 0x40023820
   \   000000FC   0x682D             LDR      R5,[R5, #+0]
   \   000000FE   0xF015 0x0501      ANDS     R5,R5,#0x1
   \   00000102   0x9500             STR      R5,[SP, #+0]
   \   00000104   0x9D00             LDR      R5,[SP, #+0]
    269                  
    270                  temp = SYSCFG->EXTICR[position >> 2];
   \   00000106   0x....             LDR.N    R5,??DataTable2_1  ;; 0x40010008
   \   00000108   0x0896             LSRS     R6,R2,#+2
   \   0000010A   0xF855 0x5026      LDR      R5,[R5, R6, LSL #+2]
   \   0000010E   0x002C             MOVS     R4,R5
    271                  CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
   \   00000110   0x250F             MOVS     R5,#+15
   \   00000112   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   00000116   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000118   0x00B6             LSLS     R6,R6,#+2
   \   0000011A   0x40B5             LSLS     R5,R5,R6
   \   0000011C   0x43AC             BICS     R4,R4,R5
    272                  SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
   \   0000011E   0x....             LDR.N    R5,??DataTable2_2  ;; 0x40020000
   \   00000120   0x42A8             CMP      R0,R5
   \   00000122   0xD101             BNE.N    ??HAL_GPIO_Init_7
   \   00000124   0x2500             MOVS     R5,#+0
   \   00000126   0xE01E             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_7: (+1)
   \   00000128   0x....             LDR.N    R5,??DataTable2_3  ;; 0x40020400
   \   0000012A   0x42A8             CMP      R0,R5
   \   0000012C   0xD101             BNE.N    ??HAL_GPIO_Init_9
   \   0000012E   0x2501             MOVS     R5,#+1
   \   00000130   0xE019             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_9: (+1)
   \   00000132   0x....             LDR.N    R5,??DataTable2_4  ;; 0x40020800
   \   00000134   0x42A8             CMP      R0,R5
   \   00000136   0xD101             BNE.N    ??HAL_GPIO_Init_10
   \   00000138   0x2502             MOVS     R5,#+2
   \   0000013A   0xE014             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_10: (+1)
   \   0000013C   0x....             LDR.N    R5,??DataTable2_5  ;; 0x40020c00
   \   0000013E   0x42A8             CMP      R0,R5
   \   00000140   0xD101             BNE.N    ??HAL_GPIO_Init_11
   \   00000142   0x2503             MOVS     R5,#+3
   \   00000144   0xE00F             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_11: (+1)
   \   00000146   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40021000
   \   00000148   0x42A8             CMP      R0,R5
   \   0000014A   0xD101             BNE.N    ??HAL_GPIO_Init_12
   \   0000014C   0x2504             MOVS     R5,#+4
   \   0000014E   0xE00A             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_12: (+1)
   \   00000150   0x....             LDR.N    R5,??DataTable2_7  ;; 0x40021400
   \   00000152   0x42A8             CMP      R0,R5
   \   00000154   0xD101             BNE.N    ??HAL_GPIO_Init_13
   \   00000156   0x2505             MOVS     R5,#+5
   \   00000158   0xE005             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_13: (+1)
   \   0000015A   0x....             LDR.N    R5,??DataTable2_8  ;; 0x40021800
   \   0000015C   0x42A8             CMP      R0,R5
   \   0000015E   0xD101             BNE.N    ??HAL_GPIO_Init_14
   \   00000160   0x2506             MOVS     R5,#+6
   \   00000162   0xE000             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_14: (+1)
   \   00000164   0x2507             MOVS     R5,#+7
   \                     ??HAL_GPIO_Init_8: (+1)
   \   00000166   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   0000016A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000016C   0x00B6             LSLS     R6,R6,#+2
   \   0000016E   0x40B5             LSLS     R5,R5,R6
   \   00000170   0x432C             ORRS     R4,R5,R4
    273                  SYSCFG->EXTICR[position >> 2] = temp;
   \   00000172   0x....             LDR.N    R5,??DataTable2_1  ;; 0x40010008
   \   00000174   0x0896             LSRS     R6,R2,#+2
   \   00000176   0xF845 0x4026      STR      R4,[R5, R6, LSL #+2]
    274                            
    275                  /* Clear EXTI line configuration */
    276                  temp = EXTI->IMR;
   \   0000017A   0x....             LDR.N    R5,??DataTable2_9  ;; 0x40010400
   \   0000017C   0x682D             LDR      R5,[R5, #+0]
   \   0000017E   0x002C             MOVS     R4,R5
    277                  CLEAR_BIT(temp, (uint32_t)iocurrent);
   \   00000180   0x439C             BICS     R4,R4,R3
    278                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \   00000182   0x684D             LDR      R5,[R1, #+4]
   \   00000184   0x03ED             LSLS     R5,R5,#+15
   \   00000186   0xD500             BPL.N    ??HAL_GPIO_Init_15
    279                  {
    280                    SET_BIT(temp, iocurrent); 
   \   00000188   0x431C             ORRS     R4,R3,R4
    281                  }
    282                  EXTI->IMR = temp;
   \                     ??HAL_GPIO_Init_15: (+1)
   \   0000018A   0x....             LDR.N    R5,??DataTable2_9  ;; 0x40010400
   \   0000018C   0x602C             STR      R4,[R5, #+0]
    283          
    284                  temp = EXTI->EMR;
   \   0000018E   0x....             LDR.N    R5,??DataTable2_10  ;; 0x40010404
   \   00000190   0x682D             LDR      R5,[R5, #+0]
   \   00000192   0x002C             MOVS     R4,R5
    285                  CLEAR_BIT(temp, (uint32_t)iocurrent);      
   \   00000194   0x439C             BICS     R4,R4,R3
    286                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \   00000196   0x684D             LDR      R5,[R1, #+4]
   \   00000198   0x03AD             LSLS     R5,R5,#+14
   \   0000019A   0xD500             BPL.N    ??HAL_GPIO_Init_16
    287                  {
    288                    SET_BIT(temp, iocurrent); 
   \   0000019C   0x431C             ORRS     R4,R3,R4
    289                  }
    290                  EXTI->EMR = temp;
   \                     ??HAL_GPIO_Init_16: (+1)
   \   0000019E   0x....             LDR.N    R5,??DataTable2_10  ;; 0x40010404
   \   000001A0   0x602C             STR      R4,[R5, #+0]
    291            
    292                  /* Clear Rising Falling edge configuration */
    293                  temp = EXTI->RTSR;
   \   000001A2   0x....             LDR.N    R5,??DataTable2_11  ;; 0x40010408
   \   000001A4   0x682D             LDR      R5,[R5, #+0]
   \   000001A6   0x002C             MOVS     R4,R5
    294                  CLEAR_BIT(temp, (uint32_t)iocurrent); 
   \   000001A8   0x439C             BICS     R4,R4,R3
    295                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \   000001AA   0x684D             LDR      R5,[R1, #+4]
   \   000001AC   0x02ED             LSLS     R5,R5,#+11
   \   000001AE   0xD500             BPL.N    ??HAL_GPIO_Init_17
    296                  {
    297                    SET_BIT(temp, iocurrent); 
   \   000001B0   0x431C             ORRS     R4,R3,R4
    298                  }
    299                  EXTI->RTSR = temp;
   \                     ??HAL_GPIO_Init_17: (+1)
   \   000001B2   0x....             LDR.N    R5,??DataTable2_11  ;; 0x40010408
   \   000001B4   0x602C             STR      R4,[R5, #+0]
    300          
    301                  temp = EXTI->FTSR;
   \   000001B6   0x....             LDR.N    R5,??DataTable2_12  ;; 0x4001040c
   \   000001B8   0x682D             LDR      R5,[R5, #+0]
   \   000001BA   0x002C             MOVS     R4,R5
    302                  CLEAR_BIT(temp, (uint32_t)iocurrent); 
   \   000001BC   0x439C             BICS     R4,R4,R3
    303                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \   000001BE   0x684D             LDR      R5,[R1, #+4]
   \   000001C0   0x02AD             LSLS     R5,R5,#+10
   \   000001C2   0xD500             BPL.N    ??HAL_GPIO_Init_18
    304                  {
    305                    SET_BIT(temp, iocurrent); 
   \   000001C4   0x431C             ORRS     R4,R3,R4
    306                  }
    307                  EXTI->FTSR = temp;
   \                     ??HAL_GPIO_Init_18: (+1)
   \   000001C6   0x....             LDR.N    R5,??DataTable2_12  ;; 0x4001040c
   \   000001C8   0x602C             STR      R4,[R5, #+0]
    308                }
    309              }
    310              
    311              position++;
   \                     ??HAL_GPIO_Init_2: (+1)
   \   000001CA   0x1C52             ADDS     R2,R2,#+1
   \   000001CC   0xE71C             B.N      ??HAL_GPIO_Init_0
    312            } 
    313          }
   \                     ??HAL_GPIO_Init_1: (+1)
   \   000001CE   0xBC71             POP      {R0,R4-R6}
   \   000001D0   0x4770             BX       LR               ;; return
    314          
    315          /**
    316            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    317            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices
    318            * @param  GPIO_Pin: specifies the port bit to be written.
    319            *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
    320            * @retval None
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    323          {
   \                     HAL_GPIO_DeInit: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    324            uint32_t position = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    325            uint32_t iocurrent = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
    326            uint32_t tmp = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    327          
    328            /* Check the parameters */
    329            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    330            assert_param(IS_GPIO_PIN(GPIO_Pin));
    331          
    332            /* Configure the port pins */
    333            while ((GPIO_Pin >> position) != 0)
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x40D5             LSRS     R5,R5,R2
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xF000 0x8093      BEQ.W    ??HAL_GPIO_DeInit_1
    334            {
    335              /* Get current io position */
    336              iocurrent = (GPIO_Pin) & ((uint32_t)1 << position);
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0x4095             LSLS     R5,R5,R2
   \   00000016   0x400D             ANDS     R5,R5,R1
   \   00000018   0x002B             MOVS     R3,R5
    337          
    338              if (iocurrent)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xF000 0x808A      BEQ.W    ??HAL_GPIO_DeInit_2
    339              {
    340                /*------------------------- GPIO Mode Configuration --------------------*/
    341                /* Configure IO Direction in Input Floting Mode */
    342                CLEAR_BIT(GPIOx->MODER, GPIO_MODER_MODER0 << (position * 2)); 
   \   00000020   0x6805             LDR      R5,[R0, #+0]
   \   00000022   0x2603             MOVS     R6,#+3
   \   00000024   0x0017             MOVS     R7,R2
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x007F             LSLS     R7,R7,#+1
   \   0000002A   0x40BE             LSLS     R6,R6,R7
   \   0000002C   0x43B5             BICS     R5,R5,R6
   \   0000002E   0x6005             STR      R5,[R0, #+0]
    343            
    344                /* Configure the default Alternate Function in current IO */ 
    345                CLEAR_BIT(GPIOx->AFR[position >> 3], (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
   \   00000030   0x08D5             LSRS     R5,R2,#+3
   \   00000032   0xEB00 0x0585      ADD      R5,R0,R5, LSL #+2
   \   00000036   0x08D6             LSRS     R6,R2,#+3
   \   00000038   0xEB00 0x0686      ADD      R6,R0,R6, LSL #+2
   \   0000003C   0x6A36             LDR      R6,[R6, #+32]
   \   0000003E   0x270F             MOVS     R7,#+15
   \   00000040   0xF012 0x0C07      ANDS     R12,R2,#0x7
   \   00000044   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000048   0xEA5F 0x0C8C      LSLS     R12,R12,#+2
   \   0000004C   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000050   0x43BE             BICS     R6,R6,R7
   \   00000052   0x622E             STR      R6,[R5, #+32]
    346            
    347                /* Configure the default value for IO Speed */
    348                CLEAR_BIT(GPIOx->OSPEEDR, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
   \   00000054   0x6885             LDR      R5,[R0, #+8]
   \   00000056   0x2603             MOVS     R6,#+3
   \   00000058   0x0017             MOVS     R7,R2
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x007F             LSLS     R7,R7,#+1
   \   0000005E   0x40BE             LSLS     R6,R6,R7
   \   00000060   0x43B5             BICS     R5,R5,R6
   \   00000062   0x6085             STR      R5,[R0, #+8]
    349                            
    350                /* Configure the default value IO Output Type */
    351                CLEAR_BIT(GPIOx->OTYPER, GPIO_OTYPER_OT_0 << position) ;
   \   00000064   0x6845             LDR      R5,[R0, #+4]
   \   00000066   0x2601             MOVS     R6,#+1
   \   00000068   0x4096             LSLS     R6,R6,R2
   \   0000006A   0x43B5             BICS     R5,R5,R6
   \   0000006C   0x6045             STR      R5,[R0, #+4]
    352            
    353                /* Deactivate the Pull-up oand Pull-down resistor for the current IO */
    354                CLEAR_BIT(GPIOx->PUPDR, GPIO_PUPDR_PUPDR0 << (position * 2));
   \   0000006E   0x68C5             LDR      R5,[R0, #+12]
   \   00000070   0x2603             MOVS     R6,#+3
   \   00000072   0x0017             MOVS     R7,R2
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x007F             LSLS     R7,R7,#+1
   \   00000078   0x40BE             LSLS     R6,R6,R7
   \   0000007A   0x43B5             BICS     R5,R5,R6
   \   0000007C   0x60C5             STR      R5,[R0, #+12]
    355          
    356                /*------------------------- EXTI Mode Configuration --------------------*/
    357                /* Clear the External Interrupt or Event for the current IO */
    358                
    359                tmp = SYSCFG->EXTICR[position >> 2];
   \   0000007E   0x....             LDR.N    R5,??DataTable2_1  ;; 0x40010008
   \   00000080   0x0896             LSRS     R6,R2,#+2
   \   00000082   0xF855 0x5026      LDR      R5,[R5, R6, LSL #+2]
   \   00000086   0x002C             MOVS     R4,R5
    360                tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
   \   00000088   0x250F             MOVS     R5,#+15
   \   0000008A   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x00B6             LSLS     R6,R6,#+2
   \   00000092   0x40B5             LSLS     R5,R5,R6
   \   00000094   0x402C             ANDS     R4,R5,R4
    361                if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
   \   00000096   0x....             LDR.N    R5,??DataTable2_2  ;; 0x40020000
   \   00000098   0x42A8             CMP      R0,R5
   \   0000009A   0xD101             BNE.N    ??HAL_GPIO_DeInit_3
   \   0000009C   0x2500             MOVS     R5,#+0
   \   0000009E   0xE01E             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \   000000A0   0x....             LDR.N    R5,??DataTable2_3  ;; 0x40020400
   \   000000A2   0x42A8             CMP      R0,R5
   \   000000A4   0xD101             BNE.N    ??HAL_GPIO_DeInit_5
   \   000000A6   0x2501             MOVS     R5,#+1
   \   000000A8   0xE019             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \   000000AA   0x....             LDR.N    R5,??DataTable2_4  ;; 0x40020800
   \   000000AC   0x42A8             CMP      R0,R5
   \   000000AE   0xD101             BNE.N    ??HAL_GPIO_DeInit_6
   \   000000B0   0x2502             MOVS     R5,#+2
   \   000000B2   0xE014             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \   000000B4   0x....             LDR.N    R5,??DataTable2_5  ;; 0x40020c00
   \   000000B6   0x42A8             CMP      R0,R5
   \   000000B8   0xD101             BNE.N    ??HAL_GPIO_DeInit_7
   \   000000BA   0x2503             MOVS     R5,#+3
   \   000000BC   0xE00F             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \   000000BE   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40021000
   \   000000C0   0x42A8             CMP      R0,R5
   \   000000C2   0xD101             BNE.N    ??HAL_GPIO_DeInit_8
   \   000000C4   0x2504             MOVS     R5,#+4
   \   000000C6   0xE00A             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \   000000C8   0x....             LDR.N    R5,??DataTable2_7  ;; 0x40021400
   \   000000CA   0x42A8             CMP      R0,R5
   \   000000CC   0xD101             BNE.N    ??HAL_GPIO_DeInit_9
   \   000000CE   0x2505             MOVS     R5,#+5
   \   000000D0   0xE005             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_9: (+1)
   \   000000D2   0x....             LDR.N    R5,??DataTable2_8  ;; 0x40021800
   \   000000D4   0x42A8             CMP      R0,R5
   \   000000D6   0xD101             BNE.N    ??HAL_GPIO_DeInit_10
   \   000000D8   0x2506             MOVS     R5,#+6
   \   000000DA   0xE000             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_10: (+1)
   \   000000DC   0x2507             MOVS     R5,#+7
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \   000000DE   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   000000E2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E4   0x00B6             LSLS     R6,R6,#+2
   \   000000E6   0x40B5             LSLS     R5,R5,R6
   \   000000E8   0x42AC             CMP      R4,R5
   \   000000EA   0xD123             BNE.N    ??HAL_GPIO_DeInit_2
    362                {
    363                  tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
   \   000000EC   0x250F             MOVS     R5,#+15
   \   000000EE   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   000000F2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F4   0x00B6             LSLS     R6,R6,#+2
   \   000000F6   0x40B5             LSLS     R5,R5,R6
   \   000000F8   0x002C             MOVS     R4,R5
    364                  CLEAR_BIT(SYSCFG->EXTICR[position >> 2], tmp);
   \   000000FA   0x....             LDR.N    R5,??DataTable2_1  ;; 0x40010008
   \   000000FC   0x0896             LSRS     R6,R2,#+2
   \   000000FE   0xF855 0x5026      LDR      R5,[R5, R6, LSL #+2]
   \   00000102   0x43A5             BICS     R5,R5,R4
   \   00000104   0x....             LDR.N    R6,??DataTable2_1  ;; 0x40010008
   \   00000106   0x0897             LSRS     R7,R2,#+2
   \   00000108   0xF846 0x5027      STR      R5,[R6, R7, LSL #+2]
    365                  
    366                  /* Clear EXTI line configuration */
    367                  CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
   \   0000010C   0x....             LDR.N    R5,??DataTable2_9  ;; 0x40010400
   \   0000010E   0x682D             LDR      R5,[R5, #+0]
   \   00000110   0x439D             BICS     R5,R5,R3
   \   00000112   0x....             LDR.N    R6,??DataTable2_9  ;; 0x40010400
   \   00000114   0x6035             STR      R5,[R6, #+0]
    368                  CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
   \   00000116   0x....             LDR.N    R5,??DataTable2_10  ;; 0x40010404
   \   00000118   0x682D             LDR      R5,[R5, #+0]
   \   0000011A   0x439D             BICS     R5,R5,R3
   \   0000011C   0x....             LDR.N    R6,??DataTable2_10  ;; 0x40010404
   \   0000011E   0x6035             STR      R5,[R6, #+0]
    369                  
    370                  /* Clear Rising Falling edge configuration */
    371                  CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
   \   00000120   0x....             LDR.N    R5,??DataTable2_11  ;; 0x40010408
   \   00000122   0x682D             LDR      R5,[R5, #+0]
   \   00000124   0x439D             BICS     R5,R5,R3
   \   00000126   0x....             LDR.N    R6,??DataTable2_11  ;; 0x40010408
   \   00000128   0x6035             STR      R5,[R6, #+0]
    372                  CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
   \   0000012A   0x....             LDR.N    R5,??DataTable2_12  ;; 0x4001040c
   \   0000012C   0x682D             LDR      R5,[R5, #+0]
   \   0000012E   0x439D             BICS     R5,R5,R3
   \   00000130   0x....             LDR.N    R6,??DataTable2_12  ;; 0x4001040c
   \   00000132   0x6035             STR      R5,[R6, #+0]
    373                }
    374              }
    375              
    376              position++;
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \   00000134   0x1C52             ADDS     R2,R2,#+1
   \   00000136   0xE767             B.N      ??HAL_GPIO_DeInit_0
    377            }
    378          }
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \   00000138   0xBCF0             POP      {R4-R7}
   \   0000013A   0x4770             BX       LR               ;; return
    379          
    380          /**
    381            * @}
    382            */
    383          
    384          /** @addtogroup GPIO_Exported_Functions_Group2
    385           *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.
    386           *
    387          @verbatim   
    388           ===============================================================================
    389                                 ##### IO operation functions #####
    390           ===============================================================================  
    391          
    392          @endverbatim
    393            * @{
    394            */
    395          
    396          /**
    397            * @brief  Reads the specified input port pin.
    398            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices 
    399            * @param  GPIO_Pin: specifies the port bit to read.
    400            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    401            * @retval The input port pin value.
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    404          {
   \                     HAL_GPIO_ReadPin: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    405            GPIO_PinState bitstatus;
    406          
    407            /* Check the parameters */
    408            assert_param(IS_GPIO_PIN(GPIO_Pin));
    409          
    410            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \   00000002   0x6913             LDR      R3,[R2, #+16]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD002             BEQ.N    ??HAL_GPIO_ReadPin_0
    411            {
    412              bitstatus = GPIO_PIN_SET;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??HAL_GPIO_ReadPin_1
    413            }
    414            else
    415            {
    416              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0018             MOVS     R0,R3
    417            }
    418            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    419          }
    420          
    421          /**
    422            * @brief  Sets or clears the selected data port bit.
    423            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify 
    424            *         accesses. In this way, there is no risk of an IRQ occurring between
    425            *         the read and the modify access.
    426            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices
    427            * @param  GPIO_Pin: specifies the port bit to be written.
    428            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    429            * @param  PinState: specifies the value to be written to the selected bit.
    430            *          This parameter can be one of the GPIO_PinState enum values:
    431            *            @arg GPIO_PIN_RESET: to clear the port pin
    432            *            @arg GPIO_PIN_SET: to set the port pin
    433            * @retval None
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    436          {
    437            /* Check the parameters */
    438            assert_param(IS_GPIO_PIN(GPIO_Pin));
    439            assert_param(IS_GPIO_PIN_ACTION(PinState));
    440          
    441            if (PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??HAL_GPIO_WritePin_0
    442            {
    443              GPIOx->BSRR = (uint32_t)GPIO_Pin;
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x6181             STR      R1,[R0, #+24]
   \   0000000A   0xE002             B.N      ??HAL_GPIO_WritePin_1
    444            }
    445            else
    446            {
    447              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16 ;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x040B             LSLS     R3,R1,#+16
   \   00000010   0x6183             STR      R3,[R0, #+24]
    448            }
    449          }
   \                     ??HAL_GPIO_WritePin_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    450            
    451          /**
    452            * @brief  Toggles the specified GPIO pin
    453            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices 
    454            * @param  GPIO_Pin: specifies the pins to be toggled.
    455            * @retval None
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    458          {
    459            /* Check the parameters */
    460            assert_param(IS_GPIO_PIN(GPIO_Pin));
    461          
    462            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x404A             EORS     R2,R1,R2
   \   00000006   0x6142             STR      R2,[R0, #+20]
    463          }
   \   00000008   0x4770             BX       LR               ;; return
    464          
    465          /**
    466          * @brief  Locks GPIO Pins configuration registers.
    467          * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    468          *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    469          * @note   The configuration of the locked GPIO pins can no longer be modified
    470          *         until the next reset.
    471          * @note   Limitation concerning GPIOx_OTYPER: Locking of GPIOx_OTYPER[i] with i = 15..8
    472          *         depends from setting of GPIOx_LCKR[i-8] and not from GPIOx_LCKR[i].
    473          *         GPIOx_LCKR[i-8] is locking GPIOx_OTYPER[i] together with GPIOx_OTYPER[i-8].
    474          *         It is not possible to lock GPIOx_OTYPER[i] with i = 15..8, without locking also
    475          *         GPIOx_OTYPER[i-8].
    476          *         Workaround: When calling HAL_GPIO_LockPin with GPIO_Pin from GPIO_PIN_8 to GPIO_PIN_15,
    477          *         you must call also HAL_GPIO_LockPin with GPIO_Pin - 8. 
    478          *         (When locking a pin from GPIO_PIN_8 to GPIO_PIN_15, you must lock also the corresponding 
    479          *         GPIO_PIN_0 to GPIO_PIN_7).
    480          * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral for STM32L1XX family devices 
    481          * @param  GPIO_Pin: Specifies the port bit to be locked.
    482          *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    483          * @retval None
    484          */

   \                                 In section .text, align 2, keep-with-next
    485          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    486          {
   \                     HAL_GPIO_LockPin: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0002             MOVS     R2,R0
    487            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \   00000004   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000008   0x9000             STR      R0,[SP, #+0]
    488          
    489            /* Check the parameters */
    490            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    491            assert_param(IS_GPIO_PIN(GPIO_Pin));
    492          
    493            /* Apply lock key write sequence */
    494            SET_BIT(tmp, GPIO_Pin);
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x9000             STR      R0,[SP, #+0]
    495            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    496            GPIOx->LCKR = tmp;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x61D0             STR      R0,[R2, #+28]
    497            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    498            GPIOx->LCKR = GPIO_Pin;
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x61D1             STR      R1,[R2, #+28]
    499            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    500            GPIOx->LCKR = tmp;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x61D0             STR      R0,[R2, #+28]
    501            /* Read LCKK bit*/
    502            tmp = GPIOx->LCKR;
   \   0000001E   0x69D0             LDR      R0,[R2, #+28]
   \   00000020   0x9000             STR      R0,[SP, #+0]
    503          
    504            if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \   00000022   0x69D0             LDR      R0,[R2, #+28]
   \   00000024   0x03C0             LSLS     R0,R0,#+15
   \   00000026   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    505            {
    506              return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_GPIO_LockPin_1
    507            }
    508            else
    509            {
    510              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \   0000002E   0xB001             ADD      SP,SP,#+4
   \   00000030   0x4770             BX       LR               ;; return
    511            }
    512          }
    513          
    514          /**
    515            * @brief  This function handles EXTI interrupt request.
    516            * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
    517            * @retval None
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    520          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    521            /* EXTI line interrupt detected */
    522            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
   \   00000004   0x....             LDR.N    R0,??DataTable2_13  ;; 0x40010414
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x4220             TST      R0,R4
   \   0000000C   0xD006             BEQ.N    ??HAL_GPIO_EXTI_IRQHandler_0
    523            { 
    524              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x....             LDR.N    R0,??DataTable2_13  ;; 0x40010414
   \   00000012   0x6004             STR      R4,[R0, #+0]
    525              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    526            }
    527          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    528          
    529          /**
    530            * @brief  EXTI line detection callbacks.
    531            * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
    532            * @retval None
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    535          {
    536            /* Prevent unused argument(s) compilation warning */
    537            UNUSED(GPIO_Pin);
    538          
    539            /* NOTE : This function Should not be modified, when the callback is needed,
    540                      the HAL_GPIO_EXTI_Callback could be implemented in the user file
    541             */ 
    542          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40010008         DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40010404         DC32     0x40010404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40010408         DC32     0x40010408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x4001040C         DC32     0x4001040c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x40010414         DC32     0x40010414
    543          
    544          /**
    545            * @}
    546            */
    547          
    548          
    549          /**
    550            * @}
    551            */
    552          
    553          #endif /* HAL_GPIO_MODULE_ENABLED */
    554          /**
    555            * @}
    556            */
    557          
    558          /**
    559            * @}
    560            */
    561          
    562          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      16   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     316  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      30  HAL_GPIO_EXTI_IRQHandler
     466  HAL_GPIO_Init
      50  HAL_GPIO_LockPin
      24  HAL_GPIO_ReadPin
      10  HAL_GPIO_TogglePin
      20  HAL_GPIO_WritePin

 
 974 bytes in section .text
 
 974 bytes of CODE memory

Errors: none
Warnings: none
