###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       13/Dec/2017  09:15:37
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_hal_rcc.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_hal_rcc.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.1.3
      6            * @date    04-March-2016
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..]  
     18                After reset the device is running from multispeed internal oscillator clock 
     19                (MSI 2.097MHz) with Flash 0 wait state and Flash prefetch buffer is disabled, 
     20                and all peripherals are off except internal SRAM, Flash and JTAG.
     21                (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;
     22                    all peripherals mapped on these buses are running at MSI speed.
     23                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     24                (+) All GPIOs are in input floating state, except the JTAG pins which
     25                    are assigned to be used for debug purpose.
     26              [..] Once the device started from reset, the user application has to:
     27                (+) Configure the clock source to be used to drive the System clock
     28                    (if the application needs higher frequency/performance)
     29                (+) Configure the System clock frequency and Flash settings  
     30                (+) Configure the AHB and APB buses prescalers
     31                (+) Enable the clock for the peripheral(s) to be used
     32                (+) Configure the clock source(s) for peripherals whose clocks are not
     33                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG) 
     34                    (*) SDIO only for STM32L1xxxD devices
     35          
     36                                ##### RCC Limitations #####
     37            ==============================================================================
     38              [..]  
     39                A delay between an RCC peripheral clock enable and the effective peripheral 
     40                enabling should be taken into account in order to manage the peripheral read/write 
     41                from/to registers.
     42                (+) This delay depends on the peripheral mapping.
     43                  (++) AHB & APB peripherals, 1 dummy read is necessary
     44          
     45              [..]  
     46                Workarounds:
     47                (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
     48                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     49          
     50            @endverbatim
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     55            *
     56            * Redistribution and use in source and binary forms, with or without modification,
     57            * are permitted provided that the following conditions are met:
     58            *   1. Redistributions of source code must retain the above copyright notice,
     59            *      this list of conditions and the following disclaimer.
     60            *   2. Redistributions in binary form must reproduce the above copyright notice,
     61            *      this list of conditions and the following disclaimer in the documentation
     62            *      and/or other materials provided with the distribution.
     63            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     64            *      may be used to endorse or promote products derived from this software
     65            *      without specific prior written permission.
     66            *
     67            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     68            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     69            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     70            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     71            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     72            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     73            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     74            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     75            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     76            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     77            *
     78            ******************************************************************************  
     79          */ 
     80            
     81          /* Includes ------------------------------------------------------------------*/
     82          #include "stm32l1xx_hal.h"
     83          
     84          /** @addtogroup STM32L1xx_HAL_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup RCC RCC
     89          * @brief RCC HAL module driver
     90            * @{
     91            */
     92          
     93          #ifdef HAL_RCC_MODULE_ENABLED
     94          
     95          /* Private typedef -----------------------------------------------------------*/
     96          /* Private define ------------------------------------------------------------*/
     97          /** @defgroup RCC_Private_Constants RCC Private Constants
     98           * @{
     99           */
    100          /**
    101            * @}
    102            */
    103          /* Private macro -------------------------------------------------------------*/
    104          /** @defgroup RCC_Private_Macros RCC Private Macros
    105            * @{
    106            */
    107          
    108          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
    109          #define MCO1_GPIO_PORT        GPIOA
    110          #define MCO1_PIN              GPIO_PIN_8
    111          
    112          /**
    113            * @}
    114            */
    115          
    116          /* Private variables ---------------------------------------------------------*/
    117          /** @defgroup RCC_Private_Variables RCC Private Variables
    118            * @{
    119            */

   \                                 In section .rodata, align 4
    120          const uint8_t aPLLDivisionFactorTable[4]  = {1, 2, 3, 4};
   \                     aPLLDivisionFactorTable:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 4
   \              0x03 0x04    

   \                                 In section .rodata, align 4
    121          const uint8_t aPLLMULFactorTable[9]       = {3, 4, 6, 8, 12, 16, 24, 32, 48};
   \                     aPLLMULFactorTable:
   \   00000000   0x03 0x04          DC8 3, 4, 6, 8, 12, 16, 24, 32, 48, 0, 0, 0
   \              0x06 0x08    
   \              0x0C 0x10    
   \              0x18 0x20    
   \              0x30 0x00    
   \              0x00 0x00    
    122          /**
    123            * @}
    124            */
    125          
    126          /* Private function prototypes -----------------------------------------------*/
    127          /** @defgroup RCC_Private_Functions RCC Private Functions
    128            * @{
    129            */
    130          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange);
    131          /**
    132            * @}
    133            */
    134          
    135          /* Exported functions ---------------------------------------------------------*/
    136          
    137          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    138            * @{
    139            */
    140          
    141          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions 
    142            *  @brief    Initialization and Configuration functions 
    143            *
    144            @verbatim    
    145            ===============================================================================
    146                     ##### Initialization and de-initialization functions #####
    147            ===============================================================================
    148              [..]
    149                This section provides functions allowing to configure the internal/external oscillators
    150                (MSI, HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1 
    151                and APB2).
    152          
    153              [..] Internal/external clock and PLL configuration
    154                (#) MSI (Multispeed internal), Seven frequency ranges are available: 65.536 kHz, 
    155                    131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz, 2.097 MHz (default value) and 4.194 MHz.
    156          
    157                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    158                    the PLL as System clock source.
    159                (#) LSI (low-speed internal), ~37 KHz low consumption RC used as IWDG and/or RTC
    160                    clock source.
    161          
    162                (#) HSE (high-speed external), 1 to 24 MHz crystal oscillator used directly or
    163                    through the PLL as System clock source. Can be used also as RTC clock source.
    164          
    165                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    166          
    167                (#) PLL (clocked by HSI or HSE), featuring different output clocks:
    168                  (++) The first output is used to generate the high speed system clock (up to 32 MHz)
    169                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz)
    170          
    171                (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    172                    and if a HSE clock failure occurs(HSE used directly or through PLL as System 
    173                    clock source), the System clocks automatically switched to MSI and an interrupt
    174                    is generated if enabled. The interrupt is linked to the Cortex-M3 NMI 
    175                    (Non-Maskable Interrupt) exception vector.   
    176          
    177                (#) MCO1 (microcontroller clock output), used to output SYSCLK, HSI, LSI, MSI, LSE, 
    178                    HSE or PLL clock (through a configurable prescaler) on PA8 pin.
    179          
    180              [..] System, AHB and APB buses clocks configuration
    181                (#) Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    182                    HSE and PLL.
    183                    The AHB clock (HCLK) is derived from System clock through configurable
    184                    prescaler and used to clock the CPU, memory and peripherals mapped
    185                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
    186                    from AHB clock through configurable prescalers and used to clock
    187                    the peripherals mapped on these buses. You can use
    188                    "@ref HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    189          
    190                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    191                    (+@) RTC: RTC clock can be derived either from the LSI, LSE or HSE clock
    192                        divided by 2 to 16. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
    193                        macros to configure this clock. 
    194                    (+@) LCD: LCD clock can be derived either from the LSI, LSE or HSE clock
    195                        divided by 2 to 16. You have to use __HAL_RCC_LCD_CONFIG()
    196                        macros to configure this clock. 
    197                    (+@) USB OTG FS and RTC: USB OTG FS require a frequency equal to 48 MHz
    198                        to work correctly. This clock is derived of the main PLL through PLL Multiplier.
    199                    (+@) IWDG clock which is always the LSI clock.
    200          
    201                (#) The maximum frequency of the SYSCLK and HCLK is 32 MHz, PCLK2 32 MHz 
    202                    and PCLK1 32 MHz. Depending on the device voltage range, the maximum 
    203                    frequency should be adapted accordingly.
    204            @endverbatim
    205            * @{
    206            */
    207            
    208          /*
    209            Additional consideration on the HCLK based on Latency settings:
    210            +----------------------------------------------------------------------+     
    211            | Latency       |                HCLK clock frequency (MHz)            |
    212            |               |------------------------------------------------------|     
    213            |               | voltage range 1  | voltage range 2 | voltage range 3 |
    214            |               |      1.8 V       |     1.5 V       |      1.2 V      |
    215            |---------------|------------------|-----------------|-----------------|              
    216            |0WS(1CPU cycle)| 0 < HCLK <= 16   | 0 < HCLK <= 8   | 0 < HCLK <= 2   |
    217            |---------------|------------------|-----------------|-----------------| 
    218            |1WS(2CPU cycle)| 16 < HCLK <= 32  | 8 < HCLK <= 16  | 2 < HCLK <= 4   | 
    219            +----------------------------------------------------------------------+     
    220          
    221            The following table gives the different clock source frequencies depending on the product
    222            voltage range:
    223            +------------------------------------------------------------------------------------------+     
    224            | Product voltage |                    Clock frequency                                     |
    225            |                 |------------------|-----------------------------|-----------------------|              
    226            |      range      |   MSI   |   HSI  |              HSE            |          PLL          |
    227            |-----------------|---------|--------|-----------------------------|-----------------------|              
    228            | Range 1 (1.8 V) | 4.2 MHz | 16 MHz | HSE 32 MHz (external clock) |         32 MHz        |
    229            |                 |         |        |      or 24 MHz (crystal)    | (PLLVCO max = 96 MHz) |
    230            |-----------------|---------|--------|-----------------------------|-----------------------|              
    231            | Range 2 (1.5 V) | 4.2 MHz | 16 MHz |         16 MHz              |         16 MHz        |
    232            |                 |         |        |                             | (PLLVCO max = 48 MHz) |
    233            |-----------------|---------|--------|-----------------------------|-----------------------|              
    234            | Range 3 (1.2 V) | 4.2 MHz |   NA   |         8 MHz               |           4 MHz       |
    235            |                 |         |        |                             | (PLLVCO max = 24 MHz) |
    236            +------------------------------------------------------------------------------------------+     
    237            */
    238          
    239          /**
    240            * @brief  Resets the RCC clock configuration to the default reset state.
    241            * @note   The default reset state of the clock configuration is given below:
    242            *            - MSI ON and used as system clock source
    243            *            - HSI, HSE and PLL  OFF
    244            *            - AHB, APB1 and APB2 prescaler set to 1.
    245            *            - CSS and MCO1 OFF
    246            *            - All interrupts disabled
    247            * @note   This function doesn't modify the configuration of the
    248            *            - Peripheral clocks  
    249            *            - LSI, LSE and RTC clocks 
    250            * @retval None
    251            */

   \                                 In section .text, align 2, keep-with-next
    252          void HAL_RCC_DeInit(void)
    253          {
    254            /* Set MSION bit */
    255            SET_BIT(RCC->CR, RCC_CR_MSION);
   \                     HAL_RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    256            
    257            /* Switch SYSCLK to MSI*/
    258            CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0880             LSRS     R0,R0,#+2
   \   00000018   0x0080             LSLS     R0,R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40023808
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    259          
    260            /* Reset HSION, HSEON, CSSON, HSEBYP & PLLON bits */
    261            CLEAR_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_HSEBYP);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0xeefafffe
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   00000030   0x6008             STR      R0,[R1, #+0]
    262            
    263            /* Reset CFGR register */
    264            CLEAR_REG(RCC->CFGR);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40023808
   \   00000038   0x6008             STR      R0,[R1, #+0]
    265            
    266            /* Set MSIClockRange & MSITRIM[4:0] bits to the reset value */
    267            MODIFY_REG(RCC->ICSCR, (RCC_ICSCR_MSIRANGE | RCC_ICSCR_MSITRIM), (((uint32_t)0 << POSITION_VAL(RCC_ICSCR_MSITRIM)) | RCC_ICSCR_MSIRANGE_5));
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0xFAB1 0xF181      CLZ      R1,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0xff1fff
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0xF450 0x4020      ORRS     R0,R0,#0xA000
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000054   0x6008             STR      R0,[R1, #+0]
    268            
    269            /* Set HSITRIM bits to the reset value */
    270            MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_ICSCR_HSITRIM)));
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   00000060   0x2110             MOVS     R1,#+16
   \   00000062   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x4091             LSLS     R1,R1,R2
   \   0000006C   0x4308             ORRS     R0,R1,R0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000072   0x6008             STR      R0,[R1, #+0]
    271            
    272            /* Disable all interrupts */
    273            CLEAR_REG(RCC->CIR);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable9_5  ;; 0x4002380c
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    274          
    275            /* Update the SystemCoreClock global variable */
    276            SystemCoreClock = MSI_VALUE;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0xf42400
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000084   0x6008             STR      R0,[R1, #+0]
    277          }
   \   00000086   0x4770             BX       LR               ;; return
    278          
    279          /**
    280            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    281            *         RCC_OscInitTypeDef.
    282            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    283            *         contains the configuration information for the RCC Oscillators.
    284            * @note   The PLL is not disabled when used as system clock.
    285            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    286            *         supported by this macro. User should request a transition to LSE Off
    287            *         first and then LSE On or LSE Bypass.
    288            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    289            *         supported by this macro. User should request a transition to HSE Off
    290            *         first and then HSE On or HSE Bypass.
    291            * @retval HAL status
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    294          {
   \                     HAL_RCC_OscConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    295             uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    296            
    297            /* Check the parameters */
    298            assert_param(RCC_OscInitStruct != NULL);
    299            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    300            
    301            /*------------------------------- HSE Configuration ------------------------*/ 
    302            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xF140 0x80C6      BPL.W    ??HAL_RCC_OscConfig_0
    303            {
    304              /* Check the parameters */
    305              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    306                  
    307              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    308              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
    309                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000018   0x2808             CMP      R0,#+8
   \   0000001A   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000026   0x280C             CMP      R0,#+12
   \   00000028   0xD126             BNE.N    ??HAL_RCC_OscConfig_2
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x03C0             LSLS     R0,R0,#+15
   \   00000032   0xD521             BPL.N    ??HAL_RCC_OscConfig_2
    310              {
    311                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0xFAB0 0xF080      CLZ      R0,R0
   \   0000003C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x0940             LSRS     R0,R0,#+5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD103             BNE.N    ??HAL_RCC_OscConfig_3
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xE002             B.N      ??HAL_RCC_OscConfig_4
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \   00000058   0xF44F 0x4180      MOV      R1,#+16384
   \   0000005C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000060   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000064   0x40C8             LSRS     R0,R0,R1
   \   00000066   0x07C0             LSLS     R0,R0,#+31
   \   00000068   0xF140 0x8097      BPL.W    ??HAL_RCC_OscConfig_0
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xF040 0x8093      BNE.W    ??HAL_RCC_OscConfig_0
    312                {
    313                  return HAL_ERROR;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE3D7             B.N      ??HAL_RCC_OscConfig_5
    314                }
    315              }
    316              else
    317              {
    318                /* Set the new HSE configuration ---------------------------------------*/
    319                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \   00000078   0x6860             LDR      R0,[R4, #+4]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD108             BNE.N    ??HAL_RCC_OscConfig_6
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   \   0000008E   0xE037             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \   00000090   0x6860             LDR      R0,[R4, #+4]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD110             BNE.N    ??HAL_RCC_OscConfig_8
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   \   000000B6   0xE023             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0x2805             CMP      R0,#+5
   \   000000BC   0xD110             BNE.N    ??HAL_RCC_OscConfig_9
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000DC   0x6008             STR      R0,[R1, #+0]
   \   000000DE   0xE00F             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000EE   0x6008             STR      R0,[R1, #+0]
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023800
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    320                
    321          
    322                 /* Check the HSE State */
    323                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \   00000100   0x6860             LDR      R0,[R4, #+4]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD024             BEQ.N    ??HAL_RCC_OscConfig_10
    324                {
    325                  /* Get Start Tick */
    326                  tickstart = HAL_GetTick();
   \   00000106   0x.... 0x....      BL       HAL_GetTick
   \   0000010A   0x0005             MOVS     R5,R0
    327                  
    328                  /* Wait till HSE is ready */
    329                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \   0000010C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000110   0xFAB0 0xF080      CLZ      R0,R0
   \   00000114   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0x0940             LSRS     R0,R0,#+5
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD103             BNE.N    ??HAL_RCC_OscConfig_12
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xE002             B.N      ??HAL_RCC_OscConfig_13
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \   00000130   0xF44F 0x4180      MOV      R1,#+16384
   \   00000134   0xFAB1 0xF181      CLZ      R1,R1
   \   00000138   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000013C   0x40C8             LSRS     R0,R0,R1
   \   0000013E   0x07C0             LSLS     R0,R0,#+31
   \   00000140   0xD42B             BMI.N    ??HAL_RCC_OscConfig_0
    330                  {
    331                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   00000142   0x.... 0x....      BL       HAL_GetTick
   \   00000146   0x1B40             SUBS     R0,R0,R5
   \   00000148   0x2865             CMP      R0,#+101
   \   0000014A   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_11
    332                    {
    333                      return HAL_TIMEOUT;
   \   0000014C   0x2003             MOVS     R0,#+3
   \   0000014E   0xE36B             B.N      ??HAL_RCC_OscConfig_5
    334                    }
    335                  }
    336                }
    337                else
    338                {
    339                  /* Get Start Tick */
    340                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \   00000150   0x.... 0x....      BL       HAL_GetTick
   \   00000154   0x0005             MOVS     R5,R0
    341                  
    342                  /* Wait till HSE is disabled */
    343                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \   00000156   0xF44F 0x4080      MOV      R0,#+16384
   \   0000015A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000015E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x0940             LSRS     R0,R0,#+5
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xD103             BNE.N    ??HAL_RCC_OscConfig_15
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0xE002             B.N      ??HAL_RCC_OscConfig_16
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \   0000017A   0xF44F 0x4180      MOV      R1,#+16384
   \   0000017E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000182   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000186   0x40C8             LSRS     R0,R0,R1
   \   00000188   0x07C0             LSLS     R0,R0,#+31
   \   0000018A   0xD506             BPL.N    ??HAL_RCC_OscConfig_0
    344                  {
    345                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   0000018C   0x.... 0x....      BL       HAL_GetTick
   \   00000190   0x1B40             SUBS     R0,R0,R5
   \   00000192   0x2865             CMP      R0,#+101
   \   00000194   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_14
    346                    {
    347                      return HAL_TIMEOUT;
   \   00000196   0x2003             MOVS     R0,#+3
   \   00000198   0xE346             B.N      ??HAL_RCC_OscConfig_5
    348                    }
    349                  }
    350                }
    351              }
    352            }
    353            /*----------------------------- HSI Configuration --------------------------*/ 
    354            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \   0000019A   0x7820             LDRB     R0,[R4, #+0]
   \   0000019C   0x0780             LSLS     R0,R0,#+30
   \   0000019E   0xF140 0x80B6      BPL.W    ??HAL_RCC_OscConfig_17
    355            {
    356              /* Check the parameters */
    357              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    358              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    359              
    360              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    361              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
    362                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001AC   0x2804             CMP      R0,#+4
   \   000001AE   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_18
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   000001B4   0x6800             LDR      R0,[R0, #+0]
   \   000001B6   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001BA   0x280C             CMP      R0,#+12
   \   000001BC   0xD135             BNE.N    ??HAL_RCC_OscConfig_19
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   000001C2   0x6800             LDR      R0,[R0, #+0]
   \   000001C4   0x03C0             LSLS     R0,R0,#+15
   \   000001C6   0xD430             BMI.N    ??HAL_RCC_OscConfig_19
    363              {
    364                /* When HSI is used as system clock it will not disabled */
    365                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \   000001C8   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000001CC   0xFAB0 0xF080      CLZ      R0,R0
   \   000001D0   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D6   0x0940             LSRS     R0,R0,#+5
   \   000001D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DA   0x2801             CMP      R0,#+1
   \   000001DC   0xD103             BNE.N    ??HAL_RCC_OscConfig_20
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0xE002             B.N      ??HAL_RCC_OscConfig_21
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \   000001EC   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000001F0   0xFAB1 0xF181      CLZ      R1,R1
   \   000001F4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000001F8   0x40C8             LSRS     R0,R0,R1
   \   000001FA   0x07C0             LSLS     R0,R0,#+31
   \   000001FC   0xD504             BPL.N    ??HAL_RCC_OscConfig_22
   \   000001FE   0x68E0             LDR      R0,[R4, #+12]
   \   00000200   0x2801             CMP      R0,#+1
   \   00000202   0xD001             BEQ.N    ??HAL_RCC_OscConfig_22
    366                {
    367                  return HAL_ERROR;
   \   00000204   0x2001             MOVS     R0,#+1
   \   00000206   0xE30F             B.N      ??HAL_RCC_OscConfig_5
    368                }
    369                /* Otherwise, just the calibration is allowed */
    370                else
    371                {
    372                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    373                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \   0000020E   0xF45F 0x0178      MOVS     R1,#+16252928
   \   00000212   0xFAB1 0xF181      CLZ      R1,R1
   \   00000216   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   0000021A   0x6922             LDR      R2,[R4, #+16]
   \   0000021C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000220   0x4308             ORRS     R0,R1,R0
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000226   0x6008             STR      R0,[R1, #+0]
   \   00000228   0xE071             B.N      ??HAL_RCC_OscConfig_17
    374                }
    375              }
    376              else
    377              {
    378                /* Check the HSI State */
    379                if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \   0000022A   0x68E0             LDR      R0,[R4, #+12]
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD03F             BEQ.N    ??HAL_RCC_OscConfig_23
    380                {
    381                 /* Enable the Internal High Speed oscillator (HSI). */
    382                  __HAL_RCC_HSI_ENABLE();
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000236   0xFAB1 0xF181      CLZ      R1,R1
   \   0000023A   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   0000023E   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000242   0x6008             STR      R0,[R1, #+0]
    383                  
    384                  /* Get Start Tick */
    385                  tickstart = HAL_GetTick();
   \   00000244   0x.... 0x....      BL       HAL_GetTick
   \   00000248   0x0005             MOVS     R5,R0
    386                  
    387                  /* Wait till HSI is ready */
    388                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \   0000024A   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000024E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000252   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000256   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000258   0x0940             LSRS     R0,R0,#+5
   \   0000025A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025C   0x2801             CMP      R0,#+1
   \   0000025E   0xD103             BNE.N    ??HAL_RCC_OscConfig_25
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000264   0x6800             LDR      R0,[R0, #+0]
   \   00000266   0xE002             B.N      ??HAL_RCC_OscConfig_26
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000026C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \   0000026E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000272   0xFAB1 0xF181      CLZ      R1,R1
   \   00000276   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000027A   0x40C8             LSRS     R0,R0,R1
   \   0000027C   0x07C0             LSLS     R0,R0,#+31
   \   0000027E   0xD406             BMI.N    ??HAL_RCC_OscConfig_27
    389                  {
    390                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   00000280   0x.... 0x....      BL       HAL_GetTick
   \   00000284   0x1B40             SUBS     R0,R0,R5
   \   00000286   0x2803             CMP      R0,#+3
   \   00000288   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_24
    391                    {
    392                      return HAL_TIMEOUT;
   \   0000028A   0x2003             MOVS     R0,#+3
   \   0000028C   0xE2CC             B.N      ??HAL_RCC_OscConfig_5
    393                    }
    394                  }
    395                          
    396                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    397                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000292   0x6800             LDR      R0,[R0, #+0]
   \   00000294   0xF45F 0x0178      MOVS     R1,#+16252928
   \   00000298   0xFAB1 0xF181      CLZ      R1,R1
   \   0000029C   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   000002A0   0x6922             LDR      R2,[R4, #+16]
   \   000002A2   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000002A6   0x4308             ORRS     R0,R1,R0
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   000002AC   0x6008             STR      R0,[R1, #+0]
   \   000002AE   0xE02E             B.N      ??HAL_RCC_OscConfig_17
    398                }
    399                else
    400                {
    401                  /* Disable the Internal High Speed oscillator (HSI). */
    402                  __HAL_RCC_HSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \   000002B0   0x2000             MOVS     R0,#+0
   \   000002B2   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   000002B6   0xFAB1 0xF181      CLZ      R1,R1
   \   000002BA   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000002BE   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000002C2   0x6008             STR      R0,[R1, #+0]
    403                  
    404                  /* Get Start Tick */
    405                  tickstart = HAL_GetTick();
   \   000002C4   0x.... 0x....      BL       HAL_GetTick
   \   000002C8   0x0005             MOVS     R5,R0
    406                  
    407                  /* Wait till HSI is disabled */
    408                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \   000002CA   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000002CE   0xFAB0 0xF080      CLZ      R0,R0
   \   000002D2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002D8   0x0940             LSRS     R0,R0,#+5
   \   000002DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002DC   0x2801             CMP      R0,#+1
   \   000002DE   0xD103             BNE.N    ??HAL_RCC_OscConfig_29
   \   000002E0   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000002E4   0x6800             LDR      R0,[R0, #+0]
   \   000002E6   0xE002             B.N      ??HAL_RCC_OscConfig_30
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \   000002E8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000002EC   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \   000002EE   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000002F2   0xFAB1 0xF181      CLZ      R1,R1
   \   000002F6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002FA   0x40C8             LSRS     R0,R0,R1
   \   000002FC   0x07C0             LSLS     R0,R0,#+31
   \   000002FE   0xD506             BPL.N    ??HAL_RCC_OscConfig_17
    409                  {
    410                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   00000300   0x.... 0x....      BL       HAL_GetTick
   \   00000304   0x1B40             SUBS     R0,R0,R5
   \   00000306   0x2803             CMP      R0,#+3
   \   00000308   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_28
    411                    {
    412                      return HAL_TIMEOUT;
   \   0000030A   0x2003             MOVS     R0,#+3
   \   0000030C   0xE28C             B.N      ??HAL_RCC_OscConfig_5
    413                    }
    414                  }
    415                }
    416              }
    417            }
    418            /*----------------------------- MSI Configuration --------------------------*/ 
    419            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \   0000030E   0x7820             LDRB     R0,[R4, #+0]
   \   00000310   0x06C0             LSLS     R0,R0,#+27
   \   00000312   0xF140 0x80EE      BPL.W    ??HAL_RCC_OscConfig_31
    420            {
    421              /* Check the parameters */
    422              assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    423              assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    424              assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    425          
    426              /* When the MSI is used as system clock it will not be disabled */
    427              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
   \   00000316   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   0000031A   0x6800             LDR      R0,[R0, #+0]
   \   0000031C   0xF010 0x0F0C      TST      R0,#0xC
   \   00000320   0xD16C             BNE.N    ??HAL_RCC_OscConfig_32
    428              {
    429                if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
   \   00000322   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000326   0xFAB0 0xF080      CLZ      R0,R0
   \   0000032A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000032E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000330   0x0940             LSRS     R0,R0,#+5
   \   00000332   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000334   0x2801             CMP      R0,#+1
   \   00000336   0xD103             BNE.N    ??HAL_RCC_OscConfig_33
   \   00000338   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   0000033C   0x6800             LDR      R0,[R0, #+0]
   \   0000033E   0xE002             B.N      ??HAL_RCC_OscConfig_34
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000344   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \   00000346   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000034A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000034E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000352   0x40C8             LSRS     R0,R0,R1
   \   00000354   0x07C0             LSLS     R0,R0,#+31
   \   00000356   0xD504             BPL.N    ??HAL_RCC_OscConfig_35
   \   00000358   0x69A0             LDR      R0,[R4, #+24]
   \   0000035A   0x2800             CMP      R0,#+0
   \   0000035C   0xD101             BNE.N    ??HAL_RCC_OscConfig_35
    430                {
    431                  return HAL_ERROR;
   \   0000035E   0x2001             MOVS     R0,#+1
   \   00000360   0xE262             B.N      ??HAL_RCC_OscConfig_5
    432                }
    433          
    434                 /* Otherwise, just the calibration and MSI range change are allowed */
    435                else
    436                {
    437                  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    438                     must be correctly programmed according to the frequency of the CPU clock
    439                     (HCLK) and the supply voltage of the device. */
    440                  if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \   00000362   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000366   0x6800             LDR      R0,[R0, #+0]
   \   00000368   0xF410 0x4060      ANDS     R0,R0,#0xE000
   \   0000036C   0x6A21             LDR      R1,[R4, #+32]
   \   0000036E   0x4288             CMP      R0,R1
   \   00000370   0xD220             BCS.N    ??HAL_RCC_OscConfig_36
    441                  {
    442                    /* First increase number of wait states update if necessary */
    443                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
   \   00000372   0x6A20             LDR      R0,[R4, #+32]
   \   00000374   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   00000378   0x2800             CMP      R0,#+0
   \   0000037A   0xD001             BEQ.N    ??HAL_RCC_OscConfig_37
    444                    {
    445                      return HAL_ERROR;
   \   0000037C   0x2001             MOVS     R0,#+1
   \   0000037E   0xE253             B.N      ??HAL_RCC_OscConfig_5
    446                    }
    447          
    448                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    449                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \   00000380   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   0000038A   0x6A21             LDR      R1,[R4, #+32]
   \   0000038C   0x4308             ORRS     R0,R1,R0
   \   0000038E   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000392   0x6008             STR      R0,[R1, #+0]
    450                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    451                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000398   0x6800             LDR      R0,[R0, #+0]
   \   0000039A   0x21FF             MOVS     R1,#+255
   \   0000039C   0xFAB1 0xF181      CLZ      R1,R1
   \   000003A0   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   000003A4   0x69E2             LDR      R2,[R4, #+28]
   \   000003A6   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000003AA   0x4308             ORRS     R0,R1,R0
   \   000003AC   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   000003B0   0x6008             STR      R0,[R1, #+0]
   \   000003B2   0xE01F             B.N      ??HAL_RCC_OscConfig_38
    452                  }
    453                  else
    454                  {
    455                    /* Else, keep current flash latency while decreasing applies */
    456                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    457                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \   000003B4   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   000003B8   0x6800             LDR      R0,[R0, #+0]
   \   000003BA   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   000003BE   0x6A21             LDR      R1,[R4, #+32]
   \   000003C0   0x4308             ORRS     R0,R1,R0
   \   000003C2   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   000003C6   0x6008             STR      R0,[R1, #+0]
    458                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    459                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   000003C8   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   000003CC   0x6800             LDR      R0,[R0, #+0]
   \   000003CE   0x21FF             MOVS     R1,#+255
   \   000003D0   0xFAB1 0xF181      CLZ      R1,R1
   \   000003D4   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   000003D8   0x69E2             LDR      R2,[R4, #+28]
   \   000003DA   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000003DE   0x4308             ORRS     R0,R1,R0
   \   000003E0   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   000003E4   0x6008             STR      R0,[R1, #+0]
    460          
    461                    /* Decrease number of wait states update if necessary */
    462                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
   \   000003E6   0x6A20             LDR      R0,[R4, #+32]
   \   000003E8   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   000003EC   0x2800             CMP      R0,#+0
   \   000003EE   0xD001             BEQ.N    ??HAL_RCC_OscConfig_38
    463                    {
    464                      return HAL_ERROR;
   \   000003F0   0x2001             MOVS     R0,#+1
   \   000003F2   0xE219             B.N      ??HAL_RCC_OscConfig_5
    465                    }          
    466                  }
    467          
    468                  /* Configure the source of time base considering new system clocks settings*/
    469                  HAL_InitTick (TICK_INT_PRIORITY);
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \   000003F4   0x2000             MOVS     R0,#+0
   \   000003F6   0x.... 0x....      BL       HAL_InitTick
   \   000003FA   0xE07A             B.N      ??HAL_RCC_OscConfig_31
    470                }
    471              }
    472              else
    473              {
    474                /* Check the MSI State */
    475                if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \   000003FC   0x69A0             LDR      R0,[R4, #+24]
   \   000003FE   0x2800             CMP      R0,#+0
   \   00000400   0xD048             BEQ.N    ??HAL_RCC_OscConfig_39
    476                {
    477                  /* Enable the Multi Speed oscillator (MSI). */
    478                  __HAL_RCC_MSI_ENABLE();
   \   00000402   0x2001             MOVS     R0,#+1
   \   00000404   0xF45F 0x0100      MOVS     R1,#+8388608
   \   00000408   0xFAB1 0xF181      CLZ      R1,R1
   \   0000040C   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   00000410   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000414   0x6008             STR      R0,[R1, #+0]
    479          
    480                  /* Get Start Tick */
    481                  tickstart = HAL_GetTick();
   \   00000416   0x.... 0x....      BL       HAL_GetTick
   \   0000041A   0x0005             MOVS     R5,R0
    482          
    483                  /* Wait till MSI is ready */
    484                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \   0000041C   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000420   0xFAB0 0xF080      CLZ      R0,R0
   \   00000424   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000428   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000042A   0x0940             LSRS     R0,R0,#+5
   \   0000042C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000042E   0x2801             CMP      R0,#+1
   \   00000430   0xD103             BNE.N    ??HAL_RCC_OscConfig_41
   \   00000432   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000436   0x6800             LDR      R0,[R0, #+0]
   \   00000438   0xE002             B.N      ??HAL_RCC_OscConfig_42
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \   0000043A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000043E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \   00000440   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000444   0xFAB1 0xF181      CLZ      R1,R1
   \   00000448   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000044C   0x40C8             LSRS     R0,R0,R1
   \   0000044E   0x07C0             LSLS     R0,R0,#+31
   \   00000450   0xD406             BMI.N    ??HAL_RCC_OscConfig_43
    485                  {
    486                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
   \   00000452   0x.... 0x....      BL       HAL_GetTick
   \   00000456   0x1B40             SUBS     R0,R0,R5
   \   00000458   0x2803             CMP      R0,#+3
   \   0000045A   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_40
    487                    {
    488                      return HAL_TIMEOUT;
   \   0000045C   0x2003             MOVS     R0,#+3
   \   0000045E   0xE1E3             B.N      ??HAL_RCC_OscConfig_5
    489                    }
    490                  }
    491                   /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    492                  __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \   00000460   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000464   0x6800             LDR      R0,[R0, #+0]
   \   00000466   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   0000046A   0x6A21             LDR      R1,[R4, #+32]
   \   0000046C   0x4308             ORRS     R0,R1,R0
   \   0000046E   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000472   0x6008             STR      R0,[R1, #+0]
    493                   /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    494                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   00000474   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40023804
   \   00000478   0x6800             LDR      R0,[R0, #+0]
   \   0000047A   0x21FF             MOVS     R1,#+255
   \   0000047C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000480   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   00000484   0x69E2             LDR      R2,[R4, #+28]
   \   00000486   0xFA12 0xF101      LSLS     R1,R2,R1
   \   0000048A   0x4308             ORRS     R0,R1,R0
   \   0000048C   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40023804
   \   00000490   0x6008             STR      R0,[R1, #+0]
   \   00000492   0xE02E             B.N      ??HAL_RCC_OscConfig_31
    495          
    496                }
    497                else
    498                {
    499                  /* Disable the Multi Speed oscillator (MSI). */
    500                  __HAL_RCC_MSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \   00000494   0x2000             MOVS     R0,#+0
   \   00000496   0xF45F 0x0100      MOVS     R1,#+8388608
   \   0000049A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000049E   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000004A2   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000004A6   0x6008             STR      R0,[R1, #+0]
    501          
    502                  /* Get Start Tick */
    503                  tickstart = HAL_GetTick();
   \   000004A8   0x.... 0x....      BL       HAL_GetTick
   \   000004AC   0x0005             MOVS     R5,R0
    504          
    505                  /* Wait till MSI is ready */
    506                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \   000004AE   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000004B2   0xFAB0 0xF080      CLZ      R0,R0
   \   000004B6   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000004BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004BC   0x0940             LSRS     R0,R0,#+5
   \   000004BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004C0   0x2801             CMP      R0,#+1
   \   000004C2   0xD103             BNE.N    ??HAL_RCC_OscConfig_45
   \   000004C4   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000004C8   0x6800             LDR      R0,[R0, #+0]
   \   000004CA   0xE002             B.N      ??HAL_RCC_OscConfig_46
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \   000004CC   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000004D0   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \   000004D2   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000004D6   0xFAB1 0xF181      CLZ      R1,R1
   \   000004DA   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000004DE   0x40C8             LSRS     R0,R0,R1
   \   000004E0   0x07C0             LSLS     R0,R0,#+31
   \   000004E2   0xD506             BPL.N    ??HAL_RCC_OscConfig_31
    507                  {
    508                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
   \   000004E4   0x.... 0x....      BL       HAL_GetTick
   \   000004E8   0x1B40             SUBS     R0,R0,R5
   \   000004EA   0x2803             CMP      R0,#+3
   \   000004EC   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_44
    509                    {
    510                      return HAL_TIMEOUT;
   \   000004EE   0x2003             MOVS     R0,#+3
   \   000004F0   0xE19A             B.N      ??HAL_RCC_OscConfig_5
    511                    }
    512                  }
    513                }
    514              }
    515            }  
    516            /*------------------------------ LSI Configuration -------------------------*/ 
    517            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \   000004F2   0x7820             LDRB     R0,[R4, #+0]
   \   000004F4   0x0700             LSLS     R0,R0,#+28
   \   000004F6   0xD54A             BPL.N    ??HAL_RCC_OscConfig_47
    518            {
    519              /* Check the parameters */
    520              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    521              
    522              /* Check the LSI State */
    523              if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
   \   000004F8   0x6960             LDR      R0,[R4, #+20]
   \   000004FA   0x2800             CMP      R0,#+0
   \   000004FC   0xD023             BEQ.N    ??HAL_RCC_OscConfig_48
    524              {
    525                /* Enable the Internal Low Speed oscillator (LSI). */
    526                __HAL_RCC_LSI_ENABLE();
   \   000004FE   0x2001             MOVS     R0,#+1
   \   00000500   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000504   0xFAB1 0xF181      CLZ      R1,R1
   \   00000508   0x.... 0x....      LDR.W    R2,??DataTable13_1  ;; 0x42470680
   \   0000050C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000510   0x6008             STR      R0,[R1, #+0]
    527                
    528                /* Get Start Tick */
    529                tickstart = HAL_GetTick();
   \   00000512   0x.... 0x....      BL       HAL_GetTick
   \   00000516   0x0005             MOVS     R5,R0
    530                
    531                /* Wait till LSI is ready */  
    532                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \   00000518   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000051C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000520   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000524   0x6800             LDR      R0,[R0, #+0]
   \   00000526   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000052A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000052E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000532   0x40C8             LSRS     R0,R0,R1
   \   00000534   0x07C0             LSLS     R0,R0,#+31
   \   00000536   0xD42A             BMI.N    ??HAL_RCC_OscConfig_47
    533                {
    534                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   00000538   0x.... 0x....      BL       HAL_GetTick
   \   0000053C   0x1B40             SUBS     R0,R0,R5
   \   0000053E   0x2803             CMP      R0,#+3
   \   00000540   0xD3EA             BCC.N    ??HAL_RCC_OscConfig_49
    535                  {
    536                    return HAL_TIMEOUT;
   \   00000542   0x2003             MOVS     R0,#+3
   \   00000544   0xE170             B.N      ??HAL_RCC_OscConfig_5
    537                  }
    538                }
    539              }
    540              else
    541              {
    542                /* Disable the Internal Low Speed oscillator (LSI). */
    543                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \   00000546   0x2000             MOVS     R0,#+0
   \   00000548   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000054C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000550   0x.... 0x....      LDR.W    R2,??DataTable13_1  ;; 0x42470680
   \   00000554   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000558   0x6008             STR      R0,[R1, #+0]
    544                
    545                /* Get Start Tick */
    546                tickstart = HAL_GetTick();
   \   0000055A   0x.... 0x....      BL       HAL_GetTick
   \   0000055E   0x0005             MOVS     R5,R0
    547                
    548                /* Wait till LSI is disabled */  
    549                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \   00000560   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000564   0xFAB0 0xF080      CLZ      R0,R0
   \   00000568   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000056C   0x6800             LDR      R0,[R0, #+0]
   \   0000056E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000572   0xFAB1 0xF181      CLZ      R1,R1
   \   00000576   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000057A   0x40C8             LSRS     R0,R0,R1
   \   0000057C   0x07C0             LSLS     R0,R0,#+31
   \   0000057E   0xD506             BPL.N    ??HAL_RCC_OscConfig_47
    550                {
    551                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   00000580   0x.... 0x....      BL       HAL_GetTick
   \   00000584   0x1B40             SUBS     R0,R0,R5
   \   00000586   0x2803             CMP      R0,#+3
   \   00000588   0xD3EA             BCC.N    ??HAL_RCC_OscConfig_50
    552                  {
    553                    return HAL_TIMEOUT;
   \   0000058A   0x2003             MOVS     R0,#+3
   \   0000058C   0xE14C             B.N      ??HAL_RCC_OscConfig_5
    554                  }
    555                }
    556              }
    557            }
    558            /*------------------------------ LSE Configuration -------------------------*/ 
    559            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \   0000058E   0x7820             LDRB     R0,[R4, #+0]
   \   00000590   0x0740             LSLS     R0,R0,#+29
   \   00000592   0xF140 0x80A5      BPL.W    ??HAL_RCC_OscConfig_51
    560            {
    561              /* Check the parameters */
    562              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    563              
    564              /* Enable Power Clock*/
    565              __HAL_RCC_PWR_CLK_ENABLE();
   \   00000596   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40023824
   \   0000059A   0x6800             LDR      R0,[R0, #+0]
   \   0000059C   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   000005A0   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40023824
   \   000005A4   0x6008             STR      R0,[R1, #+0]
   \   000005A6   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40023824
   \   000005AA   0x6800             LDR      R0,[R0, #+0]
   \   000005AC   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   000005B0   0x9000             STR      R0,[SP, #+0]
   \   000005B2   0x9800             LDR      R0,[SP, #+0]
    566              
    567              /* Enable write access to Backup domain */
    568              SET_BIT(PWR->CR, PWR_CR_DBP);
   \   000005B4   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40007000
   \   000005B8   0x6800             LDR      R0,[R0, #+0]
   \   000005BA   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000005BE   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40007000
   \   000005C2   0x6008             STR      R0,[R1, #+0]
    569          
    570              /* Wait for Backup domain Write protection disable */
    571              tickstart = HAL_GetTick();
   \   000005C4   0x.... 0x....      BL       HAL_GetTick
   \   000005C8   0x0005             MOVS     R5,R0
    572              
    573              while((PWR->CR & PWR_CR_DBP) == RESET)
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \   000005CA   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40007000
   \   000005CE   0x6800             LDR      R0,[R0, #+0]
   \   000005D0   0x05C0             LSLS     R0,R0,#+23
   \   000005D2   0xD406             BMI.N    ??HAL_RCC_OscConfig_53
    574              {
    575                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \   000005D4   0x.... 0x....      BL       HAL_GetTick
   \   000005D8   0x1B40             SUBS     R0,R0,R5
   \   000005DA   0x2865             CMP      R0,#+101
   \   000005DC   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_52
    576                {
    577                  return HAL_TIMEOUT;
   \   000005DE   0x2003             MOVS     R0,#+3
   \   000005E0   0xE122             B.N      ??HAL_RCC_OscConfig_5
    578                }      
    579              }
    580              
    581              /* Set the new LSE configuration -----------------------------------------*/
    582              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \   000005E2   0x68A0             LDR      R0,[R4, #+8]
   \   000005E4   0x2801             CMP      R0,#+1
   \   000005E6   0xD108             BNE.N    ??HAL_RCC_OscConfig_54
   \   000005E8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000005EC   0x6800             LDR      R0,[R0, #+0]
   \   000005EE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000005F2   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   000005F6   0x6008             STR      R0,[R1, #+0]
   \   000005F8   0xE037             B.N      ??HAL_RCC_OscConfig_55
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \   000005FA   0x68A0             LDR      R0,[R4, #+8]
   \   000005FC   0x2800             CMP      R0,#+0
   \   000005FE   0xD110             BNE.N    ??HAL_RCC_OscConfig_56
   \   00000600   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000604   0x6800             LDR      R0,[R0, #+0]
   \   00000606   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000060A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   0000060E   0x6008             STR      R0,[R1, #+0]
   \   00000610   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000614   0x6800             LDR      R0,[R0, #+0]
   \   00000616   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000061A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   0000061E   0x6008             STR      R0,[R1, #+0]
   \   00000620   0xE023             B.N      ??HAL_RCC_OscConfig_55
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \   00000622   0x68A0             LDR      R0,[R4, #+8]
   \   00000624   0x2805             CMP      R0,#+5
   \   00000626   0xD110             BNE.N    ??HAL_RCC_OscConfig_57
   \   00000628   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000062C   0x6800             LDR      R0,[R0, #+0]
   \   0000062E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000632   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000636   0x6008             STR      R0,[R1, #+0]
   \   00000638   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000063C   0x6800             LDR      R0,[R0, #+0]
   \   0000063E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000642   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000646   0x6008             STR      R0,[R1, #+0]
   \   00000648   0xE00F             B.N      ??HAL_RCC_OscConfig_55
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \   0000064A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000064E   0x6800             LDR      R0,[R0, #+0]
   \   00000650   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000654   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000658   0x6008             STR      R0,[R1, #+0]
   \   0000065A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000065E   0x6800             LDR      R0,[R0, #+0]
   \   00000660   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000664   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000668   0x6008             STR      R0,[R1, #+0]
    583              /* Check the LSE State */
    584              if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \   0000066A   0x68A0             LDR      R0,[R4, #+8]
   \   0000066C   0x2800             CMP      R0,#+0
   \   0000066E   0xD01B             BEQ.N    ??HAL_RCC_OscConfig_58
    585              {
    586                /* Get Start Tick */
    587                tickstart = HAL_GetTick();
   \   00000670   0x.... 0x....      BL       HAL_GetTick
   \   00000674   0x0005             MOVS     R5,R0
    588                
    589                /* Wait till LSE is ready */  
    590                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \   00000676   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000067A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000067E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000682   0x6800             LDR      R0,[R0, #+0]
   \   00000684   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000688   0xFAB1 0xF181      CLZ      R1,R1
   \   0000068C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000690   0x40C8             LSRS     R0,R0,R1
   \   00000692   0x07C0             LSLS     R0,R0,#+31
   \   00000694   0xD424             BMI.N    ??HAL_RCC_OscConfig_51
    591                {
    592                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000696   0x.... 0x....      BL       HAL_GetTick
   \   0000069A   0x1B40             SUBS     R0,R0,R5
   \   0000069C   0xF241 0x3189      MOVW     R1,#+5001
   \   000006A0   0x4288             CMP      R0,R1
   \   000006A2   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_59
    593                  {
    594                    return HAL_TIMEOUT;
   \   000006A4   0x2003             MOVS     R0,#+3
   \   000006A6   0xE0BF             B.N      ??HAL_RCC_OscConfig_5
    595                  }
    596                }
    597              }
    598              else
    599              {
    600                /* Get Start Tick */
    601                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \   000006A8   0x.... 0x....      BL       HAL_GetTick
   \   000006AC   0x0005             MOVS     R5,R0
    602                
    603                /* Wait till LSE is disabled */  
    604                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \   000006AE   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000006B2   0xFAB0 0xF080      CLZ      R0,R0
   \   000006B6   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000006BA   0x6800             LDR      R0,[R0, #+0]
   \   000006BC   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000006C0   0xFAB1 0xF181      CLZ      R1,R1
   \   000006C4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000006C8   0x40C8             LSRS     R0,R0,R1
   \   000006CA   0x07C0             LSLS     R0,R0,#+31
   \   000006CC   0xD508             BPL.N    ??HAL_RCC_OscConfig_51
    605                {
    606                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   000006CE   0x.... 0x....      BL       HAL_GetTick
   \   000006D2   0x1B40             SUBS     R0,R0,R5
   \   000006D4   0xF241 0x3189      MOVW     R1,#+5001
   \   000006D8   0x4288             CMP      R0,R1
   \   000006DA   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_60
    607                  {
    608                    return HAL_TIMEOUT;
   \   000006DC   0x2003             MOVS     R0,#+3
   \   000006DE   0xE0A3             B.N      ??HAL_RCC_OscConfig_5
    609                  }
    610                }
    611              }
    612            }
    613          
    614            /*-------------------------------- PLL Configuration -----------------------*/
    615            /* Check the parameters */
    616            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    617            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \   000006E0   0x6A60             LDR      R0,[R4, #+36]
   \   000006E2   0x2800             CMP      R0,#+0
   \   000006E4   0xF000 0x809F      BEQ.W    ??HAL_RCC_OscConfig_61
    618            {
    619              /* Check if the PLL is used as system clock or not */
    620              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \   000006E8   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   000006EC   0x6800             LDR      R0,[R0, #+0]
   \   000006EE   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000006F2   0x280C             CMP      R0,#+12
   \   000006F4   0xF000 0x8095      BEQ.W    ??HAL_RCC_OscConfig_62
    621              { 
    622                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \   000006F8   0x6A60             LDR      R0,[R4, #+36]
   \   000006FA   0x2802             CMP      R0,#+2
   \   000006FC   0xD165             BNE.N    ??HAL_RCC_OscConfig_63
    623                {
    624                  /* Check the parameters */
    625                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    626                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    627                  assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
    628            
    629                  /* Disable the main PLL. */
    630                  __HAL_RCC_PLL_DISABLE();
   \   000006FE   0x2000             MOVS     R0,#+0
   \   00000700   0x2180             MOVS     R1,#+128
   \   00000702   0xFAB1 0xF181      CLZ      R1,R1
   \   00000706   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   0000070A   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000070E   0x6008             STR      R0,[R1, #+0]
    631                  
    632                  /* Get Start Tick */
    633                  tickstart = HAL_GetTick();
   \   00000710   0x.... 0x....      BL       HAL_GetTick
   \   00000714   0x0005             MOVS     R5,R0
    634                  
    635                  /* Wait till PLL is disabled */
    636                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_64: (+1)
   \   00000716   0x2040             MOVS     R0,#+64
   \   00000718   0xFAB0 0xF080      CLZ      R0,R0
   \   0000071C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000720   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000722   0x0940             LSRS     R0,R0,#+5
   \   00000724   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000726   0x2801             CMP      R0,#+1
   \   00000728   0xD103             BNE.N    ??HAL_RCC_OscConfig_65
   \   0000072A   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   0000072E   0x6800             LDR      R0,[R0, #+0]
   \   00000730   0xE002             B.N      ??HAL_RCC_OscConfig_66
   \                     ??HAL_RCC_OscConfig_65: (+1)
   \   00000732   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000736   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_66: (+1)
   \   00000738   0x2140             MOVS     R1,#+64
   \   0000073A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000073E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000742   0x40C8             LSRS     R0,R0,R1
   \   00000744   0x07C0             LSLS     R0,R0,#+31
   \   00000746   0xD506             BPL.N    ??HAL_RCC_OscConfig_67
    637                  {
    638                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000748   0x.... 0x....      BL       HAL_GetTick
   \   0000074C   0x1B40             SUBS     R0,R0,R5
   \   0000074E   0x2803             CMP      R0,#+3
   \   00000750   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_64
    639                    {
    640                      return HAL_TIMEOUT;
   \   00000752   0x2003             MOVS     R0,#+3
   \   00000754   0xE068             B.N      ??HAL_RCC_OscConfig_5
    641                    }
    642                  }
    643          
    644                  /* Configure the main PLL clock source, multiplication and division factors. */
    645                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    646                                       RCC_OscInitStruct->PLL.PLLMUL,
    647                                       RCC_OscInitStruct->PLL.PLLDIV);
   \                     ??HAL_RCC_OscConfig_67: (+1)
   \   00000756   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   0000075A   0x6800             LDR      R0,[R0, #+0]
   \   0000075C   0xF430 0x007D      BICS     R0,R0,#0xFD0000
   \   00000760   0x6AA1             LDR      R1,[R4, #+40]
   \   00000762   0x4308             ORRS     R0,R1,R0
   \   00000764   0x6AE1             LDR      R1,[R4, #+44]
   \   00000766   0x4308             ORRS     R0,R1,R0
   \   00000768   0x6B21             LDR      R1,[R4, #+48]
   \   0000076A   0x4308             ORRS     R0,R1,R0
   \   0000076C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40023808
   \   00000770   0x6008             STR      R0,[R1, #+0]
    648                  /* Enable the main PLL. */
    649                  __HAL_RCC_PLL_ENABLE();
   \   00000772   0x2001             MOVS     R0,#+1
   \   00000774   0x2180             MOVS     R1,#+128
   \   00000776   0xFAB1 0xF181      CLZ      R1,R1
   \   0000077A   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   0000077E   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000782   0x6008             STR      R0,[R1, #+0]
    650                  
    651                  /* Get Start Tick */
    652                  tickstart = HAL_GetTick();
   \   00000784   0x.... 0x....      BL       HAL_GetTick
   \   00000788   0x0005             MOVS     R5,R0
    653                  
    654                  /* Wait till PLL is ready */
    655                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
   \                     ??HAL_RCC_OscConfig_68: (+1)
   \   0000078A   0x2040             MOVS     R0,#+64
   \   0000078C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000790   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000794   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000796   0x0940             LSRS     R0,R0,#+5
   \   00000798   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000079A   0x2801             CMP      R0,#+1
   \   0000079C   0xD103             BNE.N    ??HAL_RCC_OscConfig_69
   \   0000079E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000007A2   0x6800             LDR      R0,[R0, #+0]
   \   000007A4   0xE002             B.N      ??HAL_RCC_OscConfig_70
   \                     ??HAL_RCC_OscConfig_69: (+1)
   \   000007A6   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000007AA   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_70: (+1)
   \   000007AC   0x2140             MOVS     R1,#+64
   \   000007AE   0xFAB1 0xF181      CLZ      R1,R1
   \   000007B2   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000007B6   0x40C8             LSRS     R0,R0,R1
   \   000007B8   0x07C0             LSLS     R0,R0,#+31
   \   000007BA   0xD434             BMI.N    ??HAL_RCC_OscConfig_61
    656                  {
    657                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000007BC   0x.... 0x....      BL       HAL_GetTick
   \   000007C0   0x1B40             SUBS     R0,R0,R5
   \   000007C2   0x2803             CMP      R0,#+3
   \   000007C4   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_68
    658                    {
    659                      return HAL_TIMEOUT;
   \   000007C6   0x2003             MOVS     R0,#+3
   \   000007C8   0xE02E             B.N      ??HAL_RCC_OscConfig_5
    660                    }
    661                  }
    662                }
    663                else
    664                {
    665                  /* Disable the main PLL. */
    666                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_63: (+1)
   \   000007CA   0x2000             MOVS     R0,#+0
   \   000007CC   0x2180             MOVS     R1,#+128
   \   000007CE   0xFAB1 0xF181      CLZ      R1,R1
   \   000007D2   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000007D6   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000007DA   0x6008             STR      R0,[R1, #+0]
    667           
    668                  /* Get Start Tick */
    669                  tickstart = HAL_GetTick();
   \   000007DC   0x.... 0x....      BL       HAL_GetTick
   \   000007E0   0x0005             MOVS     R5,R0
    670                  
    671                  /* Wait till PLL is disabled */  
    672                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_71: (+1)
   \   000007E2   0x2040             MOVS     R0,#+64
   \   000007E4   0xFAB0 0xF080      CLZ      R0,R0
   \   000007E8   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000007EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007EE   0x0940             LSRS     R0,R0,#+5
   \   000007F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007F2   0x2801             CMP      R0,#+1
   \   000007F4   0xD103             BNE.N    ??HAL_RCC_OscConfig_72
   \   000007F6   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   000007FA   0x6800             LDR      R0,[R0, #+0]
   \   000007FC   0xE002             B.N      ??HAL_RCC_OscConfig_73
   \                     ??HAL_RCC_OscConfig_72: (+1)
   \   000007FE   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000802   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_73: (+1)
   \   00000804   0x2140             MOVS     R1,#+64
   \   00000806   0xFAB1 0xF181      CLZ      R1,R1
   \   0000080A   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000080E   0x40C8             LSRS     R0,R0,R1
   \   00000810   0x07C0             LSLS     R0,R0,#+31
   \   00000812   0xD508             BPL.N    ??HAL_RCC_OscConfig_61
    673                  {
    674                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000814   0x.... 0x....      BL       HAL_GetTick
   \   00000818   0x1B40             SUBS     R0,R0,R5
   \   0000081A   0x2803             CMP      R0,#+3
   \   0000081C   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_71
    675                    {
    676                      return HAL_TIMEOUT;
   \   0000081E   0x2003             MOVS     R0,#+3
   \   00000820   0xE002             B.N      ??HAL_RCC_OscConfig_5
    677                    }
    678                  }
    679                }
    680              }
    681              else
    682              {
    683                return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_62: (+1)
   \   00000822   0x2001             MOVS     R0,#+1
   \   00000824   0xE000             B.N      ??HAL_RCC_OscConfig_5
    684              }
    685            }
    686            
    687            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \   00000826   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \   00000828   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    688          }
    689          
    690          /**
    691            * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified 
    692            *         parameters in the RCC_ClkInitStruct.
    693            * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
    694            *         contains the configuration information for the RCC peripheral.
    695            * @param  FLatency FLASH Latency                   
    696            *          The value of this parameter depend on device used within the same series
    697            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    698            *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
    699            *
    700            * @note   The MSI is used (enabled by hardware) as system clock source after
    701            *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
    702            *         of failure of the HSE used directly or indirectly as system clock
    703            *         (if the Clock Security System CSS is enabled).
    704            *           
    705            * @note   A switch from one clock source to another occurs only if the target
    706            *         clock source is ready (clock stable after start-up delay or PLL locked). 
    707            *         If a clock source which is not yet ready is selected, the switch will
    708            *         occur when the clock source will be ready. 
    709            *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
    710            *         currently used as system clock source.
    711            * @note   Depending on the device voltage range, the software has to set correctly
    712            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    713            *         (for more details refer to section above "Initialization/de-initialization functions")
    714            * @retval HAL status
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    717          {
   \                     HAL_RCC_ClockConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    718            uint32_t tickstart = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    719            
    720            /* Check the parameters */
    721            assert_param(RCC_ClkInitStruct != NULL);
    722            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    723            assert_param(IS_FLASH_LATENCY(FLatency));
    724          
    725            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    726            must be correctly programmed according to the frequency of the CPU clock 
    727            (HCLK) and the supply voltage of the device. */
    728          
    729            /* Increasing the number of wait states because of higher CPU frequency */
    730            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD21B             BCS.N    ??HAL_RCC_ClockConfig_0
    731            {    
    732              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    733              __HAL_FLASH_SET_LATENCY(FLatency);
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD107             BNE.N    ??HAL_RCC_ClockConfig_1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023c00
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x4328             ORRS     R0,R5,R0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023c00
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    734              
    735              /* Check that the new number of wait states is taken into account to access the Flash
    736              memory by reading the FLASH_ACR register */
    737              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_0
    738              {
    739                return HAL_ERROR;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE127             B.N      ??HAL_RCC_ClockConfig_2
    740              }
    741            }
    742          
    743            /*-------------------------- HCLK Configuration --------------------------*/
    744            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \   0000004E   0x7820             LDRB     R0,[R4, #+0]
   \   00000050   0x0780             LSLS     R0,R0,#+30
   \   00000052   0xD50A             BPL.N    ??HAL_RCC_ClockConfig_3
    745            {
    746              assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    747              MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40023808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF07F 0x01F0      MVNS     R1,#+240
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x68A1             LDR      R1,[R4, #+8]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40023808
   \   00000068   0x6008             STR      R0,[R1, #+0]
    748            }
    749          
    750            /*------------------------- SYSCLK Configuration ---------------------------*/ 
    751            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \   0000006A   0x7820             LDRB     R0,[R4, #+0]
   \   0000006C   0x07C0             LSLS     R0,R0,#+31
   \   0000006E   0xF140 0x80C7      BPL.W    ??HAL_RCC_ClockConfig_4
    752            {    
    753              assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    754              
    755              /* HSE is selected as System Clock Source */
    756              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD11C             BNE.N    ??HAL_RCC_ClockConfig_5
    757              {
    758                /* Check the HSE ready flag */  
    759                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000078   0xF44F 0x4080      MOV      R0,#+16384
   \   0000007C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x0940             LSRS     R0,R0,#+5
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD103             BNE.N    ??HAL_RCC_ClockConfig_6
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023800
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xE002             B.N      ??HAL_RCC_ClockConfig_7
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \   0000009C   0xF44F 0x4180      MOV      R1,#+16384
   \   000000A0   0xFAB1 0xF181      CLZ      R1,R1
   \   000000A4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000A8   0x40C8             LSRS     R0,R0,R1
   \   000000AA   0x07C0             LSLS     R0,R0,#+31
   \   000000AC   0xD459             BMI.N    ??HAL_RCC_ClockConfig_8
    760                {
    761                  return HAL_ERROR;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE0F5             B.N      ??HAL_RCC_ClockConfig_2
    762                }
    763              }
    764              /* PLL is selected as System Clock Source */
    765              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \   000000B2   0x6860             LDR      R0,[R4, #+4]
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xD119             BNE.N    ??HAL_RCC_ClockConfig_9
    766              {
    767                /* Check the PLL ready flag */  
    768                if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   000000B8   0x2040             MOVS     R0,#+64
   \   000000BA   0xFAB0 0xF080      CLZ      R0,R0
   \   000000BE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x0940             LSRS     R0,R0,#+5
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD102             BNE.N    ??HAL_RCC_ClockConfig_10
   \   000000CC   0x....             LDR.N    R0,??DataTable9  ;; 0x40023800
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xE002             B.N      ??HAL_RCC_ClockConfig_11
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \   000000D8   0x2140             MOVS     R1,#+64
   \   000000DA   0xFAB1 0xF181      CLZ      R1,R1
   \   000000DE   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000E2   0x40C8             LSRS     R0,R0,R1
   \   000000E4   0x07C0             LSLS     R0,R0,#+31
   \   000000E6   0xD43C             BMI.N    ??HAL_RCC_ClockConfig_8
    769                {
    770                  return HAL_ERROR;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xE0D8             B.N      ??HAL_RCC_ClockConfig_2
    771                }
    772              }
    773              /* HSI is selected as System Clock Source */
    774              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \   000000EC   0x6860             LDR      R0,[R4, #+4]
   \   000000EE   0x2801             CMP      R0,#+1
   \   000000F0   0xD11B             BNE.N    ??HAL_RCC_ClockConfig_12
    775              {
    776                /* Check the HSI ready flag */  
    777                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \   000000F2   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000000F6   0xFAB0 0xF080      CLZ      R0,R0
   \   000000FA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x0940             LSRS     R0,R0,#+5
   \   00000102   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xD102             BNE.N    ??HAL_RCC_ClockConfig_13
   \   00000108   0x....             LDR.N    R0,??DataTable9  ;; 0x40023800
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xE002             B.N      ??HAL_RCC_ClockConfig_14
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \   00000114   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000118   0xFAB1 0xF181      CLZ      R1,R1
   \   0000011C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000120   0x40C8             LSRS     R0,R0,R1
   \   00000122   0x07C0             LSLS     R0,R0,#+31
   \   00000124   0xD41D             BMI.N    ??HAL_RCC_ClockConfig_8
    778                {
    779                  return HAL_ERROR;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xE0B9             B.N      ??HAL_RCC_ClockConfig_2
    780                }
    781              }
    782              /* MSI is selected as System Clock Source */
    783              else
    784              {
    785                /* Check the MSI ready flag */  
    786                if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \   0000012A   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000012E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000132   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x0940             LSRS     R0,R0,#+5
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xD102             BNE.N    ??HAL_RCC_ClockConfig_15
   \   00000140   0x....             LDR.N    R0,??DataTable9  ;; 0x40023800
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0xE002             B.N      ??HAL_RCC_ClockConfig_16
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \   0000014C   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000150   0xFAB1 0xF181      CLZ      R1,R1
   \   00000154   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000158   0x40C8             LSRS     R0,R0,R1
   \   0000015A   0x07C0             LSLS     R0,R0,#+31
   \   0000015C   0xD401             BMI.N    ??HAL_RCC_ClockConfig_8
    787                {
    788                  return HAL_ERROR;
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xE09D             B.N      ??HAL_RCC_ClockConfig_2
    789                }
    790              }
    791              __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \   00000162   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x0880             LSRS     R0,R0,#+2
   \   00000168   0x0080             LSLS     R0,R0,#+2
   \   0000016A   0x6861             LDR      R1,[R4, #+4]
   \   0000016C   0x4308             ORRS     R0,R1,R0
   \   0000016E   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   00000170   0x6008             STR      R0,[R1, #+0]
    792          
    793              /* Get Start Tick */
    794              tickstart = HAL_GetTick();
   \   00000172   0x.... 0x....      BL       HAL_GetTick
   \   00000176   0x0006             MOVS     R6,R0
    795              
    796              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000178   0x6860             LDR      R0,[R4, #+4]
   \   0000017A   0x2802             CMP      R0,#+2
   \   0000017C   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_17
    797              {
    798                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \   0000017E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000186   0x2808             CMP      R0,#+8
   \   00000188   0xD03A             BEQ.N    ??HAL_RCC_ClockConfig_4
    799                {
    800                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   0000018A   0x.... 0x....      BL       HAL_GetTick
   \   0000018E   0x1B80             SUBS     R0,R0,R6
   \   00000190   0xF241 0x3189      MOVW     R1,#+5001
   \   00000194   0x4288             CMP      R0,R1
   \   00000196   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_18
    801                  {
    802                    return HAL_TIMEOUT;
   \   00000198   0x2003             MOVS     R0,#+3
   \   0000019A   0xE080             B.N      ??HAL_RCC_ClockConfig_2
    803                  }
    804                }
    805              }
    806              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \   0000019C   0x6860             LDR      R0,[R4, #+4]
   \   0000019E   0x2803             CMP      R0,#+3
   \   000001A0   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_19
    807              {
    808                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \   000001A2   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   000001A4   0x6800             LDR      R0,[R0, #+0]
   \   000001A6   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001AA   0x280C             CMP      R0,#+12
   \   000001AC   0xD028             BEQ.N    ??HAL_RCC_ClockConfig_4
    809                {
    810                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001AE   0x.... 0x....      BL       HAL_GetTick
   \   000001B2   0x1B80             SUBS     R0,R0,R6
   \   000001B4   0xF241 0x3189      MOVW     R1,#+5001
   \   000001B8   0x4288             CMP      R0,R1
   \   000001BA   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_20
    811                  {
    812                    return HAL_TIMEOUT;
   \   000001BC   0x2003             MOVS     R0,#+3
   \   000001BE   0xE06E             B.N      ??HAL_RCC_ClockConfig_2
    813                  }
    814                }
    815              }
    816              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \   000001C0   0x6860             LDR      R0,[R4, #+4]
   \   000001C2   0x2801             CMP      R0,#+1
   \   000001C4   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_21
    817              {
    818                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_22: (+1)
   \   000001C6   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   000001C8   0x6800             LDR      R0,[R0, #+0]
   \   000001CA   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001CE   0x2804             CMP      R0,#+4
   \   000001D0   0xD016             BEQ.N    ??HAL_RCC_ClockConfig_4
    819                {
    820                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001D2   0x.... 0x....      BL       HAL_GetTick
   \   000001D6   0x1B80             SUBS     R0,R0,R6
   \   000001D8   0xF241 0x3189      MOVW     R1,#+5001
   \   000001DC   0x4288             CMP      R0,R1
   \   000001DE   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_22
    821                  {
    822                    return HAL_TIMEOUT;
   \   000001E0   0x2003             MOVS     R0,#+3
   \   000001E2   0xE05C             B.N      ??HAL_RCC_ClockConfig_2
    823                  }
    824                }
    825              }      
    826              else
    827              {
    828                while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
   \                     ??HAL_RCC_ClockConfig_21: (+1)
   \   000001E4   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   000001E6   0x6800             LDR      R0,[R0, #+0]
   \   000001E8   0xF010 0x0F0C      TST      R0,#0xC
   \   000001EC   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_4
    829                {
    830                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001EE   0x.... 0x....      BL       HAL_GetTick
   \   000001F2   0x1B80             SUBS     R0,R0,R6
   \   000001F4   0xF241 0x3189      MOVW     R1,#+5001
   \   000001F8   0x4288             CMP      R0,R1
   \   000001FA   0xD3F3             BCC.N    ??HAL_RCC_ClockConfig_21
    831                  {
    832                    return HAL_TIMEOUT;
   \   000001FC   0x2003             MOVS     R0,#+3
   \   000001FE   0xE04E             B.N      ??HAL_RCC_ClockConfig_2
    833                  }
    834                }
    835              }
    836            }    
    837            /* Decreasing the number of wait states because of lower CPU frequency */
    838            if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000020A   0x4285             CMP      R5,R0
   \   0000020C   0xD21B             BCS.N    ??HAL_RCC_ClockConfig_23
    839            {    
    840              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    841              __HAL_FLASH_SET_LATENCY(FLatency);
   \   0000020E   0x2D01             CMP      R5,#+1
   \   00000210   0xD107             BNE.N    ??HAL_RCC_ClockConfig_24
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023c00
   \   00000220   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_24: (+1)
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   00000226   0x6800             LDR      R0,[R0, #+0]
   \   00000228   0x0840             LSRS     R0,R0,#+1
   \   0000022A   0x0040             LSLS     R0,R0,#+1
   \   0000022C   0x4328             ORRS     R0,R5,R0
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023c00
   \   00000232   0x6008             STR      R0,[R1, #+0]
    842              
    843              /* Check that the new number of wait states is taken into account to access the Flash
    844              memory by reading the FLASH_ACR register */
    845              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   00000234   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023c00
   \   00000238   0x6800             LDR      R0,[R0, #+0]
   \   0000023A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000023E   0x42A8             CMP      R0,R5
   \   00000240   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_23
    846              {
    847                return HAL_ERROR;
   \   00000242   0x2001             MOVS     R0,#+1
   \   00000244   0xE02B             B.N      ??HAL_RCC_ClockConfig_2
    848              }
    849            }    
    850          
    851            
    852            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    853            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_23: (+1)
   \   00000246   0x7820             LDRB     R0,[R4, #+0]
   \   00000248   0x0740             LSLS     R0,R0,#+29
   \   0000024A   0xD507             BPL.N    ??HAL_RCC_ClockConfig_25
    854            {
    855              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    856              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \   0000024C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   0000024E   0x6800             LDR      R0,[R0, #+0]
   \   00000250   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   00000254   0x68E1             LDR      R1,[R4, #+12]
   \   00000256   0x4308             ORRS     R0,R1,R0
   \   00000258   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   0000025A   0x6008             STR      R0,[R1, #+0]
    857            }
    858            
    859            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    860            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_25: (+1)
   \   0000025C   0x7820             LDRB     R0,[R4, #+0]
   \   0000025E   0x0700             LSLS     R0,R0,#+28
   \   00000260   0xD508             BPL.N    ??HAL_RCC_ClockConfig_26
    861            {
    862              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    863              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \   00000262   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023808
   \   00000264   0x6800             LDR      R0,[R0, #+0]
   \   00000266   0xF430 0x5060      BICS     R0,R0,#0x3800
   \   0000026A   0x6921             LDR      R1,[R4, #+16]
   \   0000026C   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   00000270   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   00000272   0x6008             STR      R0,[R1, #+0]
    864            }
    865           
    866            /* Update the SystemCoreClock global variable */
    867            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
   \                     ??HAL_RCC_ClockConfig_26: (+1)
   \   00000274   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000278   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   0000027A   0x6809             LDR      R1,[R1, #+0]
   \   0000027C   0x.... 0x....      LDR.W    R2,??DataTable13_5
   \   00000280   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000284   0xF05F 0x6370      MOVS     R3,#+251658240
   \   00000288   0xFAB3 0xF383      CLZ      R3,R3
   \   0000028C   0x40D9             LSRS     R1,R1,R3
   \   0000028E   0x5C51             LDRB     R1,[R2, R1]
   \   00000290   0x40C8             LSRS     R0,R0,R1
   \   00000292   0x....             LDR.N    R1,??DataTable10
   \   00000294   0x6008             STR      R0,[R1, #+0]
    868          
    869            /* Configure the source of time base considering new system clocks settings*/
    870            HAL_InitTick (TICK_INT_PRIORITY);
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0x.... 0x....      BL       HAL_InitTick
    871            
    872            return HAL_OK;
   \   0000029C   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \   0000029E   0xBD70             POP      {R4-R6,PC}       ;; return
    873          }
    874          
    875          /**
    876            * @}
    877            */
    878          
    879          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions 
    880            *  @brief   RCC clocks control functions 
    881            *
    882            @verbatim   
    883            ===============================================================================
    884                            ##### Peripheral Control functions #####
    885            ===============================================================================  
    886              [..]
    887              This subsection provides a set of functions allowing to control the RCC Clocks 
    888              frequencies.
    889          
    890            @endverbatim
    891            * @{
    892            */
    893          
    894          /**
    895            * @brief  Selects the clock source to output on MCO pin.
    896            * @note   MCO pin should be configured in alternate function mode.
    897            * @param  RCC_MCOx specifies the output direction for the clock source.
    898            *          This parameter can be one of the following values:
    899            *            @arg @ref RCC_MCO Clock source to output on MCO1 pin(PA8).
    900            * @param  RCC_MCOSource specifies the clock source to output.
    901            *          This parameter can be one of the following values:
    902            *            @arg @ref RCC_MCO1SOURCE_NOCLOCK     No clock selected as MCO clock
    903            *            @arg @ref RCC_MCO1SOURCE_SYSCLK      System clock selected as MCO clock
    904            *            @arg @ref RCC_MCO1SOURCE_HSI         HSI selected as MCO clock
    905            *            @arg @ref RCC_MCO1SOURCE_HSE         HSE selected as MCO clock
    906            *            @arg @ref RCC_MCO1SOURCE_MSI         MSI oscillator clock selected as MCO clock 
    907            *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLL clock selected as MCO clock
    908            *            @arg @ref RCC_MCO1SOURCE_LSI         LSI clock selected as MCO clock
    909            *            @arg @ref RCC_MCO1SOURCE_LSE         LSE clock selected as MCO clock
    910            * @param  RCC_MCODiv specifies the MCO DIV.
    911            *          This parameter can be one of the following values:
    912            *            @arg @ref RCC_MCODIV_1 no division applied to MCO clock
    913            *            @arg @ref RCC_MCODIV_2  division by 2 applied to MCO clock
    914            *            @arg @ref RCC_MCODIV_4  division by 4 applied to MCO clock
    915            *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
    916            *            @arg @ref RCC_MCODIV_16 division by 16 applied to MCO clock
    917            * @retval None
    918            */

   \                                 In section .text, align 2, keep-with-next
    919          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    920          {
   \                     HAL_RCC_MCOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    921            GPIO_InitTypeDef gpio = {0};
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x2114             MOVS     R1,#+20
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    922          
    923            /* Check the parameters */
    924            assert_param(IS_RCC_MCO(RCC_MCOx));
    925            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    926            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    927            
    928            /* MCO Clock Enable */
    929            MCO1_CLK_ENABLE();
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002381c
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002381c
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002381c
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
    930            
    931            /* Configure the MCO1 pin in alternate function mode */
    932            gpio.Pin       = MCO1_PIN;
   \   00000030   0xF44F 0x7080      MOV      R0,#+256
   \   00000034   0x9001             STR      R0,[SP, #+4]
    933            gpio.Mode      = GPIO_MODE_AF_PP;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x9002             STR      R0,[SP, #+8]
    934            gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    935            gpio.Pull      = GPIO_NOPULL;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9003             STR      R0,[SP, #+12]
    936            gpio.Alternate = GPIO_AF0_MCO;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9005             STR      R0,[SP, #+20]
    937            HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40020000
   \   0000004A   0x.... 0x....      BL       HAL_GPIO_Init
    938            
    939            /* Configure the MCO clock source */
    940            __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
   \   0000004E   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40023808
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x40EE      BICS     R0,R0,#0x77000000
   \   00000056   0x4328             ORRS     R0,R5,R0
   \   00000058   0x4330             ORRS     R0,R6,R0
   \   0000005A   0x....             LDR.N    R1,??DataTable13_8  ;; 0x40023808
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    941          }
   \   0000005E   0xB006             ADD      SP,SP,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    942          
    943          /**
    944            * @brief  Enables the Clock Security System.
    945            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    946            *         is automatically disabled and an interrupt is generated to inform the
    947            *         software about the failure (Clock Security System Interrupt, CSSI),
    948            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    949            *         the Cortex-M3 NMI (Non-Maskable Interrupt) exception vector.  
    950            * @retval None
    951            */

   \                                 In section .text, align 2, keep-with-next
    952          void HAL_RCC_EnableCSS(void)
    953          {
    954            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCC_EnableCSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable13  ;; 0x42470000
   \   0000000A   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    955          }
   \   00000010   0x4770             BX       LR               ;; return
    956          
    957          /**
    958            * @brief  Disables the Clock Security System.
    959            * @retval None
    960            */

   \                                 In section .text, align 2, keep-with-next
    961          void HAL_RCC_DisableCSS(void)
    962          {
    963            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCC_DisableCSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable13  ;; 0x42470000
   \   0000000A   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    964          }
   \   00000010   0x4770             BX       LR               ;; return
    965          
    966          /**
    967            * @brief  Returns the SYSCLK frequency     
    968            * @note   The system frequency computed by this function is not the real 
    969            *         frequency in the chip. It is calculated based on the predefined 
    970            *         constant and the selected clock source:
    971            * @note     If SYSCLK source is MSI, function returns a value based on MSI
    972            *             Value as defined by the MSI range.
    973            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
    974            * @note     If SYSCLK source is HSE, function returns a value based on HSE_VALUE(**)
    975            * @note     If SYSCLK source is PLL, function returns a value based on HSE_VALUE(**) 
    976            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
    977            * @note     (*) HSI_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
    978            *               16 MHz) but the real value may vary depending on the variations
    979            *               in voltage and temperature.
    980            * @note     (**) HSE_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
    981            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
    982            *                frequency of the crystal used. Otherwise, this function may
    983            *                have wrong result.
    984            *                  
    985            * @note   The result of this function could be not correct when using fractional
    986            *         value for HSE crystal.
    987            *           
    988            * @note   This function can be used by the user application to compute the 
    989            *         baud-rate for the communication peripherals or configure other parameters.
    990            *           
    991            * @note   Each time SYSCLK changes, this function must be called to update the
    992            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
    993            *         
    994            * @retval SYSCLK frequency
    995            */

   \                                 In section .text, align 2, keep-with-next
    996          uint32_t HAL_RCC_GetSysClockFreq(void)
    997          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    998            uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2500             MOVS     R5,#+0
    999            uint32_t sysclockfreq = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   1000            
   1001            tmpreg = RCC->CFGR;
   \   0000000E   0x....             LDR.N    R6,??DataTable9_1  ;; 0x40023808
   \   00000010   0x6836             LDR      R6,[R6, #+0]
   \   00000012   0x0031             MOVS     R1,R6
   1002            
   1003            /* Get SYSCLK source -------------------------------------------------------*/
   1004            switch (tmpreg & RCC_CFGR_SWS)
   \   00000014   0xF011 0x060C      ANDS     R6,R1,#0xC
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \   0000001C   0x2E08             CMP      R6,#+8
   \   0000001E   0xD005             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \   00000020   0x2E0C             CMP      R6,#+12
   \   00000022   0xD006             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \   00000024   0xE02E             B.N      ??HAL_RCC_GetSysClockFreq_3
   1005            {
   1006              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
   1007              {
   1008                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \   00000026   0x....             LDR.N    R6,??DataTable9_6  ;; 0xf42400
   \   00000028   0x0030             MOVS     R0,R6
   1009                break;
   \   0000002A   0xE03C             B.N      ??HAL_RCC_GetSysClockFreq_4
   1010              }
   1011              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
   1012              {
   1013                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \   0000002C   0x....             LDR.N    R6,??DataTable13_9  ;; 0x7a1200
   \   0000002E   0x0030             MOVS     R0,R6
   1014                break;
   \   00000030   0xE039             B.N      ??HAL_RCC_GetSysClockFreq_4
   1015              }
   1016              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
   1017              {
   1018                pllm = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \   00000032   0x....             LDR.N    R6,??DataTable13_10
   \   00000034   0xF411 0x1770      ANDS     R7,R1,#0x3C0000
   \   00000038   0xF44F 0x5C70      MOV      R12,#+15360
   \   0000003C   0xFABC 0xFC8C      CLZ      R12,R12
   \   00000040   0xFA37 0xF70C      LSRS     R7,R7,R12
   \   00000044   0x5DF6             LDRB     R6,[R6, R7]
   \   00000046   0x0032             MOVS     R2,R6
   1019                plld = aPLLDivisionFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> POSITION_VAL(RCC_CFGR_PLLDIV)];
   \   00000048   0x....             LDR.N    R6,??DataTable13_11
   \   0000004A   0xF411 0x0740      ANDS     R7,R1,#0xC00000
   \   0000004E   0xF44F 0x7C40      MOV      R12,#+768
   \   00000052   0xFABC 0xFC8C      CLZ      R12,R12
   \   00000056   0xFA37 0xF70C      LSRS     R7,R7,R12
   \   0000005A   0x5DF6             LDRB     R6,[R6, R7]
   \   0000005C   0x0033             MOVS     R3,R6
   1020                if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
   \   0000005E   0x....             LDR.N    R6,??DataTable9_1  ;; 0x40023808
   \   00000060   0x6836             LDR      R6,[R6, #+0]
   \   00000062   0x03F6             LSLS     R6,R6,#+15
   \   00000064   0xD506             BPL.N    ??HAL_RCC_GetSysClockFreq_5
   1021                {
   1022                  /* HSE used as PLL clock source */
   1023                  pllvco = (HSE_VALUE * pllm) / plld;
   \   00000066   0x....             LDR.N    R6,??DataTable13_9  ;; 0x7a1200
   \   00000068   0xFB06 0xF602      MUL      R6,R6,R2
   \   0000006C   0xFBB6 0xF6F3      UDIV     R6,R6,R3
   \   00000070   0x0034             MOVS     R4,R6
   \   00000072   0xE005             B.N      ??HAL_RCC_GetSysClockFreq_6
   1024                }
   1025                else
   1026                {
   1027                  /* HSI used as PLL clock source */
   1028                  pllvco = (HSI_VALUE * pllm) / plld;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \   00000074   0x....             LDR.N    R6,??DataTable9_6  ;; 0xf42400
   \   00000076   0xFB06 0xF602      MUL      R6,R6,R2
   \   0000007A   0xFBB6 0xF6F3      UDIV     R6,R6,R3
   \   0000007E   0x0034             MOVS     R4,R6
   1029                }
   1030                sysclockfreq = pllvco;
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \   00000080   0x0020             MOVS     R0,R4
   1031                break;
   \   00000082   0xE010             B.N      ??HAL_RCC_GetSysClockFreq_4
   1032              }
   1033              case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
   1034              default: /* MSI used as system clock */
   1035              {
   1036                msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> POSITION_VAL(RCC_ICSCR_MSIRANGE);
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \   00000084   0x....             LDR.N    R6,??DataTable13_12  ;; 0x40023804
   \   00000086   0x6836             LDR      R6,[R6, #+0]
   \   00000088   0xF416 0x4660      ANDS     R6,R6,#0xE000
   \   0000008C   0xF45F 0x27E0      MOVS     R7,#+458752
   \   00000090   0xFAB7 0xF787      CLZ      R7,R7
   \   00000094   0x40FE             LSRS     R6,R6,R7
   \   00000096   0x0035             MOVS     R5,R6
   1037                sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
   \   00000098   0x2601             MOVS     R6,#+1
   \   0000009A   0x1C6F             ADDS     R7,R5,#+1
   \   0000009C   0x40BE             LSLS     R6,R6,R7
   \   0000009E   0xF44F 0x4700      MOV      R7,#+32768
   \   000000A2   0x437E             MULS     R6,R7,R6
   \   000000A4   0x0030             MOVS     R0,R6
   1038                break;
   1039              }
   1040            }
   1041            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \   000000A6   0xBCF0             POP      {R4-R7}
   \   000000A8   0x4770             BX       LR               ;; return
   1042          }
   1043          
   1044          /**
   1045            * @brief  Returns the HCLK frequency     
   1046            * @note   Each time HCLK changes, this function must be called to update the
   1047            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1048            * 
   1049            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1050            *         and updated within this function
   1051            * @retval HCLK frequency
   1052            */

   \                                 In section .text, align 2, keep-with-next
   1053          uint32_t HAL_RCC_GetHCLKFreq(void)
   1054          {
   1055            return SystemCoreClock;
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1056          }
   1057          
   1058          /**
   1059            * @brief  Returns the PCLK1 frequency     
   1060            * @note   Each time PCLK1 changes, this function must be called to update the
   1061            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1062            * @retval PCLK1 frequency
   1063            */

   \                                 In section .text, align 2, keep-with-next
   1064          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1065          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1066            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1067            return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable13_13
   \   0000000C   0xF411 0x61E0      ANDS     R1,R1,#0x700
   \   00000010   0xF45F 0x0360      MOVS     R3,#+14680064
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1068          }    
   1069          
   1070          /**
   1071            * @brief  Returns the PCLK2 frequency     
   1072            * @note   Each time PCLK2 changes, this function must be called to update the
   1073            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1074            * @retval PCLK2 frequency
   1075            */

   \                                 In section .text, align 2, keep-with-next
   1076          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1077          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1078            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1079            return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable13_13
   \   0000000C   0xF411 0x5160      ANDS     R1,R1,#0x3800
   \   00000010   0xF45F 0x13E0      MOVS     R3,#+1835008
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1080          } 
   1081          
   1082          /**
   1083            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1084            * RCC configuration registers.
   1085            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that 
   1086            * will be configured.
   1087            * @retval None
   1088            */

   \                                 In section .text, align 2, keep-with-next
   1089          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1090          {
   1091            /* Check the parameters */
   1092            assert_param(RCC_OscInitStruct != NULL);
   1093          
   1094            /* Set all possible values for the Oscillator type parameter ---------------*/
   1095            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
   1096                            | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_MSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \   00000000   0x211F             MOVS     R1,#+31
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1097          
   1098          
   1099            /* Get the HSE configuration -----------------------------------------------*/
   1100            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \   00000004   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0349             LSLS     R1,R1,#+13
   \   0000000A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_0
   1101            {
   1102              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \   0000000C   0x2105             MOVS     R1,#+5
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0xE008             B.N      ??HAL_RCC_GetOscConfig_1
   1103            }
   1104            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x03C9             LSLS     R1,R1,#+15
   \   00000018   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_2
   1105            {
   1106              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   \   0000001E   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1107            }
   1108            else
   1109            {
   1110              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6041             STR      R1,[R0, #+4]
   1111            }
   1112          
   1113            /* Get the HSI configuration -----------------------------------------------*/
   1114            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x07C9             LSLS     R1,R1,#+31
   \   0000002A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_3
   1115            {
   1116              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
   \   00000030   0xE001             B.N      ??HAL_RCC_GetOscConfig_4
   1117            }
   1118            else
   1119            {
   1120              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   1121            }
   1122            
   1123            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \   00000036   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF411 0x51F8      ANDS     R1,R1,#0x1F00
   \   0000003E   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000042   0xFAB2 0xF282      CLZ      R2,R2
   \   00000046   0x40D1             LSRS     R1,R1,R2
   \   00000048   0x6101             STR      R1,[R0, #+16]
   1124            
   1125            /* Get the MSI configuration -----------------------------------------------*/
   1126            if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)
   \   0000004A   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x05C9             LSLS     R1,R1,#+23
   \   00000050   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_5
   1127            {
   1128              RCC_OscInitStruct->MSIState = RCC_MSI_ON;
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x6181             STR      R1,[R0, #+24]
   \   00000056   0xE001             B.N      ??HAL_RCC_GetOscConfig_6
   1129            }
   1130            else
   1131            {
   1132              RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x6181             STR      R1,[R0, #+24]
   1133            }
   1134            
   1135            RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF011 0x417F      ANDS     R1,R1,#0xFF000000
   \   00000064   0x22FF             MOVS     R2,#+255
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x40D1             LSRS     R1,R1,R2
   \   0000006C   0x61C1             STR      R1,[R0, #+28]
   1136            RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSIRANGE));
   \   0000006E   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0xF411 0x4160      ANDS     R1,R1,#0xE000
   \   00000076   0x6201             STR      R1,[R0, #+32]
   1137            
   1138            /* Get the LSE configuration -----------------------------------------------*/
   1139            if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)
   \   00000078   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x0549             LSLS     R1,R1,#+21
   \   0000007E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_7
   1140            {
   1141              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \   00000080   0x2105             MOVS     R1,#+5
   \   00000082   0x6081             STR      R1,[R0, #+8]
   \   00000084   0xE008             B.N      ??HAL_RCC_GetOscConfig_8
   1142            }
   1143            else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \   00000086   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x05C9             LSLS     R1,R1,#+23
   \   0000008C   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_9
   1144            {
   1145              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x6081             STR      R1,[R0, #+8]
   \   00000092   0xE001             B.N      ??HAL_RCC_GetOscConfig_8
   1146            }
   1147            else
   1148            {
   1149              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x6081             STR      R1,[R0, #+8]
   1150            }
   1151            
   1152            /* Get the LSI configuration -----------------------------------------------*/
   1153            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0x07C9             LSLS     R1,R1,#+31
   \   0000009E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_10
   1154            {
   1155              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x6141             STR      R1,[R0, #+20]
   \   000000A4   0xE001             B.N      ??HAL_RCC_GetOscConfig_11
   1156            }
   1157            else
   1158            {
   1159              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x6141             STR      R1,[R0, #+20]
   1160            }
   1161            
   1162            /* Get the PLL configuration -----------------------------------------------*/
   1163            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x01C9             LSLS     R1,R1,#+7
   \   000000B0   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_12
   1164            {
   1165              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \   000000B2   0x2102             MOVS     R1,#+2
   \   000000B4   0x6241             STR      R1,[R0, #+36]
   \   000000B6   0xE001             B.N      ??HAL_RCC_GetOscConfig_13
   1166            }
   1167            else
   1168            {
   1169              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_12: (+1)
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x6241             STR      R1,[R0, #+36]
   1170            }
   1171            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_13: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable13_8  ;; 0x40023808
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0xF411 0x3180      ANDS     R1,R1,#0x10000
   \   000000C4   0x6281             STR      R1,[R0, #+40]
   1172            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);
   \   000000C6   0x....             LDR.N    R1,??DataTable13_8  ;; 0x40023808
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF411 0x1170      ANDS     R1,R1,#0x3C0000
   \   000000CE   0x62C1             STR      R1,[R0, #+44]
   1173            RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV);
   \   000000D0   0x....             LDR.N    R1,??DataTable13_8  ;; 0x40023808
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   000000D8   0x6301             STR      R1,[R0, #+48]
   1174          }
   \   000000DA   0x4770             BX       LR               ;; return
   1175          
   1176          /**
   1177            * @brief  Get the RCC_ClkInitStruct according to the internal 
   1178            * RCC configuration registers.
   1179            * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that 
   1180            * contains the current clock configuration.
   1181            * @param  pFLatency Pointer on the Flash Latency.
   1182            * @retval None
   1183            */

   \                                 In section .text, align 2, keep-with-next
   1184          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1185          {
   1186            /* Check the parameters */
   1187            assert_param(RCC_ClkInitStruct != NULL);
   1188            assert_param(pFLatency != NULL);
   1189          
   1190            /* Set all possible values for the Clock type parameter --------------------*/
   1191            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \   00000000   0x220F             MOVS     R2,#+15
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1192            
   1193            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1194            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \   00000004   0x....             LDR.N    R2,??DataTable13_8  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1195            
   1196            /* Get the HCLK configuration ----------------------------------------------*/ 
   1197            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   \   0000000E   0x....             LDR.N    R2,??DataTable13_8  ;; 0x40023808
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1198            
   1199            /* Get the APB1 configuration ----------------------------------------------*/ 
   1200            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   \   00000018   0x....             LDR.N    R2,??DataTable13_8  ;; 0x40023808
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   00000020   0x60C2             STR      R2,[R0, #+12]
   1201            
   1202            /* Get the APB2 configuration ----------------------------------------------*/ 
   1203            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \   00000022   0x....             LDR.N    R2,??DataTable13_8  ;; 0x40023808
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x08D2             LSRS     R2,R2,#+3
   \   00000028   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1204            
   1205            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1206            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   \   0000002E   0x....             LDR.N    R2,??DataTable13_4  ;; 0x40023c00
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0xF012 0x0201      ANDS     R2,R2,#0x1
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1207          }
   \   00000038   0x4770             BX       LR               ;; return
   1208          
   1209          /**
   1210            * @brief This function handles the RCC CSS interrupt request.
   1211            * @note This API should be called under the NMI_Handler().
   1212            * @retval None
   1213            */

   \                                 In section .text, align 2, keep-with-next
   1214          void HAL_RCC_NMI_IRQHandler(void)
   1215          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1216            /* Check RCC CSSF flag  */
   1217            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \   00000002   0x....             LDR.N    R0,??DataTable13_15  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1218            {
   1219              /* RCC Clock Security System interrupt user callback */
   1220              HAL_RCC_CSSCallback();
   \   0000000A   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1221              
   1222              /* Clear RCC CSS pending bit */
   1223              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x....             LDR.N    R1,??DataTable13_16  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1224            }
   1225          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1226          
   1227          /**
   1228            * @brief  RCC Clock Security System interrupt callback
   1229            * @retval none
   1230            */

   \                                 In section .text, align 2, keep-with-next
   1231          __weak void HAL_RCC_CSSCallback(void)
   1232          {
   1233            /* NOTE : This function Should not be modified, when the callback is needed,
   1234              the HAL_RCC_CSSCallback could be implemented in the user file
   1235              */ 
   1236          }
   \                     HAL_RCC_CSSCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1237          
   1238          /**
   1239            * @}
   1240            */
   1241          
   1242          /**
   1243            * @}
   1244            */
   1245          
   1246          /* Private function prototypes -----------------------------------------------*/
   1247          /** @addtogroup RCC_Private_Functions
   1248            * @{
   1249            */
   1250          /**
   1251            * @brief  Update number of Flash wait states in line with MSI range and current 
   1252                      voltage range
   1253            * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
   1254            * @retval HAL status
   1255            */

   \                                 In section .text, align 2, keep-with-next
   1256          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
   1257          {
   \                     RCC_SetFlashLatencyFromMSIRange: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1258            uint32_t vos = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1259            uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
   \   00000008   0x2600             MOVS     R6,#+0
   1260          
   1261            /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
   1262            if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
   \   0000000A   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40023808
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0FF0      TST      R0,#0xF0
   \   00000012   0xD124             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1263            {
   1264              if(__HAL_RCC_PWR_IS_CLK_ENABLED())
   \   00000014   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40023824
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x00C0             LSLS     R0,R0,#+3
   \   0000001A   0xD503             BPL.N    ??RCC_SetFlashLatencyFromMSIRange_1
   1265              {
   1266                vos = HAL_PWREx_GetVoltageRange();
   \   0000001C   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0xE014             B.N      ??RCC_SetFlashLatencyFromMSIRange_2
   1267              }
   1268              else
   1269              {
   1270                __HAL_RCC_PWR_CLK_ENABLE();
   \                     ??RCC_SetFlashLatencyFromMSIRange_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40023824
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000002C   0x....             LDR.N    R1,??DataTable13_2  ;; 0x40023824
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40023824
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   1271                vos = HAL_PWREx_GetVoltageRange();
   \   0000003C   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   \   00000040   0x0005             MOVS     R5,R0
   1272                __HAL_RCC_PWR_CLK_DISABLE();
   \   00000042   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40023824
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   0000004A   0x....             LDR.N    R1,??DataTable13_2  ;; 0x40023824
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1273              }
   1274              
   1275              /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
   1276              if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (msirange == RCC_MSIRANGE_6))
   \                     ??RCC_SetFlashLatencyFromMSIRange_2: (+1)
   \   0000004E   0xF5B5 0x5FC0      CMP      R5,#+6144
   \   00000052   0xD104             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   \   00000054   0xF5B4 0x4F40      CMP      R4,#+49152
   \   00000058   0xD101             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1277              {
   1278                latency = FLASH_LATENCY_1; /* 1WS */
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x0006             MOVS     R6,R0
   1279              }
   1280            }
   1281            
   1282            __HAL_FLASH_SET_LATENCY(latency);
   \                     ??RCC_SetFlashLatencyFromMSIRange_0: (+1)
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD105             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_3
   \   00000062   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40023c00
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023c00
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \                     ??RCC_SetFlashLatencyFromMSIRange_3: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40023c00
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x0840             LSRS     R0,R0,#+1
   \   00000074   0x0040             LSLS     R0,R0,#+1
   \   00000076   0x4330             ORRS     R0,R6,R0
   \   00000078   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023c00
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1283            
   1284            /* Check that the new number of wait states is taken into account to access the Flash
   1285               memory by reading the FLASH_ACR register */
   1286            if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
   \   0000007C   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40023c00
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000084   0x42B0             CMP      R0,R6
   \   00000086   0xD001             BEQ.N    ??RCC_SetFlashLatencyFromMSIRange_4
   1287            {
   1288              return HAL_ERROR;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE000             B.N      ??RCC_SetFlashLatencyFromMSIRange_5
   1289            }
   1290            
   1291            return HAL_OK;
   \                     ??RCC_SetFlashLatencyFromMSIRange_4: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??RCC_SetFlashLatencyFromMSIRange_5: (+1)
   \   0000008E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1292          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xEEFAFFFE         DC32     0xeefafffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x00FF1FFF         DC32     0xff1fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     aPLLMULFactorTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     aPLLDivisionFactorTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x4002380E         DC32     0x4002380e

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   1293          
   1294          /**
   1295            * @}
   1296            */
   1297            
   1298          #endif /* HAL_RCC_MODULE_ENABLED */
   1299          /**
   1300            * @}
   1301            */
   1302          
   1303          /**
   1304            * @}
   1305            */
   1306          
   1307          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      16   HAL_RCC_ClockConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
        16   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      16   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
        40   -> __aeabi_memclr4
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      16   HAL_RCC_OscConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
        16   -> RCC_SetFlashLatencyFromMSIRange
      24   RCC_SetFlashLatencyFromMSIRange
        24   -> HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
      20  ?_0
       2  HAL_RCC_CSSCallback
     672  HAL_RCC_ClockConfig
     136  HAL_RCC_DeInit
      18  HAL_RCC_DisableCSS
      18  HAL_RCC_EnableCSS
      58  HAL_RCC_GetClockConfig
       6  HAL_RCC_GetHCLKFreq
     220  HAL_RCC_GetOscConfig
      32  HAL_RCC_GetPCLK1Freq
      32  HAL_RCC_GetPCLK2Freq
     170  HAL_RCC_GetSysClockFreq
      98  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
    2090  HAL_RCC_OscConfig
     144  RCC_SetFlashLatencyFromMSIRange
       4  aPLLDivisionFactorTable
      12  aPLLMULFactorTable

 
    36 bytes in section .rodata
 3 822 bytes in section .text
 
 3 822 bytes of CODE  memory
    36 bytes of CONST memory

Errors: none
Warnings: none
