###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       25/Oct/2017  15:17:33
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\BSP\STM32L1xx_Nucleo\stm32l1xx_nucleo.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\BSP\STM32L1xx_Nucleo\stm32l1xx_nucleo.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\stm32l1xx_nucleo.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\stm32l1xx_nucleo.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Drivers\BSP\STM32L1xx_Nucleo\stm32l1xx_nucleo.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_nucleo.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    04-March-2016
      7            * @brief   This file provides set of firmware functions to manage:
      8            *          - LEDs and push-button available on STM32L1XX-Nucleo Kit 
      9            *            from STMicroelectronics
     10            *          - LCD, joystick and microSD available on Adafruit 1.8" TFT LCD 
     11            *            shield (reference ID 802)
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************
     40            */
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32l1xx_nucleo.h"
     44          
     45          /** @addtogroup BSP
     46            * @{
     47            */ 
     48          
     49          /** @defgroup STM32L1XX_NUCLEO STM32L152RE-Nucleo
     50            * @brief This file provides set of firmware functions to manage Leds and push-button
     51            *        available on STM32L1XX-Nucleo Kit from STMicroelectronics.
     52            *        It provides also LCD, joystick and uSD functions to communicate with 
     53            *        Adafruit 1.8" TFT LCD shield (reference ID 802)
     54            * @{
     55            */ 
     56          
     57          
     58          /** @defgroup STM32L1XX_NUCLEO_Private_Defines Private Defines
     59            * @{
     60            */ 
     61            
     62          /**
     63          * @brief STM32L152RE NUCLEO BSP Driver version
     64          */
     65          #define __STM32L1XX_NUCLEO_BSP_VERSION_MAIN   (0x01) /*!< [31:24] main version */
     66          #define __STM32L1XX_NUCLEO_BSP_VERSION_SUB1   (0x01) /*!< [23:16] sub1 version */
     67          #define __STM32L1XX_NUCLEO_BSP_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
     68          #define __STM32L1XX_NUCLEO_BSP_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
     69          #define __STM32L1XX_NUCLEO_BSP_VERSION       ((__STM32L1XX_NUCLEO_BSP_VERSION_MAIN << 24)\
     70                                                       |(__STM32L1XX_NUCLEO_BSP_VERSION_SUB1 << 16)\
     71                                                       |(__STM32L1XX_NUCLEO_BSP_VERSION_SUB2 << 8 )\
     72                                                       |(__STM32L1XX_NUCLEO_BSP_VERSION_RC))
     73          
     74          /**
     75            * @brief LINK SD Card
     76            */
     77          #define SD_DUMMY_BYTE            0xFF    
     78          #define SD_NO_RESPONSE_EXPECTED  0x80
     79             
     80          /**
     81            * @}
     82            */ 
     83          
     84          
     85          /** @defgroup STM32L1XX_NUCLEO_Private_Variables Private Variables
     86            * @{
     87            */ 

   \                                 In section .data, align 4
     88          GPIO_TypeDef* LED_PORT[LEDn] = {LED2_GPIO_PORT};
   \                     LED_PORT:
   \   00000000   0x40020000         DC32 40020000H
     89          

   \                                 In section .rodata, align 2
     90          const uint16_t LED_PIN[LEDn] = {LED2_PIN};
   \                     LED_PIN:
   \   00000000   0x0020             DC16 32
     91          

   \                                 In section .data, align 4
     92          GPIO_TypeDef* BUTTON_PORT[BUTTONn]  = {USER_BUTTON_GPIO_PORT}; 
   \                     BUTTON_PORT:
   \   00000000   0x40020800         DC32 40020800H

   \                                 In section .rodata, align 2
     93          const uint16_t BUTTON_PIN[BUTTONn]  = {USER_BUTTON_PIN}; 
   \                     BUTTON_PIN:
   \   00000000   0x2000             DC16 8192

   \                                 In section .rodata, align 1
     94          const uint8_t  BUTTON_IRQn[BUTTONn] = {USER_BUTTON_EXTI_IRQn };
   \                     BUTTON_IRQn:
   \   00000000   0x28               DC8 40
     95          
     96          /**
     97           * @brief BUS variables
     98           */
     99          
    100          #ifdef HAL_SPI_MODULE_ENABLED
    101          uint32_t SpixTimeout = NUCLEO_SPIx_TIMEOUT_MAX;        /*<! Value of Timeout when SPI communication fails */
    102          static SPI_HandleTypeDef hnucleo_Spi;
    103          #endif /* HAL_SPI_MODULE_ENABLED */
    104          
    105          #ifdef HAL_ADC_MODULE_ENABLED

   \                                 In section .bss, align 4
    106          static ADC_HandleTypeDef hnucleo_Adc;
   \                     hnucleo_Adc:
   \   00000000                      DS8 84
    107          /* ADC channel configuration structure declaration */

   \                                 In section .bss, align 4
    108          static ADC_ChannelConfTypeDef sConfig;
   \                     sConfig:
   \   00000000                      DS8 12
    109          #endif /* HAL_ADC_MODULE_ENABLED */
    110          
    111          /**
    112            * @}
    113            */ 
    114          
    115          /** @defgroup STM32L1XX_NUCLEO_Private_Functions Private Functions
    116            * @{
    117            */ 
    118          #ifdef HAL_SPI_MODULE_ENABLED
    119          static void               SPIx_Init(void);
    120          static void               SPIx_Write(uint8_t Value);
    121          static void               SPIx_WriteData(uint8_t *DataIn, uint16_t DataLength);
    122          static void               SPIx_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLegnth);
    123          static void               SPIx_Error (void);
    124          static void               SPIx_MspInit(void);
    125          
    126          /* SD IO functions */
    127          void                      SD_IO_Init(void);
    128          void                      SD_IO_CSState(uint8_t state);
    129          void                      SD_IO_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength);
    130          void                      SD_IO_ReadData(uint8_t *DataOut, uint16_t DataLength);
    131          void                      SD_IO_WriteData(const uint8_t *Data, uint16_t DataLength);
    132          uint8_t                   SD_IO_WriteByte(uint8_t Data);
    133          uint8_t                   SD_IO_ReadByte(void);
    134          
    135          /* LCD IO functions */
    136          void                      LCD_IO_Init(void);
    137          void                      LCD_IO_WriteData(uint8_t Data);
    138          void                      LCD_IO_WriteMultipleData(uint8_t *pData, uint32_t Size);
    139          void                      LCD_IO_WriteReg(uint8_t LCDReg);
    140          void                      LCD_Delay(uint32_t delay);
    141          #endif /* HAL_SPI_MODULE_ENABLED */
    142          
    143          #ifdef HAL_ADC_MODULE_ENABLED
    144          static HAL_StatusTypeDef  ADCx_Init(void);
    145          static void               ADCx_DeInit(void);
    146          static void               ADCx_MspInit(ADC_HandleTypeDef *hadc);
    147          static void               ADCx_MspDeInit(ADC_HandleTypeDef *hadc);
    148          #endif /* HAL_ADC_MODULE_ENABLED */
    149          /**
    150            * @}
    151            */ 
    152          
    153          /** @defgroup STM32L1XX_NUCLEO_Exported_Functions Exported Functions
    154            * @{
    155            */ 
    156          
    157          /**
    158            * @brief  This method returns the STM32L1XX NUCLEO BSP Driver revision
    159            * @retval version : 0xXYZR (8bits for each decimal, R for RC)
    160            */

   \                                 In section .text, align 2, keep-with-next
    161          uint32_t BSP_GetVersion(void)
    162          {
    163            return __STM32L1XX_NUCLEO_BSP_VERSION;
   \                     BSP_GetVersion: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x1010000
   \   00000004   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /** @defgroup STM32L1XX_NUCLEO_LED_Functions LED Functions
    167            * @{
    168            */ 
    169          
    170          /**
    171            * @brief  Configures LED GPIO.
    172            * @param  Led: Led to be configured. 
    173            *          This parameter can be one of the following values:
    174            *     @arg LED2
    175            * @retval None
    176            */

   \                                 In section .text, align 2, keep-with-next
    177          void BSP_LED_Init(Led_TypeDef Led)
    178          {
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    179            GPIO_InitTypeDef  gpioinitstruct;
    180            
    181            /* Enable the GPIO_LED Clock */
    182            LEDx_GPIO_CLK_ENABLE(Led);
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD10E             BNE.N    ??BSP_LED_Init_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x4002381c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x4002381c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x4002381c
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x9800             LDR      R0,[SP, #+0]
    183          
    184            /* Configure the GPIO_LED pin */
    185            gpioinitstruct.Pin    = LED_PIN[Led];
   \                     ??BSP_LED_Init_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000034   0x9001             STR      R0,[SP, #+4]
    186            gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9002             STR      R0,[SP, #+8]
    187            gpioinitstruct.Pull   = GPIO_NOPULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9003             STR      R0,[SP, #+12]
    188            gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x9004             STR      R0,[SP, #+16]
    189            
    190            HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_Init
    191          
    192            /* Reset PIN to switch off the LED */
    193            HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000068   0x.... 0x....      BL       HAL_GPIO_WritePin
    194          }
   \   0000006C   0xB006             ADD      SP,SP,#+24
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    195          
    196          /**
    197            * @brief  DeInit LEDs.
    198            * @param  Led: LED to be de-init. 
    199            *   This parameter can be one of the following values:
    200            *     @arg  LED2
    201            * @note Led DeInit does not disable the GPIO clock nor disable the Mfx 
    202            * @retval None
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          void BSP_LED_DeInit(Led_TypeDef Led)
    205          {
   \                     BSP_LED_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    206            GPIO_InitTypeDef  gpio_init_structure;
    207          
    208            /* Turn off LED */
    209            HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
    210            /* DeInit the GPIO_LED pin */
    211            gpio_init_structure.Pin = LED_PIN[Led];
   \   00000020   0x....             LDR.N    R0,??DataTable14_2
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000028   0x9000             STR      R0,[SP, #+0]
    212            HAL_GPIO_DeInit(LED_PORT[Led], gpio_init_structure.Pin);
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable14_3
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000034   0x.... 0x....      BL       HAL_GPIO_DeInit
    213          }
   \   00000038   0xB006             ADD      SP,SP,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    214          
    215          /**
    216            * @brief  Turns selected LED On.
    217            * @param  Led: Specifies the Led to be set on. 
    218            *   This parameter can be one of following parameters:
    219            *     @arg LED2
    220            * @retval None
    221            */

   \                                 In section .text, align 2, keep-with-next
    222          void BSP_LED_On(Led_TypeDef Led)
    223          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    224            HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x....             LDR.N    R0,??DataTable14_2
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000000E   0x....             LDR.N    R0,??DataTable14_3
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
    225          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    226          
    227          /**
    228            * @brief  Turns selected LED Off.
    229            * @param  Led: Specifies the Led to be set off. 
    230            *   This parameter can be one of following parameters:
    231            *     @arg LED2
    232            * @retval None
    233            */

   \                                 In section .text, align 2, keep-with-next
    234          void BSP_LED_Off(Led_TypeDef Led)
    235          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    236            HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable14_2
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000000E   0x....             LDR.N    R0,??DataTable14_3
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
    237          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    238          
    239          /**
    240            * @brief  Toggles the selected LED.
    241            * @param  Led: Specifies the Led to be toggled. 
    242            *   This parameter can be one of following parameters:
    243            *            @arg  LED2
    244            * @retval None
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          void BSP_LED_Toggle(Led_TypeDef Led)
    247          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    248            HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
   \   00000004   0x....             LDR.N    R0,??DataTable14_2
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000000C   0x....             LDR.N    R0,??DataTable14_3
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x.... 0x....      BL       HAL_GPIO_TogglePin
    249          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    250          
    251          /**
    252            * @}
    253            */ 
    254          
    255          /** @defgroup STM32L1XX_NUCLEO_BUTTON_Functions BUTTON Functions
    256            * @{
    257            */ 
    258          
    259          /**
    260            * @brief  Configures Button GPIO and EXTI Line.
    261            * @param  Button: Specifies the Button to be configured.
    262            *   This parameter should be: BUTTON_USER
    263            * @param  ButtonMode: Specifies Button mode.
    264            *   This parameter can be one of following parameters:   
    265            *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO 
    266            *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
    267            *                     generation capability  
    268            * @retval None
    269            */

   \                                 In section .text, align 2, keep-with-next
    270          void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
    271          {
   \                     BSP_PB_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    272            GPIO_InitTypeDef gpioinitstruct;
    273          
    274            /* Enable the BUTTON Clock */
    275            BUTTONx_GPIO_CLK_ENABLE(Button);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD10B             BNE.N    ??BSP_PB_Init_0
   \   0000000E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4002381c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000016   0x....             LDR.N    R1,??DataTable14_1  ;; 0x4002381c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4002381c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
    276          
    277            gpioinitstruct.Pin = BUTTON_PIN[Button];
   \                     ??BSP_PB_Init_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable14_4
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    278            gpioinitstruct.Pull = GPIO_NOPULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9003             STR      R0,[SP, #+12]
    279            gpioinitstruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9004             STR      R0,[SP, #+16]
    280          
    281            if (ButtonMode == BUTTON_MODE_GPIO)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD108             BNE.N    ??BSP_PB_Init_1
    282            {
    283              /* Configure Button pin as input */
    284              gpioinitstruct.Mode   = GPIO_MODE_INPUT;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9002             STR      R0,[SP, #+8]
    285            
    286              HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x....             LDR.N    R0,??DataTable14_5
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_Init
    287            }
    288           
    289            if (ButtonMode == BUTTON_MODE_EXTI)
   \                     ??BSP_PB_Init_1: (+1)
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D01             CMP      R5,#+1
   \   00000054   0xD116             BNE.N    ??BSP_PB_Init_2
    290            {
    291              /* Configure Button pin as input with External interrupt */
    292              gpioinitstruct.Mode   = GPIO_MODE_IT_FALLING; 
   \   00000056   0x....             LDR.N    R0,??DataTable14_6  ;; 0x10210000
   \   00000058   0x9002             STR      R0,[SP, #+8]
    293              HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
   \   0000005A   0xA901             ADD      R1,SP,#+4
   \   0000005C   0x....             LDR.N    R0,??DataTable14_5
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000064   0x.... 0x....      BL       HAL_GPIO_Init
    294          
    295              /* Enable and set Button EXTI Interrupt to the lowest priority */
    296              HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0);
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x210F             MOVS     R1,#+15
   \   0000006C   0x....             LDR.N    R0,??DataTable14_7
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x5700             LDRSB    R0,[R0, R4]
   \   00000072   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000074   0x.... 0x....      BL       HAL_NVIC_SetPriority
    297              HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000078   0x....             LDR.N    R0,??DataTable14_7
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x5700             LDRSB    R0,[R0, R4]
   \   0000007E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000080   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    298            }
    299          }
   \                     ??BSP_PB_Init_2: (+1)
   \   00000084   0xB007             ADD      SP,SP,#+28
   \   00000086   0xBD30             POP      {R4,R5,PC}       ;; return
    300          
    301          /**
    302            * @brief  Push Button DeInit.
    303            * @param  Button: Button to be configured
    304            *   This parameter should be: BUTTON_USER  
    305            * @note PB DeInit does not disable the GPIO clock
    306            * @retval None
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          void BSP_PB_DeInit(Button_TypeDef Button)
    309          {
   \                     BSP_PB_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    310            GPIO_InitTypeDef gpio_init_structure;
    311          
    312            gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   00000006   0x....             LDR.N    R0,??DataTable14_4
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    313            HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000010   0x....             LDR.N    R0,??DataTable14_7
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x5700             LDRSB    R0,[R0, R4]
   \   00000016   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    314            HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   \   0000001E   0x....             LDR.N    R0,??DataTable14_5
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000026   0x.... 0x....      BL       HAL_GPIO_DeInit
    315          }
   \   0000002A   0xB006             ADD      SP,SP,#+24
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    316          
    317          /**
    318            * @brief  Returns the selected Button state.
    319            * @param  Button: Specifies the Button to be checked.
    320            *   This parameter should be: BUTTON_USER  
    321            * @retval Button state.
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          uint32_t BSP_PB_GetState(Button_TypeDef Button)
    324          {
   \                     BSP_PB_GetState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    325            return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \   00000004   0x....             LDR.N    R0,??DataTable14_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000000C   0x....             LDR.N    R0,??DataTable14_5
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    326          }
    327          /**
    328            * @}
    329            */ 
    330          
    331          /**
    332            * @}
    333            */
    334          
    335          /** @addtogroup STM32L1XX_NUCLEO_Private_Functions
    336            * @{
    337            */ 
    338            
    339          #ifdef HAL_SPI_MODULE_ENABLED
    340          /******************************************************************************
    341                                      BUS OPERATIONS
    342          *******************************************************************************/
    343          /**
    344            * @brief  Initialize SPI MSP.
    345            * @retval None
    346            */
    347          static void SPIx_MspInit(void)
    348          {
    349            GPIO_InitTypeDef  gpioinitstruct = {0};
    350            
    351            /*** Configure the GPIOs ***/  
    352            /* Enable GPIO clock */
    353            NUCLEO_SPIx_SCK_GPIO_CLK_ENABLE();
    354            NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_ENABLE();
    355          
    356            /* Configure SPI SCK */
    357            gpioinitstruct.Pin        = NUCLEO_SPIx_SCK_PIN;
    358            gpioinitstruct.Mode       = GPIO_MODE_AF_PP;
    359            gpioinitstruct.Pull       = GPIO_PULLUP;
    360            gpioinitstruct.Speed      = GPIO_SPEED_FREQ_VERY_HIGH;
    361            gpioinitstruct.Alternate  = NUCLEO_SPIx_SCK_AF;
    362            HAL_GPIO_Init(NUCLEO_SPIx_SCK_GPIO_PORT, &gpioinitstruct);
    363          
    364            /* Configure SPI MISO and MOSI */ 
    365            gpioinitstruct.Pin        = NUCLEO_SPIx_MOSI_PIN;
    366            gpioinitstruct.Alternate  = NUCLEO_SPIx_MISO_MOSI_AF;
    367            gpioinitstruct.Pull       = GPIO_PULLDOWN;
    368            HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &gpioinitstruct);
    369            
    370            gpioinitstruct.Pin        = NUCLEO_SPIx_MISO_PIN;
    371            HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &gpioinitstruct);
    372          
    373            /*** Configure the SPI peripheral ***/ 
    374            /* Enable SPI clock */
    375            NUCLEO_SPIx_CLK_ENABLE();
    376          }
    377          
    378          /**
    379            * @brief  Initialize SPI HAL.
    380            * @retval None
    381            */
    382          static void SPIx_Init(void)
    383          {
    384            if(HAL_SPI_GetState(&hnucleo_Spi) == HAL_SPI_STATE_RESET)
    385            {
    386              /* SPI Config */
    387              hnucleo_Spi.Instance = NUCLEO_SPIx;
    388                /* SPI baudrate is set to 8 MHz maximum (PCLK2/SPI_BaudRatePrescaler = 64/8 = 8 MHz) 
    389                 to verify these constraints:
    390                    - ST7735 LCD SPI interface max baudrate is 15MHz for write and 6.66MHz for read
    391                      Since the provided driver doesn't use read capability from LCD, only constraint 
    392                      on write baudrate is considered.
    393                    - SD card SPI interface max baudrate is 25MHz for write/read
    394                    - PCLK2 max frequency is 32 MHz 
    395                 */
    396              hnucleo_Spi.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_8;
    397              hnucleo_Spi.Init.Direction          = SPI_DIRECTION_2LINES;
    398              hnucleo_Spi.Init.CLKPhase           = SPI_PHASE_1EDGE;
    399              hnucleo_Spi.Init.CLKPolarity        = SPI_POLARITY_LOW;
    400              hnucleo_Spi.Init.CRCCalculation     = SPI_CRCCALCULATION_DISABLE;
    401              hnucleo_Spi.Init.CRCPolynomial      = 7;
    402              hnucleo_Spi.Init.DataSize           = SPI_DATASIZE_8BIT;
    403              hnucleo_Spi.Init.FirstBit           = SPI_FIRSTBIT_MSB;
    404              hnucleo_Spi.Init.NSS                = SPI_NSS_SOFT;
    405              hnucleo_Spi.Init.TIMode             = SPI_TIMODE_DISABLE;
    406              hnucleo_Spi.Init.Mode               = SPI_MODE_MASTER;
    407              
    408              SPIx_MspInit();
    409              HAL_SPI_Init(&hnucleo_Spi);
    410            }
    411          }
    412          
    413          /**
    414            * @brief  SPI Write a byte to device
    415            * @param  Value: value to be written
    416            * @retval None
    417          */
    418          static void SPIx_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
    419          {
    420            HAL_StatusTypeDef status = HAL_OK;
    421            
    422            status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t*) DataIn, DataOut, DataLength, SpixTimeout);
    423            
    424            /* Check the communication status */
    425            if(status != HAL_OK)
    426            {
    427              /* Execute user timeout callback */
    428              SPIx_Error();
    429            }
    430          }
    431          
    432          /**
    433            * @brief  SPI Write an amount of data to device
    434            * @param  Value: value to be written
    435            * @param  DataLength: number of bytes to write
    436            * @retval None
    437            */
    438          static void SPIx_WriteData(uint8_t *DataIn, uint16_t DataLength)
    439          {
    440            HAL_StatusTypeDef status = HAL_OK;
    441          
    442            status = HAL_SPI_Transmit(&hnucleo_Spi, DataIn, DataLength, SpixTimeout);
    443            
    444            /* Check the communication status */
    445            if(status != HAL_OK)
    446            {
    447              /* Execute user timeout callback */
    448              SPIx_Error();
    449            }
    450          }
    451          
    452          /**
    453            * @brief  SPI Write a byte to device
    454            * @param  Value: value to be written
    455            * @retval None
    456            */
    457          static void SPIx_Write(uint8_t Value)
    458          {
    459            HAL_StatusTypeDef status = HAL_OK;
    460            uint8_t data;
    461          
    462            status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t*) &Value, &data, 1, SpixTimeout);
    463          
    464            /* Check the communication status */
    465            if(status != HAL_OK)
    466            {
    467              /* Execute user timeout callback */
    468              SPIx_Error();
    469            }
    470          }
    471          
    472          /**
    473            * @brief  SPI error treatment function
    474            * @retval None
    475            */
    476          static void SPIx_Error (void)
    477          {
    478            /* De-initialize the SPI communication BUS */
    479            HAL_SPI_DeInit(&hnucleo_Spi);
    480          
    481            /* Re-Initiaize the SPI communication BUS */
    482            SPIx_Init();
    483          }
    484          
    485          /******************************************************************************
    486                                      LINK OPERATIONS
    487          *******************************************************************************/
    488          
    489          /********************************* LINK SD ************************************/
    490          /**
    491            * @brief  Initialize the SD Card and put it into StandBy State (Ready for 
    492            *         data transfer).
    493            * @retval None
    494            */
    495          void SD_IO_Init(void)
    496          {
    497            GPIO_InitTypeDef  gpioinitstruct = {0};
    498            uint8_t counter = 0;
    499          
    500            /* SD_CS_GPIO Periph clock enable */
    501            SD_CS_GPIO_CLK_ENABLE();
    502          
    503            /* Configure SD_CS_PIN pin: SD Card CS pin */
    504            gpioinitstruct.Pin    = SD_CS_PIN;
    505            gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
    506            gpioinitstruct.Pull   = GPIO_PULLUP;
    507            gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
    508            HAL_GPIO_Init(SD_CS_GPIO_PORT, &gpioinitstruct);
    509          
    510            /* Configure LCD_CS_PIN pin: LCD Card CS pin */
    511            gpioinitstruct.Pin   = LCD_CS_PIN;
    512            gpioinitstruct.Mode  = GPIO_MODE_OUTPUT_PP;
    513            gpioinitstruct.Pull  = GPIO_NOPULL;
    514            gpioinitstruct.Speed = GPIO_SPEED_FREQ_HIGH;
    515            HAL_GPIO_Init(SD_CS_GPIO_PORT, &gpioinitstruct);
    516            LCD_CS_HIGH();
    517            /*------------Put SD in SPI mode--------------*/
    518            /* SD SPI Config */
    519            SPIx_Init();
    520          
    521            /* SD chip select high */
    522            SD_CS_HIGH();
    523            
    524            /* Send dummy byte 0xFF, 10 times with CS high */
    525            /* Rise CS and MOSI for 80 clocks cycles */
    526            for (counter = 0; counter <= 9; counter++)
    527            {
    528              /* Send dummy byte 0xFF */
    529              SD_IO_WriteByte(SD_DUMMY_BYTE);
    530            }
    531          }
    532          
    533          /**
    534            * @brief  Set the SD_CS pin.
    535            * @param  pin value.
    536            * @retval None
    537            */
    538          void SD_IO_CSState(uint8_t val)
    539          {
    540            if(val == 1) 
    541            {
    542              SD_CS_HIGH();
    543          }
    544            else
    545            {
    546              SD_CS_LOW();
    547            }
    548          }
    549           
    550          /**
    551            * @brief  Write byte(s) on the SD
    552            * @param  DataIn: Pointer to data buffer to write
    553            * @param  DataOut: Pointer to data buffer for read data
    554            * @param  DataLength: number of bytes to write
    555            * @retval None
    556            */
    557          void SD_IO_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
    558            {
    559            /* Send the byte */
    560            SPIx_WriteReadData(DataIn, DataOut, DataLength);
    561          }
    562          
    563          /**
    564            * @brief  Write a byte on the SD.
    565            * @param  Data: byte to send.
    566            * @retval Data written
    567            */
    568          uint8_t SD_IO_WriteByte(uint8_t Data)
    569          {
    570            uint8_t tmp;
    571          
    572            /* Send the byte */
    573            SPIx_WriteReadData(&Data,&tmp,1);
    574            return tmp;
    575          }
    576          
    577          /**
    578            * @brief  Write an amount of data on the SD.
    579            * @param  Data: byte to send.
    580            * @param  DataLength: number of bytes to write
    581            * @retval none
    582            */
    583          void SD_IO_ReadData(uint8_t *DataOut, uint16_t DataLength)
    584          {
    585            /* Send the byte */
    586            SD_IO_WriteReadData(DataOut, DataOut, DataLength);
    587            }  
    588           
    589          /**
    590            * @brief  Write an amount of data on the SD.
    591            * @param  Data: byte to send.
    592            * @param  DataLength: number of bytes to write
    593            * @retval none
    594            */
    595          void SD_IO_WriteData(const uint8_t *Data, uint16_t DataLength)
    596          {
    597            /* Send the byte */
    598            SPIx_WriteData((uint8_t *)Data, DataLength);
    599          }
    600          
    601          /********************************* LINK LCD ***********************************/
    602          /**
    603            * @brief  Initialize the LCD
    604            * @retval None
    605            */
    606          void LCD_IO_Init(void)
    607          {
    608            GPIO_InitTypeDef  gpioinitstruct = {0};
    609          
    610            /* LCD_CS_GPIO and LCD_DC_GPIO Periph clock enable */
    611            LCD_CS_GPIO_CLK_ENABLE();
    612            LCD_DC_GPIO_CLK_ENABLE();
    613            
    614            /* Configure LCD_CS_PIN pin: LCD Card CS pin */
    615            gpioinitstruct.Pin    = LCD_CS_PIN;
    616            gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
    617            gpioinitstruct.Pull   = GPIO_NOPULL;
    618            gpioinitstruct.Speed  = GPIO_SPEED_FREQ_VERY_HIGH;
    619            HAL_GPIO_Init(SD_CS_GPIO_PORT, &gpioinitstruct);
    620                
    621            /* Configure LCD_DC_PIN pin: LCD Card DC pin */
    622            gpioinitstruct.Pin    = LCD_DC_PIN;
    623            HAL_GPIO_Init(LCD_DC_GPIO_PORT, &gpioinitstruct);
    624          
    625            /* LCD chip select high */
    626            LCD_CS_HIGH();
    627            
    628            /* LCD SPI Config */
    629            SPIx_Init();
    630          }
    631             
    632          /**
    633            * @brief  Write command to select the LCD register.
    634            * @param  LCDReg: Address of the selected register.
    635            * @retval None
    636            */
    637          void LCD_IO_WriteReg(uint8_t LCDReg)
    638          {
    639            /* Reset LCD control line CS */
    640            LCD_CS_LOW();
    641            
    642            /* Set LCD data/command line DC to Low */
    643            LCD_DC_LOW();
    644              
    645            /* Send Command */
    646            SPIx_Write(LCDReg);
    647            
    648            /* Deselect : Chip Select high */
    649            LCD_CS_HIGH();
    650          }
    651          
    652          /**
    653          * @brief  Write register value.
    654          * @param  pData Pointer on the register value
    655          * @param  Size Size of byte to transmit to the register
    656          * @retval None
    657          */
    658          void LCD_IO_WriteMultipleData(uint8_t *pData, uint32_t Size)
    659          {
    660            uint32_t counter = 0;
    661            
    662            /* Reset LCD control line CS */
    663            LCD_CS_LOW();
    664            
    665            /* Set LCD data/command line DC to High */
    666            LCD_DC_HIGH();
    667          
    668            if (Size == 1)
    669            {
    670              /* Only 1 byte to be sent to LCD - general interface can be used */
    671              /* Send Data */
    672              SPIx_Write(*pData);
    673            }
    674            else
    675            {
    676              /* Several data should be sent in a raw */
    677              /* Direct SPI accesses for optimization */
    678              for (counter = Size; counter != 0; counter--)
    679              {
    680                while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
    681                {
    682                }  
    683                /* Need to invert bytes for LCD*/
    684                *((__IO uint8_t*)&hnucleo_Spi.Instance->DR) = *(pData+1);
    685                
    686                while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
    687                {
    688                }  
    689                *((__IO uint8_t*)&hnucleo_Spi.Instance->DR) = *pData;
    690                counter--;
    691                pData += 2;
    692              }
    693              
    694              /* Wait until the bus is ready before releasing Chip select */ 
    695              while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_BSY) != RESET)
    696              {
    697              }  
    698            } 
    699            
    700            /* Deselect : Chip Select high */
    701            LCD_CS_HIGH();
    702          }
    703          
    704          /**
    705            * @brief  Wait for loop in ms.
    706            * @param  Delay in ms.
    707            * @retval None
    708            */
    709          void LCD_Delay(uint32_t Delay)
    710          {
    711            HAL_Delay(Delay);
    712          }
    713          
    714          #endif /* HAL_SPI_MODULE_ENABLED */
    715          
    716          #ifdef HAL_ADC_MODULE_ENABLED
    717          /******************************* LINK JOYSTICK ********************************/
    718          /**
    719            * @brief  Initialize ADC MSP.
    720            * @retval None
    721            */

   \                                 In section .text, align 2, keep-with-next
    722          static void ADCx_MspInit(ADC_HandleTypeDef *hadc)
    723          {
   \                     ADCx_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    724            GPIO_InitTypeDef  gpioinitstruct = {0};
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    725            
    726            /*** Configure the GPIOs ***/  
    727            /* Enable GPIO clock */
    728            NUCLEO_ADCx_GPIO_CLK_ENABLE();
   \   0000000E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4002381c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000016   0x....             LDR.N    R1,??DataTable14_1  ;; 0x4002381c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4002381c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
    729            
    730            /* Configure ADC1 Channel8 as analog input */
    731            gpioinitstruct.Pin    = NUCLEO_ADCx_GPIO_PIN ;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9001             STR      R0,[SP, #+4]
    732            gpioinitstruct.Mode   = GPIO_MODE_ANALOG;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x9002             STR      R0,[SP, #+8]
    733            gpioinitstruct.Pull   = GPIO_NOPULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9003             STR      R0,[SP, #+12]
    734            HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT, &gpioinitstruct);
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0x....             LDR.N    R0,??DataTable14_8  ;; 0x40020400
   \   00000036   0x.... 0x....      BL       HAL_GPIO_Init
    735          
    736            /*** Configure the ADC peripheral ***/ 
    737            /* Enable ADC clock */
    738            NUCLEO_ADCx_CLK_ENABLE(); 
   \   0000003A   0x....             LDR.N    R0,??DataTable14_9  ;; 0x40023820
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000042   0x....             LDR.N    R1,??DataTable14_9  ;; 0x40023820
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0x....             LDR.N    R0,??DataTable14_9  ;; 0x40023820
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF410 0x7000      ANDS     R0,R0,#0x200
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x9800             LDR      R0,[SP, #+0]
    739          }
   \   00000052   0xB006             ADD      SP,SP,#+24
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    740          
    741          /**
    742            * @brief  DeInitializes ADC MSP.
    743            * @param  None
    744            * @note ADC DeInit does not disable the GPIO clock
    745            * @retval None
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          static void ADCx_MspDeInit(ADC_HandleTypeDef *hadc)
    748          {
   \                     ADCx_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    749            GPIO_InitTypeDef  gpioinitstruct;
    750          
    751            /*** DeInit the ADC peripheral ***/ 
    752            /* Disable ADC clock */
    753            NUCLEO_ADCx_CLK_DISABLE(); 
   \   00000006   0x....             LDR.N    R0,??DataTable14_9  ;; 0x40023820
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000000E   0x....             LDR.N    R1,??DataTable14_9  ;; 0x40023820
   \   00000010   0x6008             STR      R0,[R1, #+0]
    754          
    755            /* Configure the selected ADC Channel as analog input */
    756            gpioinitstruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x9000             STR      R0,[SP, #+0]
    757            HAL_GPIO_DeInit(NUCLEO_ADCx_GPIO_PORT, gpioinitstruct.Pin);
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x....             LDR.N    R0,??DataTable14_8  ;; 0x40020400
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_DeInit
    758          
    759            /* Disable GPIO clock has to be done by the application*/
    760            /* NUCLEO_ADCx_GPIO_CLK_DISABLE(); */
    761          }
   \   0000001E   0xB006             ADD      SP,SP,#+24
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    762          
    763          /**
    764            * @brief  Initializes ADC HAL.
    765            * @retval None
    766            */

   \                                 In section .text, align 2, keep-with-next
    767          static HAL_StatusTypeDef ADCx_Init(void)
    768          {
   \                     ADCx_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    769            /* Set ADC instance */
    770            hnucleo_Adc.Instance = NUCLEO_ADCx;
   \   00000002   0x....             LDR.N    R0,??DataTable14_10  ;; 0x40012400
   \   00000004   0x....             LDR.N    R1,??DataTable14_11
   \   00000006   0x6008             STR      R0,[R1, #+0]
    771          
    772            if(HAL_ADC_GetState(&hnucleo_Adc) == HAL_ADC_STATE_RESET)
   \   00000008   0x....             LDR.N    R0,??DataTable14_11
   \   0000000A   0x.... 0x....      BL       HAL_ADC_GetState
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD13A             BNE.N    ??ADCx_Init_0
    773            {
    774              /* ADC Config */
    775              hnucleo_Adc.Instance                    = NUCLEO_ADCx;
   \   00000012   0x....             LDR.N    R0,??DataTable14_10  ;; 0x40012400
   \   00000014   0x....             LDR.N    R1,??DataTable14_11
   \   00000016   0x6008             STR      R0,[R1, #+0]
    776          
    777              hnucleo_Adc.Init.ClockPrescaler         = ADC_CLOCK_ASYNC_DIV2;          /* ADC clock must not exceed 16MHz */
   \   00000018   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000001C   0x....             LDR.N    R1,??DataTable14_11
   \   0000001E   0x6048             STR      R0,[R1, #+4]
    778              hnucleo_Adc.Init.Resolution             = ADC_RESOLUTION_12B;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable14_11
   \   00000024   0x6088             STR      R0,[R1, #+8]
    779              hnucleo_Adc.Init.DataAlign              = ADC_DATAALIGN_RIGHT;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable14_11
   \   0000002A   0x60C8             STR      R0,[R1, #+12]
    780              hnucleo_Adc.Init.ScanConvMode           = ADC_SCAN_DISABLE;              /* Sequencer disabled (ADC conversion on only 1 channel: channel set on rank 1) */
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable14_11
   \   00000030   0x6108             STR      R0,[R1, #+16]
    781              hnucleo_Adc.Init.EOCSelection           = ADC_EOC_SEQ_CONV;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable14_11
   \   00000036   0x6148             STR      R0,[R1, #+20]
    782              hnucleo_Adc.Init.LowPowerAutoWait       = ADC_AUTOWAIT_UNTIL_DATA_READ;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x....             LDR.N    R1,??DataTable14_11
   \   0000003C   0x6188             STR      R0,[R1, #+24]
    783              hnucleo_Adc.Init.LowPowerAutoPowerOff   = ADC_AUTOPOWEROFF_DISABLE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x....             LDR.N    R1,??DataTable14_11
   \   00000042   0x61C8             STR      R0,[R1, #+28]
    784              hnucleo_Adc.Init.ChannelsBank           = ADC_CHANNELS_BANK_A;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x....             LDR.N    R1,??DataTable14_11
   \   00000048   0x6208             STR      R0,[R1, #+32]
    785              hnucleo_Adc.Init.ContinuousConvMode     = DISABLE;                       /* Continuous mode disabled to have only 1 conversion at each conversion trig */
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR.N    R1,??DataTable14_11
   \   0000004E   0x6248             STR      R0,[R1, #+36]
    786              hnucleo_Adc.Init.NbrOfConversion        = 1;                             /* Parameter discarded because sequencer is disabled */
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable14_11
   \   00000054   0x6288             STR      R0,[R1, #+40]
    787              hnucleo_Adc.Init.DiscontinuousConvMode  = DISABLE;                       /* Parameter discarded because sequencer is disabled */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x....             LDR.N    R1,??DataTable14_11
   \   0000005A   0x62C8             STR      R0,[R1, #+44]
    788              hnucleo_Adc.Init.NbrOfDiscConversion    = 1;                             /* Parameter discarded because sequencer is disabled */
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR.N    R1,??DataTable14_11
   \   00000060   0x6308             STR      R0,[R1, #+48]
    789              hnucleo_Adc.Init.ExternalTrigConv       = ADC_SOFTWARE_START;            /* Trig of conversion start done manually by software, without external event */
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0x....             LDR.N    R1,??DataTable14_11
   \   00000066   0x6348             STR      R0,[R1, #+52]
    790              hnucleo_Adc.Init.ExternalTrigConvEdge   = ADC_EXTERNALTRIGCONVEDGE_NONE; /* Parameter discarded because trig by software start */
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x....             LDR.N    R1,??DataTable14_11
   \   0000006C   0x6388             STR      R0,[R1, #+56]
    791              hnucleo_Adc.Init.DMAContinuousRequests  = DISABLE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x....             LDR.N    R1,??DataTable14_11
   \   00000072   0x63C8             STR      R0,[R1, #+60]
    792              
    793              /* Initialize MSP related to ADC */
    794              ADCx_MspInit(&hnucleo_Adc);
   \   00000074   0x....             LDR.N    R0,??DataTable14_11
   \   00000076   0x.... 0x....      BL       ADCx_MspInit
    795              
    796              /* Initialize ADC */
    797              if (HAL_ADC_Init(&hnucleo_Adc) != HAL_OK)
   \   0000007A   0x....             LDR.N    R0,??DataTable14_11
   \   0000007C   0x.... 0x....      BL       HAL_ADC_Init
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??ADCx_Init_0
    798              {
    799                return HAL_ERROR;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xE000             B.N      ??ADCx_Init_1
    800              }
    801            }
    802          
    803            return HAL_OK;
   \                     ??ADCx_Init_0: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??ADCx_Init_1: (+1)
   \   0000008A   0xBD02             POP      {R1,PC}          ;; return
    804          }  
    805          
    806          /**
    807            * @brief  Initializes ADC HAL.
    808            * @param  None
    809            * @retval None
    810            */

   \                                 In section .text, align 2, keep-with-next
    811          static void ADCx_DeInit(void)
    812          {
   \                     ADCx_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    813              hnucleo_Adc.Instance   = NUCLEO_ADCx;
   \   00000002   0x....             LDR.N    R0,??DataTable14_10  ;; 0x40012400
   \   00000004   0x....             LDR.N    R1,??DataTable14_11
   \   00000006   0x6008             STR      R0,[R1, #+0]
    814              
    815              HAL_ADC_DeInit(&hnucleo_Adc);
   \   00000008   0x....             LDR.N    R0,??DataTable14_11
   \   0000000A   0x.... 0x....      BL       HAL_ADC_DeInit
    816              ADCx_MspDeInit(&hnucleo_Adc);
   \   0000000E   0x....             LDR.N    R0,??DataTable14_11
   \   00000010   0x.... 0x....      BL       ADCx_MspDeInit
    817          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    818          
    819          /******************************* LINK JOYSTICK ********************************/
    820          
    821          /**
    822            * @brief  Configures joystick available on adafruit 1.8" TFT shield 
    823            *         managed through ADC to detect motion.
    824            * @retval Joystickstatus (0=> success, 1=> fail) 
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          uint8_t BSP_JOY_Init(void)
    827          {
   \                     BSP_JOY_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    828            if (ADCx_Init() != HAL_OK)
   \   00000002   0x.... 0x....      BL       ADCx_Init
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??BSP_JOY_Init_0
    829            {
    830              return (uint8_t) HAL_ERROR; 
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE00C             B.N      ??BSP_JOY_Init_1
    831            }
    832             
    833            /* Select Channel 8 to be converted */
    834            sConfig.Channel       = ADC_CHANNEL_8;    
   \                     ??BSP_JOY_Init_0: (+1)
   \   0000000E   0x2008             MOVS     R0,#+8
   \   00000010   0x....             LDR.N    R1,??DataTable14_12
   \   00000012   0x6008             STR      R0,[R1, #+0]
    835            sConfig.SamplingTime  = ADC_SAMPLETIME_16CYCLES;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x....             LDR.N    R1,??DataTable14_12
   \   00000018   0x6088             STR      R0,[R1, #+8]
    836            sConfig.Rank          = ADC_REGULAR_RANK_1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable14_12
   \   0000001E   0x6048             STR      R0,[R1, #+4]
    837            
    838            /* Return Joystick initialization status */
    839            return (uint8_t)HAL_ADC_ConfigChannel(&hnucleo_Adc, &sConfig);
   \   00000020   0x....             LDR.N    R1,??DataTable14_12
   \   00000022   0x....             LDR.N    R0,??DataTable14_11
   \   00000024   0x.... 0x....      BL       HAL_ADC_ConfigChannel
   \                     ??BSP_JOY_Init_1: (+1)
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    840          }
    841          
    842          /**
    843            * @brief  DeInit joystick GPIOs.
    844            * @note   JOY DeInit does not disable the Mfx, just set the Mfx pins in Off mode
    845            * @retval None.
    846            */

   \                                 In section .text, align 2, keep-with-next
    847          void BSP_JOY_DeInit(void)
    848          {
   \                     BSP_JOY_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    849              ADCx_DeInit();
   \   00000002   0x.... 0x....      BL       ADCx_DeInit
    850          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    851          
    852          /**
    853            * @brief  Returns the Joystick key pressed.
    854            * @note   To know which Joystick key is pressed we need to detect the voltage
    855            *         level on each key output
    856            *           - None  : 3.3 V / 4095
    857            *           - SEL   : 1.055 V / 1308
    858            *           - DOWN  : 0.71 V / 88
    859            *           - LEFT  : 3.0 V / 3720 
    860            *           - RIGHT : 0.595 V / 737
    861            *           - UP    : 1.65 V / 2046
    862            * @retval JOYState_TypeDef: Code of the Joystick key pressed.
    863            */

   \                                 In section .text, align 2, keep-with-next
    864          JOYState_TypeDef BSP_JOY_GetState(void)
    865          {
   \                     BSP_JOY_GetState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    866            JOYState_TypeDef state = JOY_NONE;
   \   00000002   0x2400             MOVS     R4,#+0
    867            uint16_t  keyconvertedvalue = 0; 
   \   00000004   0x2500             MOVS     R5,#+0
    868          
    869           /* Start the conversion process */
    870            HAL_ADC_Start(&hnucleo_Adc);
   \   00000006   0x....             LDR.N    R0,??DataTable14_11
   \   00000008   0x.... 0x....      BL       HAL_ADC_Start
    871              
    872            /* Wait for the end of conversion */
    873            if (HAL_ADC_PollForConversion(&hnucleo_Adc, 10) != HAL_TIMEOUT)
   \   0000000C   0x210A             MOVS     R1,#+10
   \   0000000E   0x....             LDR.N    R0,??DataTable14_11
   \   00000010   0x.... 0x....      BL       HAL_ADC_PollForConversion
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD003             BEQ.N    ??BSP_JOY_GetState_0
    874            {
    875              /* Get the converted value of regular channel */
    876              keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);
   \   00000018   0x....             LDR.N    R0,??DataTable14_11
   \   0000001A   0x.... 0x....      BL       HAL_ADC_GetValue
   \   0000001E   0x0005             MOVS     R5,R0
    877            }
    878            
    879            if((keyconvertedvalue > 2010) && (keyconvertedvalue < 2090))
   \                     ??BSP_JOY_GetState_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF240 0x70DB      MOVW     R0,#+2011
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xDB07             BLT.N    ??BSP_JOY_GetState_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF640 0x002A      MOVW     R0,#+2090
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xDA02             BGE.N    ??BSP_JOY_GetState_1
    880            {
    881              state = JOY_UP;
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0x0004             MOVS     R4,R0
   \   00000038   0xE02D             B.N      ??BSP_JOY_GetState_2
    882            }
    883            else if((keyconvertedvalue > 680) && (keyconvertedvalue < 780))
   \                     ??BSP_JOY_GetState_1: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0xF5B5 0x7F2A      CMP      R5,#+680
   \   00000040   0xDD06             BLE.N    ??BSP_JOY_GetState_3
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF5B5 0x7F43      CMP      R5,#+780
   \   00000048   0xDA02             BGE.N    ??BSP_JOY_GetState_3
    884            {
    885              state = JOY_RIGHT;
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x0004             MOVS     R4,R0
   \   0000004E   0xE022             B.N      ??BSP_JOY_GetState_2
    886            }
    887            else if((keyconvertedvalue > 1270) && (keyconvertedvalue < 1350))
   \                     ??BSP_JOY_GetState_3: (+1)
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0xF240 0x40F7      MOVW     R0,#+1271
   \   00000056   0x4285             CMP      R5,R0
   \   00000058   0xDB07             BLT.N    ??BSP_JOY_GetState_4
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0xF240 0x5046      MOVW     R0,#+1350
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xDA02             BGE.N    ??BSP_JOY_GetState_4
    888            {
    889              state = JOY_SEL;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x0004             MOVS     R4,R0
   \   00000068   0xE015             B.N      ??BSP_JOY_GetState_2
    890            }
    891            else if((keyconvertedvalue > 50) && (keyconvertedvalue < 130))
   \                     ??BSP_JOY_GetState_4: (+1)
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0x2D33             CMP      R5,#+51
   \   0000006E   0xDB05             BLT.N    ??BSP_JOY_GetState_5
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x2D82             CMP      R5,#+130
   \   00000074   0xDA02             BGE.N    ??BSP_JOY_GetState_5
    892            {
    893              state = JOY_DOWN;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x0004             MOVS     R4,R0
   \   0000007A   0xE00C             B.N      ??BSP_JOY_GetState_2
    894            }
    895            else if((keyconvertedvalue > 3680) && (keyconvertedvalue < 3760))
   \                     ??BSP_JOY_GetState_5: (+1)
   \   0000007C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007E   0xF5B5 0x6F66      CMP      R5,#+3680
   \   00000082   0xDD06             BLE.N    ??BSP_JOY_GetState_6
   \   00000084   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000086   0xF5B5 0x6F6B      CMP      R5,#+3760
   \   0000008A   0xDA02             BGE.N    ??BSP_JOY_GetState_6
    896            {
    897              state = JOY_LEFT;
   \   0000008C   0x2003             MOVS     R0,#+3
   \   0000008E   0x0004             MOVS     R4,R0
   \   00000090   0xE001             B.N      ??BSP_JOY_GetState_2
    898            }
    899            else
    900            {
    901              state = JOY_NONE;
   \                     ??BSP_JOY_GetState_6: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0004             MOVS     R4,R0
    902            }
    903            
    904            /* Return the code of the Joystick key pressed*/
    905            return state;
   \                     ??BSP_JOY_GetState_2: (+1)
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    906          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x01010000         DC32     0x1010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     LED_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     LED_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     BUTTON_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     BUTTON_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x10210000         DC32     0x10210000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     BUTTON_IRQn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     hnucleo_Adc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     sConfig

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    907          #endif /* HAL_ADC_MODULE_ENABLED */
    908          
    909          /**
    910            * @}
    911            */
    912            
    913          /**
    914            * @}
    915            */    
    916          
    917          /**
    918            * @}
    919            */ 
    920              
    921          /**
    922            * @}
    923            */ 
    924              
    925          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ADCx_DeInit
         8   -> ADCx_MspDeInit
         8   -> HAL_ADC_DeInit
       8   ADCx_Init
         8   -> ADCx_MspInit
         8   -> HAL_ADC_GetState
         8   -> HAL_ADC_Init
      32   ADCx_MspDeInit
        32   -> HAL_GPIO_DeInit
      32   ADCx_MspInit
        32   -> HAL_GPIO_Init
        32   -> __aeabi_memclr4
       0   BSP_GetVersion
       8   BSP_JOY_DeInit
         8   -> ADCx_DeInit
      16   BSP_JOY_GetState
        16   -> HAL_ADC_GetValue
        16   -> HAL_ADC_PollForConversion
        16   -> HAL_ADC_Start
       8   BSP_JOY_Init
         8   -> ADCx_Init
         8   -> HAL_ADC_ConfigChannel
      32   BSP_LED_DeInit
        32   -> HAL_GPIO_DeInit
        32   -> HAL_GPIO_WritePin
      32   BSP_LED_Init
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_WritePin
       8   BSP_LED_Off
         8   -> HAL_GPIO_WritePin
       8   BSP_LED_On
         8   -> HAL_GPIO_WritePin
       8   BSP_LED_Toggle
         8   -> HAL_GPIO_TogglePin
      32   BSP_PB_DeInit
        32   -> HAL_GPIO_DeInit
        32   -> HAL_NVIC_DisableIRQ
       8   BSP_PB_GetState
         8   -> HAL_GPIO_ReadPin
      40   BSP_PB_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      20  ?_0
      22  ADCx_DeInit
     140  ADCx_Init
      34  ADCx_MspDeInit
      86  ADCx_MspInit
       6  BSP_GetVersion
       8  BSP_JOY_DeInit
     156  BSP_JOY_GetState
      42  BSP_JOY_Init
      60  BSP_LED_DeInit
     112  BSP_LED_Init
      28  BSP_LED_Off
      28  BSP_LED_On
      26  BSP_LED_Toggle
      46  BSP_PB_DeInit
      26  BSP_PB_GetState
     136  BSP_PB_Init
       1  BUTTON_IRQn
       2  BUTTON_PIN
       4  BUTTON_PORT
       2  LED_PIN
       4  LED_PORT
      84  hnucleo_Adc
      12  sConfig

 
    96 bytes in section .bss
     8 bytes in section .data
    25 bytes in section .rodata
 1 008 bytes in section .text
 
 1 008 bytes of CODE  memory
    25 bytes of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: none
