###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.2.11341/W32 for ARM       29/Jan/2018  07:39:40
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
#    Command line =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
#        -D USE_HAL_DRIVER -D STM32L152xE -D USE_STM32L1XX_NUCLEO -D ASCII -D
#        REV_L -D LONG_DELAY -D XML_SHRT -lCN
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List" -o
#        "D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/BSP/STM32L1xx_Nucleo\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM/../Drivers/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\..\Middlewares\Third_Party\BgLib\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\List\usart.lst
#    Object file  =  
#        D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\EWARM\RdBrd
#        XMLShrt Long Always\Obj\usart.o
#
###############################################################################

D:\GoogleDriveCLT\GoogleDrive\WeatherCloud\Roadboard\Software\Road-Board-December-2016N8\Src\usart.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : USART.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the USART instances.
      6            ******************************************************************************
      7            *
      8            * COPYRIGHT(c) 2016 STMicroelectronics
      9            *
     10            * Redistribution and use in source and binary forms, with or without modification,
     11            * are permitted provided that the following conditions are met:
     12            *   1. Redistributions of source code must retain the above copyright notice,
     13            *      this list of conditions and the following disclaimer.
     14            *   2. Redistributions in binary form must reproduce the above copyright notice,
     15            *      this list of conditions and the following disclaimer in the documentation
     16            *      and/or other materials provided with the distribution.
     17            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     18            *      may be used to endorse or promote products derived from this software
     19            *      without specific prior written permission.
     20            *
     21            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     22            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     25            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     27            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     28            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     29            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     30            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "usart.h"
     37          #include <string.h>
     38          #include "parser.h"
     39          
     40          #include "gpio.h"
     41          
     42          /* USER CODE BEGIN 0 */
     43          /* Buffer used for transmission */

   \                                 In section .bss, align 4
     44          uint8_t aTxBuffer[TXBUFFERSIZE];
   \                     aTxBuffer:
   \   00000000                      DS8 132
     45          
     46          /* Buffer used for reception */

   \                                 In section .bss, align 4
     47          uint8_t aRxBuffer[RXBUFFERSIZE];
   \                     aRxBuffer:
   \   00000000                      DS8 132
     48          

   \                                 In section .bss, align 1
     49          __IO ITStatus Uart2Ready = RESET;
   \                     Uart2Ready:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     50          __IO ITStatus Uart3Ready = RESET;
   \                     Uart3Ready:
   \   00000000                      DS8 1
     51          

   \                                 In section .bss, align 4
     52          static uint8_t          *save_Ptr;
   \                     save_Ptr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     53          static uint16_t         Save_Size;
   \                     Save_Size:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     54          static uint16_t         tmpSize;
   \                     tmpSize:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     55          static uint8_t          *tmpPdata;
   \                     tmpPdata:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     56          static uint8_t          tmpData[2];
   \                     tmpData:
   \   00000000                      DS8 2
     57          /* USER CODE END 0 */
     58          

   \                                 In section .bss, align 4
     59          UART_HandleTypeDef huart2;
   \                     huart2:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     60          UART_HandleTypeDef huart3;
   \                     huart3:
   \   00000000                      DS8 64
     61          
     62          #ifndef PATCH_UART

   \                                 In section .bss, align 4
     63            static uint8_t bgm1data[40];
   \                     bgm1data:
   \   00000000                      DS8 40

   \                                 In section .bss, align 1
     64            static bool bffr1Flag = false;
   \                     bffr1Flag:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
     65            static int saveLen = 3;
   \                     saveLen:
   \   00000000   0x00000003         DC32 3
     66          #endif
     67          
     68          /* USART2 init function */
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void MX_USART2_UART_Init(void)
     71          {
   \                     MX_USART2_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     72          
     73            huart2.Instance = USART2;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40004400
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     74            huart2.Init.BaudRate = 19200;  // 9600Baud
   \   0000000C   0xF44F 0x4096      MOV      R0,#+19200
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000014   0x6048             STR      R0,[R1, #+4]
     75            huart2.Init.WordLength = UART_WORDLENGTH_8B;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     76            huart2.Init.StopBits = UART_STOPBITS_1;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     77            huart2.Init.Parity = UART_PARITY_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000002C   0x6108             STR      R0,[R1, #+16]
     78            huart2.Init.Mode = UART_MODE_TX_RX;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000034   0x6148             STR      R0,[R1, #+20]
     79            huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000003C   0x6188             STR      R0,[R1, #+24]
     80            huart2.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000044   0x61C8             STR      R0,[R1, #+28]
     81            if (HAL_UART_Init(&huart2) != HAL_OK)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000004A   0x.... 0x....      BL       HAL_UART_Init
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??MX_USART2_UART_Init_0
     82            {
     83              Error_Handler();
   \   00000052   0x.... 0x....      BL       Error_Handler
     84            }
     85          
     86          }
   \                     ??MX_USART2_UART_Init_0: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
     87          /* USART3 init function */
     88          

   \                                 In section .text, align 2, keep-with-next
     89          void MX_USART3_UART_Init(void)
     90          {
   \                     MX_USART3_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     91          
     92            huart3.Instance = USART3;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40004800
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     93            huart3.Init.BaudRate = 115200;  // 9600Baud
   \   0000000C   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000014   0x6048             STR      R0,[R1, #+4]
     94            huart3.Init.WordLength = UART_WORDLENGTH_8B;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000001C   0x6088             STR      R0,[R1, #+8]
     95            huart3.Init.StopBits = UART_STOPBITS_1;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000024   0x60C8             STR      R0,[R1, #+12]
     96            huart3.Init.Parity = UART_PARITY_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000002C   0x6108             STR      R0,[R1, #+16]
     97            huart3.Init.Mode = UART_MODE_TX_RX;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000034   0x6148             STR      R0,[R1, #+20]
     98          #ifdef TEST2
     99            huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    100          #else
    101            #ifdef PATCH_UART
    102              huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    103            #else
    104              huart3.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
   \   00000036   0xF44F 0x7040      MOV      R0,#+768
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000003E   0x6188             STR      R0,[R1, #+24]
    105            #endif
    106          //  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    107          #endif
    108            huart3.Init.OverSampling = UART_OVERSAMPLING_16;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000046   0x61C8             STR      R0,[R1, #+28]
    109            if (HAL_UART_Init(&huart3) != HAL_OK)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000004C   0x.... 0x....      BL       HAL_UART_Init
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD001             BEQ.N    ??MX_USART3_UART_Init_0
    110            {
    111              Error_Handler();
   \   00000054   0x.... 0x....      BL       Error_Handler
    112            }
    113          
    114          }
   \                     ??MX_USART3_UART_Init_0: (+1)
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
    117          {
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    118          
    119            GPIO_InitTypeDef GPIO_InitStruct;
    120            if(uartHandle->Instance==USART2)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40004400
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD11E             BNE.N    ??HAL_UART_MspInit_0
    121            {
    122            /* USER CODE BEGIN USART2_MspInit 0 */
    123          
    124            /* USER CODE END USART2_MspInit 0 */
    125              /* Peripheral clock enable */
    126              __HAL_RCC_USART2_CLK_ENABLE();
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF410 0x3000      ANDS     R0,R0,#0x20000
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
    127            
    128              /**USART2 GPIO Configuration    
    129              PA2     ------> USART2_TX
    130              PA3     ------> USART2_RX 
    131              */
    132              GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
   \   0000002E   0x200C             MOVS     R0,#+12
   \   00000030   0x9001             STR      R0,[SP, #+4]
    133              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
    134              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9003             STR      R0,[SP, #+12]
    135              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    136              GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
   \   0000003E   0x2007             MOVS     R0,#+7
   \   00000040   0x9005             STR      R0,[SP, #+20]
    137              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40020000
   \   00000048   0x.... 0x....      BL       HAL_GPIO_Init
   \   0000004C   0xE033             B.N      ??HAL_UART_MspInit_1
    138          
    139            /* USER CODE BEGIN USART2_MspInit 1 */
    140          
    141            /* USER CODE END USART2_MspInit 1 */
    142            }
    143            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40004800
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD12E             BNE.N    ??HAL_UART_MspInit_1
    144            {
    145            /* USER CODE BEGIN USART3_MspInit 0 */
    146          
    147            /* USER CODE END USART3_MspInit 0 */
    148              /* Peripheral clock enable */
    149              __HAL_RCC_USART3_CLK_ENABLE();
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF410 0x2080      ANDS     R0,R0,#0x40000
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x9800             LDR      R0,[SP, #+0]
    150            
    151              /**USART3 GPIO Configuration    
    152              PB10     ------> USART3_TX
    153              PB11     ------> USART3_RX
    154              PB13     ------> USART3_CTS
    155              PB14     ------> USART3_RTS 
    156              */
    157              GPIO_InitStruct.Pin = TX_BGM111_Pin|RX_BGM111_Pin;
   \   00000076   0xF44F 0x6040      MOV      R0,#+3072
   \   0000007A   0x9001             STR      R0,[SP, #+4]
    158              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x9002             STR      R0,[SP, #+8]
    159              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x9003             STR      R0,[SP, #+12]
    160              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x9004             STR      R0,[SP, #+16]
    161              GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
   \   00000088   0x2007             MOVS     R0,#+7
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    162              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   00000092   0x.... 0x....      BL       HAL_GPIO_Init
    163          
    164              GPIO_InitStruct.Pin = CTS_BGM111_Pin|RTS_BGM111_Pin;
   \   00000096   0xF44F 0x40C0      MOV      R0,#+24576
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    165              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    166              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9003             STR      R0,[SP, #+12]
    167              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x9004             STR      R0,[SP, #+16]
    168              GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
   \   000000A8   0x2007             MOVS     R0,#+7
   \   000000AA   0x9005             STR      R0,[SP, #+20]
    169              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_Init
    170          
    171            /* USER CODE BEGIN USART3_MspInit 1 */
    172          
    173            /* USER CODE END USART3_MspInit 1 */
    174            }
    175          }
   \                     ??HAL_UART_MspInit_1: (+1)
   \   000000B6   0xB006             ADD      SP,SP,#+24
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
    178          {
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    179          
    180            if(uartHandle->Instance==USART2)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x40004400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD10D             BNE.N    ??HAL_UART_MspDeInit_0
    181            {
    182            /* USER CODE BEGIN USART2_MspDeInit 0 */
    183          
    184            /* USER CODE END USART2_MspDeInit 0 */
    185              /* Peripheral clock disable */
    186              __HAL_RCC_USART2_CLK_DISABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    187            
    188              /**USART2 GPIO Configuration    
    189              PA2     ------> USART2_TX
    190              PA3     ------> USART2_RX 
    191              */
    192              HAL_GPIO_DeInit(GPIOA, USART_TX_Pin|USART_RX_Pin);
   \   0000001E   0x210C             MOVS     R1,#+12
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40020000
   \   00000024   0x.... 0x....      BL       HAL_GPIO_DeInit
   \   00000028   0xE012             B.N      ??HAL_UART_MspDeInit_1
    193          
    194            /* USER CODE BEGIN USART2_MspDeInit 1 */
    195          
    196            /* USER CODE END USART2_MspDeInit 1 */
    197            }
    198            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_MspDeInit_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40004800
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD10D             BNE.N    ??HAL_UART_MspDeInit_1
    199            {
    200            /* USER CODE BEGIN USART3_MspDeInit 0 */
    201          
    202            /* USER CODE END USART3_MspDeInit 0 */
    203              /* Peripheral clock disable */
    204              __HAL_RCC_USART3_CLK_DISABLE();
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40023824
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40023824
   \   00000042   0x6008             STR      R0,[R1, #+0]
    205            
    206              /**USART3 GPIO Configuration    
    207              PB10     ------> USART3_TX
    208              PB11     ------> USART3_RX
    209              PB13     ------> USART3_CTS
    210              PB14     ------> USART3_RTS 
    211              */
    212              HAL_GPIO_DeInit(GPIOB, TX_BGM111_Pin|RX_BGM111_Pin|CTS_BGM111_Pin|RTS_BGM111_Pin);
   \   00000044   0xF44F 0x41D8      MOV      R1,#+27648
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40020400
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_DeInit
    213          
    214            /* USER CODE BEGIN USART3_MspDeInit 1 */
    215          
    216            /* USER CODE END USART3_MspDeInit 1 */
    217            }
    218          } 
   \                     ??HAL_UART_MspDeInit_1: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    219          
    220          /* USER CODE BEGIN 1 */
    221          /**
    222            * @brief  RoadBrd_UART_Transmit
    223            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    224            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel
    225            *         in a blocking mode. 
    226            *         It does wait for completion.
    227            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    228            *                                HAL_ERROR:    Error found in Tasking or data passed.
    229            *                                HAL_BUSY:     UART is busy.
    230            *                                HAL_TIMEOUT:  UART timed out.
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          HAL_StatusTypeDef RoadBrd_UART_Transmit(RoadBrd_uart_TypeDef Port, uint8_t *pData)
    233          {
   \                     RoadBrd_UART_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    234            HAL_StatusTypeDef Status;
    235            uint16_t Size;
    236            
    237            Size = strlen((char *)pData);  
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0007             MOVS     R7,R0
    238            // Test parameters before starting process
    239            if (Size > TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F83             CMP      R7,#+131
   \   00000012   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_0
    240              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE03A             B.N      ??RoadBrd_UART_Transmit_1
    241            
    242            // Test Port to determine which uart to use for this transfer.
    243            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD119             BNE.N    ??RoadBrd_UART_Transmit_2
    244            {
    245              // Is UART Busy right now?
    246              if (Uart2Ready != RESET)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_3
    247                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE030             B.N      ??RoadBrd_UART_Transmit_1
    248              else
    249              {
    250                Status = HAL_UART_Transmit(&huart2, (uint8_t*)pData, Size, HAL_MAX_DELAY);
   \                     ??RoadBrd_UART_Transmit_3: (+1)
   \   0000002C   0xF44F 0x4300      MOV      R3,#+32768
   \   00000030   0x003A             MOVS     R2,R7
   \   00000032   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000003A   0x.... 0x....      BL       HAL_UART_Transmit
   \   0000003E   0x0006             MOVS     R6,R0
    251                if(Status != HAL_OK)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_4
    252                {
    253                  return Status;
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xE020             B.N      ??RoadBrd_UART_Transmit_1
    254                }
    255                else
    256                {
    257                   return Status;
   \                     ??RoadBrd_UART_Transmit_4: (+1)
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE01D             B.N      ??RoadBrd_UART_Transmit_1
    258                }
    259              }
    260            }
    261            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_2: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C01             CMP      R4,#+1
   \   00000056   0xD119             BNE.N    ??RoadBrd_UART_Transmit_5
    262            {
    263              // Is UART Busy right now?
    264              if (Uart3Ready != RESET)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_6
    265                return HAL_BUSY;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xE013             B.N      ??RoadBrd_UART_Transmit_1
    266              else
    267              {
    268                Status = HAL_UART_Transmit(&huart3, (uint8_t*)pData, Size, HAL_MAX_DELAY);
   \                     ??RoadBrd_UART_Transmit_6: (+1)
   \   00000066   0xF44F 0x4300      MOV      R3,#+32768
   \   0000006A   0x003A             MOVS     R2,R7
   \   0000006C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000074   0x.... 0x....      BL       HAL_UART_Transmit
   \   00000078   0x0006             MOVS     R6,R0
    269                if(Status != HAL_OK)
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_7
    270                {
    271                  return Status;
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xE003             B.N      ??RoadBrd_UART_Transmit_1
    272                }
    273                else
    274                {
    275                   return Status;
   \                     ??RoadBrd_UART_Transmit_7: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xE000             B.N      ??RoadBrd_UART_Transmit_1
    276                }
    277              }
    278            }
    279            else 
    280              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_5: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_1: (+1)
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    281          }
    282          
    283          /**
    284            * @brief  RoadBrd_UART_Transmit_ITSZ
    285            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    286            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel. 
    287            *         It does not wait for completion and must be tested for completion.
    288            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    289            *                                HAL_ERROR:    Error found in Tasking or data passed.
    290            *                                HAL_BUSY:     UART is busy.
    291            *                                HAL_TIMEOUT:  UART timed out.
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          HAL_StatusTypeDef RoadBrd_UART_Transmit_ITSZ(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    294          {
   \                     RoadBrd_UART_Transmit_ITSZ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    295            HAL_StatusTypeDef Status;
    296            
    297            //Size = strlen((char *)pData);  
    298            // Test parameters before starting process
    299            if (Size > TXBUFFERSIZE)
   \   00000008   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000A   0x2E83             CMP      R6,#+131
   \   0000000C   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_ITSZ_0
    300              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE036             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    301            
    302            // Test Port to determine which uart to use for this transfer.
    303            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_ITSZ_0: (+1)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD117             BNE.N    ??RoadBrd_UART_Transmit_ITSZ_2
    304            {
    305              // Is UART Busy right now?
    306              if (Uart2Ready != RESET)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_3
    307                return HAL_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE02C             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    308              else
    309              {
    310                Status = HAL_UART_Transmit_IT(&huart2, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_ITSZ_3: (+1)
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000030   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   00000034   0x0007             MOVS     R7,R0
    311                if(Status != HAL_OK)
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_4
    312                {
    313                  return Status;
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE01E             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    314                }
    315                else
    316                {
    317                   return Status;
   \                     ??RoadBrd_UART_Transmit_ITSZ_4: (+1)
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01B             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    318                }
    319              }
    320            }
    321            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_ITSZ_2: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD117             BNE.N    ??RoadBrd_UART_Transmit_ITSZ_5
    322            {
    323              // Is UART Busy right now?
    324              if (Uart3Ready != RESET)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_6
    325                return HAL_BUSY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xE011             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    326              else
    327              {
    328                Status = HAL_UART_Transmit_IT(&huart3, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_ITSZ_6: (+1)
   \   0000005C   0x0032             MOVS     R2,R6
   \   0000005E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000066   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   0000006A   0x0007             MOVS     R7,R0
    329                if(Status != HAL_OK)
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_ITSZ_7
    330                {
    331                  return Status;
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xE003             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    332                }
    333                else
    334                {
    335                   return Status;
   \                     ??RoadBrd_UART_Transmit_ITSZ_7: (+1)
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xE000             B.N      ??RoadBrd_UART_Transmit_ITSZ_1
    336                }
    337              }
    338            }
    339            else 
    340              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_ITSZ_5: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_ITSZ_1: (+1)
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    341          }
    342          
    343          /**
    344            * @brief  RoadBrd_UART_Transmit_IT
    345            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit. 
    346            * @note   This routine uses the HAL USART routines to send the reqiuested buffer to the requested channel. 
    347            *         It does not wait for completion and must be tested for completion.
    348            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    349            *                                HAL_ERROR:    Error found in Tasking or data passed.
    350            *                                HAL_BUSY:     UART is busy.
    351            *                                HAL_TIMEOUT:  UART timed out.
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          HAL_StatusTypeDef RoadBrd_UART_Transmit_IT(RoadBrd_uart_TypeDef Port, uint8_t *pData)
    354          {
   \                     RoadBrd_UART_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    355            HAL_StatusTypeDef Status;
    356            uint16_t Size;
    357            
    358            Size = strlen((char *)pData);  
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0007             MOVS     R7,R0
    359            // Test parameters before starting process
    360            if (Size > TXBUFFERSIZE)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F83             CMP      R7,#+131
   \   00000012   0xDB01             BLT.N    ??RoadBrd_UART_Transmit_IT_0
    361              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE036             B.N      ??RoadBrd_UART_Transmit_IT_1
    362            
    363            // Test Port to determine which uart to use for this transfer.
    364            if (Port == USART_2)
   \                     ??RoadBrd_UART_Transmit_IT_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD117             BNE.N    ??RoadBrd_UART_Transmit_IT_2
    365            {
    366              // Is UART Busy right now?
    367              if (Uart2Ready != RESET)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_IT_3
    368                return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE02C             B.N      ??RoadBrd_UART_Transmit_IT_1
    369              else
    370              {
    371                Status = HAL_UART_Transmit_IT(&huart2, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_IT_3: (+1)
   \   0000002C   0x003A             MOVS     R2,R7
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000036   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   0000003A   0x0006             MOVS     R6,R0
    372                if(Status != HAL_OK)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_IT_4
    373                {
    374                  return Status;
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01E             B.N      ??RoadBrd_UART_Transmit_IT_1
    375                }
    376                else
    377                {
    378                   return Status;
   \                     ??RoadBrd_UART_Transmit_IT_4: (+1)
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xE01B             B.N      ??RoadBrd_UART_Transmit_IT_1
    379                }
    380              }
    381            }
    382            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Transmit_IT_2: (+1)
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x2C01             CMP      R4,#+1
   \   00000052   0xD117             BNE.N    ??RoadBrd_UART_Transmit_IT_5
    383            {
    384              // Is UART Busy right now?
    385              if (Uart3Ready != RESET)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??RoadBrd_UART_Transmit_IT_6
    386                return HAL_BUSY;
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0xE011             B.N      ??RoadBrd_UART_Transmit_IT_1
    387              else
    388              {
    389                Status = HAL_UART_Transmit_IT(&huart3, (uint8_t*)pData, Size);
   \                     ??RoadBrd_UART_Transmit_IT_6: (+1)
   \   00000062   0x003A             MOVS     R2,R7
   \   00000064   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000006C   0x.... 0x....      BL       HAL_UART_Transmit_IT
   \   00000070   0x0006             MOVS     R6,R0
    390                if(Status != HAL_OK)
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD002             BEQ.N    ??RoadBrd_UART_Transmit_IT_7
    391                {
    392                  return Status;
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xE003             B.N      ??RoadBrd_UART_Transmit_IT_1
    393                }
    394                else
    395                {
    396                   return Status;
   \                     ??RoadBrd_UART_Transmit_IT_7: (+1)
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE000             B.N      ??RoadBrd_UART_Transmit_IT_1
    397                }
    398              }
    399            }
    400            else 
    401              return HAL_ERROR;
   \                     ??RoadBrd_UART_Transmit_IT_5: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Transmit_IT_1: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    402          }
    403          
    404          #ifndef PATCH_UART
    405          /**
    406            * @brief  RoadBrd_UART_Receive_ITBG
    407            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint16_t Size: Number of  bytes to wait for completion. 
    408            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    409            *         It does not wait for completion and must be tested for completion.
    410            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    411            *                                HAL_ERROR:    Error found in Tasking or data passed.
    412            *                                HAL_BUSY:     UART is busy.
    413            *                                HAL_TIMEOUT:  UART timed out.
    414            */

   \                                 In section .text, align 2, keep-with-next
    415          HAL_StatusTypeDef RoadBrd_UART_Receive_ITBG(RoadBrd_uart_TypeDef Port, uint16_t Size)
    416          {
   \                     RoadBrd_UART_Receive_ITBG: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    417            HAL_StatusTypeDef Status;
    418            
    419            // Test parameters before starting process
    420            if (Size > RXBUFFERSIZE)
   \   00000006   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000008   0x2D83             CMP      R5,#+131
   \   0000000A   0xDB01             BLT.N    ??RoadBrd_UART_Receive_ITBG_0
    421              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE038             B.N      ??RoadBrd_UART_Receive_ITBG_1
    422            
    423            // Test Port to determine which uart to use for this transfer.
    424            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_ITBG_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD118             BNE.N    ??RoadBrd_UART_Receive_ITBG_2
    425            {
    426              // Is UART Busy right now?
    427              if (Uart2Ready != RESET)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??RoadBrd_UART_Receive_ITBG_3
    428                return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE02E             B.N      ??RoadBrd_UART_Receive_ITBG_1
    429              else
    430              {
    431                Status = HAL_UART_Receive_IT(&huart2, (uint8_t*)bgm1data, Size);
   \                     ??RoadBrd_UART_Receive_ITBG_3: (+1)
   \   00000024   0x002A             MOVS     R2,R5
   \   00000026   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000030   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000034   0x0006             MOVS     R6,R0
    432                if(Status != HAL_OK)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD002             BEQ.N    ??RoadBrd_UART_Receive_ITBG_4
    433                {
    434                  return Status;
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE01F             B.N      ??RoadBrd_UART_Receive_ITBG_1
    435                }
    436                else
    437                {
    438                   return Status;
   \                     ??RoadBrd_UART_Receive_ITBG_4: (+1)
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01C             B.N      ??RoadBrd_UART_Receive_ITBG_1
    439                }
    440              }
    441            }
    442            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_ITBG_2: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD118             BNE.N    ??RoadBrd_UART_Receive_ITBG_5
    443            {
    444              // Is UART Busy right now?
    445              if (Uart3Ready != RESET)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??RoadBrd_UART_Receive_ITBG_6
    446                return HAL_BUSY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xE012             B.N      ??RoadBrd_UART_Receive_ITBG_1
    447              else
    448              {
    449                Status = HAL_UART_Receive_IT(&huart3, (uint8_t*)bgm1data, Size);
   \                     ??RoadBrd_UART_Receive_ITBG_6: (+1)
   \   0000005C   0x002A             MOVS     R2,R5
   \   0000005E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000068   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   0000006C   0x0006             MOVS     R6,R0
    450                if(Status != HAL_OK)
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD002             BEQ.N    ??RoadBrd_UART_Receive_ITBG_7
    451                {
    452                  return Status;
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xE003             B.N      ??RoadBrd_UART_Receive_ITBG_1
    453                }
    454                else
    455                {
    456                   return Status;
   \                     ??RoadBrd_UART_Receive_ITBG_7: (+1)
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xE000             B.N      ??RoadBrd_UART_Receive_ITBG_1
    457                }
    458              }
    459            }
    460            else 
    461              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_ITBG_5: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_ITBG_1: (+1)
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    462          }
    463          
    464          /**
    465            * @brief  Returns the pointer to the bgm1data buffer.
    466            * @param  None
    467            * @retval uint8_t*:     address of bgm1data buffer
    468            */

   \                                 In section .text, align 2, keep-with-next
    469          uint8_t *RoadBrd_GetBGPtr( void )
    470          {
    471            return &bgm1data[0];
   \                     RoadBrd_GetBGPtr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_9
   \   00000004   0x4770             BX       LR               ;; return
    472          }
    473          
    474          /**
    475            * @brief  Sets the Buffer Flag for BGM Traffic.
    476            * @param  None
    477            * @retval None.
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          void RoadBrd_SetBffrFlg( void )
    480          {
    481            bffr1Flag = true;
   \                     RoadBrd_SetBffrFlg: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    482          }
   \   00000008   0x4770             BX       LR               ;; return
    483          
    484          /**
    485            * @brief  Clears the Buffer Flag for BGM Traffic.
    486            * @param  None
    487            * @retval None.
    488            */

   \                                 In section .text, align 2, keep-with-next
    489          void RoadBrd_ClrBffrFlg( void )
    490          {
    491            bffr1Flag = false;
   \                     RoadBrd_ClrBffrFlg: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    492          }
   \   00000008   0x4770             BX       LR               ;; return
    493          
    494          /**
    495            * @brief  Returns the Buffer Flag for BGM Traffic.
    496            * @param  None
    497            * @retval uint8_t*:     address of bgm1data buffer
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          bool RoadBrd_GetBffrFlg( void )
    500          {
    501            return bffr1Flag;
   \                     RoadBrd_GetBffrFlg: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    502          }
    503          
    504          /**
    505            * @brief  Return saveLen Variable
    506            * @param  NONE. 
    507            * @note   This is needed to allow the next IT transfer to usart. 
    508          * @retval int: saveLen
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          int RoadBrd_getSaveLen( void )
    511          {
    512            return saveLen;
   \                     RoadBrd_getSaveLen: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    513          }
    514          #endif
    515          
    516          /**
    517            * @brief  RoadBrd_UART_Receive_IT
    518            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit, uint16_t Size: Number of  bytes to wait for completion. 
    519            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    520            *         It does not wait for completion and must be tested for completion.
    521            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    522            *                                HAL_ERROR:    Error found in Tasking or data passed.
    523            *                                HAL_BUSY:     UART is busy.
    524            *                                HAL_TIMEOUT:  UART timed out.
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          HAL_StatusTypeDef RoadBrd_UART_Receive_IT(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    527          {
   \                     RoadBrd_UART_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    528            HAL_StatusTypeDef Status;
    529            
    530            // Test parameters before starting process
    531            if (Size > RXBUFFERSIZE)
   \   00000008   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000A   0x2E83             CMP      R6,#+131
   \   0000000C   0xDB01             BLT.N    ??RoadBrd_UART_Receive_IT_0
    532              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE05A             B.N      ??RoadBrd_UART_Receive_IT_1
    533            
    534            // Test Port to determine which uart to use for this transfer.
    535            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_IT_0: (+1)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD129             BNE.N    ??RoadBrd_UART_Receive_IT_2
    536            {
    537              // Is UART Busy right now?
    538              if (Uart2Ready != RESET)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??RoadBrd_UART_Receive_IT_3
    539                return HAL_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE050             B.N      ??RoadBrd_UART_Receive_IT_1
    540              else
    541              {
    542                // Initialize all Key Vars from Passes Parameters
    543                save_Ptr = pData;
   \                     ??RoadBrd_UART_Receive_IT_3: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   0000002A   0x6005             STR      R5,[R0, #+0]
    544                Save_Size = Size;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000030   0x8006             STRH     R6,[R0, #+0]
    545                tmpSize = Save_Size;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000036   0x8800             LDRH     R0,[R0, #+0]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000003C   0x8008             STRH     R0,[R1, #+0]
    546                tmpPdata = save_Ptr;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   00000048   0x6008             STR      R0,[R1, #+0]
    547                
    548                // Task Usart for First Transfer.
    549                Status = HAL_UART_Receive_IT(&huart2, (uint8_t*)tmpData, 1);
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable20_16
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000054   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000058   0x0007             MOVS     R7,R0
    550                if(Status != HAL_OK)
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xD002             BEQ.N    ??RoadBrd_UART_Receive_IT_4
    551                {
    552                  return Status;
   \   00000060   0x0038             MOVS     R0,R7
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xE030             B.N      ??RoadBrd_UART_Receive_IT_1
    553                }
    554                else
    555                {
    556                   return Status;
   \                     ??RoadBrd_UART_Receive_IT_4: (+1)
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE02D             B.N      ??RoadBrd_UART_Receive_IT_1
    557                }
    558                /* OLD............................................
    559                Status = HAL_UART_Receive_IT(&huart2, (uint8_t*)pData, Size);
    560                if(Status != HAL_OK)
    561                {
    562                  return Status;
    563                }
    564                else
    565                {
    566                   return Status;
    567                }
    568                */
    569              }
    570            }
    571            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_IT_2: (+1)
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2C01             CMP      R4,#+1
   \   00000070   0xD129             BNE.N    ??RoadBrd_UART_Receive_IT_5
    572            {
    573              // Is UART Busy right now?
    574              if (Uart3Ready != RESET)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??RoadBrd_UART_Receive_IT_6
    575                return HAL_BUSY;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0xE023             B.N      ??RoadBrd_UART_Receive_IT_1
    576              else
    577              {
    578                // Initialize all Key Vars from Passes Parameters
    579                save_Ptr = pData;
   \                     ??RoadBrd_UART_Receive_IT_6: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000084   0x6005             STR      R5,[R0, #+0]
    580                Save_Size = Size;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   0000008A   0x8006             STRH     R6,[R0, #+0]
    581                tmpSize = Save_Size;
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000096   0x8008             STRH     R0,[R1, #+0]
    582                tmpPdata = save_Ptr;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    583                
    584                // Task Usart for First Transfer.
    585                Status = HAL_UART_Receive_IT(&huart3, (uint8_t*)tmpData, 1);
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable20_16
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   000000AE   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   000000B2   0x0007             MOVS     R7,R0
    586                if(Status != HAL_OK)
   \   000000B4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B6   0x2F00             CMP      R7,#+0
   \   000000B8   0xD002             BEQ.N    ??RoadBrd_UART_Receive_IT_7
    587                {
    588                  return Status;
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xE003             B.N      ??RoadBrd_UART_Receive_IT_1
    589                }
    590                else
    591                {
    592                   return Status;
   \                     ??RoadBrd_UART_Receive_IT_7: (+1)
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xE000             B.N      ??RoadBrd_UART_Receive_IT_1
    593                }
    594                /* OLD............................................
    595                Status = HAL_UART_Receive_IT(&huart3, (uint8_t*)pData, Size);
    596                if(Status != HAL_OK)
    597                {
    598                  return Status;
    599                }
    600                else
    601                {
    602                   return Status;
    603                }
    604              */
    605              }
    606            }
    607            else 
    608              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_IT_5: (+1)
   \   000000C6   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_IT_1: (+1)
   \   000000C8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    609          }
    610          
    611          /**
    612            * @brief  RoadBrd_UART_Receive
    613            * @param  RoadBrd_uart_TypeDef Port: USART Port, uint8_t *pData: Pointer to Data buffer to transmit, uint16_t Size: Number of  bytes to wait for completion. 
    614            * @note   This routine uses the HAL USART routines to receive the requested number of characters to the reqiuested buffer on the requested channel. 
    615            *         It DOES wait for completion OR a termination character of 0x0a or 0x0d.
    616            * @retval HAL_StatusTypeDef:     HAL_OK:       Tasking of block of data to UART success.
    617            *                                HAL_ERROR:    Error found in Tasking or data passed.
    618            *                                HAL_BUSY:     UART is busy.
    619            *                                HAL_TIMEOUT:  UART timed out.
    620            */

   \                                 In section .text, align 2, keep-with-next
    621          HAL_StatusTypeDef RoadBrd_UART_Receive(RoadBrd_uart_TypeDef Port, uint8_t *pData, uint16_t Size)
    622          {
   \                     RoadBrd_UART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    623            HAL_StatusTypeDef Status;
    624            uint16_t tmpSize;
    625            uint8_t tmpData[2];
    626            
    627            
    628            // Test parameters before starting process
    629            if (Size > RXBUFFERSIZE)
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0x2E83             CMP      R6,#+131
   \   00000010   0xDB01             BLT.N    ??RoadBrd_UART_Receive_0
    630              return HAL_ERROR;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE062             B.N      ??RoadBrd_UART_Receive_1
    631            
    632            // Test Port to determine which uart to use for this transfer.
    633            if (Port == USART_2)
   \                     ??RoadBrd_UART_Receive_0: (+1)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD12D             BNE.N    ??RoadBrd_UART_Receive_2
    634            {
    635              // Is UART Busy right now?
    636              if (Uart2Ready != RESET)
   \   0000001C   0x....             LDR.N    R0,??DataTable20_7
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??RoadBrd_UART_Receive_3
    637                return HAL_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE059             B.N      ??RoadBrd_UART_Receive_1
    638              else
    639              {
    640                tmpSize = Size;
   \                     ??RoadBrd_UART_Receive_3: (+1)
   \   00000028   0x46B0             MOV      R8,R6
    641                while ( tmpSize>0 )
   \                     ??RoadBrd_UART_Receive_4: (+1)
   \   0000002A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000002E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000032   0xD01E             BEQ.N    ??RoadBrd_UART_Receive_5
    642                {
    643                  Status = HAL_UART_Receive(&huart2, (uint8_t*)tmpData, 1, HAL_MAX_DELAY);
   \   00000034   0xF44F 0x4300      MOV      R3,#+32768
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x....             LDR.N    R0,??DataTable20_1
   \   0000003E   0x.... 0x....      BL       HAL_UART_Receive
   \   00000042   0x0007             MOVS     R7,R0
    644                  if(Status == HAL_OK)
   \   00000044   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD1EF             BNE.N    ??RoadBrd_UART_Receive_4
    645                  {
    646                    // Watch for termination characters.
    647                    if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x280A             CMP      R0,#+10
   \   00000050   0xD003             BEQ.N    ??RoadBrd_UART_Receive_6
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x280D             CMP      R0,#+13
   \   00000058   0xD104             BNE.N    ??RoadBrd_UART_Receive_7
    648                    {
    649                      *pData = 0x00;
   \                     ??RoadBrd_UART_Receive_6: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
    650                      // Yes..We are done.
    651                      return Status;
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xE03B             B.N      ??RoadBrd_UART_Receive_1
    652                    }
    653                    else
    654                    {
    655                      // Move new character into passed buffer.
    656                      *pData = tmpData[0];
   \                     ??RoadBrd_UART_Receive_7: (+1)
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x7028             STRB     R0,[R5, #+0]
    657                      tmpSize--;                          // Decrement Count
   \   0000006A   0xF1B8 0x0801      SUBS     R8,R8,#+1
    658                      pData++;                            // Move pointer to next buffer location.
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \   00000070   0xE7DB             B.N      ??RoadBrd_UART_Receive_4
    659                    }
    660                  }
    661                }
    662                return Status;
   \                     ??RoadBrd_UART_Receive_5: (+1)
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xE031             B.N      ??RoadBrd_UART_Receive_1
    663              }
    664            }
    665            else if (Port == USART_3)
   \                     ??RoadBrd_UART_Receive_2: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C01             CMP      R4,#+1
   \   0000007C   0xD12D             BNE.N    ??RoadBrd_UART_Receive_8
    666            {
    667              // Is UART Busy right now?
    668              if (Uart3Ready != RESET)
   \   0000007E   0x....             LDR.N    R0,??DataTable20_8
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??RoadBrd_UART_Receive_9
    669                return HAL_BUSY;
   \   00000086   0x2002             MOVS     R0,#+2
   \   00000088   0xE028             B.N      ??RoadBrd_UART_Receive_1
    670              else
    671              {
    672                tmpSize = Size;
   \                     ??RoadBrd_UART_Receive_9: (+1)
   \   0000008A   0x46B0             MOV      R8,R6
    673                while ( tmpSize>0 )
   \                     ??RoadBrd_UART_Receive_10: (+1)
   \   0000008C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000090   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000094   0xD01E             BEQ.N    ??RoadBrd_UART_Receive_11
    674                {
    675                  Status = HAL_UART_Receive(&huart3, (uint8_t*)tmpData, 1, HAL_MAX_DELAY);
   \   00000096   0xF44F 0x4300      MOV      R3,#+32768
   \   0000009A   0x2201             MOVS     R2,#+1
   \   0000009C   0x4669             MOV      R1,SP
   \   0000009E   0x....             LDR.N    R0,??DataTable20_3
   \   000000A0   0x.... 0x....      BL       HAL_UART_Receive
   \   000000A4   0x0007             MOVS     R7,R0
    676                  if(Status == HAL_OK)
   \   000000A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A8   0x2F00             CMP      R7,#+0
   \   000000AA   0xD1EF             BNE.N    ??RoadBrd_UART_Receive_10
    677                  {
    678                    // Watch for termination characters.
    679                    if((tmpData[0]==0x0a) || (tmpData[0]==0x0d))
   \   000000AC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B0   0x280A             CMP      R0,#+10
   \   000000B2   0xD003             BEQ.N    ??RoadBrd_UART_Receive_12
   \   000000B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B8   0x280D             CMP      R0,#+13
   \   000000BA   0xD104             BNE.N    ??RoadBrd_UART_Receive_13
    680                    {
    681                      *pData = 0x00;
   \                     ??RoadBrd_UART_Receive_12: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
    682                      // Yes..We are done.
    683                      return Status;
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xE00A             B.N      ??RoadBrd_UART_Receive_1
    684                    }
    685                    else
    686                    {
    687                      // Move new character into passed buffer.
    688                      *pData = tmpData[0];
   \                     ??RoadBrd_UART_Receive_13: (+1)
   \   000000C6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000CA   0x7028             STRB     R0,[R5, #+0]
    689                      tmpSize--;                          // Decrement Count
   \   000000CC   0xF1B8 0x0801      SUBS     R8,R8,#+1
    690                      pData++;                            // Move pointer to next buffer location.
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \   000000D2   0xE7DB             B.N      ??RoadBrd_UART_Receive_10
    691                    }
    692                  }
    693                }
    694                return Status;
   \                     ??RoadBrd_UART_Receive_11: (+1)
   \   000000D4   0x0038             MOVS     R0,R7
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0xE000             B.N      ??RoadBrd_UART_Receive_1
    695              }
    696            }
    697            else 
    698              return HAL_ERROR;
   \                     ??RoadBrd_UART_Receive_8: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_UART_Receive_1: (+1)
   \   000000DC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    699          }
    700          
    701          /**
    702            * @brief  RoadBrd_Uart_Status
    703            * @param  RoadBrd_uart_TypeDef Port: USART Port.
    704            * @note   This routine returns the current state of the UART passed.
    705            * @retval ITStatus:     RESET:       Last transaction complete
    706            *                       SET:         UART Channel busy.
    707            */

   \                                 In section .text, align 2, keep-with-next
    708          ITStatus RoadBrd_Uart_Status(RoadBrd_uart_TypeDef Port)
    709          {
   \                     RoadBrd_Uart_Status: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    710            // Test Port to determine which uart to use for this transfer.
    711            if ( RoadBrd_Uart_GetState(Port) != HAL_UART_STATE_READY)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       RoadBrd_Uart_GetState
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??RoadBrd_Uart_Status_0
    712              return RESET;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B.N      ??RoadBrd_Uart_Status_1
    713            else
    714              return SET;
   \                     ??RoadBrd_Uart_Status_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??RoadBrd_Uart_Status_1: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    715          }
    716            
    717          /**
    718            * @brief  RoadBrd_Uart_GetState
    719            * @param  RoadBrd_uart_TypeDef Port: USART Port.
    720            * @note   This routine returns the current state of the UART passed.
    721            * @retval ITStatus:     RESET:       Last transaction complete
    722            *   HAL_UART_STATE_RESET             = 0x00,    < Peripheral is not initialized                      
    723            *   HAL_UART_STATE_READY             = 0x01,    < Peripheral Initialized and ready for use           
    724            *   HAL_UART_STATE_BUSY              = 0x02,    < an internal process is ongoing                     
    725            *   HAL_UART_STATE_BUSY_TX           = 0x12,    < Data Transmission process is ongoing               
    726            *   HAL_UART_STATE_BUSY_RX           = 0x22,    < Data Reception process is ongoing                  
    727            *   HAL_UART_STATE_BUSY_TX_RX        = 0x32,    < Data Transmission and Reception process is ongoing 
    728            *   HAL_UART_STATE_TIMEOUT           = 0x03,    < Timeout state                                      
    729            *   HAL_UART_STATE_ERROR             = 0x04     < Error                                              
    730            */

   \                                 In section .text, align 2, keep-with-next
    731          HAL_UART_StateTypeDef RoadBrd_Uart_GetState(RoadBrd_uart_TypeDef Port)
    732          {
   \                     RoadBrd_Uart_GetState: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    733            // Test Port to determine which uart to use for this transfer.
    734            if (Port == USART_2)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD103             BNE.N    ??RoadBrd_Uart_GetState_0
    735              return huart2.State;
   \   00000008   0x....             LDR.N    R0,??DataTable20_1
   \   0000000A   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   0000000E   0xE007             B.N      ??RoadBrd_Uart_GetState_1
    736            else if (Port == USART_3)
   \                     ??RoadBrd_Uart_GetState_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD103             BNE.N    ??RoadBrd_Uart_GetState_2
    737              return huart3.State;
   \   00000016   0x....             LDR.N    R0,??DataTable20_3
   \   00000018   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   0000001C   0xE000             B.N      ??RoadBrd_Uart_GetState_1
    738            else
    739              //return huart3.State;
    740              return HAL_UART_STATE_ERROR;
   \                     ??RoadBrd_Uart_GetState_2: (+1)
   \   0000001E   0x2004             MOVS     R0,#+4
   \                     ??RoadBrd_Uart_GetState_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    741          }
    742            
    743          /**
    744            * @brief  Tx Transfer completed callback
    745            * @param  UartHandle: UART handle. 
    746            * @note   This example shows a simple way to report end of IT Tx transfer, and 
    747            *         you can add your own implementation. 
    748            * @retval None
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
    751          {
    752            // Set transmission flag: trasfer complete for correct USART
    753            //RoadBrd_gpio_On( BLUE_LED );
    754            if(UartHandle->Instance==USART2)
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x....             LDR.N    R2,??DataTable20  ;; 0x40004400
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0xD103             BNE.N    ??HAL_UART_TxCpltCallback_0
    755            {
    756              Uart2Ready = SET;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x....             LDR.N    R2,??DataTable20_7
   \   0000000C   0x7011             STRB     R1,[R2, #+0]
   \   0000000E   0xE006             B.N      ??HAL_UART_TxCpltCallback_1
    757            }
    758            else if(UartHandle->Instance==USART3)
   \                     ??HAL_UART_TxCpltCallback_0: (+1)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable20_2  ;; 0x40004800
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD102             BNE.N    ??HAL_UART_TxCpltCallback_1
    759            {
    760              Uart3Ready = SET;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x....             LDR.N    R2,??DataTable20_8
   \   0000001C   0x7011             STRB     R1,[R2, #+0]
    761            }
    762          }
   \                     ??HAL_UART_TxCpltCallback_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    763          
    764          /**
    765            * @brief  Clear Usart Ready Flag
    766            * @param  NONE. 
    767            * @note   This is needed to allow the next IT transfer to usart. 
    768            * @retval None
    769            */

   \                                 In section .text, align 2, keep-with-next
    770          void clrUsartState( RoadBrd_uart_TypeDef Port )
    771          {
    772            // Test Port to determine which uart to use for this transfer.
    773            if (Port == USART_2)
   \                     clrUsartState: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD103             BNE.N    ??clrUsartState_0
    774            {
    775              Uart2Ready = RESET;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable20_7
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   \   0000000C   0xE005             B.N      ??clrUsartState_1
    776            }
    777            else if (Port == USART_3)
   \                     ??clrUsartState_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD102             BNE.N    ??clrUsartState_1
    778            {
    779              Uart3Ready = RESET;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R2,??DataTable20_8
   \   00000018   0x7011             STRB     R1,[R2, #+0]
    780            }
    781          }
   \                     ??clrUsartState_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    782          
    783          /**
    784            * @brief  Rx Transfer completed callback
    785            * @param  UartHandle: UART handle
    786            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    787            *         you can add your own implementation.
    788            * @retval None
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          void HAL_UART_RxCpltCallback(UART_HandleTypeDef* uartHandle)
    791          {
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    792          #ifndef PATCH_UART
    793            int x;
    794            static uint8_t *temp_ptr;
    795            static int len;
    796            int newLen;
    797          #endif
    798          
    799            /* Set transmission flag: trasfer complete for correct USART*/
    800             if(uartHandle->Instance==USART2)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable20  ;; 0x40004400
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD153             BNE.N    ??HAL_UART_RxCpltCallback_0
    801            {
    802          //***** START HERE
    803              // Test Bypass Flag...If Set, we ae in special monitor mode.
    804              if (Tst_Bypass())
   \   0000000C   0x.... 0x....      BL       Tst_Bypass
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00C             BEQ.N    ??HAL_UART_RxCpltCallback_1
    805              {
    806                tmpPdata[0] = tmpData[0];
   \   00000014   0x....             LDR.N    R0,??DataTable20_16
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable20_15
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    807                tmpPdata[1] = 0x00;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable20_15
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x7048             STRB     R0,[R1, #+1]
    808                // Set Complete Flag.
    809                Uart2Ready = SET;        
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable20_7
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   \   0000002C   0xE08F             B.N      ??HAL_UART_RxCpltCallback_2
    810              } // EndIf (Tst_Bypass())
    811              else {
    812                // Watch for termination characters.
    813                if((tmpData[0]==0x0a) || (tmpData[0]==0x0d) || (tmpSize<=0) )
   \                     ??HAL_UART_RxCpltCallback_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable20_16
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xD007             BEQ.N    ??HAL_UART_RxCpltCallback_3
   \   00000036   0x....             LDR.N    R0,??DataTable20_16
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x280D             CMP      R0,#+13
   \   0000003C   0xD003             BEQ.N    ??HAL_UART_RxCpltCallback_3
   \   0000003E   0x....             LDR.N    R0,??DataTable20_14
   \   00000040   0x8800             LDRH     R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD107             BNE.N    ??HAL_UART_RxCpltCallback_4
    814                {
    815                  *tmpPdata = 0x00;
   \                     ??HAL_UART_RxCpltCallback_3: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable20_15
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    816                  // Yes..We are done.
    817                  // Set Complete Flag.
    818                  Uart2Ready = SET;        
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable20_7
   \   00000052   0x7008             STRB     R0,[R1, #+0]
   \   00000054   0xE07B             B.N      ??HAL_UART_RxCpltCallback_2
    819                } // EndIf ((tmpData[0]==0x0a) || (tmpData[0]==0x0d) || (tmpSize<=0) )
    820                // Is this a BackSpace Character?
    821                else if(tmpData[0]==0x08)
   \                     ??HAL_UART_RxCpltCallback_4: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable20_16
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2808             CMP      R0,#+8
   \   0000005C   0xD115             BNE.N    ??HAL_UART_RxCpltCallback_5
    822                {
    823                  // YES...Are there any chars to undo?
    824                  if (tmpSize < Save_Size)
   \   0000005E   0x....             LDR.N    R0,??DataTable20_14
   \   00000060   0x8800             LDRH     R0,[R0, #+0]
   \   00000062   0x....             LDR.N    R1,??DataTable20_13
   \   00000064   0x8809             LDRH     R1,[R1, #+0]
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD271             BCS.N    ??HAL_UART_RxCpltCallback_2
    825                  {
    826                    // YES...Undo Previous Character.
    827                    tmpSize++;                          // Decrement Count
   \   0000006A   0x....             LDR.N    R0,??DataTable20_14
   \   0000006C   0x8800             LDRH     R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable20_14
   \   00000072   0x8008             STRH     R0,[R1, #+0]
    828                    tmpPdata--;                            // Move pointer to Previous buffer location.
   \   00000074   0x....             LDR.N    R0,??DataTable20_15
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x....             LDR.N    R1,??DataTable20_15
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    829                    //Time to retask for next Character.
    830                    HAL_UART_Receive_IT(&huart2, (uint8_t*)tmpData, 1);
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable20_16
   \   00000082   0x....             LDR.N    R0,??DataTable20_1
   \   00000084   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   00000088   0xE061             B.N      ??HAL_UART_RxCpltCallback_2
    831                  } //endif (tmpSize < RECEIVE_SZ)
    832                } //endif (tmpData[0]==0x08)
    833                else
    834                {
    835                  *tmpPdata = tmpData[0];
   \                     ??HAL_UART_RxCpltCallback_5: (+1)
   \   0000008A   0x....             LDR.N    R0,??DataTable20_16
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x....             LDR.N    R1,??DataTable20_15
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    836                  tmpSize--;                          // Decrement Count
   \   00000094   0x....             LDR.N    R0,??DataTable20_14
   \   00000096   0x8800             LDRH     R0,[R0, #+0]
   \   00000098   0x1E40             SUBS     R0,R0,#+1
   \   0000009A   0x....             LDR.N    R1,??DataTable20_14
   \   0000009C   0x8008             STRH     R0,[R1, #+0]
    837                  tmpPdata++;                            // Move pointer to next buffer location.
   \   0000009E   0x....             LDR.N    R0,??DataTable20_15
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0x....             LDR.N    R1,??DataTable20_15
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    838                  //Time to retask for next Character.
    839                  HAL_UART_Receive_IT(&huart2, (uint8_t*)tmpData, 1);
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0x....             LDR.N    R1,??DataTable20_16
   \   000000AC   0x....             LDR.N    R0,??DataTable20_1
   \   000000AE   0x.... 0x....      BL       HAL_UART_Receive_IT
   \   000000B2   0xE04C             B.N      ??HAL_UART_RxCpltCallback_2
    840                }
    841              } // EndElse (Tst_Bypass())
    842            }
    843          //***** END HERE
    844            else if(uartHandle->Instance==USART3)
   \                     ??HAL_UART_RxCpltCallback_0: (+1)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x....             LDR.N    R1,??DataTable20_2  ;; 0x40004800
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD148             BNE.N    ??HAL_UART_RxCpltCallback_2
    845            {
    846          #ifndef TEST2
    847          #ifndef PATCH_UART
    848          #ifndef LED_OFF
    849              //RoadBrd_gpio_On( BGM_LED );
    850          #endif
    851                //if (bffrFlag)
    852              if (RoadBrd_GetBffrFlg())
   \   000000BC   0x.... 0x....      BL       RoadBrd_GetBffrFlg
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD024             BEQ.N    ??HAL_UART_RxCpltCallback_6
    853              {
    854                len = 3;
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0x....             LDR.N    R1,??DataTable20_17
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    855                // Process BGM Byte received.
    856                temp_ptr = RoadBrd_GetBGPtr();
   \   000000CA   0x.... 0x....      BL       RoadBrd_GetBGPtr
   \   000000CE   0x....             LDR.N    R1,??DataTable20_18
   \   000000D0   0x6008             STR      R0,[R1, #+0]
    857                newLen = temp_ptr[1]+1;
   \   000000D2   0x....             LDR.N    R0,??DataTable20_18
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x7840             LDRB     R0,[R0, #+1]
   \   000000D8   0x1C40             ADDS     R0,R0,#+1
   \   000000DA   0x0006             MOVS     R6,R0
    858                for (x=0; x<len; x++)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x0005             MOVS     R5,R0
   \                     ??HAL_UART_RxCpltCallback_7: (+1)
   \   000000E0   0x....             LDR.N    R0,??DataTable20_17
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x4285             CMP      R5,R0
   \   000000E6   0xDA0B             BGE.N    ??HAL_UART_RxCpltCallback_8
    859                {
    860                  RoadBrd_ProcessBGMChar(*temp_ptr);
   \   000000E8   0x....             LDR.N    R0,??DataTable20_18
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x.... 0x....      BL       RoadBrd_ProcessBGMChar
    861                  temp_ptr++;
   \   000000F2   0x....             LDR.N    R0,??DataTable20_18
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x....             LDR.N    R1,??DataTable20_18
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    862                  //Status = RoadBrd_ProcessBGMChar(bgmdata[x]);
    863                }
   \   000000FC   0x1C6D             ADDS     R5,R5,#+1
   \   000000FE   0xE7EF             B.N      ??HAL_UART_RxCpltCallback_7
    864                len = newLen;
   \                     ??HAL_UART_RxCpltCallback_8: (+1)
   \   00000100   0x....             LDR.N    R0,??DataTable20_17
   \   00000102   0x6006             STR      R6,[R0, #+0]
    865                saveLen = len;
   \   00000104   0x....             LDR.N    R0,??DataTable20_17
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0x....             LDR.N    R1,??DataTable20_11
   \   0000010A   0x6008             STR      R0,[R1, #+0]
   \   0000010C   0xE01C             B.N      ??HAL_UART_RxCpltCallback_9
    866              }
    867              else
    868              {
    869                // Process BGM Byte received.
    870                temp_ptr = RoadBrd_GetBGPtr();
   \                     ??HAL_UART_RxCpltCallback_6: (+1)
   \   0000010E   0x.... 0x....      BL       RoadBrd_GetBGPtr
   \   00000112   0x....             LDR.N    R1,??DataTable20_18
   \   00000114   0x6008             STR      R0,[R1, #+0]
    871                for (x=0; x<len; x++)
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x0005             MOVS     R5,R0
   \                     ??HAL_UART_RxCpltCallback_10: (+1)
   \   0000011A   0x....             LDR.N    R0,??DataTable20_17
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x4285             CMP      R5,R0
   \   00000120   0xDA0B             BGE.N    ??HAL_UART_RxCpltCallback_11
    872                {
    873                  RoadBrd_ProcessBGMChar(*temp_ptr);
   \   00000122   0x....             LDR.N    R0,??DataTable20_18
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x.... 0x....      BL       RoadBrd_ProcessBGMChar
    874                  temp_ptr++;
   \   0000012C   0x....             LDR.N    R0,??DataTable20_18
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \   00000130   0x1C40             ADDS     R0,R0,#+1
   \   00000132   0x....             LDR.N    R1,??DataTable20_18
   \   00000134   0x6008             STR      R0,[R1, #+0]
    875                  //Status = RoadBrd_ProcessBGMChar(bgmdata[x]);
    876                 }
   \   00000136   0x1C6D             ADDS     R5,R5,#+1
   \   00000138   0xE7EF             B.N      ??HAL_UART_RxCpltCallback_10
    877                len = 3;
   \                     ??HAL_UART_RxCpltCallback_11: (+1)
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x....             LDR.N    R1,??DataTable20_17
   \   0000013E   0x6008             STR      R0,[R1, #+0]
    878                saveLen = len;
   \   00000140   0x....             LDR.N    R0,??DataTable20_17
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x....             LDR.N    R1,??DataTable20_11
   \   00000146   0x6008             STR      R0,[R1, #+0]
    879                //Status = RoadBrd_ProcessBGMChar(bgmdata[0]);
    880              }
    881          #endif
    882          #endif
    883              Uart3Ready = SET;
   \                     ??HAL_UART_RxCpltCallback_9: (+1)
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0x....             LDR.N    R1,??DataTable20_8
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
    884            }
    885          }
   \                     ??HAL_UART_RxCpltCallback_2: (+1)
   \   0000014E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     `HAL_UART_RxCpltCallback::temp_ptr`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `HAL_UART_RxCpltCallback::len`:
   \   00000000                      DS8 4
    886          
    887          /**
    888            * @brief  UART error callbacks
    889            * @param  UartHandle: UART handle
    890            * @note   This example shows a simple way to report transfer error, and you can
    891            *         add your own implementation.
    892            * @retval None
    893            */

   \                                 In section .text, align 2, keep-with-next
    894          void HAL_UART_ErrorCallback(UART_HandleTypeDef* uartHandle)
    895          {
    896              //Error_Handler();
    897          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    898          
    899          #ifndef PATCH_UART
    900          /**
    901            * @brief  Enable UART3 for TX.
    902            * @param  none
    903            * @retval None
    904            */

   \                                 In section .text, align 2, keep-with-next
    905          void HAL_UART_EnableBGM_TXE( void )
    906          {
    907            __HAL_UART_ENABLE_IT(&huart3, UART_IT_TXE);
   \                     HAL_UART_EnableBGM_TXE: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000000A   0x....             LDR.N    R1,??DataTable20_3
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
    908          }
   \   00000010   0x4770             BX       LR               ;; return
    909          
    910          /**
    911            * @brief  Enable UART3 for RX.
    912            * @param  none
    913            * @retval None
    914            */

   \                                 In section .text, align 2, keep-with-next
    915          void HAL_UART_EnableBGM_RX( void )
    916          {
    917            /* Enable the UART Parity Error Interrupt */
    918            __HAL_UART_ENABLE_IT(&huart3, UART_IT_PE);
   \                     HAL_UART_EnableBGM_RX: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x....             LDR.N    R1,??DataTable20_3
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
    919          
    920            /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    921            __HAL_UART_ENABLE_IT(&huart3, UART_IT_ERR);
   \   00000010   0x....             LDR.N    R0,??DataTable20_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001A   0x....             LDR.N    R1,??DataTable20_3
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6148             STR      R0,[R1, #+20]
    922          
    923            /* Enable the UART Data Register not empty Interrupt */
    924            __HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);
   \   00000020   0x....             LDR.N    R0,??DataTable20_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002A   0x....             LDR.N    R1,??DataTable20_3
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
    925          }
   \   00000030   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     huart2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     huart3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     Uart2Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     Uart3Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x........         DC32     bgm1data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     bffr1Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     saveLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     save_Ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     Save_Size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     tmpSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     tmpPdata

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_16:
   \   00000000   0x........         DC32     tmpData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_17:
   \   00000000   0x........         DC32     `HAL_UART_RxCpltCallback::len`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_18:
   \   00000000   0x........         DC32     `HAL_UART_RxCpltCallback::temp_ptr`
    926          
    927          #endif
    928          
    929          
    930          /* USER CODE END 1 */
    931          
    932          /**
    933            * @}
    934            */
    935          
    936          /**
    937            * @}
    938            */
    939          
    940          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_UART_EnableBGM_RX
       0   HAL_UART_EnableBGM_TXE
       0   HAL_UART_ErrorCallback
       8   HAL_UART_MspDeInit
         8   -> HAL_GPIO_DeInit
      32   HAL_UART_MspInit
        32   -> HAL_GPIO_Init
      16   HAL_UART_RxCpltCallback
        16   -> HAL_UART_Receive_IT
        16   -> RoadBrd_GetBGPtr
        16   -> RoadBrd_GetBffrFlg
        16   -> RoadBrd_ProcessBGMChar
        16   -> Tst_Bypass
       0   HAL_UART_TxCpltCallback
       8   MX_USART2_UART_Init
         8   -> Error_Handler
         8   -> HAL_UART_Init
       8   MX_USART3_UART_Init
         8   -> Error_Handler
         8   -> HAL_UART_Init
       0   RoadBrd_ClrBffrFlg
       0   RoadBrd_GetBGPtr
       0   RoadBrd_GetBffrFlg
       0   RoadBrd_SetBffrFlg
      32   RoadBrd_UART_Receive
        32   -> HAL_UART_Receive
      24   RoadBrd_UART_Receive_IT
        24   -> HAL_UART_Receive_IT
      16   RoadBrd_UART_Receive_ITBG
        16   -> HAL_UART_Receive_IT
      24   RoadBrd_UART_Transmit
        24   -> HAL_UART_Transmit
        24   -> strlen
      24   RoadBrd_UART_Transmit_IT
        24   -> HAL_UART_Transmit_IT
        24   -> strlen
      24   RoadBrd_UART_Transmit_ITSZ
        24   -> HAL_UART_Transmit_IT
       0   RoadBrd_Uart_GetState
       8   RoadBrd_Uart_Status
         8   -> RoadBrd_Uart_GetState
       0   RoadBrd_getSaveLen
       0   clrUsartState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      50  HAL_UART_EnableBGM_RX
      18  HAL_UART_EnableBGM_TXE
       2  HAL_UART_ErrorCallback
      82  HAL_UART_MspDeInit
     186  HAL_UART_MspInit
     336  HAL_UART_RxCpltCallback
      32  HAL_UART_TxCpltCallback
      88  MX_USART2_UART_Init
      90  MX_USART3_UART_Init
      10  RoadBrd_ClrBffrFlg
       6  RoadBrd_GetBGPtr
       8  RoadBrd_GetBffrFlg
      10  RoadBrd_SetBffrFlg
     224  RoadBrd_UART_Receive
     202  RoadBrd_UART_Receive_IT
     132  RoadBrd_UART_Receive_ITBG
     144  RoadBrd_UART_Transmit
     136  RoadBrd_UART_Transmit_IT
     130  RoadBrd_UART_Transmit_ITSZ
      34  RoadBrd_Uart_GetState
      24  RoadBrd_Uart_Status
       8  RoadBrd_getSaveLen
       2  Save_Size
       1  Uart2Ready
       1  Uart3Ready
     132  aRxBuffer
     132  aTxBuffer
       1  bffr1Flag
      40  bgm1data
      28  clrUsartState
      64  huart2
      64  huart3
       4  len
       4  saveLen
       4  save_Ptr
       4  temp_ptr
       2  tmpData
       4  tmpPdata
       2  tmpSize

 
   457 bytes in section .bss
     4 bytes in section .data
 2 056 bytes in section .text
 
 2 056 bytes of CODE memory
   461 bytes of DATA memory

Errors: none
Warnings: none
